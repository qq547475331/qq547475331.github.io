<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  一、linux
  #


  1. linux系统启动流程
  #


第一步：开机自检，加载BIOS
第二步：读取ＭＢＲ
第三步：Boot Loader　grub引导菜单
第四步：加载kernel内核
第五步：init进程依据inittab文件夹来设定运行级别
第六步：init进程执行rc.sysinit
第七步：启动内核模块
第八步：执行不同运行级别的脚本程序
第九步：执行/etc/rc.d/rc.lo

Linux 系统启动流程是一个多阶段的过程，涉及多个重要的系统组件。以下是 Linux 系统从开机到完全启动的详细步骤：

  1. 加电自检 (POST)
  #


当电脑通电后，首先会执行硬件自检（POST，Power-On Self-Test），由 BIOS 或 UEFI（现代系统通常使用 UEFI）来完成。这一步检查硬件设备是否正常，比如内存、硬盘、显示器等。


  2. 加载引导程序 (Bootloader)
  #


BIOS 或 UEFI 会查找并加载存储设备（如硬盘或 SSD）上的引导加载程序（Bootloader）。常见的引导加载程序有 GRUB（GRand Unified Bootloader）和 LILO（Linux Loader）等。
引导加载程序的作用是加载并启动操作系统。它会显示可用的操作系统列表（如果有多个系统），并允许用户选择要启动的操作系统。


  3. 加载内核 (Kernel)
  #


选择操作系统后，引导加载程序会加载操作系统的内核（通常是 vmlinuz 文件）。内核是操作系统的核心，负责管理硬件资源和提供系统服务。
内核首先会解压并加载到内存中，然后初始化硬件设备（如处理器、内存、硬盘等）。


  4. 初始化硬件和挂载根文件系统 (Root Filesystem)
  #


内核在加载完毕后，会开始初始化硬件，包括磁盘驱动程序、输入设备、网络设备等。
内核通过 initramfs 或 initrd（初始 RAM 文件系统）来帮助加载根文件系统（通常是 /）到内存中。initramfs 是一个压缩的文件系统镜像，包含必要的驱动程序和工具，确保系统能够挂载根文件系统。


  5. 启动 init 进程
  #


内核初始化完成后，会启动系统的第一个用户空间进程，即 init 进程（PID 1）。这是 Linux 系统中最重要的进程，它负责启动和管理系统的其他进程。
在现代 Linux 系统中，init 进程通常由 systemd 替代，systemd 是一种系统和服务管理器，负责管理系统启动过程、服务和进程。


  6. 运行 init 脚本或服务管理器
  #



systemd"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2025-2-24 中级运维面试题"><meta property="og:description" content="一、linux # 1. linux系统启动流程 # 第一步：开机自检，加载BIOS 第二步：读取ＭＢＲ 第三步：Boot Loader　grub引导菜单 第四步：加载kernel内核 第五步：init进程依据inittab文件夹来设定运行级别 第六步：init进程执行rc.sysinit 第七步：启动内核模块 第八步：执行不同运行级别的脚本程序 第九步：执行/etc/rc.d/rc.lo Linux 系统启动流程是一个多阶段的过程，涉及多个重要的系统组件。以下是 Linux 系统从开机到完全启动的详细步骤：
1. 加电自检 (POST) # 当电脑通电后，首先会执行硬件自检（POST，Power-On Self-Test），由 BIOS 或 UEFI（现代系统通常使用 UEFI）来完成。这一步检查硬件设备是否正常，比如内存、硬盘、显示器等。 2. 加载引导程序 (Bootloader) # BIOS 或 UEFI 会查找并加载存储设备（如硬盘或 SSD）上的引导加载程序（Bootloader）。常见的引导加载程序有 GRUB（GRand Unified Bootloader）和 LILO（Linux Loader）等。 引导加载程序的作用是加载并启动操作系统。它会显示可用的操作系统列表（如果有多个系统），并允许用户选择要启动的操作系统。 3. 加载内核 (Kernel) # 选择操作系统后，引导加载程序会加载操作系统的内核（通常是 vmlinuz 文件）。内核是操作系统的核心，负责管理硬件资源和提供系统服务。 内核首先会解压并加载到内存中，然后初始化硬件设备（如处理器、内存、硬盘等）。 4. 初始化硬件和挂载根文件系统 (Root Filesystem) # 内核在加载完毕后，会开始初始化硬件，包括磁盘驱动程序、输入设备、网络设备等。 内核通过 initramfs 或 initrd（初始 RAM 文件系统）来帮助加载根文件系统（通常是 /）到内存中。initramfs 是一个压缩的文件系统镜像，包含必要的驱动程序和工具，确保系统能够挂载根文件系统。 5. 启动 init 进程 # 内核初始化完成后，会启动系统的第一个用户空间进程，即 init 进程（PID 1）。这是 Linux 系统中最重要的进程，它负责启动和管理系统的其他进程。 在现代 Linux 系统中，init 进程通常由 systemd 替代，systemd 是一种系统和服务管理器，负责管理系统启动过程、服务和进程。 6. 运行 init 脚本或服务管理器 # systemd"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2025-2-24 中级运维面试题 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.345a5f225388b9092b02d89e6ab7df4fbb2087ca7b9cd0009125f1d6fda6cfe6.js integrity="sha256-NFpfIlOIuQkrAtiearffT7sgh8p7nNAAkSXx1v2mz+Y=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-4-16-%E8%87%AA%E7%A0%94k8s%E5%B9%B3%E5%8F%B0/>2025-4-16 自研k8s平台</a></li><li><a href=/docs/2025-4-16-sleep%E7%9D%A1%E7%9C%A0%E5%BA%94%E7%94%A8/>2025-4-16 sleep睡眠应用</a></li><li><a href=/docs/2025-4-16-paas%E8%AE%BE%E8%AE%A1/>2025-4-16 paas开发记录</a></li><li><a href=/docs/2025-4-16-boss%E7%9B%B4%E8%81%98%E8%87%AA%E5%8A%A8%E6%8A%95%E9%80%92/>2025-4-16 BOSS直聘自动投递</a></li><li><a href=/docs/2025-3-30-metallb/>2025-3-30 metallb</a></li><li><a href=/docs/2025-3-24-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/>2025-3-24 自我介绍</a></li><li><a href=/docs/2025-3-20-victoriametrics-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics高可用架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 thanos高可用架构</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/ class=active>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-08-01 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 k8s面试题</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-05-01 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-04-17 面试总结</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-03-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-03-08 面试</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2024-03-04 k8s流量链路剖析</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2024-03-04 CSI剖析演进</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-03-04 CNI剖析演进</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-02-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-02-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-02-22 k8s架构师面试大全</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/2025-4-16-cursoe-free-vip/>2025 4 16 Cursoe Free Vip</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-2-24 中级运维面试题</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#1-加电自检-post>1. <strong>加电自检 (POST)</strong></a></li><li><a href=#2-加载引导程序-bootloader>2. <strong>加载引导程序 (Bootloader)</strong></a></li><li><a href=#3-加载内核-kernel>3. <strong>加载内核 (Kernel)</strong></a></li><li><a href=#4-初始化硬件和挂载根文件系统-root-filesystem>4. <strong>初始化硬件和挂载根文件系统 (Root Filesystem)</strong></a></li><li><a href=#5-启动-init-进程>5. <strong>启动 init 进程</strong></a></li><li><a href=#6-运行-init-脚本或服务管理器>6. <strong>运行 init 脚本或服务管理器</strong></a></li><li><a href=#7-启动用户空间进程>7. <strong>启动用户空间进程</strong></a></li><li><a href=#8-登录界面>8. <strong>登录界面</strong></a></li><li><a href=#9-用户登录>9. <strong>用户登录</strong></a></li><li><a href=#简要总结>简要总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-普通文件regular-file>1. <strong>普通文件（Regular File）</strong></a></li><li><a href=#2-目录文件directory-file>2. <strong>目录文件（Directory File）</strong></a></li><li><a href=#3-符号链接文件symbolic-link或-symlink>3. <strong>符号链接文件（Symbolic Link，或 Symlink）</strong></a></li><li><a href=#4-字符设备文件character-device-file>4. <strong>字符设备文件（Character Device File）</strong></a></li><li><a href=#5-块设备文件block-device-file>5. <strong>块设备文件（Block Device File）</strong></a></li><li><a href=#6-fifo-文件fifo-也叫命名管道>6. <strong>FIFO 文件（FIFO, 也叫命名管道）</strong></a></li><li><a href=#7-套接字文件socket-file>7. <strong>套接字文件（Socket File）</strong></a></li><li><a href=#8-空文件empty-file>8. <strong>空文件（Empty File）</strong></a></li><li><a href=#查看文件类型>查看文件类型</a></li><li><a href=#总结>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#centos-6-和-centos-7-开机自启动的基本步骤>CentOS 6 和 CentOS 7 开机自启动的基本步骤</a></li><li><a href=#总结-1>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#lvmlogical-volume-management简介>LVM（Logical Volume Management）简介</a></li><li><a href=#如何给使用-lvm-的--分区扩容>如何给使用 LVM 的 <code>/</code> 分区扩容</a></li></ul></li></ul><ul><li><ul><li><a href=#1-du>1. <strong><code>du</code> 命令的工作原理</strong></a></li><li><a href=#2-df>2. <strong><code>df</code> 命令的工作原理</strong></a></li><li><a href=#3-为什么>3. <strong>为什么 <code>du</code> 和 <code>df</code> 显示不一致？</strong></a></li><li><a href=#4-常见场景示例>4. <strong>常见场景示例</strong></a></li><li><a href=#5-如何让>5. <strong>如何让 <code>du</code> 和 <code>df</code> 的结果更接近？</strong></a></li><li><a href=#总结-3>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-通过官方仓库更新内核centos-7>1. <strong>通过官方仓库更新内核（CentOS 7）</strong></a></li><li><a href=#2-通过-elrepo-安装最新的内核centos-7>2. <strong>通过 ELRepo 安装最新的内核（CentOS 7）</strong></a></li><li><a href=#3-通过源代码手动编译安装内核适用于所有版本>3. <strong>通过源代码手动编译安装内核（适用于所有版本）</strong></a></li><li><a href=#4-常见问题和注意事项>4. <strong>常见问题和注意事项</strong></a></li><li><a href=#总结-4>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-基本的-nginx-访问日志格式>1. <strong>基本的 Nginx 访问日志格式</strong></a></li><li><a href=#2-通过命令统计访问量前十的-ip>2. <strong>通过命令统计访问量前十的 IP</strong></a></li><li><a href=#3-详细的字段输出>3. <strong>详细的字段输出</strong></a></li><li><a href=#4-按日期时间过滤日志>4. <strong>按日期/时间过滤日志</strong></a></li><li><a href=#5-按请求类型如-get-post进行过滤>5. <strong>按请求类型（如 GET, POST）进行过滤</strong></a></li><li><a href=#6-自动化统计并输出到文件>6. <strong>自动化统计并输出到文件</strong></a></li><li><a href=#总结-5>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-查看>1. <strong>查看 <code>.log</code> 文件中超过 30 天的文件</strong></a></li><li><a href=#2-删除超过-30-天的>2. <strong>删除超过 30 天的 <code>.log</code> 文件</strong></a></li><li><a href=#3-在删除前进行确认>3. <strong>在删除前进行确认</strong></a></li><li><a href=#4-使用>4. <strong>使用 <code>logrotate</code> 自动管理日志</strong></a></li><li><a href=#总结-6>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-文件和目录管理模块>1. <strong>文件和目录管理模块</strong></a></li><li><a href=#2-系统管理模块>2. <strong>系统管理模块</strong></a></li><li><a href=#3-网络管理模块>3. <strong>网络管理模块</strong></a></li><li><a href=#4-包管理模块>4. <strong>包管理模块</strong></a></li><li><a href=#5-数据库管理模块>5. <strong>数据库管理模块</strong></a></li><li><a href=#6-云服务模块>6. <strong>云服务模块</strong></a></li><li><a href=#7-监控与报警模块>7. <strong>监控与报警模块</strong></a></li><li><a href=#8-用户输入和通知模块>8. <strong>用户输入和通知模块</strong></a></li><li><a href=#9-容器和虚拟化管理模块>9. <strong>容器和虚拟化管理模块</strong></a></li><li><a href=#总结-7>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-事件驱动架构>1. <strong>事件驱动架构</strong></a></li><li><a href=#2-内存消耗>2. <strong>内存消耗</strong></a></li><li><a href=#3-高效的静态内容处理>3. <strong>高效的静态内容处理</strong></a></li><li><a href=#4-非阻塞-io>4. <strong>非阻塞 I/O</strong></a></li><li><a href=#5-更低的-cpu-和内存开销>5. <strong>更低的 CPU 和内存开销</strong></a></li><li><a href=#6-负载均衡和反向代理能力>6. <strong>负载均衡和反向代理能力</strong></a></li><li><a href=#7-配置简洁与优化>7. <strong>配置简洁与优化</strong></a></li><li><a href=#总结-8>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-osi模型层次>1. <strong>OSI模型层次</strong></a></li><li><a href=#2-负载均衡决策依据>2. <strong>负载均衡决策依据</strong></a></li><li><a href=#3-处理复杂度和性能>3. <strong>处理复杂度和性能</strong></a></li><li><a href=#4-应用场景>4. <strong>应用场景</strong></a></li><li><a href=#5-功能特性>5. <strong>功能特性</strong></a></li><li><a href=#6-ssltls-终止>6. <strong>SSL/TLS 终止</strong></a></li><li><a href=#总结-9>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-nat-network-address-translation-模式>1. <strong>NAT (Network Address Translation) 模式</strong></a></li><li><a href=#2-dr-direct-routing-模式>2. <strong>DR (Direct Routing) 模式</strong></a></li><li><a href=#3-tun-ip-tunneling-模式>3. <strong>TUN (IP Tunneling) 模式</strong></a></li><li><a href=#性能对比>性能对比：</a></li><li><a href=#总结-10>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-lvs-linux-virtual-server>1. <strong>LVS (Linux Virtual Server)</strong></a></li><li><a href=#2-nginx>2. <strong>Nginx</strong></a></li><li><a href=#3-haproxy>3. <strong>HAProxy</strong></a></li><li><a href=#4-keepalived>4. <strong>Keepalived</strong></a></li><li><a href=#总结与适用场景>总结与适用场景：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-协议部分https>1. <strong>协议部分</strong>：<code>https://</code></a></li><li><a href=#2-主机名部分wwwbaiducom>2. <strong>主机名部分</strong>：<code>www.baidu.com</code></a></li><li><a href=#3-路径部分s>3. <strong>路径部分</strong>：<code>/s</code></a></li><li><a href=#4-查询参数部分word123ieutf-8>4. <strong>查询参数部分</strong>：<code>?word=123&amp;ie=utf-8</code></a></li><li><a href=#总结-11>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#tomcat-目录结构含义>Tomcat 目录结构含义</a></li><li><a href=#如何修改-tomcat-的端口>如何修改 Tomcat 的端口？</a></li><li><a href=#如何修改-tomcat-的内存设置>如何修改 Tomcat 的内存设置？</a></li><li><a href=#总结-12>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#步骤-3>步骤：</a></li><li><a href=#重要提示>重要提示：</a></li><li><a href=#总结-13>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-轮询round-robin>1. <strong>轮询（Round Robin）</strong></a></li><li><a href=#2-最少连接least-connections>2. <strong>最少连接（Least Connections）</strong></a></li><li><a href=#3-ip-哈希ip-hash>3. <strong>IP 哈希（IP Hash）</strong></a></li><li><a href=#4-加权轮询weighted-round-robin>4. <strong>加权轮询（Weighted Round Robin）</strong></a></li><li><a href=#5-加权最少连接weighted-least-connections>5. <strong>加权最少连接（Weighted Least Connections）</strong></a></li><li><a href=#6-随机random>6. <strong>随机（Random）</strong></a></li><li><a href=#7-最少响应时间least-time-nginx-plus>7. <strong>最少响应时间（Least Time）</strong> (Nginx Plus)</a></li><li><a href=#总结-14>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用-apache-jmeter-进行压力测试>1. <strong>使用 Apache JMeter 进行压力测试</strong></a></li><li><a href=#2-使用-locust-进行压力测试>2. <strong>使用 Locust 进行压力测试</strong></a></li><li><a href=#3-使用-ab-apache-bench-进行压力测试>3. <strong>使用 ab (Apache Bench) 进行压力测试</strong></a></li><li><a href=#4-使用-siege-进行压力测试>4. <strong>使用 siege 进行压力测试</strong></a></li><li><a href=#5-使用-gatling-进行压力测试>5. <strong>使用 Gatling 进行压力测试</strong></a></li><li><a href=#6-使用-artillery-进行压力测试>6. <strong>使用 Artillery 进行压力测试</strong></a></li><li><a href=#总结-15>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-发送-https-请求>1. <strong>发送 HTTPS 请求</strong></a></li><li><a href=#2-查看响应头信息>2. <strong>查看响应头信息</strong></a></li><li><a href=#3-发送-get-请求>3. <strong>发送 GET 请求</strong></a></li><li><a href=#4-发送-post-请求>4. <strong>发送 POST 请求</strong></a></li><li><a href=#5-发送带自定义头的请求>5. <strong>发送带自定义头的请求</strong></a></li><li><a href=#总结-16>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#为什么索引能加快查询><strong>为什么索引能加快查询？</strong></a></li><li><a href=#索引的缺点和限制><strong>索引的缺点和限制</strong></a></li><li><a href=#总结-17><strong>总结：</strong></a></li></ul></li><li><a href=#2-sql语句左外连接-右外连接-内连接-全连接区别>2. sql语句左外连接 右外连接 内连接 全连接区别</a><ul><li><a href=#1-内连接-inner-join>1. <strong>内连接 (INNER JOIN)</strong></a></li><li><a href=#2-左外连接-left-join-或-left-outer-join>2. <strong>左外连接 (LEFT JOIN 或 LEFT OUTER JOIN)</strong></a></li><li><a href=#3-右外连接-right-join-或-right-outer-join>3. <strong>右外连接 (RIGHT JOIN 或 RIGHT OUTER JOIN)</strong></a></li><li><a href=#4-全外连接-full-join-或-full-outer-join>4. <strong>全外连接 (FULL JOIN 或 FULL OUTER JOIN)</strong></a></li><li><a href=#总结-18><strong>总结：</strong></a></li><li><a href=#举例说明><strong>举例说明：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#常见的-mysql-数据备份方式><strong>常见的 MySQL 数据备份方式</strong></a></li><li><a href=#恢复的常见方式><strong>恢复的常见方式</strong></a></li><li><a href=#mysql-备份策略><strong>MySQL 备份策略</strong></a></li><li><a href=#总结-19><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#数据库主从同步配置><strong>数据库主从同步配置</strong></a></li><li><a href=#1-配置主服务器master><strong>1. 配置主服务器（Master）</strong></a></li><li><a href=#2-配置从服务器slave><strong>2. 配置从服务器（Slave）</strong></a></li><li><a href=#3-验证同步是否正常><strong>3. 验证同步是否正常</strong></a></li><li><a href=#实际工作中遇到的数据不一致问题><strong>实际工作中遇到的数据不一致问题</strong></a></li><li><a href=#总结-20><strong>总结</strong></a></li></ul></li><li><a href=#5-mysql约束有哪些>5. mysql约束有哪些？</a><ul><li><a href=#1-主键约束primary-key><strong>1. 主键约束（PRIMARY KEY）</strong></a></li><li><a href=#2-唯一约束unique><strong>2. 唯一约束（UNIQUE）</strong></a></li><li><a href=#3-外键约束foreign-key><strong>3. 外键约束（FOREIGN KEY）</strong></a></li><li><a href=#4-检查约束check><strong>4. 检查约束（CHECK）</strong></a></li><li><a href=#5-非空约束not-null><strong>5. 非空约束（NOT NULL）</strong></a></li><li><a href=#6-默认值约束default><strong>6. 默认值约束（DEFAULT）</strong></a></li><li><a href=#7-自动递增约束auto_><strong>7. 自动递增约束（AUTO_INCREMENT）</strong></a></li><li><a href=#8-索引约束index><strong>8. 索引约束（INDEX）</strong></a></li><li><a href=#9-联合唯一约束unique-constraint><strong>9. 联合唯一约束（UNIQUE CONSTRAINT）</strong></a></li><li><a href=#总结-21><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#主要用途><strong>主要用途：</strong></a></li><li><a href=#binlog-格式><strong>binlog 格式：</strong></a></li><li><a href=#启用与配置-binlog><strong>启用与配置 binlog：</strong></a></li><li><a href=#总结-22><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-innodb><strong>1. InnoDB</strong></a></li><li><a href=#2-myisam><strong>2. MyISAM</strong></a></li><li><a href=#3-memoryheap><strong>3. MEMORY（HEAP）</strong></a></li><li><a href=#4-csv><strong>4. CSV</strong></a></li><li><a href=#5-archive><strong>5. ARCHIVE</strong></a></li><li><a href=#6-ndb-cluster><strong>6. NDB (Cluster)</strong></a></li><li><a href=#7-blackhole><strong>7. BLACKHOLE</strong></a></li><li><a href=#8-tokudb><strong>8. TokuDB</strong></a></li><li><a href=#总结-23><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-查询-mysql-数据目录配置>1. <strong>查询 MySQL 数据目录配置</strong></a></li><li><a href=#2-检查-mysql-配置文件>2. <strong>检查 MySQL 配置文件</strong></a></li><li><a href=#3-查看操作系统文件系统>3. <strong>查看操作系统文件系统</strong></a></li><li><a href=#4-通过-mysql-启动命令检查>4. <strong>通过 MySQL 启动命令检查</strong></a></li><li><a href=#总结-24><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-frm>1. <strong>.frm</strong></a></li><li><a href=#2-ibd>2. <strong>.ibd</strong></a></li><li><a href=#3-myd>3. <strong>.myd</strong></a></li><li><a href=#4-myi>4. <strong>.myi</strong></a></li><li><a href=#5-log日志文件>5. <strong>.log</strong>（日志文件）</a></li><li><a href=#6-ib_>6. <strong>.ib_logfile</strong></a></li><li><a href=#7-cnd>7. <strong>.cnd</strong></a></li><li><a href=#8-tmp>8. <strong>.tmp</strong></a></li><li><a href=#9-ibdata>9. <strong>.ibdata</strong></a></li><li><a href=#总结-25><strong>总结</strong></a></li></ul></li><li><a href=#10-如何修改数据库用户的密码>10. 如何修改数据库用户的密码？</a><ul><li><a href=#1-使用>1. <strong>使用 <code>ALTER USER</code> 语句（推荐）</strong></a></li><li><a href=#2-使用>2. <strong>使用 <code>SET PASSWORD</code> 语句</strong></a></li><li><a href=#3-使用>3. <strong>使用 <code>UPDATE</code> 语句修改 <code>mysql.user</code> 表</strong></a></li><li><a href=#4-重置>4. <strong>重置 <code>root</code> 密码</strong></a></li><li><a href=#总结-26>总结：</a></li><li><a href=#1-使用-1>1. <strong>使用 <code>ALTER USER</code> 语句（推荐）</strong></a></li><li><a href=#2-使用-1>2. <strong>使用 <code>SET PASSWORD</code> 语句</strong></a></li><li><a href=#3-直接修改>3. <strong>直接修改 <code>mysql.user</code> 表（不推荐）</strong></a></li><li><a href=#4-重置-1>4. <strong>重置 <code>root</code> 密码（如果忘记密码）</strong></a></li><li><a href=#5-查看密码加密方式>5. <strong>查看密码加密方式</strong></a></li><li><a href=#总结-27>总结</a></li></ul></li><li><a href=#11-如何修改用户权限如何查看>11. 如何修改用户权限？如何查看？</a><ul><li><a href=#1-查看用户权限>1. <strong>查看用户权限</strong></a></li><li><a href=#2-修改用户权限>2. <strong>修改用户权限</strong></a></li><li><a href=#3-刷新权限>3. <strong>刷新权限</strong></a></li><li><a href=#4-删除用户权限>4. <strong>删除用户权限</strong></a></li><li><a href=#总结-28>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-rdbredis-数据库快照>1. <strong>RDB（Redis 数据库快照）</strong></a></li><li><a href=#2-aofappend-only-file>2. <strong>AOF（Append Only File）</strong></a></li><li><a href=#3-混合持久化rdb--aof>3. <strong>混合持久化（RDB + AOF）</strong></a></li><li><a href=#4-持久化相关配置的选择>4. <strong>持久化相关配置的选择</strong></a></li><li><a href=#5-如何优化-aof-文件>5. <strong>如何优化 AOF 文件</strong></a></li><li><a href=#总结-29>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#redis-集群方案主要有以下几种>Redis 集群方案主要有以下几种：</a></li><li><a href=#1-原生-redis-集群redis-cluster>1. <strong>原生 Redis 集群（Redis Cluster）</strong></a></li><li><a href=#2-redis-sentinel>2. <strong>Redis Sentinel</strong></a></li><li><a href=#3-redis-代理方案如-twemproxy>3. <strong>Redis 代理方案（如 Twemproxy）</strong></a></li><li><a href=#4-redis-sharding手动分片>4. <strong>Redis Sharding（手动分片）</strong></a></li><li><a href=#总结-30>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-rdb-持久化备份与恢复>1. <strong>RDB 持久化备份与恢复</strong></a></li><li><a href=#2-aof-持久化备份与恢复>2. <strong>AOF 持久化备份与恢复</strong></a></li><li><a href=#3-混合持久化rdb--aof-1>3. <strong>混合持久化（RDB + AOF）</strong></a></li><li><a href=#4-手动备份通过文件复制>4. <strong>手动备份（通过文件复制）</strong></a></li><li><a href=#5-增量备份>5. <strong>增量备份</strong></a></li><li><a href=#6-备份策略与最佳实践>6. <strong>备份策略与最佳实践</strong></a></li><li><a href=#总结-31>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用-2>1. <strong>使用 <code>mongodump</code> 进行备份</strong></a></li><li><a href=#2-使用-2>2. <strong>使用 <code>mongorestore</code> 进行恢复</strong></a></li><li><a href=#3-使用文件系统级备份>3. <strong>使用文件系统级备份</strong></a></li><li><a href=#4-使用-mongodb-atlas-进行备份云托管服务>4. <strong>使用 MongoDB Atlas 进行备份（云托管服务）</strong></a></li><li><a href=#5-增量备份-1>5. <strong>增量备份</strong></a></li><li><a href=#6-定期备份和自动化>6. <strong>定期备份和自动化</strong></a></li><li><a href=#总结-32>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-顺序写入与高效磁盘存储>1. <strong>顺序写入与高效磁盘存储</strong></a></li><li><a href=#2-持久化与内存管理>2. <strong>持久化与内存管理</strong></a></li><li><a href=#3-分布式架构与水平扩展>3. <strong>分布式架构与水平扩展</strong></a></li><li><a href=#4-消息顺序和消费模型>4. <strong>消息顺序和消费模型</strong></a></li><li><a href=#5-消息存储机制>5. <strong>消息存储机制</strong></a></li><li><a href=#6-延迟与吞吐量>6. <strong>延迟与吞吐量</strong></a></li><li><a href=#7-容错性和数据持久化>7. <strong>容错性和数据持久化</strong></a></li><li><a href=#总结-33>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-from>1. <strong>FROM</strong></a></li><li><a href=#2-run>2. <strong>RUN</strong></a></li><li><a href=#3-cmd>3. <strong>CMD</strong></a></li><li><a href=#4-entrypoint>4. <strong>ENTRYPOINT</strong></a></li><li><a href=#5-copy>5. <strong>COPY</strong></a></li><li><a href=#6-add>6. <strong>ADD</strong></a></li><li><a href=#7-expose>7. <strong>EXPOSE</strong></a></li><li><a href=#8-env>8. <strong>ENV</strong></a></li><li><a href=#9-arg>9. <strong>ARG</strong></a></li><li><a href=#10-volume>10. <strong>VOLUME</strong></a></li><li><a href=#11-workdir>11. <strong>WORKDIR</strong></a></li><li><a href=#12-user>12. <strong>USER</strong></a></li><li><a href=#13-label>13. <strong>LABEL</strong></a></li><li><a href=#14-shell>14. <strong>SHELL</strong></a></li><li><a href=#15-stopsignal>15. <strong>STOPSIGNAL</strong></a></li><li><a href=#总结-34>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-选择合适的基础镜像>1. <strong>选择合适的基础镜像</strong></a></li><li><a href=#2-尽量减少>2. <strong>尽量减少 <code>RUN</code> 指令的层数</strong></a></li><li><a href=#3-删除临时文件和缓存>3. <strong>删除临时文件和缓存</strong></a></li><li><a href=#4-使用-1>4. <strong>使用 <code>.dockerignore</code> 文件</strong></a></li><li><a href=#5-使用多阶段构建multi-stage-build>5. <strong>使用多阶段构建（Multi-stage Build）</strong></a></li><li><a href=#6-使用压缩格式的文件>6. <strong>使用压缩格式的文件</strong></a></li><li><a href=#7-避免使用>7. <strong>避免使用 <code>ADD</code> 除非需要</strong></a></li><li><a href=#8-精简镜像中的文件和依赖>8. <strong>精简镜像中的文件和依赖</strong></a></li><li><a href=#9-使用合适的压缩格式>9. <strong>使用合适的压缩格式</strong></a></li><li><a href=#10-减少日志文件和调试信息>10. <strong>减少日志文件和调试信息</strong></a></li><li><a href=#总结-35>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-cmd命令>1. <strong>CMD（命令）</strong></a></li><li><a href=#2-entrypoint入口点>2. <strong>ENTRYPOINT（入口点）</strong></a></li><li><a href=#区别总结><strong>区别总结</strong></a></li><li><a href=#常见的组合方式><strong>常见的组合方式</strong></a></li><li><a href=#结论>结论</a></li></ul></li></ul><ul><li><ul><li><a href=#1-copy>1. <strong>COPY</strong></a></li><li><a href=#2-add>2. <strong>ADD</strong></a></li><li><a href=#区别总结-1><strong>区别总结</strong></a></li><li><a href=#使用建议><strong>使用建议</strong></a></li><li><a href=#示例-39><strong>示例</strong></a></li><li><a href=#结论-1><strong>结论</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-docker-client客户端>1. <strong>Docker Client（客户端）</strong></a></li><li><a href=#2-docker-daemon守护进程>2. <strong>Docker Daemon（守护进程）</strong></a></li><li><a href=#3-docker-registry镜像仓库>3. <strong>Docker Registry（镜像仓库）</strong></a></li><li><a href=#4-docker-image镜像>4. <strong>Docker Image（镜像）</strong></a></li><li><a href=#5-docker-container容器>5. <strong>Docker Container（容器）</strong></a></li><li><a href=#6-docker-volume数据卷>6. <strong>Docker Volume（数据卷）</strong></a></li><li><a href=#7-docker-network网络>7. <strong>Docker Network（网络）</strong></a></li><li><a href=#8-docker-swarm集群管理>8. <strong>Docker Swarm（集群管理）</strong></a></li><li><a href=#9-docker-compose编排工具>9. <strong>Docker Compose（编排工具）</strong></a></li><li><a href=#10-docker-cli命令行工具>10. <strong>Docker CLI（命令行工具）</strong></a></li><li><a href=#总结-36>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-bridge-network桥接网络>1. <strong>Bridge Network（桥接网络）</strong></a></li><li><a href=#2-host-network主机网络>2. <strong>Host Network（主机网络）</strong></a></li><li><a href=#3-overlay-network覆盖网络>3. <strong>Overlay Network（覆盖网络）</strong></a></li><li><a href=#4-macvlan-networkmacvlan-网络>4. <strong>Macvlan Network（Macvlan 网络）</strong></a></li><li><a href=#5-none-network无网络>5. <strong>None Network（无网络）</strong></a></li><li><a href=#6-container-network容器网络>6. <strong>Container Network（容器网络）</strong></a></li><li><a href=#总结-37>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-修改-docker-配置文件>1. 修改 Docker 配置文件</a></li><li><a href=#2-配置防火墙>2. 配置防火墙</a></li><li><a href=#3-重启-docker-服务>3. 重启 Docker 服务</a></li><li><a href=#4-测试远程访问>4. 测试远程访问</a></li><li><a href=#5-使用-tls-安全连接推荐>5. 使用 TLS 安全连接（推荐）</a></li><li><a href=#6-在客户端连接时使用-tls>6. 在客户端连接时使用 TLS</a></li><li><a href=#总结-38>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-namespace命名空间>1. <strong>Namespace（命名空间）</strong></a></li><li><a href=#2-cgroups控制组>2. <strong>Cgroups（控制组）</strong></a></li><li><a href=#3-union-file-system联合文件系统>3. <strong>Union File System（联合文件系统）</strong></a></li><li><a href=#综合总结>综合总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-导入和导出镜像>1. <strong>导入和导出镜像</strong></a></li><li><a href=#2-进入容器>2. <strong>进入容器</strong></a></li><li><a href=#3-设置重启策略>3. <strong>设置重启策略</strong></a></li><li><a href=#4-查看镜像环境变量>4. <strong>查看镜像环境变量</strong></a></li><li><a href=#5-查看容器占用资源>5. <strong>查看容器占用资源</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-通过-dockerfile-构建镜像>1. <strong>通过 Dockerfile 构建镜像</strong></a></li><li><a href=#2-使用-3>2. <strong>使用 <code>docker commit</code> 构建镜像</strong></a></li><li><a href=#3-从现有镜像创建自定义镜像>3. <strong>从现有镜像创建自定义镜像</strong></a></li><li><a href=#4-通过>4. <strong>通过 <code>docker buildx</code> 构建多平台镜像</strong></a></li><li><a href=#5-使用-buildkit-构建镜像>5. <strong>使用 BuildKit 构建镜像</strong></a></li><li><a href=#6-使用-docker-compose-构建镜像>6. <strong>使用 Docker Compose 构建镜像</strong></a></li><li><a href=#总结-39>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-虚拟化类型>1. <strong>虚拟化类型</strong></a></li><li><a href=#2-资源开销>2. <strong>资源开销</strong></a></li><li><a href=#3-启动时间>3. <strong>启动时间</strong></a></li><li><a href=#4-隔离级别>4. <strong>隔离级别</strong></a></li><li><a href=#5-性能>5. <strong>性能</strong></a></li><li><a href=#6-操作系统支持>6. <strong>操作系统支持</strong></a></li><li><a href=#7-应用场景>7. <strong>应用场景</strong></a></li><li><a href=#8-资源分配>8. <strong>资源分配</strong></a></li><li><a href=#9-迁移与扩展性>9. <strong>迁移与扩展性</strong></a></li><li><a href=#总结-40>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-控制平面组件>1. <strong>控制平面组件</strong></a></li><li><a href=#2-工作节点组件>2. <strong>工作节点组件</strong></a></li><li><a href=#3-其他组件>3. <strong>其他组件</strong></a></li><li><a href=#总结-41>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-修改副本数>1. <strong>修改副本数</strong></a></li><li><a href=#2-滚动更新>2. <strong>滚动更新</strong></a></li><li><a href=#3-回滚>3. <strong>回滚</strong></a></li><li><a href=#4-查看-pod-的详细信息>4. <strong>查看 Pod 的详细信息</strong></a></li><li><a href=#5-进入-pod-进行交互>5. <strong>进入 Pod 进行交互</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-备份-etcd-数据>1. <strong>备份 etcd 数据</strong></a></li><li><a href=#2-指定备份时使用的-etcd-集群信息>2. <strong>指定备份时使用的 etcd 集群信息</strong></a></li><li><a href=#3-恢复-etcd-数据>3. <strong>恢复 etcd 数据</strong></a></li><li><a href=#4-定期备份>4. <strong>定期备份</strong></a></li><li><a href=#5-检查备份有效性>5. <strong>检查备份有效性</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-replicationcontroller>1. <strong>ReplicationController</strong></a></li><li><a href=#2-replicaset>2. <strong>ReplicaSet</strong></a></li><li><a href=#3-deployment>3. <strong>Deployment</strong></a></li><li><a href=#4-statefulset>4. <strong>StatefulSet</strong></a></li><li><a href=#5-daemonset>5. <strong>DaemonSet</strong></a></li><li><a href=#6-job>6. <strong>Job</strong></a></li><li><a href=#7-cronjob>7. <strong>CronJob</strong></a></li><li><a href=#8-horizontalpodautoscaler-hpa>8. <strong>HorizontalPodAutoscaler (HPA)</strong></a></li><li><a href=#9-networkpolicy>9. <strong>NetworkPolicy</strong></a></li><li><a href=#10-ingresscontroller>10. <strong>IngressController</strong></a></li><li><a href=#11-custom-controller>11. <strong>Custom Controller</strong></a></li><li><a href=#12-certmanager>12. <strong>CertManager</strong></a></li><li><a href=#总结-42>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-node>1. <strong>Node</strong></a></li><li><a href=#2-namespace>2. <strong>Namespace</strong></a></li><li><a href=#3-persistentvolume-pv>3. <strong>PersistentVolume (PV)</strong></a></li><li><a href=#4-persistentvolumeclaim-pvc>4. <strong>PersistentVolumeClaim (PVC)</strong></a></li><li><a href=#5-storageclass>5. <strong>StorageClass</strong></a></li><li><a href=#6-clusterrole-和-clusterrolebinding>6. <strong>ClusterRole 和 ClusterRoleBinding</strong></a></li><li><a href=#7-configmap>7. <strong>ConfigMap</strong></a></li><li><a href=#8-secret>8. <strong>Secret</strong></a></li><li><a href=#9-ingress>9. <strong>Ingress</strong></a></li><li><a href=#10-resourcequota>10. <strong>ResourceQuota</strong></a></li><li><a href=#11-limitrange>11. <strong>LimitRange</strong></a></li><li><a href=#12-horizontalpodautoscaler-hpa>12. <strong>HorizontalPodAutoscaler (HPA)</strong></a></li><li><a href=#13-serviceaccount>13. <strong>ServiceAccount</strong></a></li><li><a href=#14-clusteroperator>14. <strong>ClusterOperator</strong></a></li><li><a href=#15-api-aggregation-layer-api-server>15. <strong>API Aggregation Layer (API Server)</strong></a></li><li><a href=#总结-43>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-pending>1. <strong>Pending</strong></a></li><li><a href=#2-running>2. <strong>Running</strong></a></li><li><a href=#3-succeeded>3. <strong>Succeeded</strong></a></li><li><a href=#4-failed>4. <strong>Failed</strong></a></li><li><a href=#5-crashloopbackoff>5. <strong>CrashLoopBackOff</strong></a></li><li><a href=#6-unknown>6. <strong>Unknown</strong></a></li><li><a href=#7-terminating>7. <strong>Terminating</strong></a></li><li><a href=#8-initializing-仅适用于-statefulset>8. <strong>Initializing</strong> (仅适用于 StatefulSet)</a></li><li><a href=#总结-44>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-用户提交请求>1. <strong>用户提交请求</strong></a></li><li><a href=#2-api-server-接收请求>2. <strong>API Server 接收请求</strong></a></li><li><a href=#3-调度scheduler选择节点>3. <strong>调度（Scheduler）选择节点</strong></a></li><li><a href=#4-node-接收-pod-配置>4. <strong>Node 接收 Pod 配置</strong></a></li><li><a href=#5-kubelet-创建容器>5. <strong>Kubelet 创建容器</strong></a></li><li><a href=#6-pod-启动和就绪检查>6. <strong>Pod 启动和就绪检查</strong></a></li><li><a href=#7-网络和服务关联>7. <strong>网络和服务关联</strong></a></li><li><a href=#8-pod-完成启动>8. <strong>Pod 完成启动</strong></a></li><li><a href=#9-监控和维护>9. <strong>监控和维护</strong></a></li><li><a href=#总结pod-创建的整个流程>总结：Pod 创建的整个流程</a></li></ul></li></ul><ul><li><ul><li><a href=#1-always>1. <strong>Always</strong></a></li><li><a href=#2-onfailure>2. <strong>OnFailure</strong></a></li><li><a href=#3-never>3. <strong>Never</strong></a></li><li><a href=#4-pod-重启策略与控制器的关系>4. <strong>Pod 重启策略与控制器的关系</strong></a></li><li><a href=#总结-45>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-存活探针liveness-probe>1. <strong>存活探针（Liveness Probe）</strong></a></li><li><a href=#2-就绪探针readiness-probe>2. <strong>就绪探针（Readiness Probe）</strong></a></li><li><a href=#3-启动探针startup-probe>3. <strong>启动探针（Startup Probe）</strong></a></li><li><a href=#4-探针配置的常见字段>4. <strong>探针配置的常见字段</strong></a></li><li><a href=#5-探针之间的区别>5. <strong>探针之间的区别</strong></a></li><li><a href=#总结-46>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-requests>1. <strong>Requests</strong></a></li><li><a href=#2-limits>2. <strong>Limits</strong></a></li><li><a href=#3-requests-和-limits-的关系>3. <strong>Requests 和 Limits 的关系</strong></a></li><li><a href=#4-cpu-和-内存的不同处理>4. <strong>CPU 和 内存的不同处理</strong></a></li><li><a href=#5-例子>5. <strong>例子</strong></a></li><li><a href=#6-总结>6. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#kubeconfig-文件的内容结构><code>kubeconfig</code> 文件的内容结构</a></li><li><a href=#kubeconfig-文件示例><code>kubeconfig</code> 文件示例</a></li><li><a href=#kubeconfig-的用途><code>kubeconfig</code> 的用途</a></li><li><a href=#kubeconfig-文件的管理><code>kubeconfig</code> 文件的管理</a></li><li><a href=#总结-47>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-role-和-clusterrole-的区别>1. <code>Role</code> 和 <code>ClusterRole</code> 的区别</a></li><li><a href=#2-rolebinding-和-clusterrolebinding-的区别>2. <code>RoleBinding</code> 和 <code>ClusterRoleBinding</code> 的区别</a></li><li><a href=#总结-48>总结</a></li><li><a href=#示例-40>示例</a></li></ul></li></ul><ul><li><ul><li><a href=#1-工作方式不同>1. <strong>工作方式不同</strong></a></li><li><a href=#2-性能优化>2. <strong>性能优化</strong></a></li><li><a href=#3-用途差异>3. <strong>用途差异</strong></a></li><li><a href=#4-流量转发方式>4. <strong>流量转发方式</strong></a></li><li><a href=#总结-49>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-storageclass-sc>1. <strong>StorageClass (SC)</strong></a></li><li><a href=#2-persistentvolume-pv>2. <strong>PersistentVolume (PV)</strong></a></li><li><a href=#3-persistentvolumeclaim-pvc>3. <strong>PersistentVolumeClaim (PVC)</strong></a></li><li><a href=#4-容器挂载存储的整个流程>4. <strong>容器挂载存储的整个流程</strong></a></li><li><a href=#总结-50>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#ingress-的原理本质><strong>Ingress 的原理本质：</strong></a></li><li><a href=#ingress-路由流程><strong>Ingress 路由流程：</strong></a></li><li><a href=#总结-51><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-kubernetes-网络模型><strong>1. Kubernetes 网络模型</strong></a></li><li><a href=#2-通信流程><strong>2. 通信流程</strong></a></li><li><a href=#3-使用-service-实现-pod-访问><strong>3. 使用 Service 实现 Pod 访问</strong></a></li><li><a href=#4-安全性和网络策略><strong>4. 安全性和网络策略</strong></a></li><li><a href=#总结-52><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#步骤-1驱逐节点上的-pod><strong>步骤 1：驱逐节点上的 Pod</strong></a></li><li><a href=#步骤-2检查集群状态><strong>步骤 2：检查集群状态</strong></a></li><li><a href=#步骤-3关闭维护节点><strong>步骤 3：关闭维护节点</strong></a></li><li><a href=#步骤-4维护完成后重新启动节点><strong>步骤 4：维护完成后重新启动节点</strong></a></li><li><a href=#步骤-5确保服务正常><strong>步骤 5：确保服务正常</strong></a></li><li><a href=#注意事项-3><strong>注意事项：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-网络模型和架构><strong>1. 网络模型和架构</strong></a></li><li><a href=#2-网络类型><strong>2. 网络类型</strong></a></li><li><a href=#3-性能><strong>3. 性能</strong></a></li><li><a href=#4-安全性><strong>4. 安全性</strong></a></li><li><a href=#5-网络策略><strong>5. 网络策略</strong></a></li><li><a href=#6-可扩展性><strong>6. 可扩展性</strong></a></li><li><a href=#7-安装和配置><strong>7. 安装和配置</strong></a></li><li><a href=#8-支持的环境><strong>8. 支持的环境</strong></a></li><li><a href=#总结-53><strong>总结：</strong></a></li><li><a href=#选择建议><strong>选择建议</strong>：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-监控模式pull-vs-push>1. <strong>监控模式：Pull vs Push</strong></a></li><li><a href=#2-时序数据存储和查询>2. <strong>时序数据存储和查询</strong></a></li><li><a href=#3-动态环境支持>3. <strong>动态环境支持</strong></a></li><li><a href=#4-集成与生态系统>4. <strong>集成与生态系统</strong></a></li><li><a href=#5-告警和通知>5. <strong>告警和通知</strong></a></li><li><a href=#6-安装和配置>6. <strong>安装和配置</strong></a></li><li><a href=#7-资源消耗>7. <strong>资源消耗</strong></a></li><li><a href=#8-水平扩展>8. <strong>水平扩展</strong></a></li><li><a href=#总结-54>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-prometheus-server>1. <strong>Prometheus Server</strong></a></li><li><a href=#2-alertmanager>2. <strong>Alertmanager</strong></a></li><li><a href=#3-prometheus-exporters>3. <strong>Prometheus Exporters</strong></a></li><li><a href=#4-prometheus-query-language-promql>4. <strong>Prometheus Query Language (PromQL)</strong></a></li><li><a href=#5-prometheus-ui>5. <strong>Prometheus UI</strong></a></li><li><a href=#6-prometheus-pushgateway>6. <strong>Prometheus Pushgateway</strong></a></li><li><a href=#7-thanos-可选>7. <strong>Thanos (可选)</strong></a></li><li><a href=#8-cortex-可选>8. <strong>Cortex (可选)</strong></a></li><li><a href=#总结-55>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-counter计数器>1. <strong>Counter（计数器）</strong></a></li><li><a href=#2-gauge仪表盘>2. <strong>Gauge（仪表盘）</strong></a></li><li><a href=#3-histogram直方图>3. <strong>Histogram（直方图）</strong></a></li><li><a href=#4-summary摘要>4. <strong>Summary（摘要）</strong></a></li><li><a href=#总结-56>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-水平扩展horizontal-scaling>1. <strong>水平扩展（Horizontal Scaling）</strong></a></li><li><a href=#2-使用->2. <strong>使用 *<em>Prometheus Operator*</em></strong></a></li><li><a href=#3-优化数据存储>3. <strong>优化数据存储</strong></a></li><li><a href=#4-优化指标收集>4. <strong>优化指标收集</strong></a></li><li><a href=#5-优化查询性能>5. <strong>优化查询性能</strong></a></li><li><a href=#6-引入->6. <strong>引入 *<em>Thanos*</em> 或 *<em>Cortex*</em> 来实现高可用和长期存储</strong></a></li><li><a href=#7-使用-alertmanager-的集群模式>7. <strong>使用 Alertmanager 的集群模式</strong></a></li><li><a href=#8-使用外部高效的存储后端>8. <strong>使用外部高效的存储后端</strong></a></li><li><a href=#9-优化网络>9. <strong>优化网络</strong></a></li><li><a href=#总结-57><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-安装-prometheus-监控系统>1. <strong>安装 Prometheus 监控系统</strong></a></li><li><a href=#2-安装并配置-node-exporter在被监控节点上>2. <strong>安装并配置 Node Exporter（在被监控节点上）</strong></a></li><li><a href=#3-prometheus-收集数据>3. <strong>Prometheus 收集数据</strong></a></li><li><a href=#4-安装-grafana>4. <strong>安装 Grafana</strong></a></li><li><a href=#5-配置-grafana-数据源>5. <strong>配置 Grafana 数据源</strong></a></li><li><a href=#6-创建仪表板和图表>6. <strong>创建仪表板和图表</strong></a></li><li><a href=#7-设置警报可选>7. <strong>设置警报（可选）</strong></a></li><li><a href=#8-查看监控数据>8. <strong>查看监控数据</strong></a></li><li><a href=#9-优化和调整>9. <strong>优化和调整</strong></a></li><li><a href=#总结-58>总结：</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=一linux>一、linux
<a class=anchor href=#%e4%b8%80linux>#</a></h1><h1 id=1-linux系统启动流程>1. linux系统启动流程
<a class=anchor href=#1-linux%e7%b3%bb%e7%bb%9f%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b>#</a></h1><ul><li>第一步：开机自检，加载BIOS</li><li>第二步：读取ＭＢＲ</li><li>第三步：Boot Loader　grub引导菜单</li><li>第四步：加载kernel内核</li><li>第五步：init进程依据inittab文件夹来设定运行级别</li><li>第六步：init进程执行rc.sysinit</li><li>第七步：启动内核模块</li><li>第八步：执行不同运行级别的脚本程序</li><li>第九步：执行/etc/rc.d/rc.lo</li></ul><p>Linux 系统启动流程是一个多阶段的过程，涉及多个重要的系统组件。以下是 Linux 系统从开机到完全启动的详细步骤：</p><h3 id=1-加电自检-post>1. <strong>加电自检 (POST)</strong>
<a class=anchor href=#1-%e5%8a%a0%e7%94%b5%e8%87%aa%e6%a3%80-post>#</a></h3><ul><li>当电脑通电后，首先会执行硬件自检（POST，Power-On Self-Test），由 BIOS 或 UEFI（现代系统通常使用 UEFI）来完成。这一步检查硬件设备是否正常，比如内存、硬盘、显示器等。</li></ul><h3 id=2-加载引导程序-bootloader>2. <strong>加载引导程序 (Bootloader)</strong>
<a class=anchor href=#2-%e5%8a%a0%e8%bd%bd%e5%bc%95%e5%af%bc%e7%a8%8b%e5%ba%8f-bootloader>#</a></h3><ul><li>BIOS 或 UEFI 会查找并加载存储设备（如硬盘或 SSD）上的引导加载程序（Bootloader）。常见的引导加载程序有 <strong>GRUB</strong>（GRand Unified Bootloader）和 <strong>LILO</strong>（Linux Loader）等。</li><li>引导加载程序的作用是加载并启动操作系统。它会显示可用的操作系统列表（如果有多个系统），并允许用户选择要启动的操作系统。</li></ul><h3 id=3-加载内核-kernel>3. <strong>加载内核 (Kernel)</strong>
<a class=anchor href=#3-%e5%8a%a0%e8%bd%bd%e5%86%85%e6%a0%b8-kernel>#</a></h3><ul><li>选择操作系统后，引导加载程序会加载操作系统的内核（通常是 <code>vmlinuz</code> 文件）。内核是操作系统的核心，负责管理硬件资源和提供系统服务。</li><li>内核首先会解压并加载到内存中，然后初始化硬件设备（如处理器、内存、硬盘等）。</li></ul><h3 id=4-初始化硬件和挂载根文件系统-root-filesystem>4. <strong>初始化硬件和挂载根文件系统 (Root Filesystem)</strong>
<a class=anchor href=#4-%e5%88%9d%e5%a7%8b%e5%8c%96%e7%a1%ac%e4%bb%b6%e5%92%8c%e6%8c%82%e8%bd%bd%e6%a0%b9%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f-root-filesystem>#</a></h3><ul><li>内核在加载完毕后，会开始初始化硬件，包括磁盘驱动程序、输入设备、网络设备等。</li><li>内核通过 <strong>initramfs</strong> 或 <strong>initrd</strong>（初始 RAM 文件系统）来帮助加载根文件系统（通常是 <code>/</code>）到内存中。initramfs 是一个压缩的文件系统镜像，包含必要的驱动程序和工具，确保系统能够挂载根文件系统。</li></ul><h3 id=5-启动-init-进程>5. <strong>启动 init 进程</strong>
<a class=anchor href=#5-%e5%90%af%e5%8a%a8-init-%e8%bf%9b%e7%a8%8b>#</a></h3><ul><li>内核初始化完成后，会启动系统的第一个用户空间进程，即 <strong>init</strong> 进程（PID 1）。这是 Linux 系统中最重要的进程，它负责启动和管理系统的其他进程。</li><li>在现代 Linux 系统中，<code>init</code> 进程通常由 <strong>systemd</strong> 替代，systemd 是一种系统和服务管理器，负责管理系统启动过程、服务和进程。</li></ul><h3 id=6-运行-init-脚本或服务管理器>6. <strong>运行 init 脚本或服务管理器</strong>
<a class=anchor href=#6-%e8%bf%90%e8%a1%8c-init-%e8%84%9a%e6%9c%ac%e6%88%96%e6%9c%8d%e5%8a%a1%e7%ae%a1%e7%90%86%e5%99%a8>#</a></h3><ul><li><p>systemd</p><p>或其他 init 系统（如</p><pre tabindex=0><code>SysVinit
</code></pre><p>或</p><pre tabindex=0><code>Upstart
</code></pre><p>）会根据配置文件（如</p><pre tabindex=0><code>/etc/systemd/system/
</code></pre><p>中的单元文件）启动各个系统服务和进程。</p><ul><li>对于 <strong>systemd</strong>，它会根据目标（如 <code>multi-user.target</code> 或 <code>graphical.target</code>）启动相关的服务。</li></ul></li><li><p>这包括启动网络服务、硬件驱动、用户登录管理器、数据库服务、应用程序等。</p></li></ul><h3 id=7-启动用户空间进程>7. <strong>启动用户空间进程</strong>
<a class=anchor href=#7-%e5%90%af%e5%8a%a8%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e8%bf%9b%e7%a8%8b>#</a></h3><ul><li>系统服务启动完毕后，开始启动用户空间的应用程序和守护进程。这些进程提供系统的功能，如网络连接、图形界面、文件共享等。</li><li>例如，<strong>login</strong> 或 <strong>getty</strong> 等进程会启动终端（TTY）或图形用户界面（GUI）。</li></ul><h3 id=8-登录界面>8. <strong>登录界面</strong>
<a class=anchor href=#8-%e7%99%bb%e5%bd%95%e7%95%8c%e9%9d%a2>#</a></h3><ul><li>如果启用了图形用户界面（GUI），例如使用 <strong>X Window</strong> 系统（如 <code>X11</code>）或 <strong>Wayland</strong>，系统会启动图形显示管理器（如 <strong>GDM</strong>，<strong>LightDM</strong>，<strong>SDDM</strong>）。</li><li>用户在图形界面中输入用户名和密码，或者在终端中使用 <strong>login</strong> 命令进行登录。</li></ul><h3 id=9-用户登录>9. <strong>用户登录</strong>
<a class=anchor href=#9-%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95>#</a></h3><ul><li>用户登录后，会进入到其个人的 shell 环境（如 <strong>bash</strong> 或 <strong>zsh</strong>），并可以开始使用系统。</li></ul><hr><h3 id=简要总结>简要总结
<a class=anchor href=#%e7%ae%80%e8%a6%81%e6%80%bb%e7%bb%93>#</a></h3><ol><li><strong>硬件自检 (POST)</strong>: BIOS/UEFI 检查硬件。</li><li><strong>加载引导程序 (Bootloader)</strong>: 引导程序如 GRUB 加载内核。</li><li><strong>加载内核 (Kernel)</strong>: 内核初始化硬件并启动 initramfs。</li><li><strong>启动 init 进程</strong>: 由 init（或 systemd）启动系统服务。</li><li><strong>初始化服务和进程</strong>: 启动必要的服务（如网络、硬件驱动等）。</li><li><strong>用户界面</strong>: 启动图形界面或终端，用户登录。</li><li><strong>登录并使用系统</strong>: 用户可以使用系统进行操作。</li></ol><p>这个过程是 Linux 系统启动的标准流程，虽然不同的发行版或配置可能有细微的差别，但大致步骤是一样的。</p><h1 id=2-linux文件类型>2. linux文件类型
<a class=anchor href=#2-linux%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b>#</a></h1><table><thead><tr><th>文件属性</th><th>文件类型</th></tr></thead><tbody><tr><td>-</td><td>常规文件，即file</td></tr><tr><td>d</td><td>目录文件</td></tr><tr><td>b</td><td>block device 即块设备文件，如硬盘;支持以block为单位进行随机访问</td></tr><tr><td>c</td><td>character device 即字符设备文件，如键盘支持以character为单位进行线性访问</td></tr><tr><td>l</td><td>symbolic link 即符号链接文件，又称软链接文件</td></tr><tr><td>p</td><td>pipe 即命名管道文件</td></tr><tr><td>s</td><td>socket 即套接字文件，用于实现两个进程进行通信</td></tr></tbody></table><p>在 Linux 中，文件是系统的基本单位，每个文件都有一个特定的类型。文件类型决定了文件的性质和如何操作该文件。Linux 文件类型可以分为以下几种：</p><h3 id=1-普通文件regular-file>1. <strong>普通文件（Regular File）</strong>
<a class=anchor href=#1-%e6%99%ae%e9%80%9a%e6%96%87%e4%bb%b6regular-file>#</a></h3><ul><li><strong>描述</strong>：普通文件是最常见的文件类型，存储着用户数据，如文本文件、图片、音频、视频、程序二进制文件等。</li><li><strong>常见扩展名</strong>：<code>.txt</code>（文本文件），<code>.jpg</code>（图片文件），<code>.mp3</code>（音频文件），<code>.bin</code>（二进制文件），<code>.cpp</code>（C++源代码文件）等。</li><li><strong>查看方式</strong>：在 <code>ls -l</code> 命令的输出中，普通文件的文件类型表示为 <code>-</code>。</li></ul><h3 id=2-目录文件directory-file>2. <strong>目录文件（Directory File）</strong>
<a class=anchor href=#2-%e7%9b%ae%e5%bd%95%e6%96%87%e4%bb%b6directory-file>#</a></h3><ul><li><strong>描述</strong>：目录文件包含指向其他文件或目录的指针。目录文件本身并不存储实际数据，而是存储文件名与文件的 inode 之间的映射关系。</li><li><strong>查看方式</strong>：在 <code>ls -l</code> 命令的输出中，目录文件的文件类型表示为 <code>d</code>。</li></ul><h3 id=3-符号链接文件symbolic-link或-symlink>3. <strong>符号链接文件（Symbolic Link，或 Symlink）</strong>
<a class=anchor href=#3-%e7%ac%a6%e5%8f%b7%e9%93%be%e6%8e%a5%e6%96%87%e4%bb%b6symbolic-link%e6%88%96-symlink>#</a></h3><ul><li><strong>描述</strong>：符号链接文件是一种指向另一个文件的引用。符号链接本身是一个指向目标文件路径的特殊文件。当访问符号链接时，系统会自动将操作转发到目标文件。</li><li><strong>查看方式</strong>：在 <code>ls -l</code> 命令的输出中，符号链接文件的文件类型表示为 <code>l</code>，并且会显示链接的目标路径。</li></ul><h3 id=4-字符设备文件character-device-file>4. <strong>字符设备文件（Character Device File）</strong>
<a class=anchor href=#4-%e5%ad%97%e7%ac%a6%e8%ae%be%e5%a4%87%e6%96%87%e4%bb%b6character-device-file>#</a></h3><ul><li><strong>描述</strong>：字符设备文件代表可以按字符流进行读写的设备。例如终端、打印机、键盘等。数据通过字符设备以字节为单位顺序处理。</li><li><strong>查看方式</strong>：在 <code>ls -l</code> 命令的输出中，字符设备文件的文件类型表示为 <code>c</code>。</li></ul><h3 id=5-块设备文件block-device-file>5. <strong>块设备文件（Block Device File）</strong>
<a class=anchor href=#5-%e5%9d%97%e8%ae%be%e5%a4%87%e6%96%87%e4%bb%b6block-device-file>#</a></h3><ul><li><strong>描述</strong>：块设备文件代表可以按块进行读写的设备，如硬盘、光驱、U 盘等。数据是以块（通常是 512 字节或更大）的形式进行传输和处理的。</li><li><strong>查看方式</strong>：在 <code>ls -l</code> 命令的输出中，块设备文件的文件类型表示为 <code>b</code>。</li></ul><h3 id=6-fifo-文件fifo-也叫命名管道>6. <strong>FIFO 文件（FIFO, 也叫命名管道）</strong>
<a class=anchor href=#6-fifo-%e6%96%87%e4%bb%b6fifo-%e4%b9%9f%e5%8f%ab%e5%91%bd%e5%90%8d%e7%ae%a1%e9%81%93>#</a></h3><ul><li><strong>描述</strong>：FIFO 文件是用于进程间通信（IPC）的特殊文件。它提供了一种单向的、按顺序流动的数据通道。通过 FIFO，数据可以从一个进程流向另一个进程。通常用于进程间的同步或数据传输。</li><li><strong>查看方式</strong>：在 <code>ls -l</code> 命令的输出中，FIFO 文件的文件类型表示为 <code>p</code>。</li></ul><h3 id=7-套接字文件socket-file>7. <strong>套接字文件（Socket File）</strong>
<a class=anchor href=#7-%e5%a5%97%e6%8e%a5%e5%ad%97%e6%96%87%e4%bb%b6socket-file>#</a></h3><ul><li><strong>描述</strong>：套接字文件是一种特殊的文件类型，通常用于进程间通信（IPC），尤其是网络通信。套接字可以用于本地进程间通信，或者通过网络进行通信。</li><li><strong>查看方式</strong>：在 <code>ls -l</code> 命令的输出中，套接字文件的文件类型表示为 <code>s</code>。</li></ul><h3 id=8-空文件empty-file>8. <strong>空文件（Empty File）</strong>
<a class=anchor href=#8-%e7%a9%ba%e6%96%87%e4%bb%b6empty-file>#</a></h3><ul><li><strong>描述</strong>：空文件是一个文件，但是它不包含任何数据。通常可以创建一个空文件用于占位或临时存储。</li><li><strong>查看方式</strong>：空文件没有特殊的标识符，仍然是普通文件的一种。</li></ul><hr><h3 id=查看文件类型>查看文件类型
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b>#</a></h3><p>可以使用 <code>ls -l</code> 命令查看文件的详细信息，文件类型会出现在第一列：</p><ul><li><code>-</code>：普通文件</li><li><code>d</code>：目录</li><li><code>l</code>：符号链接</li><li><code>c</code>：字符设备文件</li><li><code>b</code>：块设备文件</li><li><code>p</code>：FIFO 文件（命名管道）</li><li><code>s</code>：套接字文件</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls -l
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> user user  <span style=color:#ae81ff>12345</span> Jan <span style=color:#ae81ff>1</span> 12:34 example.txt   <span style=color:#75715e># 普通文件</span>
</span></span><span style=display:flex><span>drwxr-xr-x <span style=color:#ae81ff>2</span> user user  <span style=color:#ae81ff>4096</span>  Jan <span style=color:#ae81ff>1</span> 12:34 dir1          <span style=color:#75715e># 目录</span>
</span></span><span style=display:flex><span>lrwxrwxrwx <span style=color:#ae81ff>1</span> user user    <span style=color:#ae81ff>10</span>  Jan <span style=color:#ae81ff>1</span> 12:34 symlink -&gt; example.txt <span style=color:#75715e># 符号链接</span>
</span></span><span style=display:flex><span>crw-rw---- <span style=color:#ae81ff>1</span> root tty   5, <span style=color:#ae81ff>0</span>  Jan <span style=color:#ae81ff>1</span> 12:34 /dev/tty0      <span style=color:#75715e># 字符设备文件</span>
</span></span><span style=display:flex><span>brw-rw---- <span style=color:#ae81ff>1</span> root disk  8, <span style=color:#ae81ff>0</span>  Jan <span style=color:#ae81ff>1</span> 12:34 /dev/sda       <span style=color:#75715e># 块设备文件</span>
</span></span><span style=display:flex><span>prw-r--r-- <span style=color:#ae81ff>1</span> user user    <span style=color:#ae81ff>0</span>  Jan <span style=color:#ae81ff>1</span> 12:34 mypipe          <span style=color:#75715e># FIFO 文件</span>
</span></span><span style=display:flex><span>srw-rw---- <span style=color:#ae81ff>1</span> user user    <span style=color:#ae81ff>0</span>  Jan <span style=color:#ae81ff>1</span> 12:34 mysocket        <span style=color:#75715e># 套接字文件</span>
</span></span></code></pre></div><h3 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><ul><li>普通文件（Regular File）: 存储实际数据。</li><li>目录文件（Directory File）: 包含文件名和 inode 的映射。</li><li>符号链接文件（Symbolic Link）: 指向其他文件的引用。</li><li>字符设备文件（Character Device）: 按字符流读写的设备。</li><li>块设备文件（Block Device）: 按块读写的设备。</li><li>FIFO 文件（FIFO，命名管道）: 用于进程间通信。</li><li>套接字文件（Socket）: 用于网络或进程间通信。</li></ul><h1 id=3-centos6和7怎么将源码安装的程序添加到开机自启动>3. centos6和7怎么将源码安装的程序添加到开机自启动？
<a class=anchor href=#3-centos6%e5%92%8c7%e6%80%8e%e4%b9%88%e5%b0%86%e6%ba%90%e7%a0%81%e5%ae%89%e8%a3%85%e7%9a%84%e7%a8%8b%e5%ba%8f%e6%b7%bb%e5%8a%a0%e5%88%b0%e5%bc%80%e6%9c%ba%e8%87%aa%e5%90%af%e5%8a%a8>#</a></h1><ul><li>通用方法：编辑/etc/rc.d/rc.local文件，在文件末尾添加启动服务命令</li><li>centos6：①进入到/etc/rc.d/init.d目录下，②新建一个服务启动脚本，脚本中指定chkconfig参数，③添加执行权限，④执行chkconfig &ndash;add 添加服务自启动</li><li>centos7：①进入到/usr/lib/systemd/system目录下，②新建自定义服务文件，文件中包含[Unit] [Service] [Install]相关配置，然后添加下执行权限，③执行systemctl enable 服务名称</li></ul><p>在 CentOS 6 和 CentOS 7 中，尽管系统的初始化方式有所不同，但将源码安装的程序添加到开机自启动的方式基本相同。以下是针对这两个版本的操作方法。</p><h3 id=centos-6-和-centos-7-开机自启动的基本步骤>CentOS 6 和 CentOS 7 开机自启动的基本步骤
<a class=anchor href=#centos-6-%e5%92%8c-centos-7-%e5%bc%80%e6%9c%ba%e8%87%aa%e5%90%af%e5%8a%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%ad%a5%e9%aa%a4>#</a></h3><ol><li><p><strong>创建启动脚本</strong>： 无论是 CentOS 6 还是 CentOS 7，首先需要为你的程序编写一个启动脚本。假设你有一个程序 <code>/usr/local/bin/myprogram</code>，你可以创建一个启动脚本 <code>myprogram.sh</code>，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># 启动程序</span>
</span></span><span style=display:flex><span>/usr/local/bin/myprogram &amp;
</span></span></code></pre></div><p>这里的 <code>&</code> 确保程序在后台运行。</p></li><li><p><strong>设置脚本权限</strong>： 确保你的脚本可执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chmod +x /path/to/myprogram.sh
</span></span></code></pre></div></li><li><p><strong>将启动脚本添加到开机自启动</strong>：</p><h4 id=centos-6使用-initd-和-chkconfig>CentOS 6（使用 <code>init.d</code> 和 <code>chkconfig</code>）：
<a class=anchor href=#centos-6%e4%bd%bf%e7%94%a8-initd-%e5%92%8c-chkconfig>#</a></h4><p>CentOS 6 使用 <code>SysVinit</code> 初始化系统，启动脚本一般放在 <code>/etc/init.d/</code> 目录下，并通过 <code>chkconfig</code> 命令将其设置为开机自启动。</p><ul><li><p>将脚本移动到 <code>/etc/init.d/</code> 目录：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mv /path/to/myprogram.sh /etc/init.d/myprogram
</span></span></code></pre></div></li><li><p>使用 <code>chkconfig</code> 命令将脚本设置为开机自启动：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chkconfig --add myprogram
</span></span><span style=display:flex><span>chkconfig myprogram on
</span></span></code></pre></div></li><li><p>可以使用以下命令检查脚本是否已添加到启动项：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chkconfig --list myprogram
</span></span></code></pre></div></li></ul><h4 id=centos-7使用-systemd>CentOS 7（使用 <code>systemd</code>）：
<a class=anchor href=#centos-7%e4%bd%bf%e7%94%a8-systemd>#</a></h4><p>CentOS 7 引入了 <code>systemd</code>，因此你需要创建一个 <code>systemd</code> 服务单元文件来管理程序的启动。</p><ul><li><p>在 <code>/etc/systemd/system/</code> 目录下创建一个 <code>.service</code> 文件。例如，创建一个名为 <code>myprogram.service</code> 的文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nano /etc/systemd/system/myprogram.service
</span></span></code></pre></div><p>文件内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>My Program</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/local/bin/myprogram</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>always</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>User</span><span style=color:#f92672>=</span><span style=color:#e6db74>root</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><ul><li><strong><code>After=network.target</code></strong>：表示该服务将在网络服务之后启动。</li><li><strong><code>ExecStart</code></strong>：指定程序的路径和启动命令。</li><li><strong><code>Restart=always</code></strong>：程序崩溃后会自动重启。</li><li><strong><code>WantedBy=multi-user.target</code></strong>：将服务添加到 <code>multi-user.target</code>，表示程序将在多用户模式下启动。</li></ul></li><li><p>保存并退出后，重新加载 <code>systemd</code>，使其识别新的服务单元文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl daemon-reload
</span></span></code></pre></div></li><li><p>启动服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl start myprogram
</span></span></code></pre></div></li><li><p>设置服务为开机自启动：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl enable myprogram
</span></span></code></pre></div></li><li><p>可以使用以下命令检查服务状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl status myprogram
</span></span></code></pre></div></li></ul></li><li><p><strong>重启测试</strong>： 在完成上述设置后，重启系统进行测试，确认程序是否在开机时自动启动。</p><ul><li><p>在 CentOS 6 中使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo reboot
</span></span></code></pre></div></li><li><p>在 CentOS 7 中使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl reboot
</span></span></code></pre></div></li></ul></li></ol><h3 id=总结-1>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-1>#</a></h3><ul><li><strong>CentOS 6</strong>：使用 <code>init.d</code> 脚本并通过 <code>chkconfig</code> 设置开机自启动。</li><li><strong>CentOS 7</strong>：使用 <code>systemd</code> 创建服务单元文件并通过 <code>systemctl</code> 设置开机自启动。</li></ul><p>两种方式的共同点是都需要为程序创建一个启动脚本，然后将其添加到开机自启动项中。</p><h1 id=4-简述lvm如何给使用lvm的分区扩容>4. 简述lvm，如何给使用lvm的/分区扩容？
<a class=anchor href=#4-%e7%ae%80%e8%bf%b0lvm%e5%a6%82%e4%bd%95%e7%bb%99%e4%bd%bf%e7%94%a8lvm%e7%9a%84%e5%88%86%e5%8c%ba%e6%89%a9%e5%ae%b9>#</a></h1><ul><li>功能：可以对磁盘进行动态管理。动态按需调整大小</li><li>概念：</li></ul><p>①PV - 物理卷：物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘，也可以是raid设备。
②VG - 卷组：卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。
③LV - 逻辑卷：逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。</p><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012223427.png alt=image-20250224012223427></p><ul><li>给/分区扩容步骤：</li></ul><p>①添加磁盘
②使用fdisk命令对新增加的磁盘进行分区
③分区完成后修改分区类型为lvm
④使用pvcreate创建物理卷
⑤使用vgextend命令将新增加的分区加入到根目录分区中
⑥使用lvextend命令进行扩容
⑦使用xfs_growfs调整卷分区大小</p><h3 id=lvmlogical-volume-management简介>LVM（Logical Volume Management）简介
<a class=anchor href=#lvmlogical-volume-management%e7%ae%80%e4%bb%8b>#</a></h3><p>LVM（逻辑卷管理）是 Linux 中一种高级的磁盘管理方式，允许用户在逻辑层面上管理磁盘空间。LVM 将磁盘分为物理卷（Physical Volume，PV）、卷组（Volume Group，VG）和逻辑卷（Logical Volume，LV）。通过 LVM，用户可以更灵活地管理存储空间，进行动态扩展、缩减、迁移和快照等操作。</p><ul><li><strong>物理卷（PV）</strong>：物理存储设备（如硬盘、分区或 LUN），可以通过 <code>pvcreate</code> 命令初始化。</li><li><strong>卷组（VG）</strong>：由多个物理卷组成的存储池，用户可以在卷组中分配空间。</li><li><strong>逻辑卷（LV）</strong>：从卷组中划分出的存储空间，类似于传统分区，但更加灵活。</li></ul><h3 id=如何给使用-lvm-的--分区扩容>如何给使用 LVM 的 <code>/</code> 分区扩容
<a class=anchor href=#%e5%a6%82%e4%bd%95%e7%bb%99%e4%bd%bf%e7%94%a8-lvm-%e7%9a%84--%e5%88%86%e5%8c%ba%e6%89%a9%e5%ae%b9>#</a></h3><p>假设你已经有一个使用 LVM 的 <code>/</code> 分区，并且需要扩容。扩容过程涉及以下几个步骤：</p><h4 id=1-检查当前-lvm-结构>1. <strong>检查当前 LVM 结构</strong>
<a class=anchor href=#1-%e6%a3%80%e6%9f%a5%e5%bd%93%e5%89%8d-lvm-%e7%bb%93%e6%9e%84>#</a></h4><p>首先，使用以下命令查看当前的磁盘布局和 LVM 结构，确保你已经有足够的未分配空间，或者有一个可以扩展的物理卷（PV）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 查看所有物理卷</span>
</span></span><span style=display:flex><span>sudo pvdisplay
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看所有卷组</span>
</span></span><span style=display:flex><span>sudo vgdisplay
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看所有逻辑卷</span>
</span></span><span style=display:flex><span>sudo lvdisplay
</span></span></code></pre></div><h4 id=2-添加新的物理卷如果需要>2. <strong>添加新的物理卷（如果需要）</strong>
<a class=anchor href=#2-%e6%b7%bb%e5%8a%a0%e6%96%b0%e7%9a%84%e7%89%a9%e7%90%86%e5%8d%b7%e5%a6%82%e6%9e%9c%e9%9c%80%e8%a6%81>#</a></h4><p>如果当前卷组（VG）没有足够的空间，你需要添加一个新的物理磁盘或分区，并将其添加到卷组中。</p><p>假设你有一个新的磁盘 <code>/dev/sdb</code>，可以通过以下命令初始化该磁盘并将其添加到卷组（如 <code>centos</code> 卷组）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 创建物理卷</span>
</span></span><span style=display:flex><span>sudo pvcreate /dev/sdb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将物理卷添加到卷组</span>
</span></span><span style=display:flex><span>sudo vgextend centos /dev/sdb
</span></span></code></pre></div><h4 id=3-扩展逻辑卷>3. <strong>扩展逻辑卷</strong>
<a class=anchor href=#3-%e6%89%a9%e5%b1%95%e9%80%bb%e8%be%91%e5%8d%b7>#</a></h4><p>一旦有了足够的空间，下一步是扩展 <code>/</code> 分区的逻辑卷。假设 <code>/</code> 分区的逻辑卷是 <code>/dev/centos/root</code>，可以使用以下命令扩展逻辑卷：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 扩展逻辑卷</span>
</span></span><span style=display:flex><span>sudo lvextend -l +100%FREE /dev/centos/root
</span></span></code></pre></div><p><code>-l +100%FREE</code> 表示使用卷组中所有剩余的未分配空间。如果你只想使用一部分空间，可以指定实际的扩展大小，如 <code>-L +10G</code> 扩展 10GB。</p><h4 id=4-扩展文件系统>4. <strong>扩展文件系统</strong>
<a class=anchor href=#4-%e6%89%a9%e5%b1%95%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h4><p>扩展逻辑卷后，你还需要扩展文件系统，以便操作系统可以使用新的空间。根据你使用的文件系统类型（如 <code>ext4</code> 或 <code>xfs</code>），扩展命令不同。</p><ul><li><p>对于 <code>ext4</code> 文件系统，使用以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo resize2fs /dev/centos/root
</span></span></code></pre></div></li><li><p>对于 <code>xfs</code> 文件系统，使用以下命令（<code>xfs</code> 文件系统不需要指定大小，自动调整）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo xfs_growfs /dev/centos/root
</span></span></code></pre></div></li></ul><h4 id=5-验证扩容>5. <strong>验证扩容</strong>
<a class=anchor href=#5-%e9%aa%8c%e8%af%81%e6%89%a9%e5%ae%b9>#</a></h4><p>完成扩容后，使用以下命令验证分区是否已成功扩展：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 查看文件系统的使用情况</span>
</span></span><span style=display:flex><span>df -h
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看逻辑卷信息</span>
</span></span><span style=display:flex><span>sudo lvdisplay /dev/centos/root
</span></span></code></pre></div><h4 id=总结-2>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-2>#</a></h4><ol><li><strong>检查现有 LVM 配置</strong>：使用 <code>pvdisplay</code>、<code>vgdisplay</code> 和 <code>lvdisplay</code> 命令。</li><li><strong>添加新的物理卷</strong>（如果需要）：<code>pvcreate</code> 和 <code>vgextend</code>。</li><li><strong>扩展逻辑卷</strong>：使用 <code>lvextend</code> 命令扩展逻辑卷。</li><li><strong>扩展文件系统</strong>：根据文件系统类型，使用 <code>resize2fs</code>（ext4）或 <code>xfs_growfs</code>（xfs）进行扩展。</li><li><strong>验证扩容结果</strong>：使用 <code>df -h</code> 和 <code>lvdisplay</code> 确认空间是否已扩展。</li></ol><p>通过 LVM，你可以非常灵活地管理磁盘空间，进行动态扩展而不需要重新分区或重新格式化磁盘。</p><h1 id=5-为何du和df统计结果不一致>5. 为何du和df统计结果不一致？
<a class=anchor href=#5-%e4%b8%ba%e4%bd%95du%e5%92%8cdf%e7%bb%9f%e8%ae%a1%e7%bb%93%e6%9e%9c%e4%b8%8d%e4%b8%80%e8%87%b4>#</a></h1><ul><li>用户删除了大量的文件被删除后，在文件系统目录中已经不可见了，所以du就不会再统计它。</li><li>然而如果此时还有运行的进程持有这个已经被删除的文件句柄，那么这个文件就不会真正在磁盘中被删除，分区超级块中的信息也就不会更改，df仍会统计这个被删除的文件。</li><li>可通过 lsof命令查询处于deleted状态的文件，被删除的文件在系统中被标记为deleted。如果系统有大量deleted状态的文件，会导致du和df统计结果不一致。</li></ul><p><code>du</code> 和 <code>df</code> 都是用于查看磁盘使用情况的命令，但它们的统计方式和报告的内容不同，因此有时会导致它们显示的结果不一致。以下是导致 <code>du</code> 和 <code>df</code> 统计结果不一致的原因：</p><h3 id=1-du>1. <strong><code>du</code> 命令的工作原理</strong>
<a class=anchor href=#1-du>#</a></h3><ul><li><code>du</code>（Disk Usage）命令通过递归地扫描文件系统中的文件和目录，计算出文件或目录所占的磁盘空间。它的计算基于 <strong>文件实际占用的磁盘块</strong>。</li><li><code>du</code> 统计的是 <strong>文件系统中每个文件和目录的实际占用空间</strong>，包括文件内容和文件系统的元数据（如 inode 信息、目录项等）。</li><li><code>du</code> 默认会以块为单位（通常是 1K 或 4K）显示磁盘使用情况，且其结果是基于 <strong>文件系统中的数据</strong>，包括但不限于实际数据、磁盘对齐和文件系统元数据等。</li></ul><h3 id=2-df>2. <strong><code>df</code> 命令的工作原理</strong>
<a class=anchor href=#2-df>#</a></h3><ul><li><code>df</code>（Disk Free）命令报告文件系统的整体磁盘空间使用情况，显示文件系统的总空间、已用空间、可用空间和挂载点。</li><li><code>df</code> 报告的是 <strong>整个文件系统的空间</strong>，并且它计算的是 <strong>块设备的容量</strong>，包括文件系统的元数据、日志和预留空间（例如：ext4 文件系统会保留一部分空间供超级用户使用）。</li><li><code>df</code> 通常显示的是 <strong>文件系统层面的空间信息</strong>，它会考虑到预留空间、磁盘格式化信息等，而不仅仅是文件的实际占用空间。</li></ul><h3 id=3-为什么>3. <strong>为什么 <code>du</code> 和 <code>df</code> 显示不一致？</strong>
<a class=anchor href=#3-%e4%b8%ba%e4%bb%80%e4%b9%88>#</a></h3><ul><li><strong>保留空间</strong>：某些文件系统（如 ext4）会为 root 用户预留一部分空间，以防止非管理员用户填满整个文件系统。<code>df</code> 会显示包括这些保留空间在内的总空间，而 <code>du</code> 不会计算这些保留空间，因此 <code>du</code> 的结果通常会比 <code>df</code> 少。</li><li><strong>文件系统元数据</strong>：<code>df</code> 统计的空间包含了文件系统的元数据（如 inode、目录项、日志等），而 <code>du</code> 只计算文件和目录的实际数据占用。因此，<code>df</code> 的总空间可能会显示为比 <code>du</code> 更多的空间。</li><li><strong>挂载点</strong>：<code>du</code> 只会计算指定目录（及其子目录）下的文件占用空间，而 <code>df</code> 计算的是整个挂载点（包括所有子目录和挂载的其他文件系统）。如果有其他挂载点（如 <code>/mnt</code> 或 <code>/home</code>）在当前目录下，<code>df</code> 会包括这些挂载点的空间，而 <code>du</code> 则不会。</li><li><strong>文件系统特性</strong>：某些文件系统（如 Btrfs 或 ZFS）具有快照功能，<code>du</code> 可能会统计到这些快照的空间，而 <code>df</code> 可能不显示这些快照占用的空间，或者显示的是快照所使用的空间。</li><li><strong>软链接、挂载点和文件系统限制</strong>：如果文件系统有软链接或其他挂载点，<code>du</code> 会统计软链接指向的文件所占的空间，但不会考虑挂载点。如果某个文件系统的磁盘空间被多次挂载或链接，<code>df</code> 会报告总体空间，而 <code>du</code> 可能只计算一次。</li></ul><h3 id=4-常见场景示例>4. <strong>常见场景示例</strong>
<a class=anchor href=#4-%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af%e7%a4%ba%e4%be%8b>#</a></h3><ul><li><p><strong>保留空间</strong>：对于 ext4 文件系统，默认情况下，会保留 5% 的空间供超级用户使用，<code>df</code> 会显示这些保留空间，而 <code>du</code> 不会。</p><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># df 显示包括保留空间</span>
</span></span><span style=display:flex><span>$ df -h /
</span></span><span style=display:flex><span>Filesystem      Size  Used Avail Use% Mounted on
</span></span><span style=display:flex><span>/dev/sda1        50G   20G   25G  43% /
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># du 只显示实际使用的空间</span>
</span></span><span style=display:flex><span>$ du -sh /
</span></span><span style=display:flex><span>18G     /
</span></span></code></pre></div></li><li><p><strong>挂载点和软链接</strong>：如果你挂载了某个分区（例如 <code>/mnt</code>），<code>df</code> 会显示整个文件系统的空间，包括 <code>/mnt</code>，而 <code>du</code> 只会统计 <code>/mnt</code> 目录下的空间。</p></li></ul><h3 id=5-如何让>5. <strong>如何让 <code>du</code> 和 <code>df</code> 的结果更接近？</strong>
<a class=anchor href=#5-%e5%a6%82%e4%bd%95%e8%ae%a9>#</a></h3><ul><li><p><strong>排除挂载点</strong>：可以使用 <code>du</code> 命令的 <code>--one-file-system</code> 选项，避免计算挂载在当前文件系统之外的其他文件系统。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>du -sh --one-file-system /
</span></span></code></pre></div></li><li><p><strong>排除保留空间</strong>：使用 <code>df</code> 时可以使用 <code>--total</code> 选项查看所有文件系统的总使用情况，这样可以忽略一些特殊文件系统的影响。</p></li></ul><h3 id=总结-3>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-3>#</a></h3><ul><li><code>du</code> 和 <code>df</code> 显示不一致主要是因为它们统计的内容不同：<code>du</code> 统计的是文件实际占用的空间，而 <code>df</code> 统计的是文件系统级别的空间，包括保留空间、元数据和日志等。</li><li>要更准确地理解磁盘空间使用情况，建议结合 <code>du</code> 和 <code>df</code> 的输出，并注意它们各自的局限性。</li></ul><h1 id=6-如何升级内核>6. 如何升级内核？
<a class=anchor href=#6-%e5%a6%82%e4%bd%95%e5%8d%87%e7%ba%a7%e5%86%85%e6%a0%b8>#</a></h1><ul><li>方法一</li></ul><pre tabindex=0><code># 添加第三方yum源进行下载安装。
Centos 6 YUM源：http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm
Centos 7 YUM源：http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm
# 先导入elrepo的key，然后安装elrepo的yum源：
rpm -import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm
# 查看可用的内核相关包
yum --disablerepo=&#34;*&#34; --enablerepo=&#34;elrepo-kernel&#34; list available 
yum -y --enablerepo=elrepo-kernel install
</code></pre><ul><li>方法二</li></ul><pre tabindex=0><code># 通过下载kernel image的rpm包进行安装。
官方 Centos 6: http://elrepo.org/linux/kernel/el6/x86_64/RPMS/
官方 Centos 7: http://elrepo.org/linux/kernel/el7/x86_64/RPMS/
# 获取下载链接进行下载安装即可
wget https://elrepo.org/linux/kernel/el7/x86_64/RPMS/kernel-lt-4.4.185-1.el7.elrepo.x86_64.rpm
rpm -ivh kernel-lt-4.4.185-1.el7.elrepo.x86_64.rp
# 查看默认启动顺序
[root@localhost ~]# awk -F\&#39; &#39;$1==&#34;menuentry &#34; {print $2}&#39; /etc/grub2.cfg
CentOS Linux (5.2.2-1.el7.elrepo.x86_64) 7 (Core)
CentOS Linux (4.4.182-1.el7.elrepo.x86_64) 7 (Core)
CentOS Linux (3.10.0-957.21.3.el7.x86_64) 7 (Core)
CentOS Linux (3.10.0-957.10.1.el7.x86_64) 7 (Core)
CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)
CentOS Linux (0-rescue-e34fb4f1527b4f2d9fc75b77c016b6e7) 7 (Core)
由上面可以看出新内核(4.12.4)目前位置在0，原来的内核(3.10.0)目前位置在1
# 设置默认启动
[root@localhost ~]# grub2-set-default 0　　// 0代表当前第一行，也就是4.12.4版本
# 重启验证
</code></pre><p>升级 Linux 内核是一个相对常见的操作，尤其是当你需要使用某些新功能或解决安全问题时。下面是如何在 CentOS 6 和 CentOS 7 上升级内核的详细步骤。请根据你的系统版本和需求选择适合的方式。</p><h3 id=1-通过官方仓库更新内核centos-7>1. <strong>通过官方仓库更新内核（CentOS 7）</strong>
<a class=anchor href=#1-%e9%80%9a%e8%bf%87%e5%ae%98%e6%96%b9%e4%bb%93%e5%ba%93%e6%9b%b4%e6%96%b0%e5%86%85%e6%a0%b8centos-7>#</a></h3><p>在 CentOS 7 上，默认情况下会从官方仓库安装和更新内核。通过 <code>yum</code> 命令可以轻松进行内核更新，但有时这些仓库可能不会提供最新版本的内核。尽管如此，这仍然是升级内核的最简单方法。</p><h4 id=步骤>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4>#</a></h4><ol><li><p><strong>更新当前系统</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum update
</span></span></code></pre></div></li><li><p><strong>安装最新内核版本</strong>：</p><p>默认情况下，CentOS 7 会自动将内核更新到最新版本。如果不确定，执行以下命令来确保已安装最新版本的内核：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum install kernel
</span></span></code></pre></div><p>该命令会确保安装官方仓库中最新的稳定内核。</p></li><li><p><strong>查看当前内核版本</strong>：</p><p>你可以通过以下命令检查当前的内核版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uname -r
</span></span></code></pre></div></li><li><p><strong>重启系统</strong>：</p><p>更新内核后，重启系统以使新内核生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo reboot
</span></span></code></pre></div></li><li><p><strong>确认新内核是否生效</strong>：</p><p>重启后，再次执行 <code>uname -r</code> 命令检查内核版本，确认系统已经使用了新的内核。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uname -r
</span></span></code></pre></div></li></ol><hr><h3 id=2-通过-elrepo-安装最新的内核centos-7>2. <strong>通过 ELRepo 安装最新的内核（CentOS 7）</strong>
<a class=anchor href=#2-%e9%80%9a%e8%bf%87-elrepo-%e5%ae%89%e8%a3%85%e6%9c%80%e6%96%b0%e7%9a%84%e5%86%85%e6%a0%b8centos-7>#</a></h3><p>CentOS 官方仓库通常不会提供最新的内核版本，因此你可以通过第三方仓库 <strong>ELRepo</strong> 安装最新的内核。</p><h4 id=步骤-1>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-1>#</a></h4><ol><li><p><strong>安装 ELRepo 仓库</strong>：</p><p>首先，安装 ELRepo 仓库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.rpm
</span></span></code></pre></div></li><li><p><strong>安装最新的稳定内核</strong>：</p><p>ELRepo 提供了最新的内核版本。通过以下命令安装最新的内核（一般是 <code>kernel-ml</code>，即 Mainline Kernel）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum --enablerepo<span style=color:#f92672>=</span>elrepo-kernel install kernel-ml
</span></span></code></pre></div><p>如果你希望安装长期支持版本（LTS），可以安装 <code>kernel-lt</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum --enablerepo<span style=color:#f92672>=</span>elrepo-kernel install kernel-lt
</span></span></code></pre></div></li><li><p><strong>检查内核版本</strong>：</p><p>安装后，执行以下命令检查内核版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uname -r
</span></span></code></pre></div></li><li><p><strong>重启系统</strong>：</p><p>重启系统以加载新内核：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo reboot
</span></span></code></pre></div></li><li><p><strong>确认新内核</strong>：</p><p>再次使用 <code>uname -r</code> 命令检查当前内核版本。</p></li></ol><hr><h3 id=3-通过源代码手动编译安装内核适用于所有版本>3. <strong>通过源代码手动编译安装内核（适用于所有版本）</strong>
<a class=anchor href=#3-%e9%80%9a%e8%bf%87%e6%ba%90%e4%bb%a3%e7%a0%81%e6%89%8b%e5%8a%a8%e7%bc%96%e8%af%91%e5%ae%89%e8%a3%85%e5%86%85%e6%a0%b8%e9%80%82%e7%94%a8%e4%ba%8e%e6%89%80%e6%9c%89%e7%89%88%e6%9c%ac>#</a></h3><p>手动编译内核的步骤适用于那些需要非常具体内核配置或想要安装最新稳定版内核的用户。</p><h4 id=步骤-2>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-2>#</a></h4><ol><li><p><strong>下载内核源代码</strong>：</p><p>你可以从内核官方网站下载最新的内核源代码压缩包，网址：<a href=https://www.kernel.org/>https://www.kernel.org</a>。</p><p>例如，使用 <code>wget</code> 下载最新内核源代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.x.x.tar.xz
</span></span></code></pre></div></li><li><p><strong>解压源代码并进入目录</strong>：</p><p>解压下载的内核源代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tar -xvf linux-5.x.x.tar.xz
</span></span><span style=display:flex><span>cd linux-5.x.x
</span></span></code></pre></div></li><li><p><strong>配置内核</strong>：</p><p>配置内核参数。你可以使用以下命令来加载当前系统的配置，或者手动进行选择：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>make menuconfig
</span></span></code></pre></div><p>如果你想使用当前内核的配置，可以执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cp /boot/config-<span style=color:#66d9ef>$(</span>uname -r<span style=color:#66d9ef>)</span> .config
</span></span></code></pre></div></li><li><p><strong>编译内核</strong>：</p><p>使用 <code>make</code> 命令编译内核，通常会花费一些时间：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>make
</span></span></code></pre></div></li><li><p><strong>安装内核模块</strong>：</p><p>编译完成后，安装内核模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo make modules_install
</span></span></code></pre></div></li><li><p><strong>安装内核</strong>：</p><p>然后安装内核：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo make install
</span></span></code></pre></div></li><li><p><strong>更新引导加载器（GRUB）</strong>：</p><p>安装完成后，更新 GRUB 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo grub2-mkconfig -o /boot/grub2/grub.cfg
</span></span></code></pre></div><p>对于 UEFI 系统，使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg
</span></span></code></pre></div></li><li><p><strong>重启并选择新内核</strong>：</p><p>重启系统并选择新安装的内核。如果你使用的是 UEFI 系统，确保在 BIOS 或引导菜单中选择正确的启动项。</p></li><li><p><strong>验证内核版本</strong>：</p><p>重启后使用以下命令确认新内核已生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uname -r
</span></span></code></pre></div></li></ol><hr><h3 id=4-常见问题和注意事项>4. <strong>常见问题和注意事项</strong>
<a class=anchor href=#4-%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%92%8c%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h3><ul><li><p><strong>保留旧内核</strong>：安装新内核时，旧内核通常不会被删除。你可以通过 <code>yum remove kernel</code> 删除不需要的旧内核，或者手动删除 <code>/boot</code> 中的旧内核文件。务必保留至少一个旧内核，以防新内核出现问题时能回滚。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum remove kernel-&lt;version&gt;
</span></span></code></pre></div></li><li><p><strong>使用 GRUB 选择内核</strong>：在系统启动时，可以通过 GRUB 菜单选择启动哪个内核。在启动时按下 <code>Esc</code> 键或 <code>Shift</code> 键（取决于你的系统配置），选择你需要的内核。</p></li><li><p><strong>引导加载器问题</strong>：如果在系统启动时遇到问题，可以进入 GRUB 进行内核选择，或者从 Live CD 启动修复。</p></li></ul><h3 id=总结-4>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-4>#</a></h3><ul><li><strong>CentOS 7</strong> 用户可以使用 <code>yum</code> 命令更新内核，或者通过安装 <strong>ELRepo</strong> 提供的最新内核。</li><li><strong>手动编译内核</strong> 是一种高级选项，适用于需要自定义内核配置的用户。</li><li>在更新内核后，记得重启系统并验证内核版本。</li></ul><p>通过这些步骤，你可以根据自己的需求顺利升级 Linux 内核。</p><h1 id=7-nginx日志访问量前十的ip怎么统计>7. nginx日志访问量前十的ip怎么统计？
<a class=anchor href=#7-nginx%e6%97%a5%e5%bf%97%e8%ae%bf%e9%97%ae%e9%87%8f%e5%89%8d%e5%8d%81%e7%9a%84ip%e6%80%8e%e4%b9%88%e7%bb%9f%e8%ae%a1>#</a></h1><pre tabindex=0><code>awk &#39;{array[$1]++}END{for (ip in array)print ip,array[ip]}&#39; access.log |sort -k2 -rn|head
</code></pre><p>要统计 Nginx 日志中访问量前十的 IP 地址，可以通过 <code>awk</code>、<code>sort</code> 和 <code>uniq</code> 等命令来处理 Nginx 的访问日志。以下是一些常见的步骤和命令来实现这个目标。</p><h3 id=1-基本的-nginx-访问日志格式>1. <strong>基本的 Nginx 访问日志格式</strong>
<a class=anchor href=#1-%e5%9f%ba%e6%9c%ac%e7%9a%84-nginx-%e8%ae%bf%e9%97%ae%e6%97%a5%e5%bf%97%e6%a0%bc%e5%bc%8f>#</a></h3><p>假设 Nginx 的访问日志格式为以下标准格式：</p><pre tabindex=0><code>127.0.0.1 - - [12/Oct/2023:14:28:14 +0000] &#34;GET /index.html HTTP/1.1&#34; 200 1024 &#34;-&#34; &#34;Mozilla/5.0&#34;
</code></pre><p>其中，第一个字段（<code>127.0.0.1</code>）是访问的客户端 IP 地址。</p><h3 id=2-通过命令统计访问量前十的-ip>2. <strong>通过命令统计访问量前十的 IP</strong>
<a class=anchor href=#2-%e9%80%9a%e8%bf%87%e5%91%bd%e4%bb%a4%e7%bb%9f%e8%ae%a1%e8%ae%bf%e9%97%ae%e9%87%8f%e5%89%8d%e5%8d%81%e7%9a%84-ip>#</a></h3><p>你可以使用 <code>awk</code> 提取 IP 地址，然后使用 <code>sort</code> 和 <code>uniq</code> 统计每个 IP 的访问量，并显示访问量前十的 IP。</p><h4 id=统计步骤>统计步骤：
<a class=anchor href=#%e7%bb%9f%e8%ae%a1%e6%ad%a5%e9%aa%a4>#</a></h4><ol><li><p><strong>提取 IP 地址并统计次数</strong>：</p><p>假设你的 Nginx 访问日志文件是 <code>/var/log/nginx/access.log</code>，你可以使用以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /var/log/nginx/access.log | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> | sort | uniq -c | sort -nr | head -n <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>解释：</p><ul><li><code>cat /var/log/nginx/access.log</code>：输出 Nginx 访问日志。</li><li><code>awk '{print $1}'</code>：提取日志中的 IP 地址（假设 IP 是日志的第一个字段）。</li><li><code>sort</code>：对 IP 地址进行排序，<code>sort</code> 是为 <code>uniq</code> 做准备。</li><li><code>uniq -c</code>：统计每个 IP 出现的次数。</li><li><code>sort -nr</code>：按照访问次数进行降序排序。</li><li><code>head -n 10</code>：输出访问量前十的 IP 地址。</li></ul><p>该命令会输出类似如下的结果：</p><pre tabindex=0><code>320 192.168.1.1
210 10.0.0.2
180 192.168.0.3
150 10.0.0.4
...
</code></pre><p>其中数字表示该 IP 地址的访问次数。</p></li></ol><h3 id=3-详细的字段输出>3. <strong>详细的字段输出</strong>
<a class=anchor href=#3-%e8%af%a6%e7%bb%86%e7%9a%84%e5%ad%97%e6%ae%b5%e8%be%93%e5%87%ba>#</a></h3><p>如果你希望输出 IP 地址和访问次数，并且显示更详细的信息（比如每个 IP 的访问量），可以使用以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /var/log/nginx/access.log | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> | sort | uniq -c | sort -nr | head -n <span style=color:#ae81ff>10</span> | awk <span style=color:#e6db74>&#39;{print &#34;IP:&#34;, $2, &#34;访问量:&#34;, $1}&#39;</span>
</span></span></code></pre></div><p>输出示例：</p><pre tabindex=0><code>IP: 192.168.1.1 访问量: 320
IP: 10.0.0.2 访问量: 210
IP: 192.168.0.3 访问量: 180
IP: 10.0.0.4 访问量: 150
...
</code></pre><h3 id=4-按日期时间过滤日志>4. <strong>按日期/时间过滤日志</strong>
<a class=anchor href=#4-%e6%8c%89%e6%97%a5%e6%9c%9f%e6%97%b6%e9%97%b4%e8%bf%87%e6%bb%a4%e6%97%a5%e5%bf%97>#</a></h3><p>如果你只关心某个时间段内的访问量，可以通过 <code>grep</code> 结合时间过滤日志。例如，查看 2023 年 10 月 12 日的日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep <span style=color:#e6db74>&#39;12/Oct/2023&#39;</span> /var/log/nginx/access.log | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> | sort | uniq -c | sort -nr | head -n <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><h3 id=5-按请求类型如-get-post进行过滤>5. <strong>按请求类型（如 GET, POST）进行过滤</strong>
<a class=anchor href=#5-%e6%8c%89%e8%af%b7%e6%b1%82%e7%b1%bb%e5%9e%8b%e5%a6%82-get-post%e8%bf%9b%e8%a1%8c%e8%bf%87%e6%bb%a4>#</a></h3><p>如果你只关心某种请求类型的访问量（如 <code>GET</code> 请求），可以通过 <code>grep</code> 过滤：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep <span style=color:#e6db74>&#39;GET&#39;</span> /var/log/nginx/access.log | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> | sort | uniq -c | sort -nr | head -n <span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>这样，你可以针对特定类型的请求来统计访问量前十的 IP。</p><h3 id=6-自动化统计并输出到文件>6. <strong>自动化统计并输出到文件</strong>
<a class=anchor href=#6-%e8%87%aa%e5%8a%a8%e5%8c%96%e7%bb%9f%e8%ae%a1%e5%b9%b6%e8%be%93%e5%87%ba%e5%88%b0%e6%96%87%e4%bb%b6>#</a></h3><p>如果你想将统计结果保存到文件中，可以将命令输出重定向到一个文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /var/log/nginx/access.log | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> | sort | uniq -c | sort -nr | head -n <span style=color:#ae81ff>10</span> &gt; top_ip.txt
</span></span></code></pre></div><p>然后可以查看 <code>top_ip.txt</code> 文件获取统计信息。</p><hr><h3 id=总结-5>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-5>#</a></h3><ul><li>使用 <code>awk</code> 提取 IP 地址，<code>sort</code> 排序，<code>uniq -c</code> 统计访问次数，<code>sort -nr</code> 按次数降序排列。</li><li>可选择将日志按日期或请求类型进行过滤。</li><li>可以将统计结果保存到文件中以便后续查看。</li></ul><p>通过这种方式，你可以轻松统计 Nginx 日志中的访问量前十的 IP 地址。</p><h1 id=8-如何删除varlog下log结尾的30天前的日志>8. 如何删除/var/log/下.log结尾的30天前的日志？
<a class=anchor href=#8-%e5%a6%82%e4%bd%95%e5%88%a0%e9%99%a4varlog%e4%b8%8blog%e7%bb%93%e5%b0%be%e7%9a%8430%e5%a4%a9%e5%89%8d%e7%9a%84%e6%97%a5%e5%bf%97>#</a></h1><pre tabindex=0><code>find /var/log/ -type f -name .*.log -mtime 30|xargs rm -f
</code></pre><p>要删除 <code>/var/log/</code> 目录下所有 <code>.log</code> 结尾且超过 30 天的日志文件，可以使用 <code>find</code> 命令来查找这些文件并执行删除操作。以下是具体的步骤：</p><h3 id=1-查看>1. <strong>查看 <code>.log</code> 文件中超过 30 天的文件</strong>
<a class=anchor href=#1-%e6%9f%a5%e7%9c%8b>#</a></h3><p>首先，你可以使用 <code>find</code> 命令查看 <code>/var/log/</code> 目录下所有 <code>.log</code> 文件，且这些文件的最后修改时间超过 30 天：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>find /var/log/ -type f -name <span style=color:#e6db74>&#34;*.log&#34;</span> -mtime +30
</span></span></code></pre></div><p>解释：</p><ul><li><code>/var/log/</code>：指定要搜索的目录。</li><li><code>-type f</code>：查找普通文件。</li><li><code>-name "*.log"</code>：查找以 <code>.log</code> 结尾的文件。</li><li><code>-mtime +30</code>：查找修改时间超过 30 天的文件（<code>+30</code> 表示大于 30 天）。</li></ul><p>如果执行该命令后，你可以看到符合条件的日志文件列表。</p><h3 id=2-删除超过-30-天的>2. <strong>删除超过 30 天的 <code>.log</code> 文件</strong>
<a class=anchor href=#2-%e5%88%a0%e9%99%a4%e8%b6%85%e8%bf%87-30-%e5%a4%a9%e7%9a%84>#</a></h3><p>如果确认要删除这些文件，可以将 <code>find</code> 命令与 <code>-exec</code> 选项结合，执行删除操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>find /var/log/ -type f -name <span style=color:#e6db74>&#34;*.log&#34;</span> -mtime +30 -exec rm -f <span style=color:#f92672>{}</span> <span style=color:#ae81ff>\;</span>
</span></span></code></pre></div><p>解释：</p><ul><li><code>-exec rm -f {} \;</code>：对于找到的每个文件，执行 <code>rm -f</code> 删除操作。<code>{}</code> 是一个占位符，表示当前找到的文件名，<code>\;</code> 表示命令的结束。</li></ul><h3 id=3-在删除前进行确认>3. <strong>在删除前进行确认</strong>
<a class=anchor href=#3-%e5%9c%a8%e5%88%a0%e9%99%a4%e5%89%8d%e8%bf%9b%e8%a1%8c%e7%a1%ae%e8%ae%a4>#</a></h3><p>为了避免误删，可以先运行一个测试命令，确认哪些文件将被删除：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>find /var/log/ -type f -name <span style=color:#e6db74>&#34;*.log&#34;</span> -mtime +30 -exec ls -l <span style=color:#f92672>{}</span> <span style=color:#ae81ff>\;</span>
</span></span></code></pre></div><p>这个命令将列出所有符合条件的文件及其详细信息（包括文件大小、修改时间等），你可以检查确认是否正确。</p><h3 id=4-使用>4. <strong>使用 <code>logrotate</code> 自动管理日志</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8>#</a></h3><p>如果你需要定期删除过期日志文件，建议使用 <code>logrotate</code> 工具来管理日志文件的轮换和删除。<code>logrotate</code> 是 Linux 系统上用于自动化日志文件管理的工具，通常它会配置为定期归档和删除旧日志文件。</p><h4 id=配置示例>配置示例：
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e7%a4%ba%e4%be%8b>#</a></h4><p><code>/etc/logrotate.d/</code> 目录下存放着每个服务的日志轮换配置文件。你可以在该目录中为 <code>/var/log/</code> 下的日志创建或修改一个配置文件来自动管理日志。</p><p>一个基本的 <code>logrotate</code> 配置示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/log/*.log <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    daily            <span style=color:#75715e># 每天轮换</span>
</span></span><span style=display:flex><span>    rotate <span style=color:#ae81ff>7</span>         <span style=color:#75715e># 保留7个历史日志</span>
</span></span><span style=display:flex><span>    compress         <span style=color:#75715e># 压缩归档的日志</span>
</span></span><span style=display:flex><span>    missingok        <span style=color:#75715e># 如果日志文件缺失，则不报错</span>
</span></span><span style=display:flex><span>    notifempty       <span style=color:#75715e># 如果日志文件为空，不进行轮换</span>
</span></span><span style=display:flex><span>    create <span style=color:#ae81ff>0644</span> root root  <span style=color:#75715e># 新日志文件创建时的权限</span>
</span></span><span style=display:flex><span>    dateext          <span style=color:#75715e># 使用日期作为归档文件名的一部分</span>
</span></span><span style=display:flex><span>    maxage <span style=color:#ae81ff>30</span>        <span style=color:#75715e># 删除超过30天的日志文件</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=总结-6>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-6>#</a></h3><ul><li>使用 <code>find</code> 命令查找并删除 <code>/var/log/</code> 目录下修改时间超过 30 天的 <code>.log</code> 文件。</li><li>可以先使用 <code>ls -l</code> 查看将要删除的文件，确保删除操作不会误删重要文件。</li><li>建议使用 <code>logrotate</code> 工具自动管理和清理日志文件，避免手动删除。</li></ul><h1 id=9-ansible有哪些模块功能是什么>9. ansible有哪些模块？功能是什么？
<a class=anchor href=#9-ansible%e6%9c%89%e5%93%aa%e4%ba%9b%e6%a8%a1%e5%9d%97%e5%8a%9f%e8%83%bd%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>copy</td><td>拷贝文件到被控端</td></tr><tr><td>cron</td><td>定时任务</td></tr><tr><td>fetch</td><td>拷贝被控端文件到本地</td></tr><tr><td>file</td><td>文件模块</td></tr><tr><td>group</td><td>用户组模块</td></tr><tr><td>user</td><td>用户模块</td></tr><tr><td>hostname</td><td>主机名模块</td></tr><tr><td>script</td><td>脚本模块</td></tr><tr><td>service</td><td>服务启动模块</td></tr><tr><td>command</td><td>远程执行命令模块</td></tr><tr><td>shell</td><td>远程执行命令模块，command高级用法</td></tr><tr><td>yum</td><td>安装包组模块</td></tr><tr><td>setup</td><td>查看主机系统信息</td></tr></tbody></table><p>Ansible 提供了大量的模块来实现各种自动化任务。这些模块是 Ansible 执行任务的基本单元，它们负责执行特定的操作，例如文件管理、系统管理、应用部署等。模块可以分为不同的类别，每个模块实现不同的功能。以下是 Ansible 常见模块的分类和功能概述。</p><h3 id=1-文件和目录管理模块>1. <strong>文件和目录管理模块</strong>
<a class=anchor href=#1-%e6%96%87%e4%bb%b6%e5%92%8c%e7%9b%ae%e5%bd%95%e7%ae%a1%e7%90%86%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于文件和目录的创建、删除、修改、权限管理等操作。</p><ul><li><strong><code>file</code></strong>：管理文件或目录的属性，如权限、所有者和群组。<ul><li>示例：<code>ansible -m file -a "path=/tmp/testfile state=touch mode=0644"</code></li></ul></li><li><strong><code>copy</code></strong>：将本地文件或目录复制到远程主机。<ul><li>示例：<code>ansible -m copy -a "src=/path/to/local/file dest=/path/to/remote/file"</code></li></ul></li><li><strong><code>template</code></strong>：将模板文件（通常是 Jinja2 格式的）从本地复制到远程主机，并渲染模板。<ul><li>示例：<code>ansible -m template -a "src=/path/to/template.j2 dest=/path/to/remote/file"</code></li></ul></li><li><strong><code>fetch</code></strong>：从远程主机下载文件到本地。<ul><li>示例：<code>ansible -m fetch -a "src=/path/to/remote/file dest=/path/to/local/dir flat=yes"</code></li></ul></li><li><strong><code>lineinfile</code></strong>：修改文件中的某一行。<ul><li>示例：`ansible -m lineinfile -a &ldquo;path=/etc/hosts line=&lsquo;192.168.1.1 myhost&rsquo;&rdquo;</li></ul></li><li><strong><code>file</code></strong>：改变文件的属性，移动文件，或删除文件。<ul><li>示例：<code>ansible -m file -a "path=/path/to/file state=absent"</code></li></ul></li></ul><hr><h3 id=2-系统管理模块>2. <strong>系统管理模块</strong>
<a class=anchor href=#2-%e7%b3%bb%e7%bb%9f%e7%ae%a1%e7%90%86%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于管理操作系统中的各种资源。</p><ul><li><strong><code>user</code></strong>：管理用户账户。<ul><li>示例：<code>ansible -m user -a "name=test_user state=present"</code></li></ul></li><li><strong><code>group</code></strong>：管理用户组。<ul><li>示例：<code>ansible -m group -a "name=test_group state=present"</code></li></ul></li><li><strong><code>service</code></strong>：管理服务的状态（启动、停止、重启等）。<ul><li>示例：<code>ansible -m service -a "name=httpd state=started"</code></li></ul></li><li><strong><code>command</code></strong>：在远程主机上执行命令。<ul><li>示例：<code>ansible -m command -a "df -h"</code></li></ul></li><li><strong><code>shell</code></strong>：在远程主机上执行 shell 命令。<ul><li>示例：<code>ansible -m shell -a "echo 'Hello' > /tmp/hello.txt"</code></li></ul></li><li><strong><code>cron</code></strong>：管理定时任务。<ul><li>示例：<code>ansible -m cron -a "name='run_backup' minute='0' hour='2' job='/usr/bin/backup.sh' state=present"</code></li></ul></li><li><strong><code>reboot</code></strong>：重启远程主机。<ul><li>示例：<code>ansible -m reboot -a "connect_timeout=5"</code></li></ul></li><li><strong><code>hostname</code></strong>：设置主机名。<ul><li>示例：<code>ansible -m hostname -a "name=myhost"</code></li></ul></li></ul><hr><h3 id=3-网络管理模块>3. <strong>网络管理模块</strong>
<a class=anchor href=#3-%e7%bd%91%e7%bb%9c%e7%ae%a1%e7%90%86%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于网络设备的管理和配置。</p><ul><li><strong><code>uri</code></strong>：与 REST API 进行交互，发送 HTTP 请求。<ul><li>示例：<code>ansible -m uri -a "url=http://example.com method=GET"</code></li></ul></li><li><strong><code>ping</code></strong>：测试与远程主机的连接。<ul><li>示例：<code>ansible -m ping all</code></li></ul></li><li><strong><code>firewalld</code></strong>：管理 firewalld 防火墙规则。<ul><li>示例：<code>ansible -m firewalld -a "service=http permanent=true state=enabled"</code></li></ul></li><li><strong><code>docker</code></strong>：管理 Docker 容器和镜像。<ul><li>示例：<code>ansible -m docker_container -a "name=test_container state=started image=ubuntu"</code></li></ul></li></ul><hr><h3 id=4-包管理模块>4. <strong>包管理模块</strong>
<a class=anchor href=#4-%e5%8c%85%e7%ae%a1%e7%90%86%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于管理操作系统上的软件包（安装、更新、删除）。</p><ul><li><strong><code>yum</code></strong>：用于管理基于 RPM 的 Linux 发行版（如 CentOS、RHEL）的软件包。<ul><li>示例：<code>ansible -m yum -a "name=httpd state=present"</code></li></ul></li><li><strong><code>apt</code></strong>：用于管理基于 Debian 的 Linux 发行版（如 Ubuntu）的软件包。<ul><li>示例：<code>ansible -m apt -a "name=nginx state=present"</code></li></ul></li><li><strong><code>pip</code></strong>：用于安装和管理 Python 包。<ul><li>示例：<code>ansible -m pip -a "name=flask state=present"</code></li></ul></li><li><strong><code>npm</code></strong>：用于管理 Node.js 包。<ul><li>示例：<code>ansible -m npm -a "name=express state=present"</code></li></ul></li></ul><hr><h3 id=5-数据库管理模块>5. <strong>数据库管理模块</strong>
<a class=anchor href=#5-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ae%a1%e7%90%86%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于管理数据库实例和执行相关任务。</p><ul><li><strong><code>mysql_db</code></strong>：管理 MySQL 数据库的创建、删除、备份等操作。<ul><li>示例：<code>ansible -m mysql_db -a "name=testdb state=present"</code></li></ul></li><li><strong><code>postgresql_db</code></strong>：管理 PostgreSQL 数据库。<ul><li>示例：<code>ansible -m postgresql_db -a "name=testdb state=present"</code></li></ul></li><li><strong><code>mongodb</code></strong>：管理 MongoDB 数据库。<ul><li>示例：<code>ansible -m mongodb -a "name=testdb state=present"</code></li></ul></li></ul><hr><h3 id=6-云服务模块>6. <strong>云服务模块</strong>
<a class=anchor href=#6-%e4%ba%91%e6%9c%8d%e5%8a%a1%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于云平台的资源管理，如 AWS、Azure、Google Cloud 等。</p><ul><li><strong><code>ec2</code></strong>：在 AWS 上创建、管理 EC2 实例。<ul><li>示例：<code>ansible -m ec2 -a "image=ami-xxxxxxxx region=us-west-2 instance_type=t2.micro count=1"</code></li></ul></li><li><strong><code>gce_instance</code></strong>：管理 Google Cloud 上的实例。<ul><li>示例：<code>ansible -m gce_instance -a "name=my-instance zone=us-central1-a image_family=debian-9 image_project=debian-cloud"</code></li></ul></li><li><strong><code>azure_rm_virtualmachine</code></strong>：在 Azure 上创建、管理虚拟机。<ul><li>示例：<code>ansible -m azure_rm_virtualmachine -a "resource_group=myResourceGroup name=myVM image=UbuntuLTS size=Standard_B1s"</code></li></ul></li></ul><hr><h3 id=7-监控与报警模块>7. <strong>监控与报警模块</strong>
<a class=anchor href=#7-%e7%9b%91%e6%8e%a7%e4%b8%8e%e6%8a%a5%e8%ad%a6%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于监控和报警管理。</p><ul><li><strong><code>prometheus</code></strong>：与 Prometheus 进行集成，管理和查询 Prometheus 指标。<ul><li>示例：<code>ansible -m prometheus -a "job=myjob target=localhost"</code></li></ul></li><li><strong><code>grafana_dashboard</code></strong>：用于管理 Grafana 仪表盘。<ul><li>示例：<code>ansible -m grafana_dashboard -a "name=MyDashboard state=present json=/path/to/dashboard.json"</code></li></ul></li></ul><hr><h3 id=8-用户输入和通知模块>8. <strong>用户输入和通知模块</strong>
<a class=anchor href=#8-%e7%94%a8%e6%88%b7%e8%be%93%e5%85%a5%e5%92%8c%e9%80%9a%e7%9f%a5%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于处理与用户的交互或向外部系统发送通知。</p><ul><li><strong><code>pause</code></strong>：暂停执行一段时间，或等待用户输入。<ul><li>示例：<code>ansible -m pause -a "minutes=5"</code></li></ul></li><li><strong><code>debug</code></strong>：输出调试信息。<ul><li>示例：<code>ansible -m debug -a "msg='This is a debug message'"</code></li></ul></li><li><strong><code>slack</code></strong>：向 Slack 通道发送消息。<ul><li>示例：<code>ansible -m slack -a "token=YOUR_SLACK_TOKEN channel=#general msg='Deployment Complete'"</code></li></ul></li></ul><hr><h3 id=9-容器和虚拟化管理模块>9. <strong>容器和虚拟化管理模块</strong>
<a class=anchor href=#9-%e5%ae%b9%e5%99%a8%e5%92%8c%e8%99%9a%e6%8b%9f%e5%8c%96%e7%ae%a1%e7%90%86%e6%a8%a1%e5%9d%97>#</a></h3><p>这些模块用于容器和虚拟机的管理。</p><ul><li><strong><code>docker_image</code></strong>：管理 Docker 镜像的拉取和删除。<ul><li>示例：<code>ansible -m docker_image -a "name=nginx state=present"</code></li></ul></li><li><strong><code>docker_container</code></strong>：管理 Docker 容器的启动、停止、重启等操作。<ul><li>示例：<code>ansible -m docker_container -a "name=my-container state=started image=nginx"</code></li></ul></li><li><strong><code>virt</code></strong>：管理虚拟机。<ul><li>示例：<code>ansible -m virt -a "name=my-vm state=running"</code></li></ul></li></ul><hr><h3 id=总结-7>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-7>#</a></h3><p>Ansible 提供了丰富的模块，涵盖了系统管理、文件管理、数据库管理、云服务管理、网络管理等多个领域。你可以根据任务需求，选择相应的模块来实现自动化操作。Ansible 的模块功能非常灵活，支持不同操作系统和云平台，极大地方便了系统管理和应用部署。</p><h1 id=10-nginx为什么比apache快>10. nginx为什么比apache快？
<a class=anchor href=#10-nginx%e4%b8%ba%e4%bb%80%e4%b9%88%e6%af%94apache%e5%bf%ab>#</a></h1><ul><li>nginx采用epoll模型</li><li>apache采用select模型</li></ul><p>Nginx 通常比 Apache 快，主要有以下几个原因：</p><h3 id=1-事件驱动架构>1. <strong>事件驱动架构</strong>
<a class=anchor href=#1-%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%9e%b6%e6%9e%84>#</a></h3><p>Nginx 采用的是事件驱动（Event-Driven）架构，而 Apache 默认使用的是基于进程（或线程）模型。Nginx 的事件驱动模型使得它能够处理大量的并发连接，而不需要为每个连接创建新的进程或线程。</p><ul><li><strong>Nginx</strong>：使用单个或少数线程来处理请求，所有请求都由事件循环（event loop）管理，且每个连接在处理时都不阻塞其他连接。这使得 Nginx 在处理高并发请求时非常高效。</li><li><strong>Apache</strong>：默认使用进程/线程池（比如 <code>prefork</code> 模块），每个请求都会启动一个独立的进程或线程来处理。这样虽然能处理并发请求，但每个请求都需要额外的内存和上下文切换，导致效率较低。</li></ul><h3 id=2-内存消耗>2. <strong>内存消耗</strong>
<a class=anchor href=#2-%e5%86%85%e5%ad%98%e6%b6%88%e8%80%97>#</a></h3><p>由于 Nginx 是基于异步非阻塞的事件驱动模式，它能在一个工作进程中处理成千上万的并发连接。每个连接消耗的资源非常少，通常只有几十个字节的内存。</p><p>相比之下，Apache 的线程/进程模式需要为每个请求分配独立的内存和操作系统资源。即使请求量不高，资源消耗也相对较大，因此在高并发场景下性能不如 Nginx。</p><h3 id=3-高效的静态内容处理>3. <strong>高效的静态内容处理</strong>
<a class=anchor href=#3-%e9%ab%98%e6%95%88%e7%9a%84%e9%9d%99%e6%80%81%e5%86%85%e5%ae%b9%e5%a4%84%e7%90%86>#</a></h3><p>Nginx 被设计为一个高效的反向代理服务器，特别擅长处理静态文件请求（如图片、CSS、JavaScript、HTML 等）。它能够高效地使用操作系统的内存和硬件缓存机制，快速响应静态内容的请求。</p><p>Apache 虽然也支持静态内容的处理，但在处理静态文件时，Apache 的性能通常低于 Nginx，因为 Apache 需要通过多个模块进行处理，并且涉及更多的进程/线程调度。</p><h3 id=4-非阻塞-io>4. <strong>非阻塞 I/O</strong>
<a class=anchor href=#4-%e9%9d%9e%e9%98%bb%e5%a1%9e-io>#</a></h3><p>Nginx 使用非阻塞 I/O（Non-blocking I/O）模型，即使在处理大量请求时，进程不会被阻塞等待 I/O 操作完成。通过异步事件通知机制，Nginx 可以高效地在多个连接之间切换，从而避免了传统的线程/进程阻塞。</p><p>Apache 默认使用阻塞 I/O，这意味着当一个请求在处理时，如果需要等待 I/O 操作（比如访问数据库或文件系统），它会阻塞当前线程，直到操作完成。这样在高并发情况下，Apache 的响应时间会变慢。</p><h3 id=5-更低的-cpu-和内存开销>5. <strong>更低的 CPU 和内存开销</strong>
<a class=anchor href=#5-%e6%9b%b4%e4%bd%8e%e7%9a%84-cpu-%e5%92%8c%e5%86%85%e5%ad%98%e5%bc%80%e9%94%80>#</a></h3><p>由于 Nginx 的事件驱动模式和非阻塞 I/O，它通常需要更少的 CPU 和内存资源来处理大量的请求。它的工作进程不需要频繁的上下文切换，也不会为每个请求分配大量的内存。</p><p>Apache 在高并发情况下，由于每个请求都创建一个新的进程或线程，导致 CPU 和内存消耗较高。因此，Nginx 在处理大量并发请求时比 Apache 更加高效。</p><h3 id=6-负载均衡和反向代理能力>6. <strong>负载均衡和反向代理能力</strong>
<a class=anchor href=#6-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%92%8c%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e8%83%bd%e5%8a%9b>#</a></h3><p>Nginx 作为反向代理服务器和负载均衡器，提供了非常高效的请求分发和负载均衡机制。它能够通过多个算法（如轮询、IP 哈希、最少连接等）将请求分发到后端服务器，支持高效的分布式架构，极大提高了性能和扩展性。</p><p>虽然 Apache 也支持反向代理和负载均衡，但 Nginx 通常比 Apache 更高效，并且对请求的分发和处理更加精细。</p><h3 id=7-配置简洁与优化>7. <strong>配置简洁与优化</strong>
<a class=anchor href=#7-%e9%85%8d%e7%bd%ae%e7%ae%80%e6%b4%81%e4%b8%8e%e4%bc%98%e5%8c%96>#</a></h3><p>Nginx 的配置文件相对简洁且高效，能够快速加载和应用配置。而 Apache 的配置文件可能更加复杂，尤其在启用多个模块时，可能会引入不必要的复杂性和性能开销。</p><hr><h3 id=总结-8>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-8>#</a></h3><p>Nginx 比 Apache 快的主要原因是其采用了事件驱动的非阻塞 I/O 模型，能够高效处理大量并发连接，而不需要为每个请求创建新的进程或线程。此外，Nginx 对静态内容的处理非常高效，内存消耗较少，并且通过负载均衡和反向代理功能提高了性能。而 Apache 的多进程/多线程模式虽然灵活，但在高并发和资源消耗方面通常不如 Nginx 高效。</p><h1 id=11-四层负载和七层负载区别是什么>11. 四层负载和七层负载区别是什么？
<a class=anchor href=#11-%e5%9b%9b%e5%b1%82%e8%b4%9f%e8%bd%bd%e5%92%8c%e4%b8%83%e5%b1%82%e8%b4%9f%e8%bd%bd%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>四层基于IP+端口进行转发</li><li>七层就是基于URL等应用层信息的负载均衡</li></ul><p>四层负载均衡和七层负载均衡的区别主要体现在它们处理请求的层次不同，以及基于不同协议和信息进行流量分配。具体区别如下：</p><h3 id=1-osi模型层次>1. <strong>OSI模型层次</strong>
<a class=anchor href=#1-osi%e6%a8%a1%e5%9e%8b%e5%b1%82%e6%ac%a1>#</a></h3><ul><li><strong>四层负载均衡</strong>（Layer 4 Load Balancing）：操作在 OSI 模型的第四层，也就是 <strong>传输层</strong>。它处理的是 TCP 或 UDP 协议的数据包，主要根据 IP 地址和端口号来进行流量分配。</li><li><strong>七层负载均衡</strong>（Layer 7 Load Balancing）：操作在 OSI 模型的第七层，也就是 <strong>应用层</strong>。它根据应用层协议（如 HTTP、HTTPS、FTP 等）中的内容来做决策，可以基于请求的 URL、头部、Cookie、HTTP 方法等信息来进行流量调度。</li></ul><h3 id=2-负载均衡决策依据>2. <strong>负载均衡决策依据</strong>
<a class=anchor href=#2-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%86%b3%e7%ad%96%e4%be%9d%e6%8d%ae>#</a></h3><ul><li><p>四层负载均衡</p><p>：</p><ul><li><strong>基于 IP 地址和端口</strong>：四层负载均衡在流量到达服务器之前，主要基于客户端 IP 地址、目标 IP 地址和端口号来决定如何将流量转发到后端服务器。</li><li>它不理解上层协议的内容，仅仅是在传输层（TCP、UDP）进行决策，因此它的处理速度通常较快，适用于简单的流量分发。</li></ul></li><li><p>七层负载均衡</p><p>：</p><ul><li><strong>基于应用层信息</strong>：七层负载均衡可以理解并使用更复杂的应用层协议信息来进行决策。例如，它可以根据 HTTP 请求的 URL、请求头、Cookie 等信息来决定请求应该转发到哪个后端服务器。</li><li>七层负载均衡提供了更多的灵活性，能够进行内容交换、SSL 终止、基于会话的负载分配等。</li></ul></li></ul><h3 id=3-处理复杂度和性能>3. <strong>处理复杂度和性能</strong>
<a class=anchor href=#3-%e5%a4%84%e7%90%86%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%92%8c%e6%80%a7%e8%83%bd>#</a></h3><ul><li><p>四层负载均衡</p><p>：</p><ul><li><strong>性能更高，处理更简单</strong>：由于四层负载均衡只关注网络层和传输层的基本信息，处理速度较快，适合高并发的网络流量。它通常用于较为简单的负载均衡需求，如 TCP、UDP 服务的流量分发。</li></ul></li><li><p>七层负载均衡</p><p>：</p><ul><li><strong>处理较复杂，性能较低</strong>：七层负载均衡需要解析应用层的内容，计算量较大，可能影响性能，但它能提供更多的功能和灵活性。例如，应用层负载均衡可以对不同的请求类型执行不同的策略，如按请求 URL 或 HTTP 方法进行流量分配。</li></ul></li></ul><h3 id=4-应用场景>4. <strong>应用场景</strong>
<a class=anchor href=#4-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><ul><li><strong>四层负载均衡</strong>：<ul><li>适合简单的 TCP 或 UDP 服务，通常用于数据库集群、VPN、邮件服务器、实时通信等应用场景。</li><li>常见的四层负载均衡设备或软件如：硬件负载均衡器（F5 Big-IP）、Nginx、IPVS（Linux Virtual Server）等。</li></ul></li><li><strong>七层负载均衡</strong>：<ul><li>适用于 Web 应用和更复杂的应用场景，特别是需要基于请求内容（如 HTTP 头部、URL）进行智能流量分配的情况。七层负载均衡器常用于高效的 Web 应用服务、微服务架构和 API 网关等场景。</li><li>常见的七层负载均衡器如：Nginx、HAProxy、Traefik、Apache HTTP Server等。</li></ul></li></ul><h3 id=5-功能特性>5. <strong>功能特性</strong>
<a class=anchor href=#5-%e5%8a%9f%e8%83%bd%e7%89%b9%e6%80%a7>#</a></h3><ul><li><p>四层负载均衡</p><p>：</p><ul><li>支持基于源 IP 或端口号的流量分配。</li><li>支持透明传输和高效的负载分配，但不处理任何应用层协议的内容。</li><li>支持高并发连接的负载均衡，通常用于低延迟的服务。</li></ul></li><li><p>七层负载均衡</p><p>：</p><ul><li>支持更细粒度的流量控制，如基于 URL 路径、HTTP 方法（GET、POST）、头部字段、Cookie、查询字符串等进行流量分发。</li><li>可以实现内容交换（如缓存、压缩、SSL 终止等），对请求进行智能化的转发。</li><li>支持 A/B 测试、蓝绿部署、会话保持等高级功能。</li></ul></li></ul><h3 id=6-ssltls-终止>6. <strong>SSL/TLS 终止</strong>
<a class=anchor href=#6-ssltls-%e7%bb%88%e6%ad%a2>#</a></h3><ul><li><strong>四层负载均衡</strong>：不处理 SSL/TLS 加密和解密操作，流量会以加密的形式传递到后端服务器。</li><li><strong>七层负载均衡</strong>：通常可以处理 SSL/TLS 终止，即解密客户端的加密请求后，再转发给后端服务器。这样可以减轻后端服务器的负担，并提供对 HTTPS 流量的更多控制。</li></ul><hr><h3 id=总结-9>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-9>#</a></h3><ul><li><strong>四层负载均衡</strong>关注的是 <strong>传输层</strong>（IP 地址、端口），适用于简单的 TCP/UDP 流量分发，性能高，适合高并发和低延迟需求。</li><li><strong>七层负载均衡</strong>则可以解析 <strong>应用层</strong> 协议（如 HTTP、HTTPS），能够做基于内容的精细化流量调度，功能更强大，但处理复杂度较高，适合 Web 应用和其他需要基于内容进行智能流量分配的场景。</li></ul><h1 id=12-lvs有哪些工作模式哪个性能高>12. lvs有哪些工作模式？哪个性能高？
<a class=anchor href=#12-lvs%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f%e5%93%aa%e4%b8%aa%e6%80%a7%e8%83%bd%e9%ab%98>#</a></h1><ul><li>dr：直接路由模式，请求由 LVS 接受，由真实提供服务的服务器直接返回给用户，返回的时候不经过 LVS。（性能最高）</li><li>tun：隧道模式，客户端将访问vip报文发送给LVS服务器。LVS服务器将请求报文重新封装，发送给后端真实服务器。后端真实服务器将请求报文解封，在确认自身有vip之后进行请求处理。后端真实服务器在处理完数据请求后，直接响应客户端。</li><li>nat：网络报的进出都要经过 LVS 的处理。LVS 需要作为 RS 的网关。当包到达 LVS 时，LVS 做目标地址转换（DNAT），将目标 IP 改为 RS 的 IP。RS 接收到包以后，仿佛是客户端直接发给它的一样。RS 处理完，返回响应时，源 IP 是 RS IP，目标 IP 是客户端的 IP。这时 RS 的包通过网关（LVS）中转，LVS 会做源地址转换（SNAT），将包的源地址改为 VIP，这样，这个包对客户端看起来就仿佛是 LVS 直接返回给它的。客户端无法感知到后端 RS 的存在。</li><li>fullnat模式：fullnat模式和nat模式相似，但是与nat不同的是nat模式只做了两次地址转换，fullnat模式却做了四次。</li></ul><p>LVS（Linux Virtual Server）是一个高性能的负载均衡解决方案，它提供了几种不同的工作模式，用于处理不同类型的负载均衡需求。LVS 的工作模式包括：</p><h3 id=1-nat-network-address-translation-模式>1. <strong>NAT (Network Address Translation) 模式</strong>
<a class=anchor href=#1-nat-network-address-translation-%e6%a8%a1%e5%bc%8f>#</a></h3><p>在 <strong>NAT</strong> 模式下，LVS 会修改客户端请求的目标 IP 地址（即将目标 IP 地址更改为后端服务器的 IP 地址），然后将请求转发到合适的后端服务器。后端服务器的响应也会通过 LVS 转发回客户端。</p><ul><li><p>特点</p><p>：</p><ul><li>LVS 充当了客户端和后端服务器之间的代理，客户端认为自己在与 LVS 交互，而 LVS 再将请求转发到实际的后端服务器。</li><li>每个后端服务器的 IP 地址是私有地址，LVS 充当路由器，NAT 会更改请求的目标地址。</li><li>LVS 需要修改网络数据包，因此需要较多的计算资源。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>当后端服务器的 IP 地址是私有的，且不直接暴露在公网时，NAT 模式是最常用的。</li></ul></li></ul><h3 id=2-dr-direct-routing-模式>2. <strong>DR (Direct Routing) 模式</strong>
<a class=anchor href=#2-dr-direct-routing-%e6%a8%a1%e5%bc%8f>#</a></h3><p>在 <strong>DR</strong> 模式下，LVS 直接将请求转发到后端服务器，而不需要修改目标地址。LVS 只是根据请求选择合适的后端服务器，然后将请求转发给该服务器，后端服务器直接将响应返回给客户端，LVS 不参与响应的转发。</p><ul><li><strong>特点</strong>：<ul><li>在 DR 模式下，客户端请求的目标 IP 地址不需要改变，后端服务器的 IP 地址必须是公有 IP 地址，且 LVS 的虚拟 IP 地址（VIP）必须在后端服务器的网络接口上。</li><li>后端服务器直接发送响应，LVS 不会再次转发响应。</li><li>性能高，因为没有修改数据包，也没有代理响应数据，减少了系统负载。</li></ul></li><li><strong>适用场景</strong>：<ul><li>后端服务器有公有 IP 地址，并且 LVS 和后端服务器位于同一网络。</li></ul></li></ul><h3 id=3-tun-ip-tunneling-模式>3. <strong>TUN (IP Tunneling) 模式</strong>
<a class=anchor href=#3-tun-ip-tunneling-%e6%a8%a1%e5%bc%8f>#</a></h3><p>在 <strong>TUN</strong> 模式下，LVS 使用 IP 隧道技术将客户端请求转发到后端服务器。LVS 将客户端请求封装在一个新的数据包中，传输给后端服务器，后端服务器解封装并处理请求。与 NAT 模式不同，TUN 模式没有直接修改目标 IP 地址，而是通过 IP 隧道将数据包传递给后端服务器。</p><ul><li><p>特点</p><p>：</p><ul><li>适用于后端服务器与 LVS 在不同网络之间进行通信的情况。</li><li>LVS 通过 IP 隧道将请求转发给后端服务器，这样可以跨越网络边界，但需要更多的网络带宽和计算资源。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>后端服务器和 LVS 位于不同的子网，且需要通过隧道进行通信。</li></ul></li></ul><hr><h3 id=性能对比>性能对比：
<a class=anchor href=#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94>#</a></h3><ol><li><strong>NAT 模式</strong>：性能相对较低，因为每个数据包都需要被 LVS 修改，增加了处理负担。特别是在高负载时，NAT 模式的性能可能会受到影响。</li><li><strong>DR 模式</strong>：性能最高。因为 DR 模式不需要修改数据包，也不需要代理响应，所以它的效率非常高，几乎不会给系统带来额外的负载。适用于高并发场景。</li><li><strong>TUN 模式</strong>：性能次之。虽然数据包不需要修改，但 IP 隧道的开销较大，尤其在跨网络传输时需要额外的计算资源。因此，TUN 模式的性能通常低于 DR 模式，但比 NAT 模式要好。</li></ol><h3 id=总结-10>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-10>#</a></h3><ul><li><strong>DR 模式</strong> 性能最好，适用于 LVS 和后端服务器在同一网络中的情况。</li><li><strong>TUN 模式</strong> 性能较高，但会受到隧道开销的影响，适用于跨网络传输的场景。</li><li><strong>NAT 模式</strong> 性能相对较低，适用于需要将后端服务器的私有 IP 地址隐藏的场景。</li></ul><p>因此，<strong>DR 模式</strong> 被认为是性能最优的工作模式，尤其是在 LVS 和后端服务器在同一网络中时。</p><h1 id=13-lvs-nginx-haproxy-keeplived区别优缺点>13. lvs nginx haproxy keeplived区别，优缺点？
<a class=anchor href=#13-lvs-nginx-haproxy-keeplived%e5%8c%ba%e5%88%ab%e4%bc%98%e7%bc%ba%e7%82%b9>#</a></h1><blockquote><p>参考链接：https://blog.51cto.com/816885/2529993?source=dra</p></blockquote><p>LVS、Nginx、HAProxy 和 Keepalived 都是常见的负载均衡解决方案，它们各有优缺点，适用于不同的场景。以下是这四者的区别、优缺点以及适用场景的详细对比。</p><h3 id=1-lvs-linux-virtual-server>1. <strong>LVS (Linux Virtual Server)</strong>
<a class=anchor href=#1-lvs-linux-virtual-server>#</a></h3><p>LVS 是一种基于 Linux 的高性能负载均衡解决方案，主要通过不同的工作模式（NAT、DR、TUN）来进行负载均衡。</p><h4 id=优点>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9>#</a></h4><ul><li><strong>高性能</strong>：LVS 是内核级负载均衡器，直接在 Linux 内核中实现，处理速度非常快。</li><li><strong>支持高并发</strong>：能够处理大量的并发连接，适用于大规模应用。</li><li><strong>灵活性</strong>：支持多种负载均衡模式（NAT、DR、TUN），可以根据实际需求选择合适的模式。</li><li><strong>故障切换</strong>：支持高可用配置，可以和 Keepalived 配合使用，提供故障切换和虚拟 IP 高可用性。</li></ul><h4 id=缺点>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9>#</a></h4><ul><li><strong>配置复杂</strong>：相对于 Nginx 和 HAProxy，LVS 的配置和管理较为复杂，调试和排错也较为困难。</li><li><strong>缺少应用层负载均衡功能</strong>：LVS 主要操作在传输层（L4），不支持深入的应用层（L7）负载均衡，如基于 URL、HTTP 方法等。</li></ul><h4 id=适用场景>适用场景：
<a class=anchor href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h4><ul><li>高流量网站和高并发应用，尤其适用于 Web 服务器集群、数据库集群等。</li></ul><h3 id=2-nginx>2. <strong>Nginx</strong>
<a class=anchor href=#2-nginx>#</a></h3><p>Nginx 是一个高性能的 Web 服务器和反向代理服务器，也可以作为负载均衡器使用。它支持应用层负载均衡，能够处理 HTTP、HTTPS、TCP、UDP 流量。</p><h4 id=优点-1>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-1>#</a></h4><ul><li><strong>高性能</strong>：作为反向代理和负载均衡器，Nginx 性能非常好，能够处理大量并发请求。</li><li><strong>灵活性</strong>：支持 L4 和 L7 负载均衡，可以根据 URL、请求头、Cookie 等应用层信息进行流量分发。</li><li><strong>易于配置和管理</strong>：配置文件简洁，管理方便，支持热部署。</li><li><strong>功能丰富</strong>：支持 SSL 终止、缓存、会话保持等功能，适用于 Web 应用。</li></ul><h4 id=缺点-1>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-1>#</a></h4><ul><li><strong>仅限于 HTTP/S 和 TCP/UDP 负载均衡</strong>：虽然支持多种协议，但在一些特殊应用场景（如数据库负载均衡）可能不如 LVS 高效。</li><li><strong>在大规模集群环境下的性能不如 LVS</strong>：对于超高并发的负载均衡，Nginx 的性能可能不如 LVS。</li></ul><h4 id=适用场景-1>适用场景：
<a class=anchor href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-1>#</a></h4><ul><li>Web 服务、API 网关、微服务架构，适用于处理 HTTP、HTTPS 等应用层流量的负载均衡。</li></ul><h3 id=3-haproxy>3. <strong>HAProxy</strong>
<a class=anchor href=#3-haproxy>#</a></h3><p>HAProxy 是一个高性能的负载均衡器，广泛用于 Web 应用的负载均衡，尤其擅长高可用性和高并发环境。</p><h4 id=优点-2>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-2>#</a></h4><ul><li><strong>高性能</strong>：HAProxy 在 L4 和 L7 负载均衡方面表现非常好，特别适用于高并发、高可用性要求的环境。</li><li><strong>灵活性</strong>：支持多种负载均衡算法（轮询、最少连接等），并且可以基于 HTTP 请求头、URL、IP 地址等进行智能流量分配。</li><li><strong>高可用性</strong>：支持健康检查、会话保持、SSL 终止等功能，并且和 Keepalived 配合使用时可以提供高可用性。</li><li><strong>监控和统计</strong>：提供详细的日志和监控功能，便于性能分析和故障排查。</li></ul><h4 id=缺点-2>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-2>#</a></h4><ul><li><strong>配置复杂</strong>：HAProxy 的配置文件相对较为复杂，尤其是在需要自定义负载均衡规则时。</li><li><strong>不支持静态内容缓存</strong>：HAProxy 不能像 Nginx 一样处理静态文件，通常需要与其他 Web 服务器结合使用。</li></ul><h4 id=适用场景-2>适用场景：
<a class=anchor href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-2>#</a></h4><ul><li>高并发 Web 服务、微服务架构、API 网关，适用于需要高可用性和高性能负载均衡的场景。</li></ul><h3 id=4-keepalived>4. <strong>Keepalived</strong>
<a class=anchor href=#4-keepalived>#</a></h3><p>Keepalived 主要用于提供高可用性，它与 LVS、Nginx 或 HAProxy 配合使用，管理虚拟 IP 地址，提供故障切换和负载均衡功能。</p><h4 id=优点-3>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-3>#</a></h4><ul><li><strong>高可用性</strong>：Keepalived 通过 VRRP 协议提供虚拟 IP 地址，能够在主节点故障时自动切换到备节点，保证系统的高可用性。</li><li><strong>简单配置</strong>：Keepalived 配置相对简单，能够与 LVS、Nginx 或 HAProxy 等负载均衡器无缝集成。</li><li><strong>支持健康检查</strong>：Keepalived 可以监控负载均衡器的状态，自动进行故障转移。</li></ul><h4 id=缺点-3>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-3>#</a></h4><ul><li><strong>单独使用不提供负载均衡功能</strong>：Keepalived 本身并不提供负载均衡功能，必须与 LVS、Nginx 或 HAProxy 配合使用。</li><li><strong>主要针对高可用性设计</strong>：对于负载均衡功能，Keepalived 本身并不提供复杂的负载均衡策略，更多侧重于故障转移。</li></ul><h4 id=适用场景-3>适用场景：
<a class=anchor href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-3>#</a></h4><ul><li>高可用性场景，特别是与 LVS、Nginx 或 HAProxy 配合使用，确保虚拟 IP 地址的故障转移和负载均衡器的高可用性。</li></ul><hr><h3 id=总结与适用场景>总结与适用场景：
<a class=anchor href=#%e6%80%bb%e7%bb%93%e4%b8%8e%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><ul><li><strong>LVS</strong>：性能最强，适用于大规模高并发的流量负载均衡，尤其适用于需要高效 TCP/UDP 负载均衡的场景。配置较复杂。</li><li><strong>Nginx</strong>：适用于 Web 应用和 API 的负载均衡，支持 L4 和 L7，能够基于应用层信息做智能流量分发，配置简单，性能优秀，适合中小规模应用。</li><li><strong>HAProxy</strong>：适用于高可用性和高并发的 Web 应用负载均衡，支持 L4 和 L7，配置较复杂，但在高性能和高可用性场景下非常出色。</li><li><strong>Keepalived</strong>：提供高可用性和故障切换功能，通常与 LVS、Nginx 或 HAProxy 配合使用，确保系统的容错和高可用性。</li></ul><p>通常，<strong>LVS</strong> 和 <strong>Keepalived</strong> 配合使用适用于需要极高性能的负载均衡环境，而 <strong>Nginx</strong> 和 <strong>HAProxy</strong> 更适合 Web 应用和高可用负载均衡。</p><h1 id=14-如下url地址各个部分的含义>14. 如下url地址，各个部分的含义
<a class=anchor href=#14-%e5%a6%82%e4%b8%8burl%e5%9c%b0%e5%9d%80%e5%90%84%e4%b8%aa%e9%83%a8%e5%88%86%e7%9a%84%e5%90%ab%e4%b9%89>#</a></h1><p><a href="https://www.baidu.com/s?word=123&amp;ie=utf-8">https://www.baidu.com/s?word=123&ie=utf-8</a></p><ul><li>https: 使用https加密协议访问</li><li><a href=https://www.baidu.com/s>www.baidu.com/s</a>: 请求地址</li><li>?word&amp;ie=utf-8: get请求的参数，多个参数&连接</li></ul><p>这个 URL 地址是一个典型的 HTTP 请求 URL，通常用于发起一个搜索请求。下面是对各个部分的解析：</p><pre tabindex=0><code>https://www.baidu.com/s?word=123&amp;ie=utf-8
</code></pre><h3 id=1-协议部分https>1. <strong>协议部分</strong>：<code>https://</code>
<a class=anchor href=#1-%e5%8d%8f%e8%ae%ae%e9%83%a8%e5%88%86https>#</a></h3><ul><li><strong>https</strong> 表示使用的是安全的超文本传输协议（HTTP Secure），即对数据进行加密传输。</li><li><strong>://</strong> 是协议与后续内容的分隔符。</li></ul><h3 id=2-主机名部分wwwbaiducom>2. <strong>主机名部分</strong>：<code>www.baidu.com</code>
<a class=anchor href=#2-%e4%b8%bb%e6%9c%ba%e5%90%8d%e9%83%a8%e5%88%86wwwbaiducom>#</a></h3><ul><li><strong><a href=http://www.baidu.com/>www.baidu.com</a></strong> 是服务器的域名，指向百度的官方网站。</li><li>这个部分用于定位服务器的地址，也就是目标主机。</li></ul><h3 id=3-路径部分s>3. <strong>路径部分</strong>：<code>/s</code>
<a class=anchor href=#3-%e8%b7%af%e5%be%84%e9%83%a8%e5%88%86s>#</a></h3><ul><li><strong>/s</strong> 是一个路径，表示对百度网站上的某个页面进行请求。在百度中，通常 <code>/s</code> 表示进行搜索的页面。</li></ul><h3 id=4-查询参数部分word123ieutf-8>4. <strong>查询参数部分</strong>：<code>?word=123&amp;ie=utf-8</code>
<a class=anchor href=#4-%e6%9f%a5%e8%af%a2%e5%8f%82%e6%95%b0%e9%83%a8%e5%88%86word123ieutf-8>#</a></h3><ul><li><p><strong>?</strong> 表示后面跟随的是查询字符串。</p><p>查询字符串由多个参数组成，每个参数之间通过 <strong>&</strong> 符号分隔。</p><ul><li><p>word=123</p><p>：</p><ul><li><code>word</code> 是一个查询参数的名称，表示搜索的关键字。</li><li><code>123</code> 是该参数的值，表示搜索内容是 <code>123</code>。</li></ul></li><li><p>ie=utf-8</p><p>：</p><ul><li><code>ie</code> 是一个查询参数的名称，表示字符编码格式。</li><li><code>utf-8</code> 是该参数的值，表示使用 UTF-8 编码格式来传输数据。</li></ul></li></ul></li></ul><h3 id=总结-11>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-11>#</a></h3><ul><li><code>https://www.baidu.com/s</code> 是访问百度搜索页面的路径。</li><li><code>word=123</code> 表示搜索关键字是 <code>123</code>。</li><li><code>ie=utf-8</code> 表示使用 UTF-8 编码格式。</li></ul><p>所以这个 URL 的含义是：通过 HTTPS 协议访问百度的搜索页面，搜索内容是 <code>123</code>，并使用 UTF-8 编码格式来处理请求和响应。</p><h1 id=15-tomcat各个目录含义如何修改端口如何修改内存数>15. tomcat各个目录含义，如何修改端口，如何修改内存数？
<a class=anchor href=#15-tomcat%e5%90%84%e4%b8%aa%e7%9b%ae%e5%bd%95%e5%90%ab%e4%b9%89%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9%e7%ab%af%e5%8f%a3%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9%e5%86%85%e5%ad%98%e6%95%b0>#</a></h1><ul><li>bin 存放tomcat命令</li><li>conf 存放tomcat配置文件</li><li>lib 存放tomcat运行需要加载的jar包</li><li>log 存在Tomcat运行产生的日志</li><li>temp 运行过程中产生的临时文件</li><li>webapps 站点目录</li><li>work 存放tomcat运行时的编译后的文件</li><li>conf/server.xml 修改端口号</li><li>bin/catalina.sh 修改jvm内存</li></ul><h3 id=tomcat-目录结构含义>Tomcat 目录结构含义
<a class=anchor href=#tomcat-%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84%e5%90%ab%e4%b9%89>#</a></h3><p>Tomcat 的目录结构主要包含以下几个重要的文件夹和文件，每个文件夹的含义如下：</p><ol><li><strong><code>bin/</code></strong>：
包含 Tomcat 的启动脚本和控制脚本。<ul><li><strong><code>startup.sh</code></strong>：启动 Tomcat 的脚本（Linux/Unix 系统）。</li><li><strong><code>startup.bat</code></strong>：启动 Tomcat 的脚本（Windows 系统）。</li><li><strong><code>shutdown.sh</code></strong>：关闭 Tomcat 的脚本（Linux/Unix 系统）。</li><li><strong><code>shutdown.bat</code></strong>：关闭 Tomcat 的脚本（Windows 系统）。</li><li><strong><code>catalina.sh</code></strong>：Tomcat 启动的核心脚本。</li><li><strong><code>catalina.bat</code></strong>：Tomcat 启动的核心脚本（Windows 系统）。</li></ul></li><li><strong><code>conf/</code></strong>： 包含 Tomcat 的配置文件。<ul><li><strong><code>server.xml</code></strong>：Tomcat 的主要配置文件，定义了 Tomcat 的各项配置，包括端口、连接器、虚拟主机等。</li><li><strong><code>web.xml</code></strong>：Web 应用的默认配置文件，定义了 Tomcat 如何处理特定请求，配置 servlet、过滤器等。</li><li><strong><code>context.xml</code></strong>：为每个 Web 应用提供单独的配置，可以在其中定义数据库连接、路径等。</li><li><strong><code>tomcat-users.xml</code></strong>：定义 Tomcat 的用户及权限，常用于设置管理员权限。</li></ul></li><li><strong><code>lib/</code></strong>： 包含 Tomcat 所需的库文件（<code>.jar</code> 文件）。<ul><li>这些是 Tomcat 运行时所依赖的 Java 类库。</li></ul></li><li><strong><code>logs/</code></strong>： 存放 Tomcat 运行过程中的日志文件。<ul><li><strong><code>catalina.out</code></strong>：Tomcat 启动和运行时的标准输出日志。</li><li><strong><code>localhost.log</code></strong>、<strong><code>manager.log</code></strong> 等：具体的日志文件，用于记录不同方面的日志。</li></ul></li><li><strong><code>webapps/</code></strong>： 存放 Web 应用的目录。<ul><li>默认情况下，Tomcat 会将其 Web 应用放在这个目录下，每个 Web 应用对应一个文件夹。</li><li>你可以将自己的 Web 应用程序（如 <code>.war</code> 文件）放在这里，Tomcat 会自动解压并部署。</li></ul></li><li><strong><code>work/</code></strong>： 存放 Tomcat 编译过程中生成的工作文件。<ul><li>包含 JSP 编译后的文件、Servlet 生成的临时文件等。</li></ul></li><li><strong><code>temp/</code></strong>： 存放 Tomcat 在运行时使用的临时文件。</li><li><strong><code>ROOT/</code></strong>： 这是默认的 Web 应用程序目录，也就是 Tomcat 部署时会映射到 <code>/</code> 路径。</li></ol><hr><h3 id=如何修改-tomcat-的端口>如何修改 Tomcat 的端口？
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9-tomcat-%e7%9a%84%e7%ab%af%e5%8f%a3>#</a></h3><p>Tomcat 默认的 HTTP 端口是 <code>8080</code>，要修改端口，可以编辑 <code>server.xml</code> 文件：</p><ol><li>打开 <code>conf/server.xml</code> 文件。</li><li>找到以下内容，修改端口号：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Connector</span> <span style=color:#a6e22e>port=</span><span style=color:#e6db74>&#34;8080&#34;</span> <span style=color:#a6e22e>protocol=</span><span style=color:#e6db74>&#34;HTTP/1.1&#34;</span>
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>connectionTimeout=</span><span style=color:#e6db74>&#34;20000&#34;</span>
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>redirectPort=</span><span style=color:#e6db74>&#34;8443&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><ol><li>将 <code>port="8080"</code> 修改为你想要的端口（如：<code>port="9090"</code>）。</li><li>保存并关闭文件。</li><li>重启 Tomcat。</li></ol><h3 id=如何修改-tomcat-的内存设置>如何修改 Tomcat 的内存设置？
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9-tomcat-%e7%9a%84%e5%86%85%e5%ad%98%e8%ae%be%e7%bd%ae>#</a></h3><p>Tomcat 的内存配置通常通过 Java 虚拟机（JVM）的启动参数进行设置，这些设置可以在 <code>bin/catalina.sh</code>（Linux/Unix）或 <code>bin/catalina.bat</code>（Windows）中找到。</p><h4 id=1-修改-catalinashlinuxunix>1. 修改 <code>catalina.sh</code>（Linux/Unix）：
<a class=anchor href=#1-%e4%bf%ae%e6%94%b9-catalinashlinuxunix>#</a></h4><ol><li>打开 <code>bin/catalina.sh</code> 文件。</li><li>找到 <code>JAVA_OPTS</code> 变量，并设置你想要的内存大小。</li></ol><p>例如，设置最大堆内存为 2GB，初始堆内存为 1GB：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>JAVA_OPTS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-Xms1g -Xmx2g&#34;</span>
</span></span></code></pre></div><p>其中：</p><ul><li><code>-Xms1g</code>：指定初始内存为 1GB。</li><li><code>-Xmx2g</code>：指定最大内存为 2GB。</li></ul><ol><li>保存并关闭文件。</li></ol><h4 id=2-修改-catalinabatwindows>2. 修改 <code>catalina.bat</code>（Windows）：
<a class=anchor href=#2-%e4%bf%ae%e6%94%b9-catalinabatwindows>#</a></h4><ol><li>打开 <code>bin/catalina.bat</code> 文件。</li><li>找到类似的行并设置内存大小：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bat data-lang=bat><span style=display:flex><span><span style=color:#66d9ef>set</span> JAVA_OPTS=-Xms1g -Xmx2g
</span></span></code></pre></div><ol><li>保存并关闭文件。</li></ol><h4 id=3-其他内存设置可选>3. 其他内存设置（可选）：
<a class=anchor href=#3-%e5%85%b6%e4%bb%96%e5%86%85%e5%ad%98%e8%ae%be%e7%bd%ae%e5%8f%af%e9%80%89>#</a></h4><ul><li><p>PermGen/Metaspace（JVM）</p><p>： 如果使用的是较旧的 JDK（例如 JDK 7），可以配置</p><p>PermGen</p><p>内存：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>JAVA_OPTS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-XX:PermSize=128m -XX:MaxPermSize=256m&#34;</span>
</span></span></code></pre></div><p>对于 JDK 8 及以后版本，</p><pre tabindex=0><code>PermGen
</code></pre><p>被替换为</p><pre tabindex=0><code>Metaspace
</code></pre><p>，可以配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>JAVA_OPTS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m&#34;</span>
</span></span></code></pre></div></li></ul><hr><h3 id=总结-12>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-12>#</a></h3><ul><li><strong>修改端口</strong>：编辑 <code>conf/server.xml</code> 文件，修改 <code>&lt;Connector port="8080" /></code> 部分的端口。</li><li><strong>修改内存</strong>：在 <code>bin/catalina.sh</code> 或 <code>bin/catalina.bat</code> 文件中，通过 <code>JAVA_OPTS</code> 设置内存参数（例如：<code>-Xms1g -Xmx2g</code>）。</li></ul><h1 id=16-nginx反向代理时如何使后端获取真正的访问来源ip>16. nginx反向代理时，如何使后端获取真正的访问来源ip？
<a class=anchor href=#16-nginx%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e6%97%b6%e5%a6%82%e4%bd%95%e4%bd%bf%e5%90%8e%e7%ab%af%e8%8e%b7%e5%8f%96%e7%9c%9f%e6%ad%a3%e7%9a%84%e8%ae%bf%e9%97%ae%e6%9d%a5%e6%ba%90ip>#</a></h1><p>在location配置段添加以下内容：
proxy_set_header Host $http_host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;</p><p>在使用 Nginx 作为反向代理时，后端服务器通常只能看到来自 Nginx 的 IP 地址，而无法直接获取客户端的真实 IP 地址。为了使后端服务器能够获取到客户端的真实 IP 地址，你需要在 Nginx 中设置一些特殊的头部信息（<code>X-Forwarded-For</code>）来传递客户端的 IP 地址。</p><h3 id=步骤-3>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-3>#</a></h3><ol><li><p><strong>修改 Nginx 配置文件：</strong></p><p>打开 Nginx 的配置文件（通常是 <code>/etc/nginx/nginx.conf</code> 或者是 <code>/etc/nginx/sites-available/default</code> 等文件，具体路径根据安装方式而不同）。</p></li><li><p><strong>添加或修改 <code>proxy_set_header</code> 指令：</strong></p><p>在反向代理相关的 <code>location</code> 块中，添加 <code>X-Forwarded-For</code> 头部。通常，你需要确保传递正确的客户端 IP 地址。</p><p>修改或添加如下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://backend_server</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>X-Real-IP</span> $remote_addr;        <span style=color:#75715e># 将客户端真实IP传递给后端
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>X-Forwarded-For</span> $proxy_add_x_forwarded_for;  <span style=color:#75715e># 保留原有的X-Forwarded-For头
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>X-Forwarded-Proto</span> $scheme;     <span style=color:#75715e># 如果需要，还可以传递协议类型（http 或 https）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>解释：</p><ul><li><code>proxy_set_header X-Real-IP $remote_addr;</code>：将客户端的真实 IP 地址（<code>$remote_addr</code>）传递给后端服务器。</li><li><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code>：将客户端的 IP 地址添加到 <code>X-Forwarded-For</code> 头部。<code>$proxy_add_x_forwarded_for</code> 会将客户端的 IP 地址追加到现有的 <code>X-Forwarded-For</code> 头部（如果该头部已经存在的话）。</li><li><code>proxy_set_header X-Forwarded-Proto $scheme;</code>：如果你的服务器使用了 HTTPS 或者 HTTP，可以通过此头部传递协议类型，后端可以根据此值判断请求是使用的 HTTPS 还是 HTTP。</li></ul></li><li><p><strong>确保后端服务器正确解析 <code>X-Forwarded-For</code>：</strong></p><ul><li>后端应用程序（如 Web 服务器）需要从 <code>X-Forwarded-For</code> 头部获取客户端的真实 IP 地址，而不是直接使用 <code>REMOTE_ADDR</code>。通常，大多数 Web 框架（如 PHP、Django、Node.js）会自动处理这一点，但如果需要，可能需要手动配置代码来读取该头部。</li><li>在一些常见的 Web 服务器配置中，可以参考以下方法：<ul><li><strong>Apache</strong>: 可以使用 <code>mod_remoteip</code> 模块来读取 <code>X-Forwarded-For</code> 头部。</li><li><strong>PHP</strong>: 使用 <code>$_SERVER['HTTP_X_FORWARDED_FOR']</code> 来获取客户端 IP 地址。</li><li><strong>Node.js</strong>: 在请求对象中查看 <code>req.headers['x-forwarded-for']</code>。</li></ul></li></ul></li><li><p><strong>重启 Nginx：</strong></p><p>配置修改完成后，记得重启 Nginx 使更改生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nginx -t     <span style=color:#75715e># 测试配置是否正确</span>
</span></span><span style=display:flex><span>sudo systemctl restart nginx   <span style=color:#75715e># 重启 Nginx</span>
</span></span></code></pre></div></li></ol><hr><h3 id=重要提示>重要提示：
<a class=anchor href=#%e9%87%8d%e8%a6%81%e6%8f%90%e7%a4%ba>#</a></h3><ul><li><p><strong>代理链中的多个代理</strong>：如果请求经过多个代理服务器（比如 Nginx 后面还有其他的负载均衡器），<code>X-Forwarded-For</code> 头部将包含多个 IP 地址。第一个 IP 地址通常是客户端的真实 IP，后面的 IP 地址是中间代理服务器的 IP 地址。你可以根据需要处理这些地址。</p><p>例如，如果后端希望获取真实的客户端 IP 地址（即第一个 IP），需要从 <code>X-Forwarded-For</code> 头部获取第一个 IP 地址。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 示例：从 X-Forwarded-For 获取第一个 IP 地址</span>
</span></span><span style=display:flex><span>client_ip <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>headers<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;X-Forwarded-For&#39;</span>, <span style=color:#e6db74>&#39;&#39;</span>)<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;,&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span></code></pre></div></li><li><p><strong>安全性</strong>：由于 <code>X-Forwarded-For</code> 头部可以被客户端伪造，因此在没有可信代理的情况下，最好只信任来自 Nginx 服务器的 <code>X-Forwarded-For</code> 头部。为了避免头部被伪造，可以只允许特定的代理服务器添加此头部，而不信任来自客户端的请求。</p></li></ul><hr><h3 id=总结-13>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-13>#</a></h3><p>通过在 Nginx 中设置 <code>proxy_set_header X-Real-IP</code> 和 <code>proxy_set_header X-Forwarded-For</code>，你可以将客户端的真实 IP 地址传递到后端服务器。后端可以从这些头部获取客户端的真实 IP 地址，而不是 Nginx 的 IP 地址。</p><h1 id=17-nginx负载均衡算法有哪些>17. nginx负载均衡算法有哪些？
<a class=anchor href=#17-nginx%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>rr 轮训</li><li>weight 加权轮训</li><li>ip_hash 静态调度算法</li><li>fair 动态调度算法</li><li>url_hash url哈希</li><li>leat_conn 最小连接数</li></ul><p>Nginx 提供了多种负载均衡算法，用于将客户端请求分发到多个后端服务器。根据不同的需求和场景，你可以选择不同的算法。下面是 Nginx 支持的常见负载均衡算法：</p><h3 id=1-轮询round-robin>1. <strong>轮询（Round Robin）</strong>
<a class=anchor href=#1-%e8%bd%ae%e8%af%a2round-robin>#</a></h3><ul><li><p><strong>默认算法</strong>：Nginx 默认使用的是轮询（Round Robin）算法。</p></li><li><p><strong>描述</strong>：将请求按顺序轮流分发给每个后端服务器，适合后端服务器性能相似的场景。</p></li><li><p>特点</p><p>：</p><ul><li>简单有效，负载分配均匀。</li><li>没有考虑每个服务器的负载情况。</li><li>对于大部分场景是有效的，但在后端服务器性能不均衡时，可能导致一些服务器负载过高，另一些服务器几乎没有负载。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-最少连接least-connections>2. <strong>最少连接（Least Connections）</strong>
<a class=anchor href=#2-%e6%9c%80%e5%b0%91%e8%bf%9e%e6%8e%a5least-connections>#</a></h3><ul><li><p><strong>描述</strong>：将请求转发给当前连接数最少的后端服务器。这个算法适合请求处理时间不均匀的应用场景。</p></li><li><p>特点</p><p>：</p><ul><li>更加智能，根据每个后端服务器的负载情况分配请求。</li><li>可以避免某些服务器被过载（当请求处理时间不均匀时）。</li><li>对于高并发和长连接场景（如 HTTP 长连接）效果显著。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>least_conn</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-ip-哈希ip-hash>3. <strong>IP 哈希（IP Hash）</strong>
<a class=anchor href=#3-ip-%e5%93%88%e5%b8%8cip-hash>#</a></h3><ul><li><p><strong>描述</strong>：根据客户端的 IP 地址计算哈希值，然后将请求分发到与该哈希值对应的服务器。这样，同一个客户端的请求会始终发送到同一台后端服务器（持久连接）。</p></li><li><p>特点</p><p>：</p><ul><li>保证同一个客户端的请求总是分发到相同的后端服务器。</li><li>适用于需要会话保持的场景（例如购物车等状态依赖于会话的应用）。</li><li>不一定能平衡负载，特别是在客户端 IP 分布不均匀时，某些服务器可能会收到更多请求。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>ip_hash</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-加权轮询weighted-round-robin>4. <strong>加权轮询（Weighted Round Robin）</strong>
<a class=anchor href=#4-%e5%8a%a0%e6%9d%83%e8%bd%ae%e8%af%a2weighted-round-robin>#</a></h3><ul><li><p><strong>描述</strong>：在轮询的基础上为每个服务器设置一个权重值，根据权重值来调整请求的分配比例。权重高的服务器将获得更多的请求。</p></li><li><p>特点</p><p>：</p><ul><li>适用于后端服务器性能不均衡的场景。</li><li>权重可以设置为任意正整数，表示每台服务器的负载能力。</li><li>更灵活，可以根据后端服务器的性能调整请求的分配策略。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span> <span style=color:#e6db74>weight=3</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span> <span style=color:#e6db74>weight=1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-加权最少连接weighted-least-connections>5. <strong>加权最少连接（Weighted Least Connections）</strong>
<a class=anchor href=#5-%e5%8a%a0%e6%9d%83%e6%9c%80%e5%b0%91%e8%bf%9e%e6%8e%a5weighted-least-connections>#</a></h3><ul><li><p><strong>描述</strong>：结合最少连接和权重的概念，根据每个后端服务器的当前连接数和设置的权重来分配请求。服务器的权重较高且连接较少时，将获得更多的请求。</p></li><li><p>特点</p><p>：</p><ul><li>动态分配请求，根据每个服务器的连接数和权重调整负载。</li><li>适用于负载情况较为复杂的场景。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>least_conn</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span> <span style=color:#e6db74>weight=3</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span> <span style=color:#e6db74>weight=1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=6-随机random>6. <strong>随机（Random）</strong>
<a class=anchor href=#6-%e9%9a%8f%e6%9c%barandom>#</a></h3><ul><li><p><strong>描述</strong>：将请求随机地分发到后端服务器。这个算法简单，适用于负载非常均衡的情况。</p></li><li><p>特点</p><p>：</p><ul><li>非常简单且随机，适用于请求不太频繁的负载均衡场景。</li><li>可能会导致请求不均匀分布。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>random</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=7-最少响应时间least-time-nginx-plus>7. <strong>最少响应时间（Least Time）</strong> (Nginx Plus)
<a class=anchor href=#7-%e6%9c%80%e5%b0%91%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4least-time-nginx-plus>#</a></h3><ul><li><p><strong>描述</strong>：这个算法基于服务器的响应时间来分配请求，选择响应时间最短的服务器。Nginx Plus 提供了这个功能，它会选择响应时间最短的服务器来处理请求。</p></li><li><p>特点</p><p>：</p><ul><li>会动态根据服务器的响应时间来分配请求。</li><li>可以避免服务器因响应过慢导致其他请求堆积。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>least_time</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=总结-14>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-14>#</a></h3><ul><li><strong>Round Robin</strong>：简单、均衡，适合负载相对均衡的场景。</li><li><strong>Least Connections</strong>：根据连接数选择后端，适合负载不均的情况。</li><li><strong>IP Hash</strong>：基于客户端 IP 保证同一个客户端始终访问同一服务器，适合需要会话保持的应用。</li><li><strong>Weighted Round Robin</strong>：为每台服务器指定权重，适合后端服务器性能不均的情况。</li><li><strong>Weighted Least Connections</strong>：结合了最少连接和权重，适用于更复杂的负载均衡场景。</li><li><strong>Random</strong>：简单、随机，适用于负载非常均衡的情况。</li><li><strong>Least Time</strong>：基于响应时间选择后端，适合需要低延迟的场景（仅限 Nginx Plus）。</li></ul><p>选择负载均衡算法时，需要根据后端服务器的性能、应用场景、请求处理时长等因素来决定最合适的算法。</p><h1 id=18-如何进行压力测试>18. 如何进行压力测试？
<a class=anchor href=#18-%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95>#</a></h1><p>例如：模拟10个用户，对百度首页发起总共100次请求。
测试命令： ab -n 100 -c 10 <a href=https://www.baidu.com/index.htm>https://www.baidu.com/index.htm</a></p><p>进行压力测试是评估系统、应用程序或网络在高负载情况下表现的一个重要步骤。通过压力测试，可以发现系统的瓶颈、性能瓶颈和潜在的可扩展性问题。常见的压力测试包括并发用户负载测试、请求吞吐量测试、延迟测试等。</p><p>以下是进行压力测试的常见方法和工具：</p><hr><h3 id=1-使用-apache-jmeter-进行压力测试>1. <strong>使用 Apache JMeter 进行压力测试</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-apache-jmeter-%e8%bf%9b%e8%a1%8c%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95>#</a></h3><p>JMeter 是一个流行的开源性能测试工具，广泛用于 Web 应用程序、数据库和其他服务器的压力测试。</p><h4 id=步骤-4><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-4>#</a></h4><ol><li><strong>下载并安装 JMeter</strong>：<ul><li>从 <a href=https://jmeter.apache.org/>JMeter 官网</a> 下载并解压。</li></ul></li><li><strong>创建测试计划</strong>：<ul><li>打开 JMeter，创建一个新的测试计划（Test Plan）。</li><li>在测试计划中添加线程组（Thread Group），线程组指定了模拟的虚拟用户数和循环次数。</li></ul></li><li><strong>配置线程组</strong>：<ul><li><strong>Thread Group</strong>：设置用户数（Number of Threads）、循环次数（Loop Count）以及启动延迟（Ramp-Up Period）。</li><li>每个线程代表一个模拟的并发用户。</li></ul></li><li><strong>添加 HTTP 请求</strong>：<ul><li>在线程组下，添加 HTTP 请求（HTTP Request），配置目标 Web 服务器的地址、端口和请求参数。</li></ul></li><li><strong>添加监听器</strong>：<ul><li>在测试计划中添加不同的监听器（Listener），如聚合报告、图形结果、查看结果树等，用于记录测试结果并生成报告。</li></ul></li><li><strong>运行测试并分析结果</strong>：<ul><li>点击运行按钮开始测试，查看实时结果和图表，分析系统的响应时间、吞吐量、错误率等。</li></ul></li></ol><h4 id=典型场景><strong>典型场景</strong>：
<a class=anchor href=#%e5%85%b8%e5%9e%8b%e5%9c%ba%e6%99%af>#</a></h4><ul><li>测试 Web 应用、API 的并发性能。</li><li>负载、压力、容量和稳定性测试。</li></ul><hr><h3 id=2-使用-locust-进行压力测试>2. <strong>使用 Locust 进行压力测试</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-locust-%e8%bf%9b%e8%a1%8c%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95>#</a></h3><p>Locust 是一个基于 Python 的开源负载测试工具，支持分布式压力测试。</p><h4 id=步骤-5><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-5>#</a></h4><ol><li><p><strong>安装 Locust</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install locust
</span></span></code></pre></div></li><li><p><strong>编写测试脚本</strong>：</p><ul><li><p>创建一个 Python 脚本，定义用户行为（任务），例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> locust <span style=color:#f92672>import</span> HttpUser, task, between
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WebsiteUser</span>(HttpUser):
</span></span><span style=display:flex><span>    wait_time <span style=color:#f92672>=</span> between(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@task</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>load_main_page</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>client<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;/&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@task</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>load_about_page</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>client<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;/about&#34;</span>)
</span></span></code></pre></div></li></ul></li><li><p><strong>运行 Locust</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>locust -f your_locust_file.py
</span></span></code></pre></div></li><li><p><strong>访问 Web 界面</strong>：</p><ul><li>默认情况下，Locust 会在 <code>http://localhost:8089</code> 启动一个 Web 界面，您可以在界面中配置并发用户数、生成报告、查看测试结果等。</li></ul></li></ol><h4 id=典型场景-1><strong>典型场景</strong>：
<a class=anchor href=#%e5%85%b8%e5%9e%8b%e5%9c%ba%e6%99%af-1>#</a></h4><ul><li>API、Web 应用的性能测试。</li><li>分布式负载测试，多个机器可以一起参与。</li></ul><hr><h3 id=3-使用-ab-apache-bench-进行压力测试>3. <strong>使用 ab (Apache Bench) 进行压力测试</strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8-ab-apache-bench-%e8%bf%9b%e8%a1%8c%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95>#</a></h3><p>Apache Bench 是一个轻量级的命令行工具，通常用于简单的 HTTP 负载测试。</p><h4 id=步骤-6><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-6>#</a></h4><ol><li><p><strong>运行 ab 命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ab -n <span style=color:#ae81ff>1000</span> -c <span style=color:#ae81ff>10</span> http://your-server.com/
</span></span></code></pre></div><ul><li><code>-n 1000</code>：指定总请求数为 1000。</li><li><code>-c 10</code>：设置并发请求数为 10。</li></ul></li><li><p><strong>分析结果</strong>：</p><ul><li><code>ab</code> 会输出请求的响应时间、吞吐量、请求成功率等性能指标。</li></ul></li></ol><h4 id=典型场景-2><strong>典型场景</strong>：
<a class=anchor href=#%e5%85%b8%e5%9e%8b%e5%9c%ba%e6%99%af-2>#</a></h4><ul><li>简单的压力测试，适用于快速验证 Web 服务器的性能。</li><li>测试 API 或静态资源的吞吐量。</li></ul><hr><h3 id=4-使用-siege-进行压力测试>4. <strong>使用 siege 进行压力测试</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-siege-%e8%bf%9b%e8%a1%8c%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95>#</a></h3><p>Siege 是一个命令行压力测试工具，支持对 Web 应用进行负载测试。</p><h4 id=步骤-7><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-7>#</a></h4><ol><li><p><strong>安装 Siege</strong>：</p><ul><li><p>在 Linux 系统上，使用以下命令安装：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt install siege
</span></span></code></pre></div></li></ul></li><li><p><strong>运行 Siege 测试</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>siege -c <span style=color:#ae81ff>50</span> -t 30S http://your-server.com/
</span></span></code></pre></div><ul><li><code>-c 50</code>：指定并发用户数为 50。</li><li><code>-t 30S</code>：指定测试持续时间为 30 秒。</li></ul></li><li><p><strong>分析结果</strong>：</p><ul><li>Siege 会显示测试的响应时间、成功请求数、错误率等指标。</li></ul></li></ol><h4 id=典型场景-3><strong>典型场景</strong>：
<a class=anchor href=#%e5%85%b8%e5%9e%8b%e5%9c%ba%e6%99%af-3>#</a></h4><ul><li>测试 Web 服务器在不同负载下的性能。</li><li>持续压力测试，分析系统在长时间运行下的表现。</li></ul><hr><h3 id=5-使用-gatling-进行压力测试>5. <strong>使用 Gatling 进行压力测试</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8-gatling-%e8%bf%9b%e8%a1%8c%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95>#</a></h3><p>Gatling 是一个高性能的负载测试工具，适用于 HTTP、WebSocket 和其他协议的压力测试。</p><h4 id=步骤-8><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-8>#</a></h4><ol><li><p><strong>下载并安装 Gatling</strong>：</p><ul><li>从 <a href=https://gatling.io/>Gatling 官网</a> 下载并安装。</li></ul></li><li><p><strong>编写测试脚本</strong>：</p><ul><li><p>使用 Scala 编写测试脚本，模拟用户行为和负载，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BasicSimulation</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Simulation</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> httpProtocol <span style=color:#66d9ef>=</span> http
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>baseUrl<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;http://your-server.com&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>acceptHeader<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;application/json&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> scn <span style=color:#66d9ef>=</span> scenario<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Basic Load Test&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>exec<span style=color:#f92672>(</span>http<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;request_1&#34;</span><span style=color:#f92672>).</span>get<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  setUp<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    scn<span style=color:#f92672>.</span>inject<span style=color:#f92672>(</span>atOnceUsers<span style=color:#f92672>(</span><span style=color:#ae81ff>100</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>).</span>protocols<span style=color:#f92672>(</span>httpProtocol<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>运行测试</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./bin/gatling.sh -s BasicSimulation
</span></span></code></pre></div></li><li><p><strong>分析结果</strong>：</p><ul><li>Gatling 会生成 HTML 格式的报告，展示响应时间、吞吐量、错误率等。</li></ul></li></ol><h4 id=典型场景-4><strong>典型场景</strong>：
<a class=anchor href=#%e5%85%b8%e5%9e%8b%e5%9c%ba%e6%99%af-4>#</a></h4><ul><li>高并发用户模拟。</li><li>跨多协议的压力测试。</li></ul><hr><h3 id=6-使用-artillery-进行压力测试>6. <strong>使用 Artillery 进行压力测试</strong>
<a class=anchor href=#6-%e4%bd%bf%e7%94%a8-artillery-%e8%bf%9b%e8%a1%8c%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95>#</a></h3><p>Artillery 是一个轻量级、强大的负载测试工具，支持 HTTP、WebSocket 等协议。</p><h4 id=步骤-9><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-9>#</a></h4><ol><li><p><strong>安装 Artillery</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npm install -g artillery
</span></span></code></pre></div></li><li><p><strong>编写测试脚本</strong>：</p><ul><li><p>使用 YAML 配置文件定义测试场景：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>target</span>: <span style=color:#e6db74>&#39;http://your-server.com&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>phases</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>duration</span>: <span style=color:#ae81ff>60</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>arrivalRate</span>: <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>scenarios</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>flow</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>get</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>url</span>: <span style=color:#e6db74>&#34;/&#34;</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>运行测试</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>artillery run your_test_config.yml
</span></span></code></pre></div></li><li><p><strong>分析结果</strong>：</p><ul><li>Artillery 会输出实时测试结果，并生成详细报告。</li></ul></li></ol><h4 id=典型场景-5><strong>典型场景</strong>：
<a class=anchor href=#%e5%85%b8%e5%9e%8b%e5%9c%ba%e6%99%af-5>#</a></h4><ul><li>Web 应用和 API 性能测试。</li><li>简单的压力和负载测试，支持高并发。</li></ul><hr><h3 id=总结-15>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-15>#</a></h3><ol><li><strong>JMeter</strong>：功能强大，适用于复杂的负载测试，支持分布式测试。</li><li><strong>Locust</strong>：基于 Python，适合高并发分布式测试。</li><li><strong>ab</strong>：简单易用，适合基础的压力测试。</li><li><strong>Siege</strong>：命令行工具，适用于快速的压力测试。</li><li><strong>Gatling</strong>：高性能，适用于高并发的应用程序测试。</li><li><strong>Artillery</strong>：现代的负载测试工具，适用于简单和高效的负载测试。</li></ol><p>选择工具时，根据你的具体需求（如并发数、分布式支持、脚本编写难易度等）来选择最合适的压力测试工具。</p><h1 id=19-curl命令如何发送https请求如何查看response头信息如何发送get和post表单信息>19. curl命令如何发送https请求？如何查看response头信息？如何发送get和post表单信息？
<a class=anchor href=#19-curl%e5%91%bd%e4%bb%a4%e5%a6%82%e4%bd%95%e5%8f%91%e9%80%81https%e8%af%b7%e6%b1%82%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8bresponse%e5%a4%b4%e4%bf%a1%e6%81%af%e5%a6%82%e4%bd%95%e5%8f%91%e9%80%81get%e5%92%8cpost%e8%a1%a8%e5%8d%95%e4%bf%a1%e6%81%af>#</a></h1><ul><li>发送https请求：curl &ndash;tlsv1 ‘https://www.bitstamp.net/api/v2/transactions/btcusd/’</li><li>response头信息 ：curl -I</li><li>get：curl 请求地址?key1=value1&amp;key2=value2&amp;key3=value3</li><li>post： curl -d “key1=value1&amp;key2=value2&amp;key3=value3”</li></ul><p><code>curl</code> 是一个非常常用的命令行工具，支持多种协议，包括 HTTP 和 HTTPS。你可以使用 <code>curl</code> 发送 HTTPS 请求、查看响应头信息，并发送 GET 或 POST 请求。下面是一些常见用法：</p><hr><h3 id=1-发送-https-请求>1. <strong>发送 HTTPS 请求</strong>
<a class=anchor href=#1-%e5%8f%91%e9%80%81-https-%e8%af%b7%e6%b1%82>#</a></h3><p>要发送一个简单的 HTTPS 请求，只需要指定 URL，并且 <code>curl</code> 会自动使用 HTTPS 协议。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl https://www.example.com
</span></span></code></pre></div><h3 id=2-查看响应头信息>2. <strong>查看响应头信息</strong>
<a class=anchor href=#2-%e6%9f%a5%e7%9c%8b%e5%93%8d%e5%ba%94%e5%a4%b4%e4%bf%a1%e6%81%af>#</a></h3><p>如果你只想查看响应头，而不关心响应体，可以使用 <code>-I</code>（大写字母 i）选项。这样 <code>curl</code> 会发送一个 <code>HEAD</code> 请求，只返回响应头。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -I https://www.example.com
</span></span></code></pre></div><p>如果你想同时查看响应头和响应体，可以使用 <code>-i</code>（小写字母 i）选项：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -i https://www.example.com
</span></span></code></pre></div><h3 id=3-发送-get-请求>3. <strong>发送 GET 请求</strong>
<a class=anchor href=#3-%e5%8f%91%e9%80%81-get-%e8%af%b7%e6%b1%82>#</a></h3><p><code>curl</code> 默认使用 GET 方法，如果你只需要发送一个 GET 请求，可以直接写 URL：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl https://www.example.com?key<span style=color:#f92672>=</span>value&amp;anotherkey<span style=color:#f92672>=</span>anothervalue
</span></span></code></pre></div><p>如果你希望更加明确地指定使用 GET 请求，可以使用 <code>-X</code> 选项（尽管 <code>curl</code> 默认是 GET）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -X GET https://www.example.com?key<span style=color:#f92672>=</span>value
</span></span></code></pre></div><h3 id=4-发送-post-请求>4. <strong>发送 POST 请求</strong>
<a class=anchor href=#4-%e5%8f%91%e9%80%81-post-%e8%af%b7%e6%b1%82>#</a></h3><p>发送 POST 请求时，你需要使用 <code>-X POST</code> 来指定请求方法为 POST，并且用 <code>-d</code> 来传递请求的表单数据。</p><h4 id=发送表单数据x-www-form-urlencoded><strong>发送表单数据（x-www-form-urlencoded）</strong>
<a class=anchor href=#%e5%8f%91%e9%80%81%e8%a1%a8%e5%8d%95%e6%95%b0%e6%8d%aex-www-form-urlencoded>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -X POST https://www.example.com -d <span style=color:#e6db74>&#34;key1=value1&amp;key2=value2&#34;</span>
</span></span></code></pre></div><p>或者使用 <code>--data</code>（等同于 <code>-d</code>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl --data <span style=color:#e6db74>&#34;key1=value1&amp;key2=value2&#34;</span> https://www.example.com
</span></span></code></pre></div><h4 id=发送-post-请求并传递-json-数据><strong>发送 POST 请求并传递 JSON 数据</strong>
<a class=anchor href=#%e5%8f%91%e9%80%81-post-%e8%af%b7%e6%b1%82%e5%b9%b6%e4%bc%a0%e9%80%92-json-%e6%95%b0%e6%8d%ae>#</a></h4><p>如果你需要发送 JSON 格式的数据，可以设置 <code>Content-Type</code> 头部为 <code>application/json</code>，并传递 JSON 数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -X POST https://www.example.com <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -H <span style=color:#e6db74>&#34;Content-Type: application/json&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -d <span style=color:#e6db74>&#39;{&#34;key1&#34;: &#34;value1&#34;, &#34;key2&#34;: &#34;value2&#34;}&#39;</span>
</span></span></code></pre></div><h4 id=发送带文件的-post-请求><strong>发送带文件的 POST 请求</strong>
<a class=anchor href=#%e5%8f%91%e9%80%81%e5%b8%a6%e6%96%87%e4%bb%b6%e7%9a%84-post-%e8%af%b7%e6%b1%82>#</a></h4><p>如果你需要发送文件，可以使用 <code>-F</code> 选项来模拟表单文件上传：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -X POST https://www.example.com/upload -F <span style=color:#e6db74>&#34;file=@/path/to/file&#34;</span>
</span></span></code></pre></div><h4 id=发送带-cookie-的-post-请求><strong>发送带 Cookie 的 POST 请求</strong>
<a class=anchor href=#%e5%8f%91%e9%80%81%e5%b8%a6-cookie-%e7%9a%84-post-%e8%af%b7%e6%b1%82>#</a></h4><p>如果你需要在 POST 请求中携带 Cookie，可以使用 <code>-b</code>（或者 <code>--cookie</code>）选项：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -X POST https://www.example.com <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -b <span style=color:#e6db74>&#34;name=value&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -d <span style=color:#e6db74>&#34;key1=value1&amp;key2=value2&#34;</span>
</span></span></code></pre></div><h3 id=5-发送带自定义头的请求>5. <strong>发送带自定义头的请求</strong>
<a class=anchor href=#5-%e5%8f%91%e9%80%81%e5%b8%a6%e8%87%aa%e5%ae%9a%e4%b9%89%e5%a4%b4%e7%9a%84%e8%af%b7%e6%b1%82>#</a></h3><p>你可以使用 <code>-H</code> 选项来设置自定义的请求头。例如，设置 <code>User-Agent</code> 和 <code>Authorization</code> 头：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -X POST https://www.example.com <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -H <span style=color:#e6db74>&#34;User-Agent: MyCustomAgent&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -H <span style=color:#e6db74>&#34;Authorization: Bearer your_token_here&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -d <span style=color:#e6db74>&#34;key1=value1&amp;key2=value2&#34;</span>
</span></span></code></pre></div><hr><h3 id=总结-16>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-16>#</a></h3><ul><li><strong>发送 HTTPS 请求</strong>：<code>curl https://example.com</code></li><li><strong>查看响应头</strong>：<code>curl -I https://example.com</code></li><li><strong>查看响应头和响应体</strong>：<code>curl -i https://example.com</code></li><li><strong>发送 GET 请求</strong>：<code>curl https://example.com?key=value</code></li><li><strong>发送 POST 请求（表单数据）</strong>：<code>curl -X POST https://example.com -d "key=value"</code></li><li><strong>发送 JSON 数据的 POST 请求</strong>：<code>curl -X POST https://example.com -H "Content-Type: application/json" -d '{"key": "value"}'</code></li><li><strong>发送文件的 POST 请求</strong>：<code>curl -X POST https://example.com -F "file=@/path/to/file"</code></li><li><strong>携带 Cookie 的 POST 请求</strong>：<code>curl -X POST https://example.com -b "name=value" -d "key=value"</code></li></ul><p>通过这些基本命令，你可以使用 <code>curl</code> 进行各种类型的 HTTP/HTTPS 请求，并控制请求和响应的各个方面。</p><h1 id=二mysql>二、mysql
<a class=anchor href=#%e4%ba%8cmysql>#</a></h1><h1 id=1-索引的为什么使查询加快有啥缺点>1. 索引的为什么使查询加快？有啥缺点？
<a class=anchor href=#1-%e7%b4%a2%e5%bc%95%e7%9a%84%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e6%9f%a5%e8%af%a2%e5%8a%a0%e5%bf%ab%e6%9c%89%e5%95%a5%e7%bc%ba%e7%82%b9>#</a></h1><p>默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度
缺点：</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大</li><li>以表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度</li></ul><p><strong>索引</strong> 是数据库管理系统（DBMS）中的一种数据结构，用于加速数据的检索过程。索引通过在表中创建一个排序的数据结构，使得数据库可以更高效地查找数据。简单来说，索引就像书籍的目录，它帮助我们快速找到目标信息，而不需要从头到尾逐一查找。</p><h3 id=为什么索引能加快查询><strong>为什么索引能加快查询？</strong>
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%b4%a2%e5%bc%95%e8%83%bd%e5%8a%a0%e5%bf%ab%e6%9f%a5%e8%af%a2>#</a></h3><ol><li><strong>减少全表扫描</strong>：<ul><li>如果没有索引，数据库查询通常需要对整个表进行<strong>全表扫描</strong>（扫描每一行）。对于大表，这种方式非常慢。</li><li>索引通过提供一个有序的数据结构（如 B+ 树），使得数据库可以通过<strong>二分查找</strong>或者<strong>树形查找</strong>等高效算法快速定位到目标数据，而不需要扫描整个表。</li></ul></li><li><strong>提高检索效率</strong>：<ul><li>在没有索引时，查找某个值的时间复杂度是 O(n)，即需要逐行扫描。</li><li>有了索引后，查找时间复杂度降低为 O(log n)（例如 B+ 树），可以大大提升查询速度。</li></ul></li><li><strong>减少磁盘 I/O</strong>：<ul><li>索引通常存储在磁盘上，但它比整个数据表小，因此查找一个值时，只需要读取少量的磁盘数据。</li><li>在磁盘和内存之间的 I/O 操作是数据库操作中的瓶颈，使用索引可以显著减少这种 I/O 操作，提升性能。</li></ul></li><li><strong>加速排序和聚合操作</strong>：<ul><li>索引不仅能加速查询，还能加速排序（ORDER BY）和聚合（GROUP BY）操作。</li><li>如果查询涉及到排序和分组，索引可以直接提供有序的数据，避免了额外的排序操作。</li></ul></li></ol><hr><h3 id=索引的缺点和限制><strong>索引的缺点和限制</strong>
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e7%9a%84%e7%bc%ba%e7%82%b9%e5%92%8c%e9%99%90%e5%88%b6>#</a></h3><p>虽然索引在提高查询性能方面有显著的优势，但它也存在一些缺点和限制：</p><ol><li><strong>占用存储空间</strong>：<ul><li>每个索引都会消耗一定的存储空间，特别是在有大量索引的情况下。对于大表，多个索引的存储开销可能非常大，尤其是当表的数据量不断增加时。</li><li>索引本身也是需要存储在磁盘上的，如果不合理使用索引，可能会导致磁盘空间的浪费。</li></ul></li><li><strong>降低写入性能</strong>：<ul><li>每当向表中插入、更新或删除数据时，相关的索引也需要更新。因此，<strong>写操作</strong>（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）的性能会受到影响，尤其是在有多个索引的情况下。</li><li>例如，插入新记录时，不仅要将数据插入到表中，还要将该数据的索引条目添加到相应的索引中。更新和删除操作也同样会导致索引的重新调整。</li></ul></li><li><strong>索引的选择和维护成本</strong>：<ul><li>在大型数据库系统中，选择哪些列建立索引、使用哪种类型的索引（例如 B+ 树、哈希索引等）需要根据具体查询的情况进行评估。这需要一定的经验和知识。</li><li>随着数据量的增长，索引的维护也变得更加复杂。例如，某些索引可能变得过时或不再有效，可能需要重新设计或调整。</li></ul></li><li><strong>影响查询优化器的选择</strong>：<ul><li>在某些情况下，过多的索引可能会影响查询优化器的决策。查询优化器可能选择一个较差的索引路径，导致查询性能下降。</li><li>在有多个索引的情况下，数据库可能需要评估哪些索引最优，但优化器的选择并不总是完美的，可能会选择不适合当前查询的索引。</li></ul></li><li><strong>索引的更新和重建</strong>：<ul><li>当表的数据发生变化时，索引会被更新，随着时间的推移，索引可能会变得不平衡或碎片化，影响查询性能。</li><li>在某些情况下，可能需要定期<strong>重建索引</strong>或<strong>重新组织索引</strong>，以保持查询性能。</li></ul></li></ol><hr><h3 id=总结-17><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-17>#</a></h3><ul><li><strong>优点</strong>：<ul><li><strong>加速查询</strong>：通过减少全表扫描，使得数据检索更加高效。</li><li><strong>提高排序和聚合操作</strong>：索引可以加速排序（<code>ORDER BY</code>）和聚合（<code>GROUP BY</code>）操作。</li><li><strong>减少磁盘 I/O</strong>：减少查询过程中的磁盘读取，提高查询效率。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>占用存储空间</strong>：索引占用额外的磁盘空间。</li><li><strong>降低写入性能</strong>：每次写操作都需要更新相关的索引。</li><li><strong>索引维护成本</strong>：需要定期更新和优化索引，维护复杂。</li><li><strong>不当索引选择</strong>：可能导致查询优化器选择错误的索引，影响查询性能。</li></ul></li></ul><p>合理地使用索引，可以显著提升查询性能。但也要平衡索引带来的开销，根据具体业务需求和查询特点，选择合适的索引类型和数量。</p><h2 id=2-sql语句左外连接-右外连接-内连接-全连接区别>2. sql语句左外连接 右外连接 内连接 全连接区别
<a class=anchor href=#2-sql%e8%af%ad%e5%8f%a5%e5%b7%a6%e5%a4%96%e8%bf%9e%e6%8e%a5-%e5%8f%b3%e5%a4%96%e8%bf%9e%e6%8e%a5-%e5%86%85%e8%bf%9e%e6%8e%a5-%e5%85%a8%e8%bf%9e%e6%8e%a5%e5%8c%ba%e5%88%ab>#</a></h2><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012349689.png alt=image-20250224012349689></p><p>在 SQL 中，<code>JOIN</code> 用于从多个表中查询数据，<code>LEFT JOIN</code>、<code>RIGHT JOIN</code>、<code>INNER JOIN</code> 和 <code>FULL JOIN</code> 是常见的几种连接类型，它们用于指定表之间数据的连接方式。每种连接类型的行为有所不同，以下是它们的详细区别：</p><h3 id=1-内连接-inner-join>1. <strong>内连接 (INNER JOIN)</strong>
<a class=anchor href=#1-%e5%86%85%e8%bf%9e%e6%8e%a5-inner-join>#</a></h3><p><strong>定义</strong>：<code>INNER JOIN</code> 返回的是两个表中满足连接条件的<strong>交集</strong>，即只返回两个表中都有的匹配数据。</p><ul><li><strong>行为</strong>：如果两个表中有相同的匹配记录，则返回这些记录。对于没有匹配的记录，<code>INNER JOIN</code> 不会返回。</li></ul><h4 id=示例>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> employees e
</span></span><span style=display:flex><span><span style=color:#66d9ef>INNER</span> <span style=color:#66d9ef>JOIN</span> departments d <span style=color:#66d9ef>ON</span> e.department_id <span style=color:#f92672>=</span> d.department_id;
</span></span></code></pre></div><p>这个查询将返回所有有匹配的 <code>employees</code> 和 <code>departments</code> 的记录。</p><h4 id=特点>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9>#</a></h4><ul><li>只返回两个表中匹配的记录。</li><li>如果一个表中没有匹配，数据行就不会出现在结果中。</li></ul><hr><h3 id=2-左外连接-left-join-或-left-outer-join>2. <strong>左外连接 (LEFT JOIN 或 LEFT OUTER JOIN)</strong>
<a class=anchor href=#2-%e5%b7%a6%e5%a4%96%e8%bf%9e%e6%8e%a5-left-join-%e6%88%96-left-outer-join>#</a></h3><p><strong>定义</strong>：<code>LEFT JOIN</code> 返回的是左表（<code>LEFT</code>）中的所有记录以及右表（<code>RIGHT</code>）中与左表匹配的记录。如果右表没有匹配的记录，右表的列将包含 <code>NULL</code>。</p><ul><li><strong>行为</strong>：返回左表中的所有行，即使右表没有与左表匹配的行。对于没有匹配的右表行，将会显示 <code>NULL</code>。</li></ul><h4 id=示例-1>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> employees e
</span></span><span style=display:flex><span><span style=color:#66d9ef>LEFT</span> <span style=color:#66d9ef>JOIN</span> departments d <span style=color:#66d9ef>ON</span> e.department_id <span style=color:#f92672>=</span> d.department_id;
</span></span></code></pre></div><p>这个查询将返回 <code>employees</code> 表中的所有记录，即使某些员工没有对应的 <code>department_id</code>（右表为空时会返回 <code>NULL</code>）。</p><h4 id=特点-1>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-1>#</a></h4><ul><li>返回左表（<code>LEFT</code>）中的所有记录。</li><li>如果右表没有匹配，右表的值将为 <code>NULL</code>。</li></ul><hr><h3 id=3-右外连接-right-join-或-right-outer-join>3. <strong>右外连接 (RIGHT JOIN 或 RIGHT OUTER JOIN)</strong>
<a class=anchor href=#3-%e5%8f%b3%e5%a4%96%e8%bf%9e%e6%8e%a5-right-join-%e6%88%96-right-outer-join>#</a></h3><p><strong>定义</strong>：<code>RIGHT JOIN</code> 返回的是右表（<code>RIGHT</code>）中的所有记录以及左表（<code>LEFT</code>）中与右表匹配的记录。如果左表没有匹配的记录，左表的列将包含 <code>NULL</code>。</p><ul><li><strong>行为</strong>：返回右表中的所有行，即使左表没有与右表匹配的行。对于没有匹配的左表行，将会显示 <code>NULL</code>。</li></ul><h4 id=示例-2>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-2>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> employees e
</span></span><span style=display:flex><span><span style=color:#66d9ef>RIGHT</span> <span style=color:#66d9ef>JOIN</span> departments d <span style=color:#66d9ef>ON</span> e.department_id <span style=color:#f92672>=</span> d.department_id;
</span></span></code></pre></div><p>这个查询将返回 <code>departments</code> 表中的所有记录，即使某些部门没有员工（左表为空时会返回 <code>NULL</code>）。</p><h4 id=特点-2>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-2>#</a></h4><ul><li>返回右表（<code>RIGHT</code>）中的所有记录。</li><li>如果左表没有匹配，左表的值将为 <code>NULL</code>。</li></ul><hr><h3 id=4-全外连接-full-join-或-full-outer-join>4. <strong>全外连接 (FULL JOIN 或 FULL OUTER JOIN)</strong>
<a class=anchor href=#4-%e5%85%a8%e5%a4%96%e8%bf%9e%e6%8e%a5-full-join-%e6%88%96-full-outer-join>#</a></h3><p><strong>定义</strong>：<code>FULL JOIN</code> 返回的是两个表中的所有记录。如果某个表中没有与另一个表匹配的行，缺少的部分将用 <code>NULL</code> 填充。</p><ul><li><strong>行为</strong>：返回两个表中的所有行。如果某个表中没有匹配，另一个表的列会显示 <code>NULL</code>。</li></ul><h4 id=示例-3>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-3>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> employees e
</span></span><span style=display:flex><span><span style=color:#66d9ef>FULL</span> <span style=color:#66d9ef>JOIN</span> departments d <span style=color:#66d9ef>ON</span> e.department_id <span style=color:#f92672>=</span> d.department_id;
</span></span></code></pre></div><p>这个查询将返回 <code>employees</code> 和 <code>departments</code> 表中的所有记录。如果一个表中的某些记录在另一个表中没有匹配，则会填充 <code>NULL</code>。</p><h4 id=特点-3>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-3>#</a></h4><ul><li>返回两个表中的所有记录。</li><li>如果某个表没有匹配，结果中的缺失部分用 <code>NULL</code> 填充。</li></ul><hr><h3 id=总结-18><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-18>#</a></h3><table><thead><tr><th><strong>连接类型</strong></th><th><strong>返回记录</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>INNER JOIN</strong></td><td>只返回两个表中匹配的记录。</td><td>只返回两个表中满足连接条件的记录。</td></tr><tr><td><strong>LEFT JOIN</strong></td><td>返回左表的所有记录，以及右表中匹配的记录。右表没有匹配时返回 <code>NULL</code>。</td><td>返回左表的所有记录，并且如果右表没有匹配，右表的值为 <code>NULL</code>。</td></tr><tr><td><strong>RIGHT JOIN</strong></td><td>返回右表的所有记录，以及左表中匹配的记录。左表没有匹配时返回 <code>NULL</code>。</td><td>返回右表的所有记录，并且如果左表没有匹配，左表的值为 <code>NULL</code>。</td></tr><tr><td><strong>FULL JOIN</strong></td><td>返回两个表的所有记录。若某个表没有匹配，缺失部分为 <code>NULL</code>。</td><td>返回两个表中的所有记录，若某个表没有匹配，用 <code>NULL</code> 填充。</td></tr></tbody></table><hr><h3 id=举例说明><strong>举例说明：</strong>
<a class=anchor href=#%e4%b8%be%e4%be%8b%e8%af%b4%e6%98%8e>#</a></h3><p>假设有两张表：<code>employees</code> 和 <code>departments</code>。</p><p><strong>employees</strong> 表：</p><table><thead><tr><th>employee_id</th><th>name</th><th>department_id</th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>101</td></tr><tr><td>2</td><td>Bob</td><td>102</td></tr><tr><td>3</td><td>Charlie</td><td>NULL</td></tr></tbody></table><p><strong>departments</strong> 表：</p><table><thead><tr><th>department_id</th><th>department_name</th></tr></thead><tbody><tr><td>101</td><td>HR</td></tr><tr><td>102</td><td>IT</td></tr><tr><td>103</td><td>Finance</td></tr></tbody></table><ul><li><strong>INNER JOIN</strong> 结果：<ul><li>只会返回 <code>department_id</code> 为 101 和 102 的员工，即 Alice 和 Bob。</li></ul></li><li><strong>LEFT JOIN</strong> 结果：<ul><li>返回所有员工，Bob 和 Alice 会显示部门名称，Charlie 会显示 <code>NULL</code> 部门。</li></ul></li><li><strong>RIGHT JOIN</strong> 结果：<ul><li>返回所有部门，HR 和 IT 部门对应的员工会显示，Finance 部门没有员工，所以员工列为 <code>NULL</code>。</li></ul></li><li><strong>FULL JOIN</strong> 结果：<ul><li>返回所有员工和所有部门，无论是否匹配。没有匹配的部门或员工都会显示 <code>NULL</code>。</li></ul></li></ul><p>通过选择适合的连接类型，可以根据实际需求灵活地获取所需的数据。</p><h1 id=3-mysql数据备份方式如何恢复你们的备份策略是什么>3. mysql数据备份方式，如何恢复？你们的备份策略是什么？
<a class=anchor href=#3-mysql%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd%e6%96%b9%e5%bc%8f%e5%a6%82%e4%bd%95%e6%81%a2%e5%a4%8d%e4%bd%a0%e4%bb%ac%e7%9a%84%e5%a4%87%e4%bb%bd%e7%ad%96%e7%95%a5%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>物理完全备份</li></ul><p>备份所有数据库文件：/var/lib/mysql/*
备份所有binlog文件: /var/lib/mysql/mysql-bin.*
备份选项文件: /etc/my.cnf</p><ul><li>mysqldump逻辑备份</li></ul><p>mysqldump -uroot -p &ndash;all-databases > /backup/mysqldump/all.db</p><ul><li>物理备份恢复</li></ul><p>mv /var/lib/mysql /var/lib/mysql.old #先把原来的数据目录改名
cp -a /backups/mysql /var/lib</p><ul><li>逻辑备份数据恢复</li></ul><p>mysql > use db_name
mysql > source /backup/mysqldump/db_name.db</p><p>在 MySQL 中，数据备份是保障数据安全和防止数据丢失的重要措施。备份方式有多种，每种备份方式在不同场景下有不同的优劣。下面是常见的 MySQL 数据备份方式和恢复方法，并提供一份备份策略的参考。</p><h3 id=常见的-mysql-数据备份方式><strong>常见的 MySQL 数据备份方式</strong>
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84-mysql-%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd%e6%96%b9%e5%bc%8f>#</a></h3><ol><li><p><strong>逻辑备份（Logical Backup）</strong></p><ul><li><p><strong>方式</strong>：通过 SQL 脚本导出数据库的表结构和数据。</p></li><li><p><strong>工具</strong>：<code>mysqldump</code></p></li><li><p>优点</p><p>：</p><ul><li>备份文件是纯文本，可以跨平台恢复。</li><li>适用于小型数据库、迁移数据库到不同平台。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>备份速度较慢，尤其对于大规模数据表，备份文件会很大。</li><li>需要更多的存储空间来存放备份文件。</li></ul></li></ul><h4 id=如何备份><strong>如何备份</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%a4%87%e4%bb%bd>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysqldump -u username -p database_name &gt; backup.sql
</span></span></code></pre></div><h4 id=如何恢复><strong>如何恢复</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e6%81%a2%e5%a4%8d>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql -u username -p database_name &lt; backup.sql
</span></span></code></pre></div></li><li><p><strong>物理备份（Physical Backup）</strong></p><ul><li><p><strong>方式</strong>：直接复制数据库数据文件，通常通过 <code>xtrabackup</code> 或文件系统的备份。</p></li><li><p><strong>工具</strong>：<code>Percona XtraBackup</code>, <code>cp</code> 或 <code>rsync</code>（在停机或只读模式下）</p></li><li><p>优点</p><p>：</p><ul><li>备份速度快，适合大规模数据备份。</li><li>恢复速度快，直接复制数据文件即可恢复。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>需要确保备份期间没有修改数据，通常会要求停机或者锁定表。</li><li>备份文件是二进制文件，跨平台恢复较麻烦。</li></ul></li></ul><h4 id=如何备份-1><strong>如何备份</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%a4%87%e4%bb%bd-1>#</a></h4><p>使用 <code>Percona XtraBackup</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>innobackupex --user<span style=color:#f92672>=</span>username --password<span style=color:#f92672>=</span>password /path/to/backup
</span></span></code></pre></div><h4 id=如何恢复-1><strong>如何恢复</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e6%81%a2%e5%a4%8d-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>innobackupex --apply-log /path/to/backup
</span></span><span style=display:flex><span>innobackupex --copy-back /path/to/backup
</span></span></code></pre></div></li><li><p><strong>增量备份（Incremental Backup）</strong></p><ul><li><p><strong>方式</strong>：只备份自上次备份以来发生变化的数据。</p></li><li><p><strong>工具</strong>：<code>Percona XtraBackup</code>（支持增量备份）。</p></li><li><p>优点</p><p>：</p><ul><li>备份速度比全量备份快，节省存储空间。</li><li>适用于需要频繁备份和恢复的场景。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>恢复时需要先恢复最后的全量备份，然后再恢复所有增量备份。</li><li>增量备份需要管理更多的备份文件，增加了恢复复杂度。</li></ul></li></ul><h4 id=如何备份-2><strong>如何备份</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%a4%87%e4%bb%bd-2>#</a></h4><p>使用 <code>Percona XtraBackup</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>innobackupex --user<span style=color:#f92672>=</span>username --password<span style=color:#f92672>=</span>password --incremental /path/to/incremental_backup --incremental-basedir /path/to/previous_backup
</span></span></code></pre></div><h4 id=如何恢复-2><strong>如何恢复</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e6%81%a2%e5%a4%8d-2>#</a></h4><p>首先恢复全量备份，然后按顺序恢复增量备份：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>innobackupex --apply-log /path/to/full_backup
</span></span><span style=display:flex><span>innobackupex --apply-log --incremental-dir /path/to/incremental_backup /path/to/full_backup
</span></span></code></pre></div></li><li><p><strong>二进制日志备份（Binary Log Backup）</strong></p><ul><li><p><strong>方式</strong>：备份 MySQL 的二进制日志，以便在全量备份后，捕获和恢复增量变更。</p></li><li><p><strong>工具</strong>：<code>mysqlbinlog</code></p></li><li><p>优点</p><p>：</p><ul><li>可以记录所有的数据修改操作，用于恢复和点时间恢复（PITR）。</li><li>支持备份期间的数据变化捕获。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>需要定期备份和归档二进制日志。</li><li>恢复过程相对复杂。</li></ul></li></ul><h4 id=如何备份-3><strong>如何备份</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%a4%87%e4%bb%bd-3>#</a></h4><p>在 MySQL 配置文件中启用二进制日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[mysqld]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>log-bin</span><span style=color:#f92672>=</span><span style=color:#e6db74>mysql-bin</span>
</span></span></code></pre></div><p>获取二进制日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysqlbinlog /var/lib/mysql/mysql-bin.000001 &gt; binary_log.sql
</span></span></code></pre></div><h4 id=如何恢复-3><strong>如何恢复</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e6%81%a2%e5%a4%8d-3>#</a></h4><p>将二进制日志应用到备份数据库中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysqlbinlog /path/to/binary_log | mysql -u username -p database_name
</span></span></code></pre></div></li></ol><h3 id=恢复的常见方式><strong>恢复的常见方式</strong>
<a class=anchor href=#%e6%81%a2%e5%a4%8d%e7%9a%84%e5%b8%b8%e8%a7%81%e6%96%b9%e5%bc%8f>#</a></h3><p>恢复的方式与备份方式相关。常见的恢复方式有以下几种：</p><ol><li><strong>从逻辑备份恢复</strong>：直接执行 <code>.sql</code> 文件恢复。</li><li><strong>从物理备份恢复</strong>：将备份文件复制回数据库的相关目录，并确保权限正确。</li><li><strong>从增量备份恢复</strong>：先恢复全量备份，再应用所有增量备份。</li><li><strong>从二进制日志恢复</strong>：将二进制日志文件中的操作应用到备份数据中，恢复到特定时间点。</li></ol><h3 id=mysql-备份策略><strong>MySQL 备份策略</strong>
<a class=anchor href=#mysql-%e5%a4%87%e4%bb%bd%e7%ad%96%e7%95%a5>#</a></h3><p>一个良好的备份策略应该根据业务的需求、数据量和恢复要求来制定，以下是一个常见的备份策略：</p><ol><li><strong>全量备份</strong>：
每周进行一次全量备份（比如每周日进行）。这确保了我们可以快速恢复到一个较为完整的状态。</li><li><strong>增量备份</strong>：
每天进行增量备份，备份自上次全量或增量备份以来变化的数据。增量备份可以减少备份数据的大小和备份时间。</li><li><strong>二进制日志备份</strong>：
开启二进制日志，并每小时或每次应用更新时备份日志。这样可以保证在全量和增量备份之间的变更也能被备份，并在需要时进行点时间恢复（PITR）。</li><li><strong>备份存储</strong>：<ul><li>将备份存储在不同的物理位置（如备份到云端，或使用本地和远程存储）。</li><li>保持一定数量的备份副本（如保留过去 7 天的备份）。</li><li>使用加密来保护备份数据的安全性。</li></ul></li><li><strong>定期验证备份</strong>：<ul><li>定期执行恢复演练，确保备份文件有效且恢复过程可行。</li></ul></li><li><strong>备份保留策略</strong>：<ul><li>保留一定时间内的备份（如每月的全量备份保留一个月，日常增量备份保留一周）。</li></ul></li><li><strong>自动化备份</strong>：<ul><li>使用脚本或备份工具（如 <code>cron</code>、<code>Percona XtraBackup</code> 等）自动化备份过程，减少人为干预。</li></ul></li></ol><hr><h3 id=总结-19><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-19>#</a></h3><ul><li><strong>备份方式</strong>：<ul><li>逻辑备份（<code>mysqldump</code>）适用于小型数据库或跨平台迁移。</li><li>物理备份（<code>Percona XtraBackup</code>）适用于大规模数据库，恢复速度快。</li><li>增量备份适用于大数据量并且需要频繁备份的场景。</li><li>二进制日志备份用于捕获和恢复数据库的变更操作。</li></ul></li><li><strong>恢复方式</strong>：<ul><li>根据备份方式，恢复流程也会有所不同。通常包括从备份文件恢复或应用增量备份、二进制日志恢复等。</li></ul></li><li><strong>备份策略</strong>：<ul><li>定期全量备份+增量备份+二进制日志备份，并确保备份存储的安全性、可恢复性和备份文件的有效性。</li></ul></li></ul><h1 id=4-如何配置数据库主从同步实际工作中是否遇到数据不一致问题如何解决>4. 如何配置数据库主从同步，实际工作中是否遇到数据不一致问题？如何解决？
<a class=anchor href=#4-%e5%a6%82%e4%bd%95%e9%85%8d%e7%bd%ae%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e5%ae%9e%e9%99%85%e5%b7%a5%e4%bd%9c%e4%b8%ad%e6%98%af%e5%90%a6%e9%81%87%e5%88%b0%e6%95%b0%e6%8d%ae%e4%b8%8d%e4%b8%80%e8%87%b4%e9%97%ae%e9%a2%98%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3>#</a></h1><p>为每个服务器配置唯一值的server-id</p><ul><li>主库</li></ul><p>开启binlog日志
创建主从复制用户
查看master的状态</p><ul><li>从库</li></ul><p>change master to设置主库信息
start slave开始复制</p><h3 id=数据库主从同步配置><strong>数据库主从同步配置</strong>
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e9%85%8d%e7%bd%ae>#</a></h3><p>在 MySQL 中，主从同步（Master-Slave Replication）是一种常见的数据库复制方式，用于实现数据的高可用性和负载均衡。配置 MySQL 主从同步通常涉及以下几个步骤：</p><hr><h3 id=1-配置主服务器master><strong>1. 配置主服务器（Master）</strong>
<a class=anchor href=#1-%e9%85%8d%e7%bd%ae%e4%b8%bb%e6%9c%8d%e5%8a%a1%e5%99%a8master>#</a></h3><p>首先，确保主服务器配置为允许复制操作，并创建一个专门的复制用户。</p><h4 id=步骤-1-配置主服务器的-mycnf-配置文件>步骤 1: 配置主服务器的 <code>my.cnf</code> 配置文件
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-1-%e9%85%8d%e7%bd%ae%e4%b8%bb%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84-mycnf-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h4><p>编辑主服务器上的 <code>my.cnf</code>（或 <code>my.ini</code>，视操作系统而定）配置文件，启用二进制日志（<code>binlog</code>）并配置唯一的服务器 ID。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>mysqld<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>server-id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>log-bin <span style=color:#f92672>=</span> mysql-bin
</span></span><span style=display:flex><span>binlog-do-db <span style=color:#f92672>=</span> your_database_name  <span style=color:#75715e># 可选，只复制指定的数据库</span>
</span></span></code></pre></div><ul><li><code>server-id</code>：每个 MySQL 实例必须有唯一的 <code>server-id</code>，且主服务器和从服务器的 <code>server-id</code> 必须不同。</li><li><code>log-bin</code>：启用二进制日志，这样从服务器可以获取主服务器上的所有变更事件。</li><li><code>binlog-do-db</code>：如果只希望同步某个特定数据库的数据，可以在这里配置。</li></ul><h4 id=步骤-2-创建复制用户>步骤 2: 创建复制用户
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-2-%e5%88%9b%e5%bb%ba%e5%a4%8d%e5%88%b6%e7%94%a8%e6%88%b7>#</a></h4><p>登录到主服务器的 MySQL，创建一个用于复制的专用用户，并授权。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;replica_user&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;%&#39;</span> IDENTIFIED <span style=color:#66d9ef>BY</span> <span style=color:#e6db74>&#39;password&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>GRANT</span> REPLICATION SLAVE <span style=color:#66d9ef>ON</span> <span style=color:#f92672>*</span>.<span style=color:#f92672>*</span> <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;replica_user&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;%&#39;</span>;
</span></span><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div><ul><li><code>replica_user</code>：复制用户，<code>%</code> 表示允许所有 IP 连接。</li><li><code>REPLICATION SLAVE</code> 权限：允许从服务器读取二进制日志。</li></ul><h4 id=步骤-3-获取主服务器的二进制日志位置>步骤 3: 获取主服务器的二进制日志位置
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-3-%e8%8e%b7%e5%8f%96%e4%b8%bb%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97%e4%bd%8d%e7%bd%ae>#</a></h4><p>在配置主从同步之前，需要获取主服务器的当前二进制日志文件名和位置。执行以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SHOW</span> MASTER STATUS;
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 | 1234     | your_database_name |                  |
+------------------+----------+--------------+------------------+
</code></pre><p>记录下 <code>File</code> 和 <code>Position</code>，稍后需要在从服务器配置时使用。</p><hr><h3 id=2-配置从服务器slave><strong>2. 配置从服务器（Slave）</strong>
<a class=anchor href=#2-%e9%85%8d%e7%bd%ae%e4%bb%8e%e6%9c%8d%e5%8a%a1%e5%99%a8slave>#</a></h3><p>接下来，配置从服务器使其能够接收并执行主服务器的更新。</p><h4 id=步骤-1-配置从服务器的-mycnf-配置文件>步骤 1: 配置从服务器的 <code>my.cnf</code> 配置文件
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-1-%e9%85%8d%e7%bd%ae%e4%bb%8e%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84-mycnf-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h4><p>编辑从服务器的 <code>my.cnf</code> 配置文件，设置唯一的 <code>server-id</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>mysqld<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>server-id <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># 从服务器的 ID 必须与主服务器不同</span>
</span></span></code></pre></div><h4 id=步骤-2-启动从服务器复制>步骤 2: 启动从服务器复制
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-2-%e5%90%af%e5%8a%a8%e4%bb%8e%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%a4%8d%e5%88%b6>#</a></h4><p>登录到从服务器的 MySQL，执行以下命令配置复制信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>CHANGE MASTER <span style=color:#66d9ef>TO</span>
</span></span><span style=display:flex><span>  MASTER_HOST <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;master_ip&#39;</span>,  <span style=color:#75715e>-- 主服务器的 IP 地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  MASTER_USER <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;replica_user&#39;</span>,  <span style=color:#75715e>-- 复制用户
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  MASTER_PASSWORD <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;password&#39;</span>,  <span style=color:#75715e>-- 复制用户密码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  MASTER_LOG_FILE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;mysql-bin.000001&#39;</span>,  <span style=color:#75715e>-- 主服务器的二进制日志文件名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  MASTER_LOG_POS <span style=color:#f92672>=</span> <span style=color:#ae81ff>1234</span>;  <span style=color:#75715e>-- 主服务器的二进制日志位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>START</span> SLAVE;
</span></span></code></pre></div><ul><li><code>MASTER_HOST</code>：主服务器的 IP 地址。</li><li><code>MASTER_USER</code> 和 <code>MASTER_PASSWORD</code>：复制用户和密码。</li><li><code>MASTER_LOG_FILE</code> 和 <code>MASTER_LOG_POS</code>：主服务器的二进制日志文件名和位置（通过 <code>SHOW MASTER STATUS</code> 获取）。</li></ul><h4 id=步骤-3-检查复制状态>步骤 3: 检查复制状态
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-3-%e6%a3%80%e6%9f%a5%e5%a4%8d%e5%88%b6%e7%8a%b6%e6%80%81>#</a></h4><p>使用以下命令查看从服务器的复制状态，确保没有错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SHOW</span> SLAVE STATUS<span style=color:#960050;background-color:#1e0010>\</span><span style=color:#66d9ef>G</span>
</span></span></code></pre></div><p>你应该看到如下信息：</p><pre tabindex=0><code>Slave_IO_Running: Yes
Slave_SQL_Running: Yes
</code></pre><ul><li><code>Slave_IO_Running</code>：表示从服务器是否能从主服务器读取二进制日志。</li><li><code>Slave_SQL_Running</code>：表示从服务器是否能执行读取到的 SQL 语句。</li></ul><p>如果都为 <code>Yes</code>，说明主从同步已经正常工作。</p><hr><h3 id=3-验证同步是否正常><strong>3. 验证同步是否正常</strong>
<a class=anchor href=#3-%e9%aa%8c%e8%af%81%e5%90%8c%e6%ad%a5%e6%98%af%e5%90%a6%e6%ad%a3%e5%b8%b8>#</a></h3><ol><li><p><strong>插入测试数据</strong>：在主服务器上插入数据，检查从服务器是否同步。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> your_table (column1, column2) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;value1&#39;</span>, <span style=color:#e6db74>&#39;value2&#39;</span>);
</span></span></code></pre></div></li><li><p><strong>在从服务器查询</strong>：在从服务器上检查该数据是否已同步。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> your_table;
</span></span></code></pre></div></li></ol><p>如果数据同步正常，那么配置成功。</p><hr><h3 id=实际工作中遇到的数据不一致问题><strong>实际工作中遇到的数据不一致问题</strong>
<a class=anchor href=#%e5%ae%9e%e9%99%85%e5%b7%a5%e4%bd%9c%e4%b8%ad%e9%81%87%e5%88%b0%e7%9a%84%e6%95%b0%e6%8d%ae%e4%b8%8d%e4%b8%80%e8%87%b4%e9%97%ae%e9%a2%98>#</a></h3><p>在实际工作中，主从同步通常能工作良好，但也可能会遇到以下常见的 <strong>数据不一致问题</strong>：</p><h4 id=1-延迟replication-lag>1. <strong>延迟（Replication Lag）</strong>
<a class=anchor href=#1-%e5%bb%b6%e8%bf%9freplication-lag>#</a></h4><ul><li><p><strong>问题</strong>：从服务器延迟同步主服务器上的数据，导致从服务器的数据滞后。</p></li><li><p>原因</p><p>：</p><ul><li>主服务器的写入频繁，二进制日志增长过快。</li><li>从服务器的性能较差，无法及时执行来自主服务器的更新。</li><li>网络延迟或主从服务器的硬件瓶颈。</li></ul></li><li><p>解决方案</p><p>：</p><ul><li>优化从服务器性能，增加硬件资源（CPU、内存、磁盘 IO）。</li><li>调整 MySQL 配置，增加 <code>slave_parallel_workers</code> 参数并启用并行复制（适用于 MySQL 5.7 及以上版本）。</li><li>使用 <code>pt-heartbeat</code> 等工具来监控延迟并优化。</li><li>监控复制延迟并根据需要进行警告。</li></ul></li></ul><h4 id=2-数据丢失data-loss>2. <strong>数据丢失（Data Loss）</strong>
<a class=anchor href=#2-%e6%95%b0%e6%8d%ae%e4%b8%a2%e5%a4%b1data-loss>#</a></h4><ul><li><p><strong>问题</strong>：主服务器发生故障，导致主服务器的数据丢失，但从服务器数据尚未同步。</p></li><li><p>原因</p><p>：</p><ul><li>主服务器停机或崩溃时，未及时备份或持久化数据。</li><li>从服务器的复制延迟过大，主服务器的数据还未同步到从服务器。</li></ul></li><li><p>解决方案</p><p>：</p><ul><li>启用 MySQL 的 <strong>GTID</strong>（全局事务标识符）或 <strong>binlog</strong>，以确保事务的完整性。</li><li>定期进行备份，确保有最新的数据库备份。</li><li>使用双主或多主复制架构来减少单点故障的风险。</li></ul></li></ul><h4 id=3-复制失败replication-errors>3. <strong>复制失败（Replication Errors）</strong>
<a class=anchor href=#3-%e5%a4%8d%e5%88%b6%e5%a4%b1%e8%b4%a5replication-errors>#</a></h4><ul><li><p><strong>问题</strong>：复制过程中出现错误，导致从服务器无法同步主服务器的数据。</p></li><li><p>原因</p><p>：</p><ul><li>主服务器上执行了从服务器无法理解或执行的 SQL 语句（例如，删除字段、数据类型变化）。</li><li>网络或连接问题导致复制中断。</li></ul></li><li><p>解决方案</p><p>：</p><ul><li>使用 <code>SHOW SLAVE STATUS</code> 查看错误信息，识别并解决复制失败的原因。</li><li>可以通过执行 <code>STOP SLAVE;</code>，然后使用 <code>START SLAVE UNTIL SQL_AFTER_GTIDS='gtid_set'</code> 指令来跳过错误的事务，确保复制继续。</li><li>使用 <code>pt-table-sync</code> 等工具进行数据对齐，确保主从数据一致。</li></ul></li></ul><h4 id=4-不一致的数据库结构schema-divergence>4. <strong>不一致的数据库结构（Schema Divergence）</strong>
<a class=anchor href=#4-%e4%b8%8d%e4%b8%80%e8%87%b4%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e7%bb%93%e6%9e%84schema-divergence>#</a></h4><ul><li><p><strong>问题</strong>：主从服务器的数据库结构（表结构、索引等）不一致，导致从服务器复制失败。</p></li><li><p>原因</p><p>：</p><ul><li>主服务器上的数据库结构发生了变化（例如添加了新表、修改了字段），但未同步到从服务器。</li></ul></li><li><p>解决方案</p><p>：</p><ul><li>确保主从数据库的结构一致，可以使用工具（如 <code>pt-table-checksum</code>）来校验主从数据库结构是否一致。</li><li>在执行结构变更时，确保主从服务器一起变更。</li></ul></li></ul><hr><h3 id=总结-20><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-20>#</a></h3><ul><li><strong>主从同步配置</strong>：配置主从同步需要在主服务器和从服务器上分别做配置，确保二进制日志启用并且设置复制用户。通过 <code>CHANGE MASTER TO</code> 和 <code>START SLAVE</code> 命令在从服务器配置主服务器的信息。</li><li><strong>数据不一致问题</strong>：常见问题包括复制延迟、数据丢失、复制失败和数据库结构不一致等。解决这些问题的办法包括优化硬件、调整配置、使用工具进行同步检查，并且确保主从数据库结构一致。</li><li><strong>解决方案</strong>：监控复制状态，定期备份，优化性能，使用并行复制和工具来确保主从同步的稳定性。</li></ul><p>通过正确配置和监控，能够保证 MySQL 主从同步的可靠性和高效性。</p><h2 id=5-mysql约束有哪些>5. mysql约束有哪些？
<a class=anchor href=#5-mysql%e7%ba%a6%e6%9d%9f%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h2><ul><li>非空约束</li><li>唯一约束</li><li>主键约束</li><li>外键约束</li></ul><p>MySQL 中的 <strong>约束（Constraints）</strong> 是用来确保数据库中的数据符合特定规则的机制。约束可以用于保证数据的完整性、准确性和一致性。MySQL 提供了以下几种常见的约束：</p><h3 id=1-主键约束primary-key><strong>1. 主键约束（PRIMARY KEY）</strong>
<a class=anchor href=#1-%e4%b8%bb%e9%94%ae%e7%ba%a6%e6%9d%9fprimary-key>#</a></h3><ul><li><p><strong>定义</strong>：主键约束用于唯一标识表中的每一行记录。一个表只能有一个主键。</p></li><li><p>特点</p><p>：</p><ul><li>主键列中的值必须是唯一的。</li><li>主键列不能包含 NULL 值。</li><li>MySQL 会自动为主键列创建索引。</li></ul></li></ul><h4 id=示例-4>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-4>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> users (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>, 
</span></span><span style=display:flex><span>  username VARCHAR(<span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=2-唯一约束unique><strong>2. 唯一约束（UNIQUE）</strong>
<a class=anchor href=#2-%e5%94%af%e4%b8%80%e7%ba%a6%e6%9d%9funique>#</a></h3><ul><li><p><strong>定义</strong>：唯一约束确保列中的所有值都是唯一的，但与主键不同，唯一约束允许有 NULL 值，且 NULL 值可以重复。</p></li><li><p>特点</p><p>：</p><ul><li>一列或多列组合起来定义唯一性。</li><li>允许多个 NULL 值。</li></ul></li></ul><h4 id=示例-5>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> users (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>, 
</span></span><span style=display:flex><span>  email VARCHAR(<span style=color:#ae81ff>100</span>) <span style=color:#66d9ef>UNIQUE</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=3-外键约束foreign-key><strong>3. 外键约束（FOREIGN KEY）</strong>
<a class=anchor href=#3-%e5%a4%96%e9%94%ae%e7%ba%a6%e6%9d%9fforeign-key>#</a></h3><ul><li><p><strong>定义</strong>：外键约束用于确保一个表中的列值必须存在于另一个表中的列中。外键约束用于实现表之间的关系（如一对多、多对多关系）。</p></li><li><p>特点</p><p>：</p><ul><li>外键列的值必须在参照表的主键或唯一键列中。</li><li>外键约束可以设置删除和更新时的操作（如 <code>CASCADE</code>、<code>SET NULL</code>、<code>NO ACTION</code> 等）。</li></ul></li></ul><h4 id=示例-6>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-6>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> orders (
</span></span><span style=display:flex><span>  order_id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  user_id INT,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (user_id) <span style=color:#66d9ef>REFERENCES</span> users(id)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=4-检查约束check><strong>4. 检查约束（CHECK）</strong>
<a class=anchor href=#4-%e6%a3%80%e6%9f%a5%e7%ba%a6%e6%9d%9fcheck>#</a></h3><ul><li><p><strong>定义</strong>：检查约束用于确保列中的数据满足特定的条件或规则。</p></li><li><p>特点</p><p>：</p><ul><li>在插入或更新数据时，MySQL 会检查是否满足 <code>CHECK</code> 条件。</li><li>该约束通常用于保证数据的合理性，如限制某个字段的取值范围。</li></ul></li></ul><h4 id=示例-7>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-7>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> products (
</span></span><span style=display:flex><span>  product_id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  price DECIMAL(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>CHECK</span> (price <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><blockquote><p><strong>注意</strong>：<code>CHECK</code> 约束从 MySQL 8.0.16 版本开始才被支持。在此之前，MySQL 并不强制执行 <code>CHECK</code> 约束。</p></blockquote><h3 id=5-非空约束not-null><strong>5. 非空约束（NOT NULL）</strong>
<a class=anchor href=#5-%e9%9d%9e%e7%a9%ba%e7%ba%a6%e6%9d%9fnot-null>#</a></h3><ul><li><p><strong>定义</strong>：非空约束用于确保列中的值不能为 NULL。对于需要保证某一列有数据的字段，通常会使用该约束。</p></li><li><p>特点</p><p>：</p><ul><li>在插入或更新数据时，列值不能为 NULL。</li></ul></li></ul><h4 id=示例-8>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-8>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> users (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>, 
</span></span><span style=display:flex><span>  username VARCHAR(<span style=color:#ae81ff>50</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=6-默认值约束default><strong>6. 默认值约束（DEFAULT）</strong>
<a class=anchor href=#6-%e9%bb%98%e8%ae%a4%e5%80%bc%e7%ba%a6%e6%9d%9fdefault>#</a></h3><ul><li><p><strong>定义</strong>：默认值约束用于在插入数据时，如果没有指定某个列的值，则该列会自动使用预设的默认值。</p></li><li><p>特点</p><p>：</p><ul><li>可以为列指定一个默认值。</li><li>如果插入数据时没有显式给某个列赋值，那么该列会使用默认值。</li></ul></li></ul><h4 id=示例-9>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-9>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> employees (
</span></span><span style=display:flex><span>  employee_id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>, 
</span></span><span style=display:flex><span>  hire_date DATE <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>CURRENT_DATE</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=7-自动递增约束auto_><strong>7. 自动递增约束（AUTO_INCREMENT）</strong>
<a class=anchor href=#7-%e8%87%aa%e5%8a%a8%e9%80%92%e5%a2%9e%e7%ba%a6%e6%9d%9fauto_>#</a></h3><ul><li><p><strong>定义</strong>：自动递增约束通常用于主键列，MySQL 会自动为每次插入的新记录生成一个唯一的数字值。</p></li><li><p>特点</p><p>：</p><ul><li>用于整型字段，MySQL 会自动为每次插入的记录生成一个唯一的增量值。</li><li>每次插入记录时，该字段的值会自动增加，无需手动赋值。</li></ul></li></ul><h4 id=示例-10>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-10>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> employees (
</span></span><span style=display:flex><span>  employee_id INT AUTO_INCREMENT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>, 
</span></span><span style=display:flex><span>  name VARCHAR(<span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=8-索引约束index><strong>8. 索引约束（INDEX）</strong>
<a class=anchor href=#8-%e7%b4%a2%e5%bc%95%e7%ba%a6%e6%9d%9findex>#</a></h3><ul><li><p><strong>定义</strong>：索引约束用于加速数据查询的速度。它通常用于表中经常查询的列上。</p></li><li><p>特点</p><p>：</p><ul><li>索引会提高数据检索速度，但会稍微降低插入和更新操作的性能。</li><li>你可以显式为某列创建索引，也可以在主键、唯一键等约束上自动创建索引。</li></ul></li></ul><h4 id=示例-11>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-11>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> users (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>, 
</span></span><span style=display:flex><span>  username VARCHAR(<span style=color:#ae81ff>50</span>), 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>INDEX</span> idx_username (username)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=9-联合唯一约束unique-constraint><strong>9. 联合唯一约束（UNIQUE CONSTRAINT）</strong>
<a class=anchor href=#9-%e8%81%94%e5%90%88%e5%94%af%e4%b8%80%e7%ba%a6%e6%9d%9funique-constraint>#</a></h3><ul><li><p><strong>定义</strong>：通过组合多列来创建唯一约束，以确保这些列的组合在表中是唯一的。</p></li><li><p>特点</p><p>：</p><ul><li>允许列中有 NULL 值，但 NULL 值也可以是唯一的（这取决于数据库引擎）。</li><li>可以确保某些列组合的唯一性。</li></ul></li></ul><h4 id=示例-12>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-12>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> employees (
</span></span><span style=display:flex><span>  first_name VARCHAR(<span style=color:#ae81ff>50</span>),
</span></span><span style=display:flex><span>  last_name VARCHAR(<span style=color:#ae81ff>50</span>),
</span></span><span style=display:flex><span>  email VARCHAR(<span style=color:#ae81ff>100</span>),
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>UNIQUE</span> (first_name, last_name)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><hr><h3 id=总结-21><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-21>#</a></h3><ul><li><strong>主键约束（PRIMARY KEY）</strong>：确保列的唯一性且不允许 NULL 值。</li><li><strong>唯一约束（UNIQUE）</strong>：确保列的唯一性，允许 NULL 值。</li><li><strong>外键约束（FOREIGN KEY）</strong>：确保数据表间的关系完整性，引用另一个表的主键。</li><li><strong>检查约束（CHECK）</strong>：限制列的值符合特定条件。</li><li><strong>非空约束（NOT NULL）</strong>：确保列的值不能为 NULL。</li><li><strong>默认值约束（DEFAULT）</strong>：为列提供默认值。</li><li><strong>自动递增约束（AUTO_INCREMENT）</strong>：为每条记录自动生成唯一的整数值。</li><li><strong>索引约束（INDEX）</strong>：加速查询操作，提高查询性能。</li><li><strong>联合唯一约束（UNIQUE CONSTRAINT）</strong>：确保多列的组合值唯一。</li></ul><p>这些约束确保了数据库中数据的完整性、准确性和一致性，帮助实现更高效、可维护的数据库管理。</p><h1 id=6-二进制日志binlog用途>6. 二进制日志（binlog）用途？
<a class=anchor href=#6-%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97binlog%e7%94%a8%e9%80%94>#</a></h1><p>BINLOG记录数据库的变更过程。例如创建数据库、建表、修改表等DDL操作、以及数据表的相关DML操作，这些操作会导致数据库产生变化，开启binlog以后导致数据库产生变化的操作会按照时间顺序以“事件”的形式记录到binlog二进制文件中</p><p><strong>二进制日志（binlog）</strong> 是 MySQL 中用于记录所有更改数据库状态的操作日志（包括数据表结构变化和数据修改操作）。它是 MySQL 数据库的核心日志之一，具有重要的用途。</p><h3 id=主要用途><strong>主要用途：</strong>
<a class=anchor href=#%e4%b8%bb%e8%a6%81%e7%94%a8%e9%80%94>#</a></h3><ol><li><strong>数据复制（Replication）</strong><ul><li><strong>主从复制</strong>：二进制日志是 MySQL 主从复制的基础。主服务器将所有更改数据的操作记录到 binlog 中，从服务器读取这些日志并执行相同的操作，保持与主服务器数据的一致性。</li><li>复制通常使用异步方式，binlog 记录了所有修改数据的操作，通过复制进程将这些操作传输到从服务器。</li></ul></li><li><strong>数据恢复（Point-in-time Recovery）</strong><ul><li><strong>时间点恢复</strong>：通过使用 binlog，您可以将数据库恢复到某个特定的时间点。例如，数据库在某个时刻被误操作，您可以利用 binlog 恢复到错误发生之前的状态。</li><li>备份时，通常先做全量备份，然后利用 binlog 来恢复自备份以来的所有变动数据。</li></ul></li><li><strong>审计与监控（Auditing and Monitoring）</strong><ul><li><strong>操作追踪</strong>：通过分析 binlog，可以追踪到数据库执行的所有写操作，如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等。它是进行审计的一个重要手段。</li><li>通过定期查看 binlog，您可以监控哪些操作被执行，哪些数据被修改。</li></ul></li><li><strong>数据库优化（Optimization）</strong><ul><li><strong>查询优化</strong>：有时候，分析 binlog 可以帮助数据库管理员识别数据库中可能存在的性能瓶颈，例如频繁的写操作或重复的事务。</li></ul></li></ol><h3 id=binlog-格式><strong>binlog 格式：</strong>
<a class=anchor href=#binlog-%e6%a0%bc%e5%bc%8f>#</a></h3><p>MySQL 提供了几种不同的 binlog 格式，分别是：</p><ol><li><strong>STATEMENT</strong>（语句模式）<ul><li>记录的是 SQL 语句本身，例如 <code>UPDATE table SET col = val</code>。</li><li>优点：占用空间小，因为只记录 SQL 语句。</li><li>缺点：某些操作可能无法完全复制，特别是涉及到非确定性函数的情况（如 <code>NOW()</code>、<code>RAND()</code> 等）。</li></ul></li><li><strong>ROW</strong>（行模式）<ul><li>记录的是每一行数据的变化。例如，更新某一行的数据时，会记录该行的旧值和新值。</li><li>优点：能够确保复制的准确性，尤其在有非确定性查询的情况下。</li><li>缺点：日志量较大，因为每个修改操作都需要记录每一行的变化。</li></ul></li><li><strong>MIXED</strong>（混合模式）<ul><li>结合了 STATEMENT 和 ROW 模式，MySQL 会自动选择适合的模式来记录操作。</li><li>优点：在保证准确性的同时，尽量减少日志的空间消耗。</li></ul></li></ol><h3 id=启用与配置-binlog><strong>启用与配置 binlog：</strong>
<a class=anchor href=#%e5%90%af%e7%94%a8%e4%b8%8e%e9%85%8d%e7%bd%ae-binlog>#</a></h3><p>为了使用 binlog，需要在 MySQL 配置文件（通常是 <code>my.cnf</code> 或 <code>my.ini</code>）中进行配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[mysqld]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>log-bin</span><span style=color:#f92672>=</span><span style=color:#e6db74>mysql-bin  # 启用 binlog</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>binlog-format</span><span style=color:#f92672>=</span><span style=color:#e6db74>ROW  # 设置 binlog 格式（可选）</span>
</span></span></code></pre></div><h3 id=总结-22><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-22>#</a></h3><ul><li><strong>数据复制</strong>：binlog 用于主从复制，确保主服务器和从服务器数据同步。</li><li><strong>数据恢复</strong>：提供基于时间点的恢复能力。</li><li><strong>审计与监控</strong>：帮助监控数据变更，进行操作审计。</li><li><strong>数据库优化</strong>：通过分析 binlog，发现潜在的性能瓶颈。</li></ul><p>通过合理利用 binlog，能够提高 MySQL 数据库的可靠性、可维护性以及性能优化。</p><h1 id=7-mysql数据引擎有哪些>7. mysql数据引擎有哪些？
<a class=anchor href=#7-mysql%e6%95%b0%e6%8d%ae%e5%bc%95%e6%93%8e%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>常用的 myisam、innodb</li><li>区别：</li></ul><p>InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM就不可以了；
MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用；
InnoDB 支持外键，MyISAM 不支持；
MyISAM 是默认引擎，InnoDB 需要指定；
InnoDB 不支持 FULLTEXT 类型的索引；
InnoDB 中不保存表的行数，如 select count(<em>) from table 时，InnoDB；需要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count(</em>)语句包含 where 条件时 MyISAM 也需要扫描整个表；
对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM表中可以和其他字段一起建立联合索引；
清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表；
InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’</p><p>MySQL 支持多种存储引擎（Storage Engines），每种存储引擎具有不同的特性，适用于不同的场景。以下是 MySQL 常见的存储引擎及其简要介绍：</p><h3 id=1-innodb><strong>1. InnoDB</strong>
<a class=anchor href=#1-innodb>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>事务支持</strong>：InnoDB 支持 ACID 事务，能够确保数据的原子性、一致性、隔离性和持久性。</li><li><strong>外键支持</strong>：InnoDB 支持外键约束，用于维护表与表之间的关系。</li><li><strong>行级锁</strong>：InnoDB 支持行级锁，以提高并发性能，适合高并发的读写操作。</li><li><strong>崩溃恢复</strong>：通过日志文件进行崩溃恢复，保证数据的一致性。</li><li><strong>自动增长主键</strong>：支持自动递增字段（如 <code>AUTO_INCREMENT</code>）。</li><li><strong>事务日志</strong>：提供事务日志来记录对数据的更改，可以用于恢复数据。</li></ul></li><li><p><strong>适用场景</strong>：适用于需要支持事务、外键以及高并发的应用场景，如金融、电商、CRM 等。</p></li></ul><h4 id=示例-13>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-13>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> users (
</span></span><span style=display:flex><span>  id INT AUTO_INCREMENT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name VARCHAR(<span style=color:#ae81ff>50</span>),
</span></span><span style=display:flex><span>  age INT
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB;
</span></span></code></pre></div><h3 id=2-myisam><strong>2. MyISAM</strong>
<a class=anchor href=#2-myisam>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>表级锁</strong>：MyISAM 采用表级锁，不支持行级锁，适合读操作较多的场景，但在高并发写入时性能较差。</li><li><strong>不支持事务</strong>：MyISAM 不支持事务管理，因此无法保证 ACID 特性。</li><li><strong>快速读操作</strong>：MyISAM 对于读密集型应用表现较好，特别是对于复杂查询的优化。</li><li><strong>存储方式</strong>：每个表由三个文件组成：数据文件、索引文件和表定义文件。</li></ul></li><li><p><strong>适用场景</strong>：适用于读操作频繁、对事务支持要求较低的场景，如日志记录、数据分析等。</p></li></ul><h4 id=示例-14>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-14>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> logs (
</span></span><span style=display:flex><span>  id INT AUTO_INCREMENT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  log_message TEXT
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>MyISAM;
</span></span></code></pre></div><h3 id=3-memoryheap><strong>3. MEMORY（HEAP）</strong>
<a class=anchor href=#3-memoryheap>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>内存存储</strong>：所有数据都存储在内存中，速度非常快，适用于需要快速读写的场景。</li><li><strong>表级锁</strong>：支持表级锁。</li><li><strong>不支持事务和外键</strong>：不支持事务和外键约束。</li><li><strong>数据丢失</strong>：由于数据存储在内存中，服务器重启时数据会丢失。</li></ul></li><li><p><strong>适用场景</strong>：适用于需要快速访问且对持久化要求不高的临时表、缓存等场景。</p></li></ul><h4 id=示例-15>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-15>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> temp_table (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name VARCHAR(<span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>MEMORY;
</span></span></code></pre></div><h3 id=4-csv><strong>4. CSV</strong>
<a class=anchor href=#4-csv>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>文本格式存储</strong>：数据以 CSV（逗号分隔值）格式存储为文件。</li><li><strong>不支持索引</strong>：CSV 引擎不支持索引，查询性能较差。</li><li><strong>易于导入导出</strong>：数据以文本格式存储，适合用于与其他系统的导入导出。</li></ul></li><li><p><strong>适用场景</strong>：适用于需要将数据导出为 CSV 格式的场景，如数据交换、备份等。</p></li></ul><h4 id=示例-16>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-16>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> csv_table (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name VARCHAR(<span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>CSV;
</span></span></code></pre></div><h3 id=5-archive><strong>5. ARCHIVE</strong>
<a class=anchor href=#5-archive>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>适合归档数据</strong>：ARCHIVE 引擎专为存储归档数据设计，适合需要存储大量历史数据的场景。</li><li><strong>只支持 INSERT 和 SELECT</strong>：仅支持插入和查询操作，不支持更新、删除操作。</li><li><strong>压缩存储</strong>：自动压缩数据以节省存储空间。</li><li><strong>不支持索引</strong>：ARCHIVE 表没有索引，查询性能较差。</li></ul></li><li><p><strong>适用场景</strong>：适用于存储长期归档数据，且该数据大多不需要更新的场景。</p></li></ul><h4 id=示例-17>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-17>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> archive_table (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>data</span> TEXT
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>ARCHIVE;
</span></span></code></pre></div><h3 id=6-ndb-cluster><strong>6. NDB (Cluster)</strong>
<a class=anchor href=#6-ndb-cluster>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>分布式存储</strong>：NDB 存储引擎用于 MySQL Cluster，提供分布式数据库解决方案，能够支持高可用和高并发。</li><li><strong>数据分片</strong>：数据可以在多台服务器上分布存储，提供水平扩展能力。</li><li><strong>支持事务</strong>：NDB 支持事务，但性能开销较大。</li><li><strong>高可用性</strong>：NDB 引擎的数据库集群通常是高可用的，能够容忍节点故障。</li></ul></li><li><p><strong>适用场景</strong>：适用于需要高可用、分布式存储、高并发访问的场景，如大规模在线应用、金融等。</p></li></ul><h4 id=示例-18>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-18>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> ndb_table (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name VARCHAR(<span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>NDB;
</span></span></code></pre></div><h3 id=7-blackhole><strong>7. BLACKHOLE</strong>
<a class=anchor href=#7-blackhole>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>数据“黑洞”</strong>：数据写入后直接丢弃，不存储任何数据，适用于特定的复制场景。</li><li><strong>不存储数据</strong>：所有插入操作都会被丢弃，但操作日志会被记录。</li></ul></li><li><p><strong>适用场景</strong>：用于主从复制中，作为从服务器接收主服务器数据，但不需要存储数据的场景。</p></li></ul><h4 id=示例-19>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-19>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> blackhole_table (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name VARCHAR(<span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>BLACKHOLE;
</span></span></code></pre></div><h3 id=8-tokudb><strong>8. TokuDB</strong>
<a class=anchor href=#8-tokudb>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li><strong>面向大数据存储</strong>：TokuDB 是一个高效的存储引擎，适用于需要处理大规模数据的场景。</li><li><strong>支持压缩和索引</strong>：TokuDB 提供高效的数据压缩，并支持高效的索引机制。</li><li><strong>ACID 支持</strong>：支持事务，并具备较好的事务性能。</li></ul></li><li><p><strong>适用场景</strong>：适用于大数据量的存储和复杂查询的场景，如大规模分析和数据仓库。</p></li></ul><h4 id=示例-20>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-20>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> toku_table (
</span></span><span style=display:flex><span>  id INT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name VARCHAR(<span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>TokuDB;
</span></span></code></pre></div><hr><h3 id=总结-23><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-23>#</a></h3><p>MySQL 提供了多种存储引擎，每种引擎在性能、支持的功能和适用场景上有所不同。常用的存储引擎包括：</p><ul><li><strong>InnoDB</strong>：支持事务、外键、行级锁，适合高并发、高一致性的应用。</li><li><strong>MyISAM</strong>：无事务支持，适合读密集型应用。</li><li><strong>MEMORY</strong>：数据存储在内存中，适合临时表和快速存取。</li><li><strong>ARCHIVE</strong>：适用于归档数据，数据压缩存储。</li><li><strong>NDB</strong>：用于 MySQL Cluster，适合分布式、高可用场景。</li><li><strong>BLACKHOLE</strong>：数据写入黑洞，通常用于复制。</li><li><strong>TokuDB</strong>：适合大数据量存储，提供高效的压缩和索引。</li></ul><p>选择合适的存储引擎要根据具体的业务需求、性能要求以及数据的特性来决定。</p><h1 id=8-如何查询mysql数据库存放路径>8. 如何查询mysql数据库存放路径？
<a class=anchor href=#8-%e5%a6%82%e4%bd%95%e6%9f%a5%e8%af%a2mysql%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ad%98%e6%94%be%e8%b7%af%e5%be%84>#</a></h1><pre tabindex=0><code>mysql&gt; show variables like &#39;datadir%&#39;;
+---------------+------------------------+
| Variable_name | Value                  |
+---------------+------------------------+
| datadir       | /usr/local/mysql/data/ |
+---------------+------------------------+
1 row in set (0.00 sec)
</code></pre><p>要查询 MySQL 数据库的存放路径，可以通过以下几种方式：</p><h3 id=1-查询-mysql-数据目录配置>1. <strong>查询 MySQL 数据目录配置</strong>
<a class=anchor href=#1-%e6%9f%a5%e8%af%a2-mysql-%e6%95%b0%e6%8d%ae%e7%9b%ae%e5%bd%95%e9%85%8d%e7%bd%ae>#</a></h3><p>MySQL 的数据文件存储路径可以通过查询 MySQL 的 <code>datadir</code> 配置项来获取。你可以使用以下 SQL 语句来查询：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SHOW</span> VARIABLES <span style=color:#66d9ef>LIKE</span> <span style=color:#e6db74>&#39;datadir&#39;</span>;
</span></span></code></pre></div><p>这个命令会返回 <code>datadir</code> 配置项的值，表示 MySQL 数据库的存储目录路径。</p><h4 id=示例-21>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-21>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SHOW</span> VARIABLES <span style=color:#66d9ef>LIKE</span> <span style=color:#e6db74>&#39;datadir&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> Variable_name <span style=color:#f92672>|</span> Value                             <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> datadir       <span style=color:#f92672>|</span> <span style=color:#f92672>/</span>var<span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>mysql<span style=color:#f92672>/</span>                   <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>在这个例子中，MySQL 数据库的存储路径是 <code>/var/lib/mysql/</code>。</p><h3 id=2-检查-mysql-配置文件>2. <strong>检查 MySQL 配置文件</strong>
<a class=anchor href=#2-%e6%a3%80%e6%9f%a5-mysql-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h3><p>你还可以通过查看 MySQL 配置文件来查找数据库存储路径。MySQL 配置文件通常位于 <code>/etc/my.cnf</code> 或 <code>/etc/mysql/my.cnf</code>，具体路径取决于你的操作系统和安装方式。</p><p>打开配置文件并查找 <code>datadir</code> 配置项，类似这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[mysqld]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>datadir</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>/var/lib/mysql</span>
</span></span></code></pre></div><h3 id=3-查看操作系统文件系统>3. <strong>查看操作系统文件系统</strong>
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h3><p>如果你不确定 MySQL 配置文件的位置，也可以检查操作系统中 MySQL 数据目录的位置，尤其是通过文件系统的查找：</p><p>在 Linux 系统中，可以通过查找 <code>mysql</code> 进程的工作目录来找到数据存储路径：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps aux | grep mysql
</span></span></code></pre></div><p>这条命令会显示 MySQL 服务的进程信息，在信息中可能会包含数据目录的路径。</p><h3 id=4-通过-mysql-启动命令检查>4. <strong>通过 MySQL 启动命令检查</strong>
<a class=anchor href=#4-%e9%80%9a%e8%bf%87-mysql-%e5%90%af%e5%8a%a8%e5%91%bd%e4%bb%a4%e6%a3%80%e6%9f%a5>#</a></h3><p>如果你知道 MySQL 是如何启动的，也可以通过启动命令查看 MySQL 的数据目录。MySQL 启动时会使用 <code>--datadir</code> 参数指定数据目录。</p><p>例如，可以使用 <code>ps</code> 命令查找 MySQL 进程，并检查是否有 <code>--datadir</code> 参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps aux | grep mysqld
</span></span></code></pre></div><p>如果 MySQL 启动时指定了 <code>--datadir</code>，它会显示数据目录的路径。</p><h3 id=总结-24><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-24>#</a></h3><ul><li><strong>通过 SQL 查询</strong>：使用 <code>SHOW VARIABLES LIKE 'datadir';</code> 获取 MySQL 数据目录。</li><li><strong>查看 MySQL 配置文件</strong>：检查 <code>/etc/my.cnf</code> 或 <code>/etc/mysql/my.cnf</code> 中的 <code>datadir</code> 配置项。</li><li><strong>操作系统级别查找</strong>：通过 <code>ps</code> 或其他系统命令查找 MySQL 进程的启动信息。</li></ul><p>通常，<code>datadir</code> 默认是 <code>/var/lib/mysql</code>，但如果在安装时做了修改，数据目录路径也可能会有所不同。</p><h1 id=9-mysql数据库文件后缀名有哪些用途什么>9. mysql数据库文件后缀名有哪些？用途什么？
<a class=anchor href=#9-mysql%e6%95%b0%e6%8d%ae%e5%ba%93%e6%96%87%e4%bb%b6%e5%90%8e%e7%bc%80%e5%90%8d%e6%9c%89%e5%93%aa%e4%ba%9b%e7%94%a8%e9%80%94%e4%bb%80%e4%b9%88>#</a></h1><ul><li>myisam</li></ul><p>.frm文件：保护表的定义
.myd：保存表的数据
.myi：表的索引文件</p><ul><li>innodb</li></ul><p>.frm：保存表的定义
.ibd：表空间</p><p>MySQL 数据库文件的后缀名通常与存储引擎相关，具体来说，不同的存储引擎会使用不同的文件格式来存储数据。下面是常见的 MySQL 数据库文件后缀名及其用途：</p><h3 id=1-frm>1. <strong>.frm</strong>
<a class=anchor href=#1-frm>#</a></h3><ul><li><strong>用途</strong>：<code>frm</code> 文件用于存储表的定义（即表的结构）。每个表都有一个对应的 <code>.frm</code> 文件，记录了表的列、索引、数据类型等元数据。</li><li><strong>存储引擎</strong>：不论是 <code>InnoDB</code> 还是 <code>MyISAM</code> 存储引擎，都会为每个表创建一个 <code>.frm</code> 文件。</li></ul><h4 id=示例-22>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-22>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/lib/mysql/database_name/my_table.frm
</span></span></code></pre></div><h3 id=2-ibd>2. <strong>.ibd</strong>
<a class=anchor href=#2-ibd>#</a></h3><ul><li><strong>用途</strong>：<code>ibd</code> 文件是 <strong>InnoDB</strong> 存储引擎使用的表空间文件，专门用来存储表的数据和索引。每个使用 InnoDB 存储引擎的表（如果启用了独立表空间模式）都会有一个 <code>.ibd</code> 文件，存储实际的数据和索引。</li><li><strong>存储引擎</strong>：仅 <strong>InnoDB</strong> 存储引擎使用。</li><li><strong>位置</strong>：在启用了独立表空间（<code>innodb_file_per_table=1</code>）的情况下，每个表会有一个独立的 <code>.ibd</code> 文件。</li></ul><h4 id=示例-23>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-23>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/lib/mysql/database_name/my_table.ibd
</span></span></code></pre></div><h3 id=3-myd>3. <strong>.myd</strong>
<a class=anchor href=#3-myd>#</a></h3><ul><li><strong>用途</strong>：<code>myd</code> 文件是 <strong>MyISAM</strong> 存储引擎的数据文件，用来存储表中的数据。</li><li><strong>存储引擎</strong>：仅 <strong>MyISAM</strong> 存储引擎使用。</li><li><strong>位置</strong>：每个 MyISAM 表都会有一个 <code>.myd</code> 文件，用来存储实际的行数据。</li></ul><h4 id=示例-24>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-24>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/lib/mysql/database_name/my_table.myd
</span></span></code></pre></div><h3 id=4-myi>4. <strong>.myi</strong>
<a class=anchor href=#4-myi>#</a></h3><ul><li><strong>用途</strong>：<code>myi</code> 文件是 <strong>MyISAM</strong> 存储引擎的索引文件，用来存储表的索引数据。</li><li><strong>存储引擎</strong>：仅 <strong>MyISAM</strong> 存储引擎使用。</li><li><strong>位置</strong>：每个 MyISAM 表都有一个 <code>.myi</code> 文件，用来存储该表的索引。</li></ul><h4 id=示例-25>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-25>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/lib/mysql/database_name/my_table.myi
</span></span></code></pre></div><h3 id=5-log日志文件>5. <strong>.log</strong>（日志文件）
<a class=anchor href=#5-log%e6%97%a5%e5%bf%97%e6%96%87%e4%bb%b6>#</a></h3><ul><li><p>用途</p><p>：</p><pre tabindex=0><code>log
</code></pre><p>文件通常是 MySQL 的日志文件，主要用于记录数据库的操作过程（如查询、事务等）。</p><ul><li><strong>错误日志（<code>error.log</code>）</strong>：记录启动、运行和关闭时的错误信息。</li><li><strong>查询日志（<code>query.log</code>）</strong>：记录所有 SQL 查询（如果启用）。</li><li><strong>慢查询日志（<code>slow_query.log</code>）</strong>：记录执行时间较长的查询。</li><li><strong>二进制日志（<code>binlog</code>）</strong>：记录数据库的更改操作，用于数据复制和数据恢复。</li></ul></li><li><p><strong>存储引擎</strong>：日志文件与存储引擎无关，而是 MySQL 的全局配置项。</p></li></ul><h4 id=示例-26>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-26>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/log/mysql/mysql-bin.000001  <span style=color:#75715e># 二进制日志</span>
</span></span><span style=display:flex><span>/var/log/mysql/error.log        <span style=color:#75715e># 错误日志</span>
</span></span></code></pre></div><h3 id=6-ib_>6. <strong>.ib_logfile</strong>
<a class=anchor href=#6-ib_>#</a></h3><ul><li><p>用途</p><p>：</p><pre tabindex=0><code>ib_logfile
</code></pre><p>文件是</p><p>InnoDB</p><p>存储引擎的重做日志文件，用于事务日志的存储。InnoDB 采用两种日志：重做日志和撤销日志，这些日志文件用于崩溃恢复。</p><ul><li><strong><code>ib_logfile0</code></strong> 和 <strong><code>ib_logfile1</code></strong>：是 InnoDB 存储引擎的日志文件，记录事务的重做操作（Redo log）。</li></ul></li><li><p><strong>存储引擎</strong>：仅 <strong>InnoDB</strong> 存储引擎使用。</p></li></ul><h4 id=示例-27>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-27>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/lib/mysql/ib_logfile0
</span></span><span style=display:flex><span>/var/lib/mysql/ib_logfile1
</span></span></code></pre></div><h3 id=7-cnd>7. <strong>.cnd</strong>
<a class=anchor href=#7-cnd>#</a></h3><ul><li><strong>用途</strong>：<code>cnd</code> 文件是 <strong>InnoDB</strong> 存储引擎的表空间的变化日志文件，记录数据库表空间的增删改操作。</li><li><strong>存储引擎</strong>：仅 <strong>InnoDB</strong> 存储引擎使用。</li></ul><h4 id=示例-28>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-28>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/lib/mysql/database_name/your_table.cnd
</span></span></code></pre></div><h3 id=8-tmp>8. <strong>.tmp</strong>
<a class=anchor href=#8-tmp>#</a></h3><ul><li><strong>用途</strong>：<code>tmp</code> 文件用于存储临时数据。在 MySQL 执行查询时，如果需要临时存储数据（例如在复杂的查询中使用临时表），MySQL 会使用 <code>.tmp</code> 文件。</li><li><strong>存储引擎</strong>：与存储引擎无关，MySQL 在执行查询时可能会使用临时文件来存储中间数据。</li></ul><h4 id=示例-29>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-29>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/tmp/mysql_temp_file.tmp
</span></span></code></pre></div><h3 id=9-ibdata>9. <strong>.ibdata</strong>
<a class=anchor href=#9-ibdata>#</a></h3><ul><li><strong>用途</strong>：<code>ibdata</code> 文件是 <strong>InnoDB</strong> 存储引擎的系统表空间文件，用于存储所有的表数据、索引和元数据（例如表的结构信息），如果没有启用独立表空间模式（<code>innodb_file_per_table=0</code>），则所有 InnoDB 表的数据都存储在这个文件中。</li><li><strong>存储引擎</strong>：仅 <strong>InnoDB</strong> 存储引擎使用。</li></ul><h4 id=示例-30>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-30>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/var/lib/mysql/ibdata1
</span></span></code></pre></div><hr><h3 id=总结-25><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-25>#</a></h3><p>MySQL 中常见的数据库文件后缀名和用途如下：</p><ul><li><strong>.frm</strong>：存储表的结构信息，适用于所有存储引擎。</li><li><strong>.ibd</strong>：用于 InnoDB 存储引擎的表数据和索引文件。</li><li><strong>.myd</strong>：用于 MyISAM 存储引擎的表数据文件。</li><li><strong>.myi</strong>：用于 MyISAM 存储引擎的表索引文件。</li><li><strong>.log</strong>：日志文件，如错误日志、查询日志、二进制日志等。</li><li><strong>.ib_logfile</strong>：InnoDB 的重做日志文件。</li><li><strong>.cnd</strong>：InnoDB 的表空间变化日志文件。</li><li><strong>.tmp</strong>：用于临时存储的数据文件。</li><li><strong>.ibdata</strong>：InnoDB 的系统表空间文件。</li></ul><p>这些文件在 MySQL 中具有不同的作用，帮助管理和存储数据库的结构、数据、索引以及日志信息。</p><h2 id=10-如何修改数据库用户的密码>10. 如何修改数据库用户的密码？
<a class=anchor href=#10-%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae%e5%ba%93%e7%94%a8%e6%88%b7%e7%9a%84%e5%af%86%e7%a0%81>#</a></h2><ul><li>mysql8之前</li></ul><pre tabindex=0><code>set password for 用户名@localhost = password(&#39;新密码&#39;); 
mysqladmin -u用户名 -p旧密码 password 新密码  
update user set password=password(&#39;123&#39;) where user=&#39;root&#39; and host=&#39;localhost&#39;;
</code></pre><ul><li>mysql8之后</li></ul><pre tabindex=0><code># mysql8初始对密码要求高，简单的字符串不让改。先改成:MyNewPass@123;
alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;MyNewPass@123&#39;;
# 降低密码难度
set global validate_password.policy=0;
set global validate_password.length=4;
# 修改成简易密码
alter user &#39;root&#39;@&#39;localhost&#39;IDENTIFIED BY &#39;1111&#39;;
</code></pre><p>在 MySQL 中修改数据库用户的密码，可以通过以下几种方式：</p><h3 id=1-使用>1. <strong>使用 <code>ALTER USER</code> 语句（推荐）</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8>#</a></h3><p>在 MySQL 5.7.6 及以上版本中，可以使用 <code>ALTER USER</code> 语句来修改用户密码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span> IDENTIFIED <span style=color:#66d9ef>BY</span> <span style=color:#e6db74>&#39;new_password&#39;</span>;
</span></span></code></pre></div><ul><li><code>'username'</code> 是数据库用户名。</li><li><code>'host'</code> 是该用户的主机名（一般是 <code>%</code>，表示任何主机，或者 <code>localhost</code>，表示本机）。</li><li><code>'new_password'</code> 是新的密码。</li></ul><h4 id=示例-31>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-31>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span> IDENTIFIED <span style=color:#66d9ef>BY</span> <span style=color:#e6db74>&#39;newpassword123&#39;</span>;
</span></span></code></pre></div><h3 id=2-使用>2. <strong>使用 <code>SET PASSWORD</code> 语句</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8>#</a></h3><p>对于 MySQL 5.7.5 及以下版本，或者如果 <code>ALTER USER</code> 不可用时，可以使用 <code>SET PASSWORD</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> PASSWORD <span style=color:#66d9ef>FOR</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span> <span style=color:#f92672>=</span> PASSWORD(<span style=color:#e6db74>&#39;new_password&#39;</span>);
</span></span></code></pre></div><h4 id=示例-32>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-32>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> PASSWORD <span style=color:#66d9ef>FOR</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span> <span style=color:#f92672>=</span> PASSWORD(<span style=color:#e6db74>&#39;newpassword123&#39;</span>);
</span></span></code></pre></div><h3 id=3-使用>3. <strong>使用 <code>UPDATE</code> 语句修改 <code>mysql.user</code> 表</strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8>#</a></h3><p>在一些特殊情况下（例如：忘记了管理员密码），也可以直接通过更新 <code>mysql.user</code> 表来修改密码。不过这种方法在高版本 MySQL 中较少使用，推荐使用上面的方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> mysql.<span style=color:#66d9ef>user</span> <span style=color:#66d9ef>SET</span> authentication_string <span style=color:#f92672>=</span> PASSWORD(<span style=color:#e6db74>&#39;new_password&#39;</span>) <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>User</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;username&#39;</span> <span style=color:#66d9ef>AND</span> <span style=color:#66d9ef>Host</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;host&#39;</span>;
</span></span><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div><ul><li><code>authentication_string</code> 字段保存密码（旧版本是 <code>password</code> 字段）。</li><li><code>FLUSH PRIVILEGES</code> 用于刷新权限，使改动生效。</li></ul><h4 id=示例-33>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-33>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> mysql.<span style=color:#66d9ef>user</span> <span style=color:#66d9ef>SET</span> authentication_string <span style=color:#f92672>=</span> PASSWORD(<span style=color:#e6db74>&#39;newpassword123&#39;</span>) <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>User</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;myuser&#39;</span> <span style=color:#66d9ef>AND</span> <span style=color:#66d9ef>Host</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div><h3 id=4-重置>4. <strong>重置 <code>root</code> 密码</strong>
<a class=anchor href=#4-%e9%87%8d%e7%bd%ae>#</a></h3><p>如果需要重置 <code>root</code> 密码（例如忘记了密码），可以进入 MySQL 的安全模式进行修改：</p><ol><li><p>停止 MySQL 服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl stop mysql
</span></span></code></pre></div></li><li><p>启动 MySQL 无密码模式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo mysqld_safe --skip-grant-tables &amp;
</span></span></code></pre></div></li><li><p>进入 MySQL：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql -u root
</span></span></code></pre></div></li><li><p>修改密码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> mysql.<span style=color:#66d9ef>user</span> <span style=color:#66d9ef>SET</span> authentication_string <span style=color:#f92672>=</span> PASSWORD(<span style=color:#e6db74>&#39;newpassword123&#39;</span>) <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>User</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;root&#39;</span>;
</span></span><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div></li><li><p>退出 MySQL 并重启 MySQL 服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl restart mysql
</span></span></code></pre></div></li></ol><h3 id=总结-26>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-26>#</a></h3><ul><li>推荐使用 <code>ALTER USER</code> 来修改密码。</li><li><code>SET PASSWORD</code> 适用于较旧的版本。</li><li>在特殊情况下，可以直接修改 <code>mysql.user</code> 表并执行 <code>FLUSH PRIVILEGES</code>。</li></ul><p>使用这些方法后，用户的密码就会被成功修改。</p><p>在 MySQL 8.0 中，修改数据库用户密码的方法与 MySQL 5.7 版本有所不同，主要是通过 <code>ALTER USER</code> 语句来实现。下面是针对 MySQL 8.0 的几种常用修改密码的方式：</p><h3 id=1-使用-1>1. <strong>使用 <code>ALTER USER</code> 语句（推荐）</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-1>#</a></h3><p>MySQL 8.0 版本推荐使用 <code>ALTER USER</code> 语句来修改用户的密码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span> IDENTIFIED <span style=color:#66d9ef>BY</span> <span style=color:#e6db74>&#39;new_password&#39;</span>;
</span></span></code></pre></div><ul><li><code>'username'</code> 是要修改密码的用户名。</li><li><code>'host'</code> 是用户的主机（如 <code>%</code> 或 <code>localhost</code>）。</li><li><code>'new_password'</code> 是新的密码。</li></ul><h4 id=示例-34>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-34>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span> IDENTIFIED <span style=color:#66d9ef>BY</span> <span style=color:#e6db74>&#39;newpassword123&#39;</span>;
</span></span></code></pre></div><h3 id=2-使用-1>2. <strong>使用 <code>SET PASSWORD</code> 语句</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-1>#</a></h3><p>在 MySQL 8.0 中，虽然 <code>ALTER USER</code> 是推荐方法，但 <code>SET PASSWORD</code> 仍然有效，可以通过该方法修改密码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> PASSWORD <span style=color:#66d9ef>FOR</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;new_password&#39;</span>;
</span></span></code></pre></div><h4 id=示例-35>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-35>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> PASSWORD <span style=color:#66d9ef>FOR</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;newpassword123&#39;</span>;
</span></span></code></pre></div><h3 id=3-直接修改>3. <strong>直接修改 <code>mysql.user</code> 表（不推荐）</strong>
<a class=anchor href=#3-%e7%9b%b4%e6%8e%a5%e4%bf%ae%e6%94%b9>#</a></h3><p>虽然可以直接更新 <code>mysql.user</code> 表来修改密码，但这种做法在 MySQL 8.0 中并不推荐，因为它可能导致安全问题，且需要手动刷新权限。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> mysql.<span style=color:#66d9ef>user</span> <span style=color:#66d9ef>SET</span> authentication_string <span style=color:#f92672>=</span> PASSWORD(<span style=color:#e6db74>&#39;new_password&#39;</span>) <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>User</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;username&#39;</span> <span style=color:#66d9ef>AND</span> <span style=color:#66d9ef>Host</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;host&#39;</span>;
</span></span><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div><ul><li><code>authentication_string</code> 存储的是用户的加密密码。</li></ul><h4 id=示例-36>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-36>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> mysql.<span style=color:#66d9ef>user</span> <span style=color:#66d9ef>SET</span> authentication_string <span style=color:#f92672>=</span> PASSWORD(<span style=color:#e6db74>&#39;newpassword123&#39;</span>) <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>User</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;myuser&#39;</span> <span style=color:#66d9ef>AND</span> <span style=color:#66d9ef>Host</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div><h3 id=4-重置-1>4. <strong>重置 <code>root</code> 密码（如果忘记密码）</strong>
<a class=anchor href=#4-%e9%87%8d%e7%bd%ae-1>#</a></h3><p>如果忘记了 <code>root</code> 密码，可以通过以下步骤重置密码：</p><ol><li><p><strong>停止 MySQL 服务</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl stop mysql
</span></span></code></pre></div></li><li><p><strong>启动 MySQL 安全模式（跳过授权表）</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo mysqld_safe --skip-grant-tables &amp;
</span></span></code></pre></div></li><li><p><strong>进入 MySQL 命令行</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql -u root
</span></span></code></pre></div></li><li><p><strong>修改 <code>root</code> 密码</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;root&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span> IDENTIFIED <span style=color:#66d9ef>BY</span> <span style=color:#e6db74>&#39;newpassword123&#39;</span>;
</span></span><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div></li><li><p><strong>退出 MySQL 并重启 MySQL 服务</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl restart mysql
</span></span></code></pre></div></li></ol><h3 id=5-查看密码加密方式>5. <strong>查看密码加密方式</strong>
<a class=anchor href=#5-%e6%9f%a5%e7%9c%8b%e5%af%86%e7%a0%81%e5%8a%a0%e5%af%86%e6%96%b9%e5%bc%8f>#</a></h3><p>在 MySQL 8.0 中，密码加密方式有所变化。如果你需要查看当前用户的加密方式，可以执行以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>user</span>, <span style=color:#66d9ef>host</span>, authentication_string <span style=color:#66d9ef>FROM</span> mysql.<span style=color:#66d9ef>user</span> <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>user</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;username&#39;</span>;
</span></span></code></pre></div><h3 id=总结-27>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-27>#</a></h3><ul><li><strong>推荐方法</strong>：使用 <code>ALTER USER</code> 语句修改用户密码。</li><li><strong>次推荐方法</strong>：使用 <code>SET PASSWORD</code> 来修改密码。</li><li><strong>不推荐的做法</strong>：直接修改 <code>mysql.user</code> 表。</li><li>如果忘记 <code>root</code> 密码，可以通过跳过授权表的方式重置密码。</li></ul><p>MySQL 8.0 加强了对安全性的保护，推荐使用 <code>ALTER USER</code> 和 <code>SET PASSWORD</code> 来修改密码。</p><h2 id=11-如何修改用户权限如何查看>11. 如何修改用户权限？如何查看？
<a class=anchor href=#11-%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b>#</a></h2><ul><li>授权：</li></ul><pre tabindex=0><code>grant all on *.* to user@&#39;%&#39; identified by &#39;passwd&#39;
</code></pre><ul><li>查看权限</li></ul><pre tabindex=0><code>show grants for user@&#39;%&#39;;
</code></pre><p>在 MySQL 中，修改用户权限和查看用户权限是常见的操作。这里提供如何修改和查看权限的详细步骤。</p><h3 id=1-查看用户权限>1. <strong>查看用户权限</strong>
<a class=anchor href=#1-%e6%9f%a5%e7%9c%8b%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90>#</a></h3><p>要查看 MySQL 中某个用户的权限，可以使用以下查询：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SHOW</span> GRANTS <span style=color:#66d9ef>FOR</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span>;
</span></span></code></pre></div><ul><li><code>'username'</code> 是用户名。</li><li><code>'host'</code> 是用户连接数据库的主机（通常是 <code>localhost</code> 或 <code>%</code>，表示任意主机）。</li></ul><h4 id=示例-37>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-37>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SHOW</span> GRANTS <span style=color:#66d9ef>FOR</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span></code></pre></div><p>这条命令会返回该用户在 MySQL 中的所有授权信息，输出类似如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>GRANT</span> <span style=color:#66d9ef>USAGE</span> <span style=color:#66d9ef>ON</span> <span style=color:#f92672>*</span>.<span style=color:#f92672>*</span> <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>GRANT</span> <span style=color:#66d9ef>SELECT</span>, <span style=color:#66d9ef>INSERT</span>, <span style=color:#66d9ef>UPDATE</span>, <span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>ON</span> <span style=color:#f92672>`</span>mydb<span style=color:#f92672>`</span>.<span style=color:#f92672>*</span> <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>
</span></span></code></pre></div><h3 id=2-修改用户权限>2. <strong>修改用户权限</strong>
<a class=anchor href=#2-%e4%bf%ae%e6%94%b9%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90>#</a></h3><p>修改用户权限的操作一般通过 <code>GRANT</code> 或 <code>REVOKE</code> 命令来实现。</p><h4 id=1-授予权限>(1) <strong>授予权限</strong>
<a class=anchor href=#1-%e6%8e%88%e4%ba%88%e6%9d%83%e9%99%90>#</a></h4><p>通过 <code>GRANT</code> 语句，可以授予用户权限。常见的权限有 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>，以及数据库级、表级、列级权限等。</p><p>语法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>GRANT</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>privileges</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>ON</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>database</span><span style=color:#f92672>&gt;</span>.<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>table</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span>;
</span></span></code></pre></div><ul><li><code>&lt;privileges></code> 是要授予的权限，如 <code>SELECT</code>、<code>INSERT</code> 等，多个权限用逗号分隔，或使用 <code>ALL PRIVILEGES</code> 授予所有权限。</li><li><code>&lt;database></code> 是要授予权限的数据库，<code>*</code> 表示所有数据库。</li><li><code>&lt;table></code> 是要授予权限的表，<code>*</code> 表示所有表。</li><li><code>'username'</code> 是要授予权限的用户。</li><li><code>'host'</code> 是用户可以连接的主机，<code>%</code> 表示任意主机。</li></ul><h4 id=示例-1授予-myuser-用户对-mydb-数据库的-select-和-insert-权限>示例 1：授予 <code>myuser</code> 用户对 <code>mydb</code> 数据库的 <code>SELECT</code> 和 <code>INSERT</code> 权限
<a class=anchor href=#%e7%a4%ba%e4%be%8b-1%e6%8e%88%e4%ba%88-myuser-%e7%94%a8%e6%88%b7%e5%af%b9-mydb-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84-select-%e5%92%8c-insert-%e6%9d%83%e9%99%90>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>GRANT</span> <span style=color:#66d9ef>SELECT</span>, <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>ON</span> mydb.<span style=color:#f92672>*</span> <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span></code></pre></div><h4 id=示例-2授予-myuser-用户对所有数据库的所有权限>示例 2：授予 <code>myuser</code> 用户对所有数据库的所有权限
<a class=anchor href=#%e7%a4%ba%e4%be%8b-2%e6%8e%88%e4%ba%88-myuser-%e7%94%a8%e6%88%b7%e5%af%b9%e6%89%80%e6%9c%89%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e6%89%80%e6%9c%89%e6%9d%83%e9%99%90>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>GRANT</span> <span style=color:#66d9ef>ALL</span> <span style=color:#66d9ef>PRIVILEGES</span> <span style=color:#66d9ef>ON</span> <span style=color:#f92672>*</span>.<span style=color:#f92672>*</span> <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span></code></pre></div><h4 id=示例-3授予-myuser-用户对特定表的-select-权限>示例 3：授予 <code>myuser</code> 用户对特定表的 <code>SELECT</code> 权限
<a class=anchor href=#%e7%a4%ba%e4%be%8b-3%e6%8e%88%e4%ba%88-myuser-%e7%94%a8%e6%88%b7%e5%af%b9%e7%89%b9%e5%ae%9a%e8%a1%a8%e7%9a%84-select-%e6%9d%83%e9%99%90>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>GRANT</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>ON</span> mydb.mytable <span style=color:#66d9ef>TO</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span></code></pre></div><h4 id=2-撤销权限>(2) <strong>撤销权限</strong>
<a class=anchor href=#2-%e6%92%a4%e9%94%80%e6%9d%83%e9%99%90>#</a></h4><p>使用 <code>REVOKE</code> 语句可以撤销用户的某些权限。</p><p>语法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>REVOKE</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>privileges</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>ON</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>database</span><span style=color:#f92672>&gt;</span>.<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>table</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span>;
</span></span></code></pre></div><h4 id=示例-1撤销-myuser-用户对-mydb-数据库的-select-权限>示例 1：撤销 <code>myuser</code> 用户对 <code>mydb</code> 数据库的 <code>SELECT</code> 权限
<a class=anchor href=#%e7%a4%ba%e4%be%8b-1%e6%92%a4%e9%94%80-myuser-%e7%94%a8%e6%88%b7%e5%af%b9-mydb-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84-select-%e6%9d%83%e9%99%90>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>REVOKE</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>ON</span> mydb.<span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span></code></pre></div><h4 id=示例-2撤销-myuser-用户对所有数据库的所有权限>示例 2：撤销 <code>myuser</code> 用户对所有数据库的所有权限
<a class=anchor href=#%e7%a4%ba%e4%be%8b-2%e6%92%a4%e9%94%80-myuser-%e7%94%a8%e6%88%b7%e5%af%b9%e6%89%80%e6%9c%89%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e6%89%80%e6%9c%89%e6%9d%83%e9%99%90>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>REVOKE</span> <span style=color:#66d9ef>ALL</span> <span style=color:#66d9ef>PRIVILEGES</span> <span style=color:#66d9ef>ON</span> <span style=color:#f92672>*</span>.<span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span></code></pre></div><h3 id=3-刷新权限>3. <strong>刷新权限</strong>
<a class=anchor href=#3-%e5%88%b7%e6%96%b0%e6%9d%83%e9%99%90>#</a></h3><p>当授予或撤销权限后，需要刷新权限表以使更改生效，使用以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>FLUSH <span style=color:#66d9ef>PRIVILEGES</span>;
</span></span></code></pre></div><h3 id=4-删除用户权限>4. <strong>删除用户权限</strong>
<a class=anchor href=#4-%e5%88%a0%e9%99%a4%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90>#</a></h3><p>如果你想要删除一个用户，删除用户时会自动撤销该用户的所有权限：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;username&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;host&#39;</span>;
</span></span></code></pre></div><h4 id=示例-38>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-38>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>USER</span> <span style=color:#e6db74>&#39;myuser&#39;</span><span style=color:#f92672>@</span><span style=color:#e6db74>&#39;localhost&#39;</span>;
</span></span></code></pre></div><h3 id=总结-28>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-28>#</a></h3><ul><li><strong>查看用户权限</strong>：使用 <code>SHOW GRANTS FOR 'username'@'host';</code>。</li><li><strong>授予权限</strong>：使用 <code>GRANT</code> 命令。</li><li><strong>撤销权限</strong>：使用 <code>REVOKE</code> 命令。</li><li><strong>刷新权限</strong>：修改权限后使用 <code>FLUSH PRIVILEGES;</code> 来使改动生效。</li><li><strong>删除用户</strong>：使用 <code>DROP USER</code> 删除用户及其所有权限。</li></ul><p>通过这些操作，你可以灵活地管理 MySQL 用户的权限。</p><h1 id=三nosql>三、nosql
<a class=anchor href=#%e4%b8%89nosql>#</a></h1><h1 id=1-redis数据持久化有哪些方式>1. redis数据持久化有哪些方式？
<a class=anchor href=#1-redis%e6%95%b0%e6%8d%ae%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e5%bc%8f>#</a></h1><ul><li>rdb</li><li>aof</li></ul><p>Redis 提供了两种主要的数据持久化方式，以确保数据在重启或故障后不会丢失。它们分别是 <strong>RDB（Redis 数据库快照）</strong> 和 <strong>AOF（Append Only File）</strong>。除了这两种主要的持久化方式，Redis 还支持 <strong>混合持久化</strong>（RDB + AOF），具体如下：</p><h3 id=1-rdbredis-数据库快照>1. <strong>RDB（Redis 数据库快照）</strong>
<a class=anchor href=#1-rdbredis-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bf%ab%e7%85%a7>#</a></h3><p>RDB 是 Redis 默认的持久化方式，它通过在指定的时间间隔内创建数据库的快照来保存数据。</p><h4 id=工作原理>工作原理：
<a class=anchor href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h4><ul><li>Redis 会定期将数据库的状态（即数据）保存到硬盘上的一个 <code>.rdb</code> 文件中。</li><li>RDB 文件是压缩的二进制文件，可以在 Redis 启动时快速加载。</li><li>快照的创建是异步的，不会影响 Redis 的主操作。</li></ul><h4 id=配置>配置：
<a class=anchor href=#%e9%85%8d%e7%bd%ae>#</a></h4><ul><li><p>在 <code>redis.conf</code> 文件中，通过 <code>save</code> 指令配置保存快照的条件。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>save <span style=color:#ae81ff>900</span> <span style=color:#ae81ff>1</span>   <span style=color:#75715e># 如果在 900 秒（15分钟）内有至少 1 个 key 被修改，则进行快照</span>
</span></span><span style=display:flex><span>save <span style=color:#ae81ff>300</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># 如果在 300 秒内有至少 10 个 key 被修改，则进行快照</span>
</span></span><span style=display:flex><span>save <span style=color:#ae81ff>60</span> <span style=color:#ae81ff>10000</span>  <span style=color:#75715e># 如果在 60 秒内有至少 10000 个 key 被修改，则进行快照</span>
</span></span></code></pre></div></li><li><p>快照文件的路径和文件名可以通过 <code>dir</code> 和 <code>dbfilename</code> 指定：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dir /var/lib/redis
</span></span><span style=display:flex><span>dbfilename dump.rdb
</span></span></code></pre></div></li></ul><h4 id=优缺点>优缺点：
<a class=anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9>#</a></h4><ul><li><strong>优点</strong>：RDB 持久化方式对 Redis 性能影响较小，特别是在写入频繁的情况下，因为它是在后台异步操作的。</li><li><strong>缺点</strong>：由于是周期性的保存快照，如果 Redis 崩溃，最后一次保存的数据和崩溃时的数据之间的更改会丢失，数据持久化的精度较低。</li></ul><h3 id=2-aofappend-only-file>2. <strong>AOF（Append Only File）</strong>
<a class=anchor href=#2-aofappend-only-file>#</a></h3><p>AOF 通过记录所有写操作的日志来持久化数据，每次对 Redis 的写操作都会被追加到 AOF 文件中，Redis 启动时可以通过重放 AOF 文件来恢复数据。</p><h4 id=工作原理-1>工作原理：
<a class=anchor href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86-1>#</a></h4><ul><li>每当发生写操作时，Redis 会将操作写入 AOF 文件。</li><li>AOF 文件是以追加的方式记录的，保留了 Redis 中所有的写操作，可以精确恢复数据。</li><li>Redis 提供了三种不同的同步策略：<ul><li><strong>always</strong>：每次操作都同步写入磁盘，性能最差，持久化最可靠。</li><li><strong>everysec</strong>：每秒钟同步写入一次，这是性能和可靠性的折衷方案，也是默认选项。</li><li><strong>no</strong>：从不同步写入磁盘，性能最好，但一旦发生故障，数据会丢失。</li></ul></li></ul><h4 id=配置-1>配置：
<a class=anchor href=#%e9%85%8d%e7%bd%ae-1>#</a></h4><ul><li><p>在 <code>redis.conf</code> 文件中通过 <code>appendonly</code> 和 <code>appendfsync</code> 配置 AOF 持久化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>appendonly yes  <span style=color:#75715e># 启用 AOF 持久化</span>
</span></span><span style=display:flex><span>appendfsync everysec  <span style=color:#75715e># 每秒钟同步写入一次磁盘</span>
</span></span></code></pre></div></li><li><p>AOF 文件的路径可以通过 <code>dir</code> 和 <code>appendfilename</code> 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dir /var/lib/redis
</span></span><span style=display:flex><span>appendfilename <span style=color:#e6db74>&#34;appendonly.aof&#34;</span>
</span></span></code></pre></div></li></ul><h4 id=优缺点-1>优缺点：
<a class=anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-1>#</a></h4><ul><li><strong>优点</strong>：AOF 能够提供更高的数据可靠性，因为它记录了所有的写操作，可以做到“最小丢失”。</li><li><strong>缺点</strong>：AOF 文件会不断增长，尤其是对大量数据写入的场景，AOF 文件可能会变得很大。为了优化 AOF 文件的大小，可以定期进行 <strong>AOF 重写</strong>（<code>BGREWRITEAOF</code>），将 AOF 文件压缩到更小的体积。</li></ul><h3 id=3-混合持久化rdb--aof>3. <strong>混合持久化（RDB + AOF）</strong>
<a class=anchor href=#3-%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96rdb--aof>#</a></h3><p>Redis 4.0 引入了混合持久化机制，结合了 RDB 和 AOF 两种持久化方式的优点。混合持久化允许 Redis 同时使用 RDB 快照和 AOF 日志文件，在 Redis 启动时能够尽量减少数据恢复的时间，同时保证数据的持久性。</p><h4 id=工作原理-2>工作原理：
<a class=anchor href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86-2>#</a></h4><ul><li>在进行 AOF 重写时，Redis 会将数据存储在内存中的一个混合格式中（即 RDB 快照 + AOF 追加日志），这可以减少 AOF 重写时的性能开销。</li><li>启动时，Redis 会首先加载 RDB 快照文件，然后读取 AOF 文件中的操作来恢复数据。</li></ul><h4 id=配置-2>配置：
<a class=anchor href=#%e9%85%8d%e7%bd%ae-2>#</a></h4><ul><li><p>通过 <code>redis.conf</code> 文件中的 <code>aof-use-rdb-preamble</code> 配置来启用混合持久化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aof-use-rdb-preamble yes
</span></span></code></pre></div></li></ul><h4 id=优缺点-2>优缺点：
<a class=anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-2>#</a></h4><ul><li><strong>优点</strong>：结合了 RDB 的启动速度和 AOF 的数据可靠性。</li><li><strong>缺点</strong>：增加了配置复杂度，需要合理选择使用场景。</li></ul><h3 id=4-持久化相关配置的选择>4. <strong>持久化相关配置的选择</strong>
<a class=anchor href=#4-%e6%8c%81%e4%b9%85%e5%8c%96%e7%9b%b8%e5%85%b3%e9%85%8d%e7%bd%ae%e7%9a%84%e9%80%89%e6%8b%a9>#</a></h3><p>根据你的使用场景，选择合适的持久化方式至关重要：</p><ul><li>如果 <strong>对数据丢失的容忍度较低</strong>，且希望保证数据的完整性，建议使用 <strong>AOF</strong>（最好是 <code>everysec</code> 配置）。</li><li>如果希望 <strong>性能优先</strong>，并且可以接受 <strong>部分数据丢失</strong>，可以使用 <strong>RDB</strong>。</li><li>如果希望兼顾 <strong>性能和可靠性</strong>，可以考虑使用 <strong>RDB + AOF 混合持久化</strong>。</li></ul><h3 id=5-如何优化-aof-文件>5. <strong>如何优化 AOF 文件</strong>
<a class=anchor href=#5-%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96-aof-%e6%96%87%e4%bb%b6>#</a></h3><p>AOF 文件会随着时间的推移不断增长，因此 Redis 提供了 AOF 重写机制，可以压缩 AOF 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>BGREWRITEAOF
</span></span></code></pre></div><p>通过 <code>BGREWRITEAOF</code> 命令，Redis 会生成一个新的 AOF 文件，合并其中的命令，从而减小 AOF 文件的大小。</p><h3 id=总结-29>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-29>#</a></h3><ul><li><strong>RDB</strong>：通过定期快照方式持久化，性能较高，但数据丢失可能性较大。</li><li><strong>AOF</strong>：记录所有写操作，数据可靠性高，但文件会较大，可能影响性能。</li><li><strong>混合持久化</strong>：结合了 RDB 快照和 AOF 日志，兼顾启动速度和数据可靠性。</li></ul><p>根据实际的需求和对数据持久化的要求，可以选择最合适的持久化方式。</p><h1 id=2-redis集群方案有哪些>2. redis集群方案有哪些？
<a class=anchor href=#2-redis%e9%9b%86%e7%be%a4%e6%96%b9%e6%a1%88%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>官方cluster方案</li><li>twemproxy代理方案</li><li>哨兵模式</li><li>codis
客户端分片</li></ul><p>Redis 集群是为了实现分布式数据存储而设计的一种方案，它将数据分布在多个 Redis 实例（节点）上，提供高可用、分布式存储、负载均衡和故障恢复功能。Redis 集群支持水平扩展（sharding），使得 Redis 可以在多个机器上分布式地存储大量数据。</p><h3 id=redis-集群方案主要有以下几种>Redis 集群方案主要有以下几种：
<a class=anchor href=#redis-%e9%9b%86%e7%be%a4%e6%96%b9%e6%a1%88%e4%b8%bb%e8%a6%81%e6%9c%89%e4%bb%a5%e4%b8%8b%e5%87%a0%e7%a7%8d>#</a></h3><h3 id=1-原生-redis-集群redis-cluster>1. <strong>原生 Redis 集群（Redis Cluster）</strong>
<a class=anchor href=#1-%e5%8e%9f%e7%94%9f-redis-%e9%9b%86%e7%be%a4redis-cluster>#</a></h3><p><strong>Redis Cluster</strong> 是 Redis 官方提供的分布式集群方案，旨在提供高可用和可扩展的 Redis 服务。</p><h4 id=特点-4>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-4>#</a></h4><ul><li><strong>数据分片</strong>：数据被分散存储在多个 Redis 节点上，每个节点存储数据的一个子集。</li><li><strong>自动分片</strong>：Redis 集群支持将数据分成多个 &ldquo;槽&rdquo;（hash slots），并自动将这些槽分配到不同的 Redis 节点。</li><li><strong>高可用性</strong>：通过 Redis 集群的复制机制，每个主节点都有一个或多个副本节点，保证主节点故障时可以自动切换。</li><li><strong>无中心化管理</strong>：Redis 集群没有一个中央的控制节点，每个节点都包含自己的配置和集群状态，所有节点通过协议进行通信。</li></ul><h4 id=工作原理-3>工作原理：
<a class=anchor href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86-3>#</a></h4><ul><li>Redis 集群将数据按一定的规则（哈希槽）分散到集群中的不同节点上。</li><li>Redis 集群默认将数据划分为 16384 个槽，每个键值会通过一致性哈希算法映射到一个槽，槽再由各个节点存储。</li><li>节点之间通过 <strong>Gossip 协议</strong> 和 <strong>TCP 连接</strong> 进行状态同步，确保集群中所有节点的状态一致。</li></ul><h4 id=优缺点-3>优缺点：
<a class=anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-3>#</a></h4><ul><li><p>优点</p><p>：</p><ul><li>提供水平扩展能力，可以通过增加节点来扩展集群容量。</li><li>内建故障恢复，主节点宕机时会自动将从节点提升为主节点。</li><li>对外暴露单一的 Redis 端口，客户端自动路由。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>需要集群中的每个节点都有足够的内存来存储一部分数据。</li><li>配置较为复杂，需要至少 3 个主节点和 3 个副本来确保高可用性。</li><li>集群中发生故障时，可能会暂时导致部分槽的不可用。</li></ul></li></ul><h4 id=配置-3>配置：
<a class=anchor href=#%e9%85%8d%e7%bd%ae-3>#</a></h4><p>Redis 集群需要至少 3 个主节点和 3 个从节点来实现高可用，并且节点数量是 2 的倍数。 具体配置可以参考 Redis 官方文档中的集群部署指南。</p><h3 id=2-redis-sentinel>2. <strong>Redis Sentinel</strong>
<a class=anchor href=#2-redis-sentinel>#</a></h3><p><strong>Redis Sentinel</strong> 是 Redis 官方提供的高可用性解决方案。它可以监控 Redis 主从架构的节点，自动进行故障转移。</p><h4 id=特点-5>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-5>#</a></h4><ul><li><strong>高可用性</strong>：通过对 Redis 实例的监控，Sentinel 可以自动进行故障转移，主节点发生故障时，自动选举新的主节点。</li><li><strong>自动恢复</strong>：当主节点发生故障，Sentinel 会将一个从节点提升为主节点，并更新集群中的配置。</li><li><strong>集群监控</strong>：Redis Sentinel 提供对 Redis 实例的监控服务，并支持对集群进行通知和警告。</li></ul><h4 id=工作原理-4>工作原理：
<a class=anchor href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86-4>#</a></h4><ul><li>Sentinel 通过定期 ping 主节点和从节点来检查它们的状态。</li><li>如果检测到主节点不可用，Sentinel 会启动自动故障转移，将一个从节点提升为主节点，并通知其他 Sentinel 进行配置更新。</li><li>Sentinel 实例之间通过心跳机制和投票机制来选举新的主节点。</li></ul><h4 id=优缺点-4>优缺点：
<a class=anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-4>#</a></h4><ul><li><p>优点</p><p>：</p><ul><li>容错能力强，能够自动恢复主节点故障。</li><li>配置简单，适合大多数 Redis 部署。</li><li>可以与 Redis 单机模式结合使用，增加高可用性。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>Sentinel 本身并不提供数据分片能力，只适用于主从复制架构。</li><li>故障转移过程可能会有短暂的服务中断。</li></ul></li></ul><h4 id=配置-4>配置：
<a class=anchor href=#%e9%85%8d%e7%bd%ae-4>#</a></h4><ul><li>至少需要 3 个 Sentinel 实例来保证故障转移的正常工作。</li><li>需要至少 1 个主节点和 1 个从节点来构建 Redis 集群。</li></ul><h3 id=3-redis-代理方案如-twemproxy>3. <strong>Redis 代理方案（如 Twemproxy）</strong>
<a class=anchor href=#3-redis-%e4%bb%a3%e7%90%86%e6%96%b9%e6%a1%88%e5%a6%82-twemproxy>#</a></h3><p><strong>Twemproxy</strong>（又称 Nutcracker）是一个开源的代理工具，可以作为 Redis 集群的代理层。它允许在客户端与多个 Redis 实例之间进行负载均衡和路由。Twemproxy 适用于 Redis 主从架构或 Redis 集群架构。</p><h4 id=特点-6>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-6>#</a></h4><ul><li><strong>负载均衡</strong>：通过代理进行请求路由，可以在多个 Redis 实例之间均衡负载。</li><li><strong>透明代理</strong>：客户端与 Twemproxy 通信，Twemproxy 会根据请求路由到相应的 Redis 节点。</li><li><strong>高性能</strong>：Twemproxy 是一个非常高效的代理，适用于高并发场景。</li></ul><h4 id=优缺点-5>优缺点：
<a class=anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-5>#</a></h4><ul><li><p>优点</p><p>：</p><ul><li>可以作为 Redis 集群的代理层，简化客户端操作。</li><li>支持连接池和负载均衡，提供性能优化。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>不支持 Redis 集群的所有功能（如自动故障转移、复制等）。</li><li>需要额外的代理层，可能会增加系统复杂度。</li></ul></li></ul><h4 id=配置-5>配置：
<a class=anchor href=#%e9%85%8d%e7%bd%ae-5>#</a></h4><ul><li>配置 Twemproxy 需要指定多个 Redis 实例作为后端，并在前端处理客户端请求。</li></ul><h3 id=4-redis-sharding手动分片>4. <strong>Redis Sharding（手动分片）</strong>
<a class=anchor href=#4-redis-sharding%e6%89%8b%e5%8a%a8%e5%88%86%e7%89%87>#</a></h3><p><strong>手动分片</strong> 是通过在多个 Redis 实例之间人工分配数据来实现的。客户端通过特定的规则来决定数据应该存储在哪个 Redis 实例上。</p><h4 id=特点-7>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-7>#</a></h4><ul><li><strong>简单</strong>：不需要复杂的集群配置，适合小规模的 Redis 部署。</li><li><strong>灵活</strong>：可以根据具体业务需求来设计数据分片策略。</li></ul><h4 id=优缺点-6>优缺点：
<a class=anchor href=#%e4%bc%98%e7%bc%ba%e7%82%b9-6>#</a></h4><ul><li><p>优点</p><p>：</p><ul><li>简单易用，适合小规模应用。</li><li>可以灵活地进行分片和扩展。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>数据分片的管理较为复杂，需要手动配置分片规则。</li><li>不提供自动故障转移和数据恢复机制。</li></ul></li></ul><h3 id=总结-30>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-30>#</a></h3><ul><li><strong>Redis 集群（Redis Cluster）</strong> 是 Redis 原生的分布式集群方案，支持数据分片、自动故障转移和高可用性。</li><li><strong>Redis Sentinel</strong> 主要提供高可用性和自动故障转移，但不提供数据分片功能，适用于主从架构。</li><li><strong>Twemproxy</strong> 提供负载均衡和代理服务，适用于 Redis 集群和主从架构，但没有 Redis 集群的完整功能。</li><li><strong>Redis Sharding</strong> 是手动分片方式，适合小规模部署，灵活但管理复杂。</li></ul><p>选择哪种方案，取决于你的需求：</p><ul><li>如果需要 <strong>数据分片和高可用性</strong>，建议使用 <strong>Redis Cluster</strong>。</li><li>如果只需要 <strong>高可用性</strong> 而不需要分片，可以选择 <strong>Redis Sentinel</strong>。</li><li>如果需要 <strong>代理和负载均衡</strong>，可以使用 <strong>Twemproxy</strong>。</li><li>如果是 <strong>小规模部署</strong>，可以使用 <strong>手动分片</strong>。</li></ul><p>这些方案都可以根据不同的应用场景和架构要求进行调整和优化。</p><h1 id=3-redis如何进行数据备份与恢复>3. redis如何进行数据备份与恢复？
<a class=anchor href=#3-redis%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d>#</a></h1><ul><li>备份</li></ul><p>redis 127.0.0.1:6379> SAVE
创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。</p><ul><li>还原</li></ul><p>只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可
redis 127.0.0.1:6379> CONFIG GET dir</p><ol><li>“dir”</li><li>“/usr/local/redis/bin”</li></ol><p>Redis 提供了多种数据备份和恢复的方式，主要通过 <strong>持久化机制</strong>（RDB 和 AOF）以及 <strong>手动备份</strong> 来实现数据备份与恢复。以下是详细的备份与恢复方法：</p><h3 id=1-rdb-持久化备份与恢复>1. <strong>RDB 持久化备份与恢复</strong>
<a class=anchor href=#1-rdb-%e6%8c%81%e4%b9%85%e5%8c%96%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d>#</a></h3><p><strong>RDB</strong>（Redis DataBase）是 Redis 的默认持久化方式，它将内存中的数据快照保存在硬盘上，以便在重启或故障时恢复数据。</p><h4 id=rdb-备份><strong>RDB 备份</strong>
<a class=anchor href=#rdb-%e5%a4%87%e4%bb%bd>#</a></h4><ul><li><p><strong>自动备份</strong>：Redis 默认会根据配置（<code>redis.conf</code>）定期进行数据持久化。</p><ul><li><p>在</p><pre tabindex=0><code>redis.conf
</code></pre><p>文件中，</p><pre tabindex=0><code>save
</code></pre><p>指令配置了定期备份的规则。例如：</p><pre tabindex=0><code>save 900 1    # 900秒（15分钟）内有至少1次写操作时，自动生成快照
save 300 10   # 300秒（5分钟）内有至少10次写操作时，自动生成快照
save 60 10000 # 60秒内有至少10000次写操作时，自动生成快照
</code></pre></li><li><p>在这种配置下，Redis 会在满足这些条件时自动生成 RDB 文件。</p></li></ul></li><li><p><strong>手动备份</strong>：可以使用 <code>BGSAVE</code> 命令进行手动备份，该命令会在后台生成数据快照，不会阻塞 Redis 服务。</p><ul><li><p>命令：</p><pre tabindex=0><code>BGSAVE
</code></pre><p>这会在后台异步生成</p><pre tabindex=0><code>dump.rdb
</code></pre><p>文件。</p></li></ul></li><li><p><strong>RDB 文件位置</strong>：默认情况下，生成的 RDB 文件 <code>dump.rdb</code> 会存放在 Redis 数据目录下，通常在 <code>/var/lib/redis/</code> 或 <code>./</code>（Redis启动目录）。</p></li></ul><h4 id=rdb-恢复><strong>RDB 恢复</strong>
<a class=anchor href=#rdb-%e6%81%a2%e5%a4%8d>#</a></h4><ol><li><strong>停止 Redis 服务</strong>。</li><li>将备份的 <code>dump.rdb</code> 文件放回 Redis 数据目录。</li><li>启动 Redis 服务，Redis 会在启动时自动加载 <code>dump.rdb</code> 文件中的数据。</li></ol><p>如果你手动备份了 <code>dump.rdb</code> 文件，只需要将其恢复到 Redis 的数据目录并启动 Redis 服务即可。</p><h3 id=2-aof-持久化备份与恢复>2. <strong>AOF 持久化备份与恢复</strong>
<a class=anchor href=#2-aof-%e6%8c%81%e4%b9%85%e5%8c%96%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d>#</a></h3><p><strong>AOF</strong>（Append-Only File）持久化将所有写操作记录到日志文件中，可以确保数据更持久和可靠。每个写命令都会记录在 AOF 文件中，因此 AOF 提供了比 RDB 更高的持久性。</p><h4 id=aof-备份><strong>AOF 备份</strong>
<a class=anchor href=#aof-%e5%a4%87%e4%bb%bd>#</a></h4><ul><li><p><strong>自动备份</strong>：当 Redis 启用 AOF 持久化时，会将每一个写操作追加到 AOF 文件中。</p><ul><li><p>在</p><pre tabindex=0><code>redis.conf
</code></pre><p>中配置 AOF 相关参数：</p><pre tabindex=0><code>appendonly yes       # 启用 AOF 持久化
appendfilename &#34;appendonly.aof&#34;  # AOF 文件名
appendfsync everysec  # 每秒同步一次 AOF 文件
</code></pre></li><li><p>appendfsync</p><p>参数可以设置为：</p><ul><li><code>always</code>：每次写操作都同步到磁盘，性能较差。</li><li><code>everysec</code>：每秒同步一次到磁盘，通常是推荐的设置。</li><li><code>no</code>：不进行同步，由操作系统进行同步（性能最好，但可靠性最差）。</li></ul></li></ul></li><li><p><strong>手动备份</strong>：使用 <code>BGREWRITEAOF</code> 命令来重写 AOF 文件，这会生成一个新的 AOF 文件并删除旧的 AOF 文件，从而节省空间。</p><ul><li><p>命令：</p><pre tabindex=0><code>BGREWRITEAOF
</code></pre><p>这会在后台进行 AOF 重写操作，生成一个新的压缩后的 AOF 文件。</p></li></ul></li></ul><h4 id=aof-恢复><strong>AOF 恢复</strong>
<a class=anchor href=#aof-%e6%81%a2%e5%a4%8d>#</a></h4><ol><li>停止 Redis 服务。</li><li>将备份的 <code>appendonly.aof</code> 文件复制到 Redis 的数据目录。</li><li>启动 Redis 服务，Redis 会在启动时根据 AOF 文件恢复数据。</li></ol><p>如果你启用了 AOF 持久化，只需要将备份的 <code>appendonly.aof</code> 文件放回 Redis 数据目录并重启 Redis 即可。</p><h3 id=3-混合持久化rdb--aof-1>3. <strong>混合持久化（RDB + AOF）</strong>
<a class=anchor href=#3-%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96rdb--aof-1>#</a></h3><p>Redis 4.0 及以后的版本支持同时启用 <strong>RDB</strong> 和 <strong>AOF</strong> 持久化（混合持久化）。这种方式能够结合 RDB 的快速启动和 AOF 的高可靠性，在启动时首先使用 RDB 快照，如果没有 RDB 快照，才使用 AOF 文件。</p><h4 id=启用混合持久化>启用混合持久化：
<a class=anchor href=#%e5%90%af%e7%94%a8%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96>#</a></h4><ol><li><p>在 <code>redis.conf</code> 中配置：</p><pre tabindex=0><code>appendonly yes  # 启用 AOF
appendfsync everysec  # 每秒同步到 AOF
save 900 1  # 900秒有一次写操作时进行 RDB 快照
</code></pre></li><li><p>使用混合持久化时，Redis 会在保存 RDB 快照时将 AOF 也作为增量记录保留。</p></li></ol><h3 id=4-手动备份通过文件复制>4. <strong>手动备份（通过文件复制）</strong>
<a class=anchor href=#4-%e6%89%8b%e5%8a%a8%e5%a4%87%e4%bb%bd%e9%80%9a%e8%bf%87%e6%96%87%e4%bb%b6%e5%a4%8d%e5%88%b6>#</a></h3><p>如果你只是希望进行简单的备份，可以直接复制 Redis 的数据文件（<code>dump.rdb</code> 和 <code>appendonly.aof</code> 文件）。这种方式适用于备份频率较低的场景。</p><ol><li>停止 Redis 服务。</li><li>复制 <code>dump.rdb</code> 和 <code>appendonly.aof</code> 文件到备份存储。</li><li>启动 Redis 服务。</li></ol><h3 id=5-增量备份>5. <strong>增量备份</strong>
<a class=anchor href=#5-%e5%a2%9e%e9%87%8f%e5%a4%87%e4%bb%bd>#</a></h3><p>Redis 本身不直接支持增量备份，但可以通过以下方式实现：</p><ul><li><strong>RDB + AOF</strong>：结合 RDB 和 AOF 可以达到类似增量备份的效果。定期备份 RDB 快照，然后通过 AOF 文件记录增量数据。</li><li><strong>外部工具</strong>：可以使用一些备份工具（如 <code>redis-dump</code>、<code>redis-py</code> 等）定期获取 Redis 数据并实现增量备份。</li></ul><h3 id=6-备份策略与最佳实践>6. <strong>备份策略与最佳实践</strong>
<a class=anchor href=#6-%e5%a4%87%e4%bb%bd%e7%ad%96%e7%95%a5%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5>#</a></h3><ul><li><strong>定期备份</strong>：定期进行 RDB 快照备份，建议根据业务量的大小、数据的重要性、磁盘容量等来调整备份频率。</li><li><strong>多地备份</strong>：将备份文件存储在不同的物理位置，以防止硬盘损坏等不可预见的事件。</li><li><strong>自动化备份</strong>：设置定时任务（如 cron job）来自动备份 Redis 数据。</li><li><strong>监控与报警</strong>：结合监控工具，设置 Redis 数据备份的成功或失败的报警机制。</li></ul><h3 id=总结-31>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-31>#</a></h3><ul><li><strong>RDB</strong>：适合做定期的快照备份，恢复速度较快，数据丢失较少，但持久化操作可能较慢，适合对数据丢失容忍度较高的场景。</li><li><strong>AOF</strong>：适合需要高可靠性、保证不丢失数据的场景，写入性能相对较低，恢复速度较慢。</li><li><strong>混合持久化</strong>：结合了 RDB 的快速恢复和 AOF 的高可靠性，是目前较为推荐的方式。</li></ul><p>选择备份方式时，可以根据实际需求决定是采用 RDB、AOF，还是两者结合使用。</p><h1 id=4-mongodb如何进行数据备份>4. MongoDB如何进行数据备份？
<a class=anchor href=#4-mongodb%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd>#</a></h1><p>mongoexport / mongoimport
mongodump / mongorestore</p><p>MongoDB 提供了几种数据备份方式，主要有以下几种：</p><h3 id=1-使用-2>1. <strong>使用 <code>mongodump</code> 进行备份</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-2>#</a></h3><p><code>mongodump</code> 是 MongoDB 提供的命令行工具，用于将数据库的内容导出为二进制格式的备份文件。</p><h4 id=备份操作><strong>备份操作</strong>
<a class=anchor href=#%e5%a4%87%e4%bb%bd%e6%93%8d%e4%bd%9c>#</a></h4><ul><li><p><strong>备份整个数据库</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongodump --host &lt;host&gt; --port &lt;port&gt; --out /path/to/backup/directory
</span></span></code></pre></div><p>这将备份所有数据库到指定目录。</p></li><li><p><strong>备份指定数据库</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongodump --host &lt;host&gt; --port &lt;port&gt; --db &lt;database_name&gt; --out /path/to/backup/directory
</span></span></code></pre></div><p>只备份指定的数据库。</p></li><li><p><strong>备份指定集合</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongodump --host &lt;host&gt; --port &lt;port&gt; --db &lt;database_name&gt; --collection &lt;collection_name&gt; --out /path/to/backup/directory
</span></span></code></pre></div><p>只备份指定数据库中的某个集合。</p></li><li><p><strong>指定认证</strong>： 如果 MongoDB 实例启用了认证，需要提供 <code>--username</code> 和 <code>--password</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongodump --host &lt;host&gt; --port &lt;port&gt; --db &lt;database_name&gt; --username &lt;user&gt; --password &lt;password&gt; --out /path/to/backup/directory
</span></span></code></pre></div></li><li><p><strong>备份压缩数据</strong>： 可以使用 <code>--gzip</code> 参数压缩备份文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongodump --host &lt;host&gt; --port &lt;port&gt; --out /path/to/backup/directory --gzip
</span></span></code></pre></div></li></ul><h4 id=备份数据的存储路径><strong>备份数据的存储路径</strong>
<a class=anchor href=#%e5%a4%87%e4%bb%bd%e6%95%b0%e6%8d%ae%e7%9a%84%e5%ad%98%e5%82%a8%e8%b7%af%e5%be%84>#</a></h4><ul><li>备份的数据默认存储在 <code>--out</code> 指定的目录下，通常备份的数据会生成 <code>*.bson</code> 格式的文件以及一些元数据文件。</li></ul><h4 id=注意事项><strong>注意事项</strong>
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h4><ul><li><code>mongodump</code> 是基于查询的方式进行备份的，因此会导致备份的时间较长，并且可能会对 MongoDB 的性能产生影响。</li><li>使用 <code>mongodump</code> 时会锁定数据库，所以在进行备份时，数据库的写操作可能会受到一定影响。</li></ul><h3 id=2-使用-2>2. <strong>使用 <code>mongorestore</code> 进行恢复</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-2>#</a></h3><p><code>mongorestore</code> 是 MongoDB 提供的工具，用于将 <code>mongodump</code> 生成的备份文件恢复到数据库中。</p><ul><li><p><strong>恢复整个备份</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongorestore --host &lt;host&gt; --port &lt;port&gt; /path/to/backup/directory
</span></span></code></pre></div><p>该命令将从备份目录恢复所有数据库和集合。</p></li><li><p><strong>恢复指定数据库</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongorestore --host &lt;host&gt; --port &lt;port&gt; --db &lt;database_name&gt; /path/to/backup/directory/&lt;database_name&gt;
</span></span></code></pre></div></li><li><p><strong>恢复指定集合</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongorestore --host &lt;host&gt; --port &lt;port&gt; --db &lt;database_name&gt; --collection &lt;collection_name&gt; /path/to/backup/directory/&lt;database_name&gt;/&lt;collection_name&gt;.bson
</span></span></code></pre></div></li><li><p><strong>恢复压缩的备份</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongorestore --host &lt;host&gt; --port &lt;port&gt; --gzip /path/to/backup/directory
</span></span></code></pre></div></li></ul><h4 id=注意事项-1><strong>注意事项</strong>
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-1>#</a></h4><ul><li><p>恢复时会根据备份文件覆盖数据库中的现有数据，如果你需要保留现有数据，请使用</p><pre tabindex=0><code>--drop
</code></pre><p>参数来删除现有集合再恢复数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mongorestore --host &lt;host&gt; --port &lt;port&gt; --drop /path/to/backup/directory
</span></span></code></pre></div></li></ul><h3 id=3-使用文件系统级备份>3. <strong>使用文件系统级备份</strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%a4%87%e4%bb%bd>#</a></h3><p>如果 MongoDB 以复制集的方式运行，可以通过文件系统级别的备份来实现备份。这种方法适合大规模的数据备份，通常用于生产环境中的定期备份。</p><h4 id=步骤-10><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-10>#</a></h4><ol><li><p><strong>停用写操作（可选）</strong>： 你可以使用 <code>fsync</code> 命令让 MongoDB 进行一次同步操作，这有助于确保备份的一致性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>db.fsyncLock<span style=color:#f92672>()</span>
</span></span></code></pre></div></li><li><p><strong>复制 MongoDB 数据目录</strong>： 备份 MongoDB 数据目录（默认情况下，数据目录为 <code>/data/db</code>）。 你可以使用操作系统的 <code>cp</code> 或 <code>rsync</code> 命令将数据库文件复制到备份存储。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rsync -avz /data/db /path/to/backup/directory
</span></span></code></pre></div></li><li><p><strong>解锁同步（可选）</strong>： 完成备份后，使用以下命令解锁写操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>db.fsyncUnlock<span style=color:#f92672>()</span>
</span></span></code></pre></div></li></ol><h4 id=注意事项-2><strong>注意事项</strong>
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-2>#</a></h4><ul><li>使用文件系统备份时需要确保数据库的 <code>journal</code> 文件夹处于一致的状态，因此最好在 MongoDB 副本集的情况下进行备份。</li><li>此方法适用于大规模备份和恢复，但需要停机或锁定写操作，因此不适合高可用性要求非常高的场景。</li></ul><h3 id=4-使用-mongodb-atlas-进行备份云托管服务>4. <strong>使用 MongoDB Atlas 进行备份（云托管服务）</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-mongodb-atlas-%e8%bf%9b%e8%a1%8c%e5%a4%87%e4%bb%bd%e4%ba%91%e6%89%98%e7%ae%a1%e6%9c%8d%e5%8a%a1>#</a></h3><p>如果使用的是 MongoDB Atlas（MongoDB 的托管云服务），则可以利用其内建的自动备份功能。</p><ul><li><strong>自动备份</strong>：MongoDB Atlas 提供了自动备份服务，可以按日、周、月等频率自动进行备份。</li><li><strong>恢复备份</strong>：可以通过 Atlas 控制面板恢复备份，或者使用 MongoDB Atlas 的 API 恢复指定时间点的备份。</li></ul><h3 id=5-增量备份-1>5. <strong>增量备份</strong>
<a class=anchor href=#5-%e5%a2%9e%e9%87%8f%e5%a4%87%e4%bb%bd-1>#</a></h3><p>MongoDB 本身并不直接支持增量备份，但可以通过以下方式实现类似的功能：</p><ul><li><strong>复制集备份</strong>：通过 <code>oplog</code> （操作日志）实现增量备份。可以监控 MongoDB 的操作日志并提取增量数据，通常结合 <code>mongodump</code> 进行备份。</li></ul><h3 id=6-定期备份和自动化>6. <strong>定期备份和自动化</strong>
<a class=anchor href=#6-%e5%ae%9a%e6%9c%9f%e5%a4%87%e4%bb%bd%e5%92%8c%e8%87%aa%e5%8a%a8%e5%8c%96>#</a></h3><p>建议使用定时任务（如 cron job）来自动执行 <code>mongodump</code> 命令，以便定期备份数据库。这样可以确保数据定期得到保护，并且在数据库崩溃时能恢复。</p><h3 id=总结-32>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-32>#</a></h3><ul><li><strong>mongodump</strong> 是最常见的备份方式，适合大多数场景，使用时需要注意备份过程对性能的影响。</li><li><strong>mongorestore</strong> 用于从 <code>mongodump</code> 备份恢复数据。</li><li><strong>文件系统级备份</strong> 对于大规模数据库非常有效，但需要额外的同步和锁定操作。</li><li><strong>MongoDB Atlas</strong> 提供了便捷的云备份和恢复服务，适合云环境。</li></ul><p>根据具体业务需求选择合适的备份方式。</p><h1 id=5-kafka为何比redis-rabbitmq快>5. kafka为何比redis rabbitmq快？
<a class=anchor href=#5-kafka%e4%b8%ba%e4%bd%95%e6%af%94redis-rabbitmq%e5%bf%ab>#</a></h1><blockquote><p><a href=https://www.zhihu.com/question/22480085>https://www.zhihu.com/question/22480085</a></p></blockquote><p>Kafka 通常比 Redis 和 RabbitMQ 在消息传递性能上要快，主要是由于它的架构设计和使用的技术不同。以下是一些关键原因：</p><h3 id=1-顺序写入与高效磁盘存储>1. <strong>顺序写入与高效磁盘存储</strong>
<a class=anchor href=#1-%e9%a1%ba%e5%ba%8f%e5%86%99%e5%85%a5%e4%b8%8e%e9%ab%98%e6%95%88%e7%a3%81%e7%9b%98%e5%ad%98%e5%82%a8>#</a></h3><p>Kafka 通过顺序写入磁盘来优化性能。磁盘的顺序写入性能通常比随机写入要好得多，这也是 Kafka 高效的关键。消息在 Kafka 中被追加到日志文件的末尾，这使得磁盘 I/O 性能得到极大提升。而 Redis 和 RabbitMQ 则依赖于不同的存储和数据结构，通常会发生更多的随机访问操作，从而影响性能。</p><h3 id=2-持久化与内存管理>2. <strong>持久化与内存管理</strong>
<a class=anchor href=#2-%e6%8c%81%e4%b9%85%e5%8c%96%e4%b8%8e%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>#</a></h3><ul><li><strong>Kafka</strong> 的消息持久化是基于日志文件的，它通过将消息追加到文件系统的顺序日志中，从而使得消息可以高效地写入磁盘，并通过日志分段来管理大规模的数据。Kafka 将存储和传输解耦，支持高吞吐量的写入和读取。</li><li><strong>Redis</strong> 在默认情况下将所有数据存储在内存中（即使可以选择持久化数据到磁盘），这就意味着当处理大规模数据时，内存成为瓶颈。虽然 Redis 也支持磁盘持久化，但其持久化机制（RDB 或 AOF）可能会导致性能下降。</li><li><strong>RabbitMQ</strong> 使用 Erlang 构建，并将消息持久化到磁盘时，会有更高的延迟，尤其是在消息需要强一致性保障时。其高吞吐量的能力不如 Kafka，且在高并发时可能会遇到性能瓶颈。</li></ul><h3 id=3-分布式架构与水平扩展>3. <strong>分布式架构与水平扩展</strong>
<a class=anchor href=#3-%e5%88%86%e5%b8%83%e5%bc%8f%e6%9e%b6%e6%9e%84%e4%b8%8e%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95>#</a></h3><p>Kafka 从设计之初就支持分布式架构和水平扩展。它使用 <strong>分区</strong> 来水平分割数据，并可以通过增加分区和副本的数量来提高吞吐量。每个分区内的消息是按顺序存储的，并且可以并行处理，这使得 Kafka 能够支持大规模的并发消息传输。</p><ul><li><strong>Redis</strong> 是单线程的，虽然它支持分片（Cluster），但是在高并发的场景下，它的性能和吞吐量会受到单个节点的 CPU 和内存限制。</li><li><strong>RabbitMQ</strong> 可以通过集群和镜像队列来实现分布式，但是它的消息传递和存储机制相对复杂，且吞吐量通常比 Kafka 要低。</li></ul><h3 id=4-消息顺序和消费模型>4. <strong>消息顺序和消费模型</strong>
<a class=anchor href=#4-%e6%b6%88%e6%81%af%e9%a1%ba%e5%ba%8f%e5%92%8c%e6%b6%88%e8%b4%b9%e6%a8%a1%e5%9e%8b>#</a></h3><p>Kafka 提供了更高效的消费者模型。Kafka 中的消费者是基于偏移量（offset）来消费消息的，可以非常灵活地在消息流中前进或回溯。并且，由于消息在分区内是按顺序写入的，因此 Kafka 能够提供更高的消息吞吐量和低延迟。</p><ul><li><strong>Redis</strong> 通常依赖于发布/订阅模型，在高频率的数据推送场景下，消息的处理和消费可能会受到阻塞，尤其是在消息量非常大的情况下。</li><li><strong>RabbitMQ</strong> 使用队列来存储和分发消息，虽然支持多个消费者并行消费，但其消费效率通常低于 Kafka，尤其是在大规模并发场景下。</li></ul><h3 id=5-消息存储机制>5. <strong>消息存储机制</strong>
<a class=anchor href=#5-%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8%e6%9c%ba%e5%88%b6>#</a></h3><p>Kafka 是基于 <strong>append-only logs</strong>（仅追加日志）的方式进行存储的。这意味着一旦写入 Kafka，消息将被持久化并按时间顺序存储。这种方式大大减少了锁的竞争，写入性能非常高。</p><ul><li><strong>Redis</strong> 是内存存储系统，数据放在内存中时速度快，但当数据量过大时，内存成为瓶颈，存储限制更为严格。</li><li><strong>RabbitMQ</strong> 中的队列消息在传输和存储时需要在内存和磁盘之间频繁切换，尤其是当消息队列积压时，会引起更多的 I/O 操作，从而影响性能。</li></ul><h3 id=6-延迟与吞吐量>6. <strong>延迟与吞吐量</strong>
<a class=anchor href=#6-%e5%bb%b6%e8%bf%9f%e4%b8%8e%e5%90%9e%e5%90%90%e9%87%8f>#</a></h3><p>Kafka 设计时注重高吞吐量（high throughput）和低延迟，适合大规模的数据流传输，并且支持高并发的生产者和消费者。它能够处理数百万的消息和高频率的数据传输，而 RabbitMQ 和 Redis 虽然也能处理高吞吐量的场景，但相比之下，Kafka 更加专注于大规模、高并发的消息传递和持久化。</p><h3 id=7-容错性和数据持久化>7. <strong>容错性和数据持久化</strong>
<a class=anchor href=#7-%e5%ae%b9%e9%94%99%e6%80%a7%e5%92%8c%e6%95%b0%e6%8d%ae%e6%8c%81%e4%b9%85%e5%8c%96>#</a></h3><p>Kafka 的设计有 <strong>日志复制</strong> 和 <strong>数据持久化</strong> 机制，确保了在节点发生故障时数据不丢失。同时，Kafka 的日志压缩功能使得消息可以存储较长时间，并且可以进行高效的回放和数据重放。</p><h3 id=总结-33>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-33>#</a></h3><p>Kafka 相对于 Redis 和 RabbitMQ 的优势主要在于：</p><ul><li>顺序写入和高效的磁盘存储。</li><li>高吞吐量和低延迟的分布式消息传递。</li><li>大规模扩展能力和高并发支持。</li></ul><p>如果是处理需要高吞吐量、高并发、大规模数据流的场景，Kafka 无疑是更好的选择；而 Redis 和 RabbitMQ 更适合小规模、高频次的消息传递场景。</p><h1 id=四docker>四、docker
<a class=anchor href=#%e5%9b%9bdocker>#</a></h1><h1 id=1-dockerfile有哪些关键字用途是什么>1. dockerfile有哪些关键字？用途是什么？
<a class=anchor href=#1-dockerfile%e6%9c%89%e5%93%aa%e4%ba%9b%e5%85%b3%e9%94%ae%e5%ad%97%e7%94%a8%e9%80%94%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012431696.png alt=image-20250224012431696></p><p>Dockerfile 是一个用于自动化创建 Docker 镜像的脚本文件，其中包含了构建镜像所需的所有命令和参数。Dockerfile 中的关键字定义了如何构建镜像。常用的关键字及其用途如下：</p><h3 id=1-from>1. <strong>FROM</strong>
<a class=anchor href=#1-from>#</a></h3><ul><li><p><strong>用途</strong>：指定基础镜像，是 Dockerfile 中的第一个命令。所有的 Dockerfile 都必须以 <code>FROM</code> 开始，表示从哪个镜像基础上构建。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ubuntu:20.04</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=2-run>2. <strong>RUN</strong>
<a class=anchor href=#2-run>#</a></h3><ul><li><p><strong>用途</strong>：在镜像构建过程中执行命令。通常用于安装依赖、更新系统等操作。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y curl<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=3-cmd>3. <strong>CMD</strong>
<a class=anchor href=#3-cmd>#</a></h3><ul><li><p><strong>用途</strong>：为容器设置默认执行的命令。可以覆盖容器启动时的命令。<code>CMD</code> 可以接受命令和参数，通常用于运行容器时的入口点。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;python&#34;</span>, <span style=color:#e6db74>&#34;app.py&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=4-entrypoint>4. <strong>ENTRYPOINT</strong>
<a class=anchor href=#4-entrypoint>#</a></h3><ul><li><p><strong>用途</strong>：定义容器启动时的默认命令。与 <code>CMD</code> 类似，但 <code>ENTRYPOINT</code> 是不可覆盖的，<code>CMD</code> 是可选的。如果 <code>CMD</code> 和 <code>ENTRYPOINT</code> 同时存在，<code>CMD</code> 提供默认参数。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;python&#34;</span>, <span style=color:#e6db74>&#34;app.py&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=5-copy>5. <strong>COPY</strong>
<a class=anchor href=#5-copy>#</a></h3><ul><li><p><strong>用途</strong>：将文件或目录从主机复制到镜像内。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> ./app /usr/src/app<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=6-add>6. <strong>ADD</strong>
<a class=anchor href=#6-add>#</a></h3><ul><li><p><strong>用途</strong>：类似于 <code>COPY</code>，但还支持从 URL 下载文件以及自动解压 tar 包。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ADD</span> https://example.com/app.tar.gz /usr/src/app<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=7-expose>7. <strong>EXPOSE</strong>
<a class=anchor href=#7-expose>#</a></h3><ul><li><p><strong>用途</strong>：声明容器运行时监听的端口。它不会主动发布端口，而是作为文档的说明。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=8-env>8. <strong>ENV</strong>
<a class=anchor href=#8-env>#</a></h3><ul><li><p><strong>用途</strong>：设置环境变量。在容器内部可以使用这些环境变量。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENV</span> APP_HOME /usr/src/app<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=9-arg>9. <strong>ARG</strong>
<a class=anchor href=#9-arg>#</a></h3><ul><li><p><strong>用途</strong>：定义构建时使用的变量。可以在 <code>docker build</code> 时通过 <code>--build-arg</code> 提供参数。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ARG</span> VERSION<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.0<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=10-volume>10. <strong>VOLUME</strong>
<a class=anchor href=#10-volume>#</a></h3><ul><li><p><strong>用途</strong>：创建挂载点，允许容器与主机或其他容器之间共享数据。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>VOLUME</span> [<span style=color:#e6db74>&#34;/data&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=11-workdir>11. <strong>WORKDIR</strong>
<a class=anchor href=#11-workdir>#</a></h3><ul><li><p><strong>用途</strong>：设置工作目录。后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 等指令将在此目录下执行。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /usr/src/app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=12-user>12. <strong>USER</strong>
<a class=anchor href=#12-user>#</a></h3><ul><li><p><strong>用途</strong>：指定镜像中的用户。容器在启动时会以指定的用户身份运行。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> appuser</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=13-label>13. <strong>LABEL</strong>
<a class=anchor href=#13-label>#</a></h3><ul><li><p><strong>用途</strong>：给镜像添加元数据（如版本号、作者等）。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>LABEL</span> version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1.0&#34;</span> maintainer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;yourname@example.com&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=14-shell>14. <strong>SHELL</strong>
<a class=anchor href=#14-shell>#</a></h3><ul><li><p><strong>用途</strong>：设置 <code>RUN</code> 命令使用的 shell，默认为 <code>/bin/sh -c</code>，可以通过 <code>SHELL</code> 指令改变。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>SHELL</span> [<span style=color:#e6db74>&#34;/bin/bash&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=15-stopsignal>15. <strong>STOPSIGNAL</strong>
<a class=anchor href=#15-stopsignal>#</a></h3><ul><li><p><strong>用途</strong>：指定容器停止时要发送的信号，默认是 <code>SIGTERM</code>。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>STOPSIGNAL</span><span style=color:#e6db74> SIGINT</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=总结-34>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-34>#</a></h3><p>这些关键字在 Dockerfile 中分别用于定义镜像的基础、运行时的命令、容器的配置等，帮助用户灵活配置和构建自定义镜像。通过合理的使用这些关键字，可以大大提高镜像构建的效率和可维护性。</p><h1 id=2-如何减小dockerfile生成镜像体积>2. 如何减小dockerfile生成镜像体积？
<a class=anchor href=#2-%e5%a6%82%e4%bd%95%e5%87%8f%e5%b0%8fdockerfile%e7%94%9f%e6%88%90%e9%95%9c%e5%83%8f%e4%bd%93%e7%a7%af>#</a></h1><ul><li>尽量选取满足需求但较小的基础系统镜像，例如大部分时候可以选择debian:wheezy或debian:jessie镜像，仅有不足百兆大小；</li><li>清理编译生成文件、安装包的缓存等临时文件；</li><li>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖；</li><li>从安全角度考虑，应用要尽量使用系统的库和依赖；</li><li>如果安装应用时候需要配置一些特殊的环境变量，在安装后要还原不需要保持的变量值；</li></ul><p>减小 Dockerfile 生成镜像体积是优化 Docker 镜像大小的一个重要步骤。较小的镜像不仅节省存储空间，还能提高镜像的拉取速度和启动速度。以下是一些减小 Docker 镜像体积的最佳实践：</p><h3 id=1-选择合适的基础镜像>1. <strong>选择合适的基础镜像</strong>
<a class=anchor href=#1-%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f>#</a></h3><ul><li><p>使用较小的基础镜像，例如 <code>alpine</code>，而不是较大的镜像如 <code>ubuntu</code> 或 <code>centos</code>。<code>Alpine</code> 是一个非常轻量的 Linux 发行版，通常它的体积只有 5 MB 左右。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:3.12</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=2-尽量减少>2. <strong>尽量减少 <code>RUN</code> 指令的层数</strong>
<a class=anchor href=#2-%e5%b0%bd%e9%87%8f%e5%87%8f%e5%b0%91>#</a></h3><ul><li><p>Dockerfile 中的每个命令都会创建一个新的镜像层。尽量将多个命令合并到一个 <code>RUN</code> 指令中，从而减少镜像层数。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># 不推荐</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get install -y curl<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get install -y vim<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 推荐</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y curl vim<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=3-删除临时文件和缓存>3. <strong>删除临时文件和缓存</strong>
<a class=anchor href=#3-%e5%88%a0%e9%99%a4%e4%b8%b4%e6%97%b6%e6%96%87%e4%bb%b6%e5%92%8c%e7%bc%93%e5%ad%98>#</a></h3><ul><li><p>在安装软件时，通常会产生缓存文件和临时文件，这些文件在最终镜像中是没用的。在安装完成后，使用 <code>&&</code> 将删除缓存的操作合并到同一个 <code>RUN</code> 命令中。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y curl <span style=color:#f92672>&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=4-使用-1>4. <strong>使用 <code>.dockerignore</code> 文件</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-1>#</a></h3><ul><li><p>类似于 <code>.gitignore</code> 文件，<code>.dockerignore</code> 文件可以防止不需要的文件被复制到镜像中，减少镜像体积。通常应该忽略不需要的源代码文件、临时文件、日志文件等。</p></li><li><p>示例</p><p>：</p><pre tabindex=0><code>.git
*.log
*.md
</code></pre></li></ul><h3 id=5-使用多阶段构建multi-stage-build>5. <strong>使用多阶段构建（Multi-stage Build）</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8%e5%a4%9a%e9%98%b6%e6%ae%b5%e6%9e%84%e5%bb%bamulti-stage-build>#</a></h3><ul><li><p>使用多阶段构建可以将构建过程和最终的运行镜像分开，在构建阶段安装依赖并进行编译，然后只将最终生成的二进制文件复制到一个更小的运行镜像中。这种方式可以有效减小最终镜像的大小。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># 构建阶段</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.15 as builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /src</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go build -o /bin/myapp<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 运行阶段</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:3.12</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder /bin/myapp /bin/myapp<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;/bin/myapp&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=6-使用压缩格式的文件>6. <strong>使用压缩格式的文件</strong>
<a class=anchor href=#6-%e4%bd%bf%e7%94%a8%e5%8e%8b%e7%bc%a9%e6%a0%bc%e5%bc%8f%e7%9a%84%e6%96%87%e4%bb%b6>#</a></h3><ul><li><p>如果你需要将文件添加到镜像中，可以考虑使用压缩文件。然后在镜像构建时解压这些文件，这样可以减小源文件的大小。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> app.tar.gz /app/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> tar -zxvf /app/app.tar.gz -C /app <span style=color:#f92672>&amp;&amp;</span> rm /app/app.tar.gz<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=7-避免使用>7. <strong>避免使用 <code>ADD</code> 除非需要</strong>
<a class=anchor href=#7-%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8>#</a></h3><ul><li><p><code>ADD</code> 可以处理压缩包并自动解压缩文件，但它也会带来不必要的文件操作。除非需要解压缩或从 URL 下载文件，否则应使用 <code>COPY</code> 代替。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># 不推荐</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> app.tar.gz /app/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 推荐</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> app.tar.gz /app/<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=8-精简镜像中的文件和依赖>8. <strong>精简镜像中的文件和依赖</strong>
<a class=anchor href=#8-%e7%b2%be%e7%ae%80%e9%95%9c%e5%83%8f%e4%b8%ad%e7%9a%84%e6%96%87%e4%bb%b6%e5%92%8c%e4%be%9d%e8%b5%96>#</a></h3><ul><li><p>避免安装不必要的库和工具。安装后删除不需要的文件，例如开发依赖和文档文件。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y --no-install-recommends <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    curl vim <span style=color:#f92672>&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=9-使用合适的压缩格式>9. <strong>使用合适的压缩格式</strong>
<a class=anchor href=#9-%e4%bd%bf%e7%94%a8%e5%90%88%e9%80%82%e7%9a%84%e5%8e%8b%e7%bc%a9%e6%a0%bc%e5%bc%8f>#</a></h3><ul><li>Docker 镜像支持多种压缩格式，使用 <code>gzip</code> 格式可能会产生较大的镜像，而使用 <code>xz</code> 或 <code>lzma</code> 格式会使得镜像体积更小。通过 Docker 工具 <code>docker export</code> 和 <code>docker import</code> 还可以重新压缩镜像。</li></ul><h3 id=10-减少日志文件和调试信息>10. <strong>减少日志文件和调试信息</strong>
<a class=anchor href=#10-%e5%87%8f%e5%b0%91%e6%97%a5%e5%bf%97%e6%96%87%e4%bb%b6%e5%92%8c%e8%b0%83%e8%af%95%e4%bf%a1%e6%81%af>#</a></h3><ul><li>在容器镜像中避免包含不必要的日志文件或调试信息，这些文件在生产环境中并不需要。</li></ul><h3 id=总结-35>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-35>#</a></h3><p>通过合理的优化 Dockerfile，可以显著减小生成镜像的体积，提高部署速度、减少网络带宽消耗。最重要的优化措施是选择合适的基础镜像、合并 <code>RUN</code> 命令、清理临时文件以及使用多阶段构建。</p><h1 id=3-dockerfile中cmd与entrypoint区别是什么>3. dockerfile中CMD与ENTRYPOINT区别是什么？
<a class=anchor href=#3-dockerfile%e4%b8%adcmd%e4%b8%8eentrypoint%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>CMD 和 ENTRYPOINT 指令都是用来指定容器启动时运行的命令。</li><li>指定 ENTRYPOINT 指令为 exec 模式时，CMD指定的参数会作为参数添加到 ENTRYPOINT 指定命令的参数列表中。</li></ul><p>在 Dockerfile 中，<code>CMD</code> 和 <code>ENTRYPOINT</code> 都是用来指定容器启动时执行的命令，它们在功能上有些相似，但也有一些关键的区别：</p><h3 id=1-cmd命令>1. <strong>CMD（命令）</strong>
<a class=anchor href=#1-cmd%e5%91%bd%e4%bb%a4>#</a></h3><ul><li><p><strong>用途</strong>：设置容器启动时的默认命令及其参数。可以通过 <code>docker run</code> 时提供的命令来覆盖。</p></li><li><p><strong>语法</strong>：</p><ul><li><code>CMD ["executable", "param1", "param2"]</code>（JSON 数组格式）</li><li><code>CMD ["param1", "param2"]</code>（Shell 格式，假设默认使用某个命令，比如 <code>/bin/sh -c</code>）</li><li><code>CMD command param1 param2</code>（Shell 格式）</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>如果 Dockerfile 中既有 <code>CMD</code>，也有 <code>ENTRYPOINT</code>，则 <code>CMD</code> 提供默认的参数，<code>ENTRYPOINT</code> 定义默认的执行程序。</li><li>如果通过 <code>docker run</code> 命令指定了其它命令，<code>CMD</code> 中的命令会被覆盖。</li></ul></li><li><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;echo&#34;</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>运行时：<code>docker run &lt;image></code> 会输出 <code>Hello, World!</code>。</p><p>通过 <code>docker run &lt;image> &lt;new command></code> 可以覆盖 <code>CMD</code> 设置的命令。</p></li></ul><h3 id=2-entrypoint入口点>2. <strong>ENTRYPOINT（入口点）</strong>
<a class=anchor href=#2-entrypoint%e5%85%a5%e5%8f%a3%e7%82%b9>#</a></h3><ul><li><p><strong>用途</strong>：设置容器启动时的入口命令，通常是容器启动时的主命令。与 <code>CMD</code> 不同，<code>ENTRYPOINT</code> 定义的是容器的执行方式，<code>CMD</code> 可以为 <code>ENTRYPOINT</code> 提供默认参数。</p></li><li><p><strong>语法</strong>：</p><ul><li><code>ENTRYPOINT ["executable", "param1", "param2"]</code>（JSON 数组格式）</li><li><code>ENTRYPOINT command param1 param2</code>（Shell 格式）</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><code>ENTRYPOINT</code> 不会被 <code>docker run</code> 命令覆盖。如果需要动态地给 <code>ENTRYPOINT</code> 提供参数，通常通过 <code>CMD</code> 提供默认参数。</li><li><code>ENTRYPOINT</code> 使容器执行的命令更固定，通常用于像服务程序等容器主程序。</li></ul></li><li><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;echo&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;Hello, World!&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>运行时：<code>docker run &lt;image></code> 会输出 <code>Hello, World!</code>，这是因为 <code>CMD</code> 提供了默认参数 <code>Hello, World!</code> 给 <code>ENTRYPOINT</code>。</p><p>通过 <code>docker run &lt;image> &lt;new param></code> 可以覆盖 <code>CMD</code> 的参数，但 <code>ENTRYPOINT</code> 不会被覆盖，<code>echo</code> 命令始终会执行。</p></li></ul><h3 id=区别总结><strong>区别总结</strong>
<a class=anchor href=#%e5%8c%ba%e5%88%ab%e6%80%bb%e7%bb%93>#</a></h3><table><thead><tr><th>特性</th><th>CMD</th><th>ENTRYPOINT</th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>定义默认命令及其参数，容器启动时执行。</td><td>定义容器的主命令，通常不被覆盖。</td></tr><tr><td><strong>能否被覆盖</strong></td><td>可以通过 <code>docker run</code> 时指定命令覆盖。</td><td>不会被 <code>docker run</code> 指定的命令覆盖。</td></tr><tr><td><strong>与 <code>ENTRYPOINT</code> 结合使用</strong></td><td>可以为 <code>ENTRYPOINT</code> 提供默认参数。</td><td>一般作为主命令，<code>CMD</code> 提供默认参数。</td></tr><tr><td><strong>用法</strong></td><td>通常用于提供默认的参数或执行的命令。</td><td>用于定义容器的主进程命令，确保容器启动时执行。</td></tr></tbody></table><h3 id=常见的组合方式><strong>常见的组合方式</strong>
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84%e7%bb%84%e5%90%88%e6%96%b9%e5%bc%8f>#</a></h3><ul><li><p><strong>只使用 <code>CMD</code></strong>：适合容器启动时可以有灵活的命令行参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;echo&#34;</span>, <span style=color:#e6db74>&#34;Hello, World!&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li><li><p><strong>只使用 <code>ENTRYPOINT</code></strong>：适合容器启动时执行固定的命令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;echo&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;Hello, World!&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>这样可以通过 <code>docker run</code> 时指定不同的参数来改变输出内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run &lt;image&gt; <span style=color:#e6db74>&#34;New Message&#34;</span>
</span></span></code></pre></div></li><li><p><strong>使用 <code>ENTRYPOINT</code> + <code>CMD</code></strong>：这种方式组合可以确保容器始终执行主命令，而 <code>CMD</code> 提供默认参数，且可以通过 <code>docker run</code> 覆盖。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;python&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;app.py&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>通过 <code>docker run</code> 可以指定不同的脚本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run &lt;image&gt; app2.py
</span></span></code></pre></div></li></ul><h3 id=结论>结论
<a class=anchor href=#%e7%bb%93%e8%ae%ba>#</a></h3><ul><li>使用 <code>ENTRYPOINT</code> 来定义固定的主命令，不希望用户覆盖。</li><li>使用 <code>CMD</code> 来为命令提供默认参数，或者提供默认命令，可以被用户覆盖。</li></ul><h1 id=4-dockerfile中copy和add区别是什么>4. dockerfile中COPY和ADD区别是什么？
<a class=anchor href=#4-dockerfile%e4%b8%adcopy%e5%92%8cadd%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>COPY指令和ADD指令都可以将主机上的资源复制或加入到容器镜像中</li><li>区别是ADD可以从 远程URL中的资源不会被解压缩。</li><li>如果是本地的压缩包ADD进去会被解压缩</li></ul><p>在 Dockerfile 中，<code>COPY</code> 和 <code>ADD</code> 都是用来将文件或目录从宿主机复制到 Docker 镜像中，但它们有一些不同的功能和用途。下面是它们的主要区别：</p><h3 id=1-copy>1. <strong>COPY</strong>
<a class=anchor href=#1-copy>#</a></h3><ul><li><p><strong>用途</strong>：<code>COPY</code> 是最简单的文件复制指令，用于将宿主机的文件或目录复制到镜像中。它只做简单的复制操作，不会进行任何解压或额外的操作。</p></li><li><p><strong>语法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> &lt;src&gt; &lt;dest&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li><code>&lt;src></code>：源路径，可以是宿主机中的文件或目录。</li><li><code>&lt;dest></code>：目标路径，将文件或目录复制到镜像中。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>只做文件复制，不支持解压压缩文件。</li><li>不会自动从 URL 下载文件。</li><li>适用于普通的文件复制需求。</li></ul></li><li><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> ./myapp /usr/src/app/<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=2-add>2. <strong>ADD</strong>
<a class=anchor href=#2-add>#</a></h3><ul><li><p><strong>用途</strong>：<code>ADD</code> 是一个功能更强大的指令，不仅可以将文件从宿主机复制到镜像中，还支持从 URL 下载文件并解压 tar 文件到镜像中。</p></li><li><p><strong>语法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ADD</span> &lt;src&gt; &lt;dest&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li><code>&lt;src></code>：源路径，可以是宿主机中的文件、目录或 URL。</li><li><code>&lt;dest></code>：目标路径，将文件或目录复制到镜像中。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>如果源是一个 <code>.tar</code> 文件，<code>ADD</code> 会自动解压到目标路径。</li><li>支持从 URL 下载文件并将其复制到镜像中。</li><li>由于功能更多，因此 <code>ADD</code> 可能会引入一些不必要的复杂性，特别是在没有解压需求的情况下。</li></ul></li><li><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ADD</span> ./myapp.tar /usr/src/app/  <span style=color:#75715e># 自动解压 myapp.tar</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> https://example.com/file.tar.gz /usr/src/app/  <span style=color:#75715e># 从 URL 下载并解压</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h3 id=区别总结-1><strong>区别总结</strong>
<a class=anchor href=#%e5%8c%ba%e5%88%ab%e6%80%bb%e7%bb%93-1>#</a></h3><table><thead><tr><th>特性</th><th><code>COPY</code></th><th><code>ADD</code></th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>仅仅复制文件或目录</td><td>复制文件或目录，同时支持解压 <code>.tar</code> 文件和从 URL 下载文件</td></tr><tr><td><strong>解压支持</strong></td><td>不支持自动解压文件</td><td>支持自动解压 <code>.tar</code> 文件</td></tr><tr><td><strong>从 URL 下载文件</strong></td><td>不支持</td><td>支持从 URL 下载文件并复制到镜像中</td></tr><tr><td><strong>推荐场景</strong></td><td>简单的文件复制操作，无需解压或下载功能</td><td>当需要解压 <code>.tar</code> 文件或从 URL 下载文件时</td></tr><tr><td><strong>安全性和可控性</strong></td><td>更加简洁和明确，推荐用于复制文件</td><td>由于额外功能（自动解压和下载），使用时需要小心，避免不必要的复杂性</td></tr></tbody></table><h3 id=使用建议><strong>使用建议</strong>
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%bb%ba%e8%ae%ae>#</a></h3><ul><li><strong>推荐使用 <code>COPY</code></strong>：对于普通的文件复制操作，<code>COPY</code> 更加简单明了，避免了额外的复杂性。如果不需要解压或从 URL 下载文件，使用 <code>COPY</code> 更加合适。</li><li><strong>使用 <code>ADD</code> 时</strong>：仅当你确实需要从 URL 下载文件或需要自动解压 <code>.tar</code> 文件时，才应使用 <code>ADD</code>，因为 <code>ADD</code> 的额外功能可能会增加不必要的复杂性。</li></ul><h3 id=示例-39><strong>示例</strong>
<a class=anchor href=#%e7%a4%ba%e4%be%8b-39>#</a></h3><ul><li><p><strong>简单复制文件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> ./myapp /usr/src/app/<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>使用 <code>COPY</code> 来将文件从宿主机复制到镜像。</li></ul></li><li><p><strong>下载并解压文件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ADD</span> https://example.com/file.tar.gz /usr/src/app/<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>使用 <code>ADD</code> 从 URL 下载文件并解压到镜像中。</li></ul></li></ul><h3 id=结论-1><strong>结论</strong>
<a class=anchor href=#%e7%bb%93%e8%ae%ba-1>#</a></h3><ul><li>如果只是复制文件，<strong>优先使用 <code>COPY</code></strong>，它更简洁且不会做多余的操作。</li><li>如果需要从 URL 下载文件或解压文件，才使用 <code>ADD</code>。</li></ul><h1 id=5-docker的cs架构组件有哪些>5. docker的cs架构组件有哪些？
<a class=anchor href=#5-docker%e7%9a%84cs%e6%9e%b6%e6%9e%84%e7%bb%84%e4%bb%b6%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012525565.png alt=image-20250224012525565></p><p>Docker 的 CS（Client-Server）架构是 Docker 的核心架构模式，其中包含以下主要组件：</p><h3 id=1-docker-client客户端>1. <strong>Docker Client（客户端）</strong>
<a class=anchor href=#1-docker-client%e5%ae%a2%e6%88%b7%e7%ab%af>#</a></h3><ul><li><strong>作用</strong>：Docker 客户端是用户与 Docker 引擎交互的接口，负责发送命令并接收输出。它通过命令行界面（CLI）与 Docker 引擎通信。</li><li><strong>常见命令</strong>：<code>docker run</code>、<code>docker ps</code>、<code>docker build</code>、<code>docker images</code> 等。</li><li><strong>与 Docker Engine 通信</strong>：客户端通过 Docker API 与 Docker 引擎进行交互，通常是通过 HTTP 或 Unix socket 来与 Docker 守护进程通信。</li></ul><h3 id=2-docker-daemon守护进程>2. <strong>Docker Daemon（守护进程）</strong>
<a class=anchor href=#2-docker-daemon%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b>#</a></h3><ul><li><strong>作用</strong>：Docker 守护进程是 Docker 的核心，它负责管理容器生命周期（创建、启动、停止和销毁容器）。它还负责管理镜像、网络、卷等其他 Docker 组件，并处理来自 Docker 客户端的请求。</li><li><strong>常见操作</strong>：<code>docker run</code>、<code>docker build</code>、<code>docker network</code>、<code>docker volume</code> 等。</li><li><strong>通信方式</strong>：守护进程通常运行在后台，监听来自 Docker 客户端的请求并返回相应的结果。</li></ul><h3 id=3-docker-registry镜像仓库>3. <strong>Docker Registry（镜像仓库）</strong>
<a class=anchor href=#3-docker-registry%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93>#</a></h3><ul><li><strong>作用</strong>：Docker Registry 是一个用于存储和分发 Docker 镜像的服务。官方的 Docker 镜像仓库是 Docker Hub，用户可以将自己的镜像上传到此仓库，也可以从仓库拉取所需的镜像。</li><li><strong>常见操作</strong>：<code>docker push</code>（上传镜像）、<code>docker pull</code>（拉取镜像）、<code>docker search</code>（搜索镜像）。</li><li><strong>本地仓库</strong>：除了 Docker Hub，还可以配置私有仓库来存储自己的镜像。</li></ul><h3 id=4-docker-image镜像>4. <strong>Docker Image（镜像）</strong>
<a class=anchor href=#4-docker-image%e9%95%9c%e5%83%8f>#</a></h3><ul><li><strong>作用</strong>：Docker 镜像是一个包含了应用程序及其所有依赖项、库、配置文件等的只读模板。镜像是容器的蓝图。</li><li><strong>构建过程</strong>：可以通过 <code>Dockerfile</code> 文件来构建镜像。</li><li><strong>从镜像启动容器</strong>：通过 <code>docker run</code> 命令启动一个容器实例。</li></ul><h3 id=5-docker-container容器>5. <strong>Docker Container（容器）</strong>
<a class=anchor href=#5-docker-container%e5%ae%b9%e5%99%a8>#</a></h3><ul><li><strong>作用</strong>：Docker 容器是镜像的一个可执行实例。它是一个轻量级的、可移植的、封装了应用及其依赖环境的运行时环境。容器运行在宿主操作系统内，且与宿主系统隔离。</li><li><strong>常见操作</strong>：<code>docker start</code>、<code>docker stop</code>、<code>docker exec</code>、<code>docker logs</code> 等。</li><li><strong>隔离性</strong>：容器提供进程、网络、文件系统的隔离，但与宿主系统共享内核。</li></ul><h3 id=6-docker-volume数据卷>6. <strong>Docker Volume（数据卷）</strong>
<a class=anchor href=#6-docker-volume%e6%95%b0%e6%8d%ae%e5%8d%b7>#</a></h3><ul><li><strong>作用</strong>：Docker 卷是持久化和共享容器数据的机制，允许容器和主机共享数据或在多个容器之间共享数据。数据卷独立于容器的生命周期存在，即使容器被删除，数据卷中的数据仍然存在。</li><li><strong>常见操作</strong>：<code>docker volume create</code>、<code>docker volume inspect</code>、<code>docker volume rm</code>。</li></ul><h3 id=7-docker-network网络>7. <strong>Docker Network（网络）</strong>
<a class=anchor href=#7-docker-network%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><strong>作用</strong>：Docker 网络功能使容器能够互相通信。Docker 提供了几种网络模式，包括桥接网络（bridge）、主机网络（host）、覆盖网络（overlay）等。</li><li><strong>常见操作</strong>：<code>docker network create</code>、<code>docker network inspect</code>、<code>docker network connect</code>。</li></ul><h3 id=8-docker-swarm集群管理>8. <strong>Docker Swarm（集群管理）</strong>
<a class=anchor href=#8-docker-swarm%e9%9b%86%e7%be%a4%e7%ae%a1%e7%90%86>#</a></h3><ul><li><strong>作用</strong>：Docker Swarm 是 Docker 提供的集群管理和编排工具。它使得多个 Docker 主机可以联合起来，共同运行容器，形成一个集群，提供容器的负载均衡、服务发现、扩展性等功能。</li><li><strong>常见操作</strong>：<code>docker swarm init</code>（初始化集群）、<code>docker service create</code>（创建服务）、<code>docker node ls</code>（列出集群节点）。</li></ul><h3 id=9-docker-compose编排工具>9. <strong>Docker Compose（编排工具）</strong>
<a class=anchor href=#9-docker-compose%e7%bc%96%e6%8e%92%e5%b7%a5%e5%85%b7>#</a></h3><ul><li><strong>作用</strong>：Docker Compose 是一个工具，用于定义和运行多容器 Docker 应用。通过 <code>docker-compose.yml</code> 配置文件，用户可以定义多个容器服务的组成、配置及其之间的依赖关系，方便进行多容器环境的管理和部署。</li><li><strong>常见操作</strong>：<code>docker-compose up</code>（启动应用）、<code>docker-compose down</code>（停止应用）、<code>docker-compose build</code>（构建服务）。</li></ul><h3 id=10-docker-cli命令行工具>10. <strong>Docker CLI（命令行工具）</strong>
<a class=anchor href=#10-docker-cli%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%b7%a5%e5%85%b7>#</a></h3><ul><li><strong>作用</strong>：Docker CLI 是与 Docker 守护进程进行交互的命令行工具，允许用户通过命令行来操作 Docker，管理容器、镜像、网络、卷等。</li><li><strong>常见命令</strong>：<code>docker ps</code>（列出容器）、<code>docker run</code>（运行容器）、<code>docker build</code>（构建镜像）等。</li></ul><h3 id=总结-36>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-36>#</a></h3><p>Docker 的 CS 架构组件包括：</p><ol><li><strong>Docker Client</strong>：用户与 Docker 引擎交互的客户端。</li><li><strong>Docker Daemon</strong>：Docker 引擎，负责处理命令并管理容器、镜像等。</li><li><strong>Docker Registry</strong>：用于存储和分发镜像的仓库。</li><li><strong>Docker Image</strong>：容器的静态模板。</li><li><strong>Docker Container</strong>：镜像的运行实例，具有隔离性。</li><li><strong>Docker Volume</strong>：持久化容器数据。</li><li><strong>Docker Network</strong>：容器之间的网络通信管理。</li><li><strong>Docker Swarm</strong>：容器集群管理和编排工具。</li><li><strong>Docker Compose</strong>：用于管理和编排多个容器的工具。</li><li><strong>Docker CLI</strong>：命令行界面，允许与 Docker 引擎进行交互。</li></ol><p>这些组件共同作用，确保 Docker 提供高效、灵活、易于扩展的容器化平台。</p><h1 id=6-docker网络类型有哪些>6. docker网络类型有哪些？
<a class=anchor href=#6-docker%e7%bd%91%e7%bb%9c%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>host模式</li><li>container模式</li><li>none模式</li><li>bridge模式</li></ul><p>Docker 提供了几种不同的网络类型，以满足不同应用场景下的容器通信需求。以下是 Docker 支持的主要网络类型及其特点：</p><h3 id=1-bridge-network桥接网络>1. <strong>Bridge Network（桥接网络）</strong>
<a class=anchor href=#1-bridge-network%e6%a1%a5%e6%8e%a5%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p><strong>作用</strong>：这是 Docker 的默认网络模式。它在宿主机上创建一个虚拟的网络桥（bridge），容器会连接到这个网络上，所有容器共享此网络接口。容器之间通过桥接网络进行通信。</p></li><li><p><strong>特点</strong>：</p><ul><li>每个容器会获得一个私有 IP 地址，并且能够通过宿主机的 IP 地址与外界通信。</li><li>容器之间可以互相通信，但只能通过网络桥接接口（如 <code>docker0</code>）实现。</li><li>通常适用于单机环境，容器相互之间需要隔离但仍可以共享宿主机的网络。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>默认网络模式，适合单机环境下的容器通信。</li></ul></li><li><p><strong>常见命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create --driver bridge my_bridge_network
</span></span></code></pre></div></li></ul><h3 id=2-host-network主机网络>2. <strong>Host Network（主机网络）</strong>
<a class=anchor href=#2-host-network%e4%b8%bb%e6%9c%ba%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p><strong>作用</strong>：在这种模式下，容器直接使用宿主机的网络接口。容器不会获得独立的 IP 地址，而是与宿主机共享网络栈。</p></li><li><p><strong>特点</strong>：</p><ul><li>容器与宿主机共享网络 IP 和端口（容器中的端口映射到宿主机的端口）。</li><li>适用于要求低延迟和高性能的网络应用，因为它消除了网络隔离。</li><li>由于容器与宿主机共享网络，因此容器暴露的端口不会经过虚拟网络桥。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>性能要求高的场景，特别是需要访问宿主机网络资源的应用（如数据库连接、低延迟通信等）。</li></ul></li><li><p><strong>常见命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --network host my_container
</span></span></code></pre></div></li></ul><h3 id=3-overlay-network覆盖网络>3. <strong>Overlay Network（覆盖网络）</strong>
<a class=anchor href=#3-overlay-network%e8%a6%86%e7%9b%96%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p><strong>作用</strong>：覆盖网络是 Docker Swarm 模式下使用的网络类型，允许跨多个宿主机的容器之间进行通信。Overlay 网络使得分布式应用中的容器能够通过一个虚拟的网络在不同宿主机之间进行通信。</p></li><li><p><strong>特点</strong>：</p><ul><li>容器无需知道实际所在的宿主机，所有容器都可以使用相同的虚拟 IP 地址。</li><li>通过 VXLAN 隧道技术实现跨宿主机的容器网络连接。</li><li>适用于多主机集群中容器之间的通信，特别是 Docker Swarm 或 Kubernetes 集群中的容器通信。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>在 Docker Swarm 或 Kubernetes 等集群环境中使用，适合分布式微服务架构的部署。</li></ul></li><li><p><strong>常见命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create --driver overlay my_overlay_network
</span></span></code></pre></div></li></ul><h3 id=4-macvlan-networkmacvlan-网络>4. <strong>Macvlan Network（Macvlan 网络）</strong>
<a class=anchor href=#4-macvlan-networkmacvlan-%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p><strong>作用</strong>：Macvlan 网络为容器提供一个独立的 MAC 地址和 IP 地址，使得容器像物理设备一样直接连接到物理网络中。这种模式适合需要与物理网络设备直接通信的场景。</p></li><li><p><strong>特点</strong>：</p><ul><li>每个容器都有独立的 MAC 地址和 IP 地址，因此容器可以被视为网络中的独立设备。</li><li>容器可以直接与物理网络中的其他设备进行通信，如访问外部网络中的其他机器。</li><li>常用于要求容器与物理网络设备直接交互的情况，如通过 DHCP 获取 IP 地址等。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>容器需要与宿主机外的网络设备直接通信，或需要与其他物理主机共享网络。</li></ul></li><li><p><strong>常见命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create -d macvlan --subnet<span style=color:#f92672>=</span>192.168.1.0/24 --gateway<span style=color:#f92672>=</span>192.168.1.1 my_macvlan_network
</span></span></code></pre></div></li></ul><h3 id=5-none-network无网络>5. <strong>None Network（无网络）</strong>
<a class=anchor href=#5-none-network%e6%97%a0%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p><strong>作用</strong>：这种网络模式下，容器不会连接任何网络接口，也没有自己的 IP 地址。容器可以完全隔离与外界的网络通信。</p></li><li><p><strong>特点</strong>：</p><ul><li>容器没有网络接口，无法访问外部网络，适用于容器不需要网络连接的场景。</li><li>如果容器需要使用其他网络，可以通过自定义配置实现。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>对于某些需要完全隔离的容器，或者某些只处理计算任务而不需要网络连接的场景。</li></ul></li><li><p><strong>常见命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --network none my_container
</span></span></code></pre></div></li></ul><h3 id=6-container-network容器网络>6. <strong>Container Network（容器网络）</strong>
<a class=anchor href=#6-container-network%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p><strong>作用</strong>：容器网络是指通过 <code>--link</code> 选项将一个容器的网络连接到另一个容器。容器与容器之间通过共享网络栈来进行通信。</p></li><li><p><strong>特点</strong>：</p><ul><li>一个容器的网络栈被直接共享给另一个容器，使得两个容器之间能够直接通信。</li><li>容器共享 IP 地址和端口，适用于需要高度耦合的应用。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>当容器之间需要直接共享网络环境时，例如服务间需要高度耦合并直接访问对方网络资源。</li></ul></li><li><p><strong>常见命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --network container:&lt;container_name&gt; my_container
</span></span></code></pre></div></li></ul><h3 id=总结-37>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-37>#</a></h3><p>Docker 支持的网络类型包括：</p><ol><li><strong>Bridge Network</strong>：默认网络模式，适用于单机容器间的通信。</li><li><strong>Host Network</strong>：容器与宿主机共享网络，适用于高性能场景。</li><li><strong>Overlay Network</strong>：适用于 Docker Swarm 集群环境，跨主机容器通信。</li><li><strong>Macvlan Network</strong>：给容器分配独立的 MAC 地址和 IP 地址，适用于与物理网络直接通信。</li><li><strong>None Network</strong>：容器不使用任何网络接口，完全隔离。</li><li><strong>Container Network</strong>：容器间共享网络栈，适用于需要紧密耦合的应用。</li></ol><p>每种网络类型适用于不同的场景，根据你的应用需求选择合适的网络模式来保证容器间通信的效率与安全性。</p><h1 id=7-如何配置docker远程访问>7. 如何配置docker远程访问？
<a class=anchor href=#7-%e5%a6%82%e4%bd%95%e9%85%8d%e7%bd%aedocker%e8%bf%9c%e7%a8%8b%e8%ae%bf%e9%97%ae>#</a></h1><ul><li>vim /lib/systemd/system/docker.service</li><li>在ExecStart=后添加配置，注意，需要先空格后，再输入 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</li></ul><p>要配置 Docker 远程访问，需要修改 Docker 的配置，使其监听在一个可供远程访问的 IP 地址和端口上。以下是配置 Docker 远程访问的步骤：</p><h3 id=1-修改-docker-配置文件>1. 修改 Docker 配置文件
<a class=anchor href=#1-%e4%bf%ae%e6%94%b9-docker-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h3><p>默认情况下，Docker 只监听本地的 Unix Socket（<code>/var/run/docker.sock</code>），不允许远程访问。要启用远程访问，需要修改 Docker 的配置，使其监听 TCP 端口。</p><h4 id=步骤-11>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-11>#</a></h4><ol><li><p>打开 Docker 服务的配置文件，通常是 <code>/lib/systemd/system/docker.service</code> 或 <code>/etc/systemd/system/docker.service</code>，取决于你的 Linux 发行版和 Docker 的安装方式。</p></li><li><p>找到以 <code>ExecStart</code> 开头的行。它会指定 Docker 的启动命令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ExecStart<span style=color:#f92672>=</span>/usr/bin/dockerd --host<span style=color:#f92672>=</span>unix:///var/run/docker.sock
</span></span></code></pre></div><p>修改为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ExecStart<span style=color:#f92672>=</span>/usr/bin/dockerd --host<span style=color:#f92672>=</span>unix:///var/run/docker.sock --host<span style=color:#f92672>=</span>tcp://0.0.0.0:2375
</span></span></code></pre></div><p>这将使 Docker 同时监听 Unix Socket 和 0.0.0.0 的 TCP 端口 2375（所有 IP 地址的 2375 端口）。你可以根据需要修改监听的 IP 地址和端口。若只允许特定 IP 访问，可以将 <code>0.0.0.0</code> 改为服务器的实际 IP 地址，例如 <code>tcp://192.168.1.100:2375</code>。</p></li></ol><h3 id=2-配置防火墙>2. 配置防火墙
<a class=anchor href=#2-%e9%85%8d%e7%bd%ae%e9%98%b2%e7%81%ab%e5%a2%99>#</a></h3><p>确保防火墙允许访问 Docker 的 2375 端口。如果使用 <code>firewalld</code>，可以运行以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo firewall-cmd --zone<span style=color:#f92672>=</span>public --add-port<span style=color:#f92672>=</span>2375/tcp --permanent
</span></span><span style=display:flex><span>sudo firewall-cmd --reload
</span></span></code></pre></div><p>如果使用 <code>ufw</code>，可以执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ufw allow 2375/tcp
</span></span></code></pre></div><h3 id=3-重启-docker-服务>3. 重启 Docker 服务
<a class=anchor href=#3-%e9%87%8d%e5%90%af-docker-%e6%9c%8d%e5%8a%a1>#</a></h3><p>修改配置后，需要重启 Docker 服务使配置生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h3 id=4-测试远程访问>4. 测试远程访问
<a class=anchor href=#4-%e6%b5%8b%e8%af%95%e8%bf%9c%e7%a8%8b%e8%ae%bf%e9%97%ae>#</a></h3><p>在客户端机器上使用 Docker 命令连接远程 Docker 守护进程。</p><p>例如，使用以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker -H tcp://&lt;docker_host_ip&gt;:2375 info
</span></span></code></pre></div><p>如果配置成功，你应该能够看到 Docker 服务器的详细信息。</p><h3 id=5-使用-tls-安全连接推荐>5. 使用 TLS 安全连接（推荐）
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8-tls-%e5%ae%89%e5%85%a8%e8%bf%9e%e6%8e%a5%e6%8e%a8%e8%8d%90>#</a></h3><p>暴露 Docker 的远程访问接口时，默认是没有加密和认证的，任何可以访问该端口的人都能控制 Docker 服务。这非常不安全，尤其是在生产环境中。为确保安全，建议启用 TLS 加密和认证。</p><ol><li><p>生成 SSL 证书并配置 Docker 使用它们：</p><p>你可以使用 <code>openssl</code> 生成证书，或者使用 Let’s Encrypt 等证书提供商。</p></li><li><p>配置 Docker 使用证书和私钥：</p><p>修改 Docker 服务启动命令来指定证书和私钥：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ExecStart<span style=color:#f92672>=</span>/usr/bin/dockerd --host<span style=color:#f92672>=</span>tcp://0.0.0.0:2376 --tlsverify --tlscacert<span style=color:#f92672>=</span>/etc/docker/ca.pem --tlscert<span style=color:#f92672>=</span>/etc/docker/server-cert.pem --tlskey<span style=color:#f92672>=</span>/etc/docker/server-key.pem
</span></span></code></pre></div><p>在这种情况下，Docker 远程访问需要客户端提供相应的证书。</p></li></ol><h3 id=6-在客户端连接时使用-tls>6. 在客户端连接时使用 TLS
<a class=anchor href=#6-%e5%9c%a8%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bf%9e%e6%8e%a5%e6%97%b6%e4%bd%bf%e7%94%a8-tls>#</a></h3><p>客户端连接 Docker 服务时，必须使用 TLS 认证。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker --host<span style=color:#f92672>=</span>tcp://&lt;docker_host_ip&gt;:2376 --tlsverify --tlscacert<span style=color:#f92672>=</span>/path/to/ca.pem --tlscert<span style=color:#f92672>=</span>/path/to/cert.pem --tlskey<span style=color:#f92672>=</span>/path/to/key.pem info
</span></span></code></pre></div><h3 id=总结-38>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-38>#</a></h3><ul><li><strong>开放端口</strong>：修改 Docker 配置，监听 TCP 端口（如 2375）来允许远程访问。</li><li><strong>防火墙配置</strong>：确保防火墙允许外部访问 Docker 的端口。</li><li><strong>远程连接</strong>：通过 <code>docker -H tcp://&lt;docker_host_ip>:2375</code> 来进行远程连接。</li><li><strong>安全</strong>：建议使用 TLS 加密和认证来保护 Docker 远程接口，防止未授权的访问。</li></ul><p>通过以上步骤，你就可以配置 Docker 进行远程访问并与远程主机进行交互。</p><h1 id=8-docker核心namespace-cgroups-联合文件系统功能是什么>8. docker核心namespace CGroups 联合文件系统功能是什么？
<a class=anchor href=#8-docker%e6%a0%b8%e5%bf%83namespace-cgroups-%e8%81%94%e5%90%88%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e5%8a%9f%e8%83%bd%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>namespace：资源隔离</li><li>cgroup：资源控制</li><li>联合文件系统：支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下</li></ul><p>Docker 作为一个容器化平台，依赖于操作系统的几个核心技术来实现容器的轻量化和高效性。Docker 主要通过 <strong>Namespace</strong>、<strong>Cgroups</strong> 和 <strong>联合文件系统（Union File System）</strong> 来实现容器的隔离性、资源限制和文件系统共享。下面是这三种技术的功能和作用：</p><h3 id=1-namespace命名空间>1. <strong>Namespace（命名空间）</strong>
<a class=anchor href=#1-namespace%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4>#</a></h3><p><strong>命名空间（Namespace）</strong> 是 Linux 内核的一个特性，提供了对系统资源的隔离，使得每个容器都可以拥有独立的视图，而互相之间是隔离的。Docker 使用命名空间来确保容器之间的资源不会互相干扰。Docker 支持以下几种命名空间：</p><ul><li><p>PID Namespace（进程命名空间）</p><p>：</p><ul><li>每个容器有独立的进程 ID 空间。容器内的进程 ID 从 1 开始，和宿主机的进程 ID 是完全隔离的。这使得容器内的进程与宿主机或其他容器的进程互不干扰。</li></ul></li><li><p>NET Namespace（网络命名空间）</p><p>：</p><ul><li>每个容器有独立的网络栈，包括 IP 地址、路由表、网络接口、端口等。这样可以确保容器之间的网络是隔离的，不会互相干扰。</li></ul></li><li><p>MNT Namespace（挂载命名空间）</p><p>：</p><ul><li>每个容器可以拥有自己的文件系统挂载点，容器的挂载点与宿主机的文件系统是隔离的。这样可以使容器内的文件系统和宿主机或其他容器的文件系统互不干扰。</li></ul></li><li><p>UTS Namespace（UNIX时间命名空间）</p><p>：</p><ul><li>每个容器有独立的主机名和域名。容器内的主机名和域名与宿主机或其他容器的主机名和域名是隔离的。</li></ul></li><li><p>IPC Namespace（进程间通信命名空间）</p><p>：</p><ul><li>每个容器有独立的进程间通信资源（如共享内存、信号量、消息队列等）。这意味着容器内的进程不能与宿主机或其他容器中的进程共享内存或进行通信。</li></ul></li><li><p>USER Namespace（用户命名空间）</p><p>：</p><ul><li>容器内的用户和组 ID 被映射到宿主机的用户和组 ID，这可以有效地增强容器的安全性。容器内的 root 用户可以映射为宿主机上的非特权用户，从而降低安全风险。</li></ul></li></ul><p><strong>总结</strong>：命名空间的作用是 <strong>资源隔离</strong>，每个容器在自己的命名空间中拥有独立的资源视图，互不干扰。</p><h3 id=2-cgroups控制组>2. <strong>Cgroups（控制组）</strong>
<a class=anchor href=#2-cgroups%e6%8e%a7%e5%88%b6%e7%bb%84>#</a></h3><p><strong>Cgroups（Control Groups）</strong> 是 Linux 内核的一个特性，用于限制、控制和监控进程组的资源使用。Docker 利用 Cgroups 来限制每个容器使用的 CPU、内存、磁盘 I/O 和网络等资源，以确保资源的公平分配和容器的限制性使用。</p><ul><li><p>CPU 限制</p><p>：</p><ul><li>通过 Cgroups，可以为容器分配一定的 CPU 配额和权重，控制容器的 CPU 使用量。</li></ul></li><li><p>内存限制</p><p>：</p><ul><li>Cgroups 可以为容器指定最大内存使用量，一旦超过该限制，容器内的进程会被 OOM Killer 杀死，避免因内存耗尽导致系统崩溃。</li></ul></li><li><p>磁盘 I/O 限制</p><p>：</p><ul><li>Cgroups 可以限制容器的磁盘 I/O 性能，如读取和写入速度等，避免某些容器过度占用磁盘资源影响其他容器。</li></ul></li><li><p>网络带宽限制</p><p>：</p><ul><li>通过 Cgroups，容器的网络带宽也可以被控制和限制。</li></ul></li></ul><p><strong>总结</strong>：Cgroups 的作用是 <strong>资源限制和管理</strong>，它确保每个容器使用的资源不会超出预定的限制，防止某个容器占用过多资源导致其他容器和宿主机资源不足。</p><h3 id=3-union-file-system联合文件系统>3. <strong>Union File System（联合文件系统）</strong>
<a class=anchor href=#3-union-file-system%e8%81%94%e5%90%88%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h3><p><strong>联合文件系统（Union FS）</strong> 是一种文件系统，它允许将多个目录合并成一个虚拟的文件系统。Docker 使用联合文件系统来实现容器文件系统的共享和隔离，从而避免重复的数据存储。</p><ul><li><strong>层叠存储</strong>：<ul><li>Docker 使用 Union File System（如 AUFS、OverlayFS、Btrfs、ZFS 等）来将多个文件系统层叠在一起，形成一个单一的文件系统。每个容器的文件系统由多个只读层和一个可写层组成。容器启动时，会从镜像中加载文件系统的只读层，而容器写入的数据会存储在容器的可写层中。</li></ul></li><li><strong>镜像共享</strong>：<ul><li>镜像的每一层是不可修改的，可以被多个容器共享。这使得容器能够快速启动并节省磁盘空间，因为不同容器共享相同的镜像层，只为容器的个性化修改保留单独的可写层。</li></ul></li><li><strong>文件系统效率</strong>：<ul><li>由于文件系统层是基于差异（如只读层与可写层的差异），容器不会浪费存储空间来重复存储相同的数据，从而提高了文件系统的效率和节省存储空间。</li></ul></li></ul><p><strong>总结</strong>：联合文件系统的作用是 <strong>高效的存储和层叠文件系统</strong>，它通过文件系统的层叠存储，使得容器能够共享镜像层、节省存储空间并提高性能。</p><hr><h3 id=综合总结>综合总结：
<a class=anchor href=#%e7%bb%bc%e5%90%88%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong>Namespace</strong> 提供了容器之间的 <strong>资源隔离</strong>，每个容器都有独立的资源视图。</li><li><strong>Cgroups</strong> 用于 <strong>资源限制</strong>，保证容器不会占用过多的 CPU、内存等资源。</li><li><strong>Union File System</strong> 实现了容器文件系统的 <strong>共享和高效存储</strong>，通过层叠文件系统降低存储浪费，提高效率。</li></ul><p>这三种技术共同作用，使得 Docker 能够在保证容器资源隔离、限制和高效存储的同时，提供轻量级和高性能的容器化解决方案。</p><h1 id=9-命令相关导入导出镜像进入容器设置重启容器策略查看镜像环境变量查看容器占用资源>9. 命令相关：导入导出镜像，进入容器，设置重启容器策略，查看镜像环境变量，查看容器占用资源
<a class=anchor href=#9-%e5%91%bd%e4%bb%a4%e7%9b%b8%e5%85%b3%e5%af%bc%e5%85%a5%e5%af%bc%e5%87%ba%e9%95%9c%e5%83%8f%e8%bf%9b%e5%85%a5%e5%ae%b9%e5%99%a8%e8%ae%be%e7%bd%ae%e9%87%8d%e5%90%af%e5%ae%b9%e5%99%a8%e7%ad%96%e7%95%a5%e6%9f%a5%e7%9c%8b%e9%95%9c%e5%83%8f%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e6%9f%a5%e7%9c%8b%e5%ae%b9%e5%99%a8%e5%8d%a0%e7%94%a8%e8%b5%84%e6%ba%90>#</a></h1><ul><li>导入镜像 docker load -i xx.tar</li><li>导出镜像docker save -o xx.tar image_name</li><li>进入容器docker exec -it 容器命令 /bin/bash</li><li>设置容器重启策略启动时 &ndash;restart选项</li><li>查看容器环境变量 docker exec {containerID} env</li><li>查看容器资源占用docker stats test2</li></ul><p>以下是 Docker 常用命令及其用途，帮助你完成常见操作：</p><h3 id=1-导入和导出镜像>1. <strong>导入和导出镜像</strong>
<a class=anchor href=#1-%e5%af%bc%e5%85%a5%e5%92%8c%e5%af%bc%e5%87%ba%e9%95%9c%e5%83%8f>#</a></h3><ul><li><p><strong>导入镜像</strong>（从 tar 包导入镜像）：</p><p>将一个 tar 文件（例如备份的镜像）导入到 Docker 本地镜像中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker import /path/to/your/image.tar
</span></span></code></pre></div><p>你也可以指定标签（tag）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker import /path/to/your/image.tar my_image:tag
</span></span></code></pre></div></li><li><p><strong>导出镜像</strong>（将容器文件系统导出为 tar 包）：</p><p>从容器中导出文件系统为 tar 包：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker export &lt;container_id&gt; &gt; /path/to/your/container_backup.tar
</span></span></code></pre></div><p>这将导出容器的文件系统，但不会导出镜像层。</p></li></ul><h3 id=2-进入容器>2. <strong>进入容器</strong>
<a class=anchor href=#2-%e8%bf%9b%e5%85%a5%e5%ae%b9%e5%99%a8>#</a></h3><p>使用 <code>docker exec</code> 命令进入正在运行的容器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker exec -it &lt;container_id_or_name&gt; /bin/bash
</span></span></code></pre></div><ul><li><code>-i</code>：保持标准输入流（stdin）打开，允许你与容器交互。</li><li><code>-t</code>：为容器分配一个伪终端。</li></ul><p>如果容器内没有 <code>/bin/bash</code>，可以尝试 <code>/bin/sh</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker exec -it &lt;container_id_or_name&gt; /bin/sh
</span></span></code></pre></div><h3 id=3-设置重启策略>3. <strong>设置重启策略</strong>
<a class=anchor href=#3-%e8%ae%be%e7%bd%ae%e9%87%8d%e5%90%af%e7%ad%96%e7%95%a5>#</a></h3><p>使用 <code>--restart</code> 标志设置容器的重启策略，确保容器在特定情况下自动重启。常见的重启策略包括：</p><ul><li><strong>no</strong>：默认值，容器退出时不重启。</li><li><strong>always</strong>：容器退出时始终重启。</li><li><strong>unless-stopped</strong>：容器退出时重启，除非它被手动停止。</li><li><strong>on-failure</strong>：只有在容器非零退出时才会重启。</li></ul><p>例如，创建一个总是重启的容器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d --restart always my_image
</span></span></code></pre></div><p>或者，修改现有容器的重启策略：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker update --restart always &lt;container_id_or_name&gt;
</span></span></code></pre></div><h3 id=4-查看镜像环境变量>4. <strong>查看镜像环境变量</strong>
<a class=anchor href=#4-%e6%9f%a5%e7%9c%8b%e9%95%9c%e5%83%8f%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f>#</a></h3><p>要查看镜像中的环境变量，可以使用以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker inspect --format <span style=color:#e6db74>&#39;{{.Config.Env}}&#39;</span> &lt;image_id_or_name&gt;
</span></span></code></pre></div><p>这将返回镜像中定义的环境变量列表。</p><p>如果你想查看容器的环境变量，可以执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker exec &lt;container_id_or_name&gt; printenv
</span></span></code></pre></div><p>这将显示容器内所有的环境变量。</p><h3 id=5-查看容器占用资源>5. <strong>查看容器占用资源</strong>
<a class=anchor href=#5-%e6%9f%a5%e7%9c%8b%e5%ae%b9%e5%99%a8%e5%8d%a0%e7%94%a8%e8%b5%84%e6%ba%90>#</a></h3><p>要查看容器的资源使用情况，可以使用以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker stats &lt;container_id_or_name&gt;
</span></span></code></pre></div><p>这将显示容器的 CPU 使用率、内存使用、网络 I/O 等实时信息。</p><ul><li><p><code>docker stats</code> 命令会持续输出资源使用情况，直到你按 <code>Ctrl + C</code> 停止。</p></li><li><p>要查看所有容器的资源使用情况，可以不指定容器 ID，直接运行 <code>docker stats</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker stats
</span></span></code></pre></div></li></ul><p>这个命令显示的是容器实时的资源消耗情况，可以帮助你识别资源瓶颈。</p><hr><p>总结：</p><ul><li><strong>导入镜像</strong>：<code>docker import</code></li><li><strong>导出容器文件系统</strong>：<code>docker export</code></li><li><strong>进入容器</strong>：<code>docker exec -it &lt;container_id> /bin/bash</code></li><li><strong>设置重启策略</strong>：<code>--restart</code> 或 <code>docker update --restart</code></li><li><strong>查看镜像环境变量</strong>：<code>docker inspect --format '{{.Config.Env}}'</code></li><li><strong>查看容器占用资源</strong>：<code>docker stats</code></li></ul><h1 id=10-构建镜像有哪些方式>10. 构建镜像有哪些方式？
<a class=anchor href=#10-%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8f%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e5%bc%8f>#</a></h1><ul><li>dockerfile</li><li>容器提交为镜像</li></ul><p>构建 Docker 镜像的方式有多种，常见的方式包括使用 Dockerfile、通过 <code>docker commit</code> 命令以及从已有镜像创建自定义镜像。以下是详细介绍：</p><h3 id=1-通过-dockerfile-构建镜像>1. <strong>通过 Dockerfile 构建镜像</strong>
<a class=anchor href=#1-%e9%80%9a%e8%bf%87-dockerfile-%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8f>#</a></h3><p>最常见的方式是使用 <code>Dockerfile</code> 构建镜像。<code>Dockerfile</code> 是一组指令，用于定义镜像的构建过程。每一条指令都会创建一个新的镜像层。</p><ul><li><p><strong>步骤</strong>：</p><ol><li>编写 <code>Dockerfile</code>，并指定基础镜像、安装应用、配置环境等。</li><li>使用 <code>docker build</code> 命令来构建镜像。</li></ol></li><li><p><strong>示例 Dockerfile</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># 使用官方的 Ubuntu 镜像作为基础镜像</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ubuntu:20.04</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 设置维护者信息</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> maintainer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;yourname@example.com&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 安装必要的软件包</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  curl <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  vim<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 设置工作目录</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 复制文件到容器中</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . /app<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 设置容器的启动命令</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;python3&#34;</span>, <span style=color:#e6db74>&#34;app.py&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li><li><p><strong>构建命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build -t my_image_name:tag .
</span></span></code></pre></div><ul><li><code>-t my_image_name:tag</code>：指定镜像的名称和标签（例如 <code>my_image_name:latest</code>）。</li><li><code>.</code>：指定 <code>Dockerfile</code> 的路径，<code>.</code> 表示当前目录。</li></ul></li></ul><hr><h3 id=2-使用-3>2. <strong>使用 <code>docker commit</code> 构建镜像</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-3>#</a></h3><p>如果你已经运行了一个容器，并且对容器进行了某些修改（比如安装了软件包或改变了配置），你可以通过 <code>docker commit</code> 命令将容器的当前状态保存为一个新的镜像。</p><ul><li><p><strong>步骤</strong>：</p><ol><li>启动一个容器并对其进行修改。</li><li>使用 <code>docker commit</code> 命令将容器的当前状态保存为一个新的镜像。</li></ol></li><li><p><strong>命令</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker commit &lt;container_id_or_name&gt; &lt;new_image_name&gt;:&lt;tag&gt;
</span></span></code></pre></div><ul><li><code>container_id_or_name</code>：容器的 ID 或名称。</li><li><code>new_image_name:tag</code>：要创建的镜像的名称和标签。</li></ul></li><li><p><strong>示例</strong>：</p><p>假设你已经运行了一个容器，并且在容器中安装了一个新的软件包：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker commit my_container my_new_image:v1
</span></span></code></pre></div><p>这样，你就创建了一个新的镜像 <code>my_new_image:v1</code>，其中包含你在容器中所做的修改。</p></li></ul><hr><h3 id=3-从现有镜像创建自定义镜像>3. <strong>从现有镜像创建自定义镜像</strong>
<a class=anchor href=#3-%e4%bb%8e%e7%8e%b0%e6%9c%89%e9%95%9c%e5%83%8f%e5%88%9b%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89%e9%95%9c%e5%83%8f>#</a></h3><p>你也可以基于现有的镜像，手动修改容器并保存为新的镜像。这通常是通过交互式地进入容器进行修改，然后使用 <code>docker commit</code> 命令保存这些修改。</p><ul><li><p><strong>步骤</strong>：</p><ol><li>启动一个容器并进入容器。</li><li>在容器内部进行修改。</li><li>使用 <code>docker commit</code> 保存容器的状态为新镜像。</li></ol></li><li><p><strong>命令</strong>：</p><ol><li><p>启动容器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -it ubuntu:20.04 /bin/bash
</span></span></code></pre></div></li><li><p>在容器内做一些修改（例如安装软件）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y curl
</span></span></code></pre></div></li><li><p>退出容器后，使用 <code>docker commit</code> 创建一个新的镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker commit &lt;container_id&gt; my_custom_image:v1
</span></span></code></pre></div></li></ol></li></ul><hr><h3 id=4-通过>4. <strong>通过 <code>docker buildx</code> 构建多平台镜像</strong>
<a class=anchor href=#4-%e9%80%9a%e8%bf%87>#</a></h3><p><code>docker buildx</code> 是 Docker 提供的一个构建工具，支持构建跨平台的多架构镜像（如 ARM、x86）。</p><ul><li><p><strong>步骤</strong>：</p><ol><li>使用 <code>docker buildx</code> 创建支持多平台的镜像。</li><li>需要安装 <code>buildx</code> 插件并启用多平台支持。</li></ol></li><li><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker buildx create --use
</span></span><span style=display:flex><span>docker buildx build --platform linux/amd64,linux/arm64 -t my_multiarch_image .
</span></span></code></pre></div></li></ul><hr><h3 id=5-使用-buildkit-构建镜像>5. <strong>使用 BuildKit 构建镜像</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8-buildkit-%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8f>#</a></h3><p><strong>Docker BuildKit</strong> 是 Docker 18.09 引入的一个功能，提供了更快、更高效、更灵活的构建方式。</p><ul><li><p><strong>启用 BuildKit</strong>：</p><p>通过设置环境变量启用 BuildKit：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export DOCKER_BUILDKIT<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>然后使用 <code>docker build</code> 命令构建镜像：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build -t my_image_name:tag .
</span></span></code></pre></div></li><li><p><strong>优势</strong>：</p><ul><li>支持缓存优化、并行构建、以及更精细的构建控制。</li><li>提供更强的支持来构建多阶段构建（multi-stage builds）。</li></ul></li></ul><hr><h3 id=6-使用-docker-compose-构建镜像>6. <strong>使用 Docker Compose 构建镜像</strong>
<a class=anchor href=#6-%e4%bd%bf%e7%94%a8-docker-compose-%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8f>#</a></h3><p>如果你使用 <strong>Docker Compose</strong> 来管理多个容器，可以通过 <code>docker-compose.yml</code> 文件来定义镜像的构建过程。</p><ul><li><p><strong>步骤</strong>：</p><ol><li>在 <code>docker-compose.yml</code> 文件中定义服务。</li><li>使用 <code>docker-compose build</code> 构建镜像。</li></ol></li><li><p><strong>示例 <code>docker-compose.yml</code> 文件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;80:80&#34;</span>
</span></span></code></pre></div><ul><li><code>build: .</code> 表示使用当前目录下的 <code>Dockerfile</code> 构建镜像。</li></ul></li><li><p><strong>构建镜像</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker-compose build
</span></span></code></pre></div></li></ul><hr><h3 id=总结-39>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-39>#</a></h3><ol><li><strong>Dockerfile 构建镜像</strong>：标准的镜像构建方式，灵活、可复用，适用于复杂的镜像构建。</li><li><strong>docker commit 构建镜像</strong>：通过修改容器并保存为镜像，适用于快速创建镜像，通常不推荐用于生产环境。</li><li><strong>现有镜像创建自定义镜像</strong>：手动修改容器后，通过 <code>docker commit</code> 保存修改，适用于基于已有镜像做定制化开发。</li><li><strong>docker buildx 构建多平台镜像</strong>：支持跨平台架构构建，适用于构建多种平台的镜像。</li><li><strong>Docker BuildKit</strong>：提供更高效的构建，支持并行构建和缓存优化，适用于复杂的构建场景。</li><li><strong>Docker Compose 构建镜像</strong>：适用于多容器应用的镜像构建和管理。</li></ol><p>这些方法可以根据项目需求、工作流程和团队协作的需要来选择。</p><h1 id=11-docker和vmware虚拟化区别>11. docker和vmware虚拟化区别？
<a class=anchor href=#11-docker%e5%92%8cvmware%e8%99%9a%e6%8b%9f%e5%8c%96%e5%8c%ba%e5%88%ab>#</a></h1><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012702230.png alt></p><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012754816.png alt=image-20250224012754816></p><p>Docker 和 VMware 都是虚拟化技术，但它们的工作原理和使用场景有很大的不同。以下是它们的主要区别：</p><h3 id=1-虚拟化类型>1. <strong>虚拟化类型</strong>
<a class=anchor href=#1-%e8%99%9a%e6%8b%9f%e5%8c%96%e7%b1%bb%e5%9e%8b>#</a></h3><ul><li><strong>Docker（容器化）</strong>：Docker 是一种 <strong>操作系统级虚拟化</strong> 技术，基于 Linux 内核的 <strong>cgroups</strong> 和 <strong>namespace</strong> 实现。容器在共享宿主机操作系统内核的基础上运行，每个容器是一个独立的用户空间环境，但它们共享宿主操作系统的内核。</li><li><strong>VMware（虚拟机）</strong>：VMware 是一种 <strong>硬件级虚拟化</strong> 技术，使用虚拟机管理程序（Hypervisor）直接在硬件上创建和管理多个虚拟机（VM）。每个虚拟机都包含一个完整的操作系统，包括内核和用户空间。</li></ul><h3 id=2-资源开销>2. <strong>资源开销</strong>
<a class=anchor href=#2-%e8%b5%84%e6%ba%90%e5%bc%80%e9%94%80>#</a></h3><ul><li><strong>Docker</strong>：容器是共享宿主操作系统内核的，因此启动速度快，资源占用低，不需要为每个容器分配完整的操作系统。Docker 容器的资源开销相对较小。</li><li><strong>VMware</strong>：虚拟机包含完整的操作系统和虚拟化的硬件资源，因此每个虚拟机的启动速度较慢，资源开销也较大。每个虚拟机都需要分配一定的内存、CPU、存储等硬件资源。</li></ul><h3 id=3-启动时间>3. <strong>启动时间</strong>
<a class=anchor href=#3-%e5%90%af%e5%8a%a8%e6%97%b6%e9%97%b4>#</a></h3><ul><li><strong>Docker</strong>：容器启动速度非常快，通常只需几秒钟。因为容器仅包含运行应用程序所需的文件系统和依赖，它们不会像虚拟机一样加载完整的操作系统。</li><li><strong>VMware</strong>：虚拟机启动速度相对较慢，需要加载整个操作系统，并进行硬件初始化，通常需要几分钟。</li></ul><h3 id=4-隔离级别>4. <strong>隔离级别</strong>
<a class=anchor href=#4-%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab>#</a></h3><ul><li><strong>Docker</strong>：容器共享宿主机操作系统的内核，容器之间的隔离度较低。虽然 Docker 使用了 cgroups 和 namespaces 来实现一定程度的资源隔离和安全性，但容器间仍然存在一定的安全风险。</li><li><strong>VMware</strong>：虚拟机完全隔离，虚拟机之间的资源是完全独立的，每个虚拟机运行自己的操作系统和内核，因此隔离性更强，安全性较高。</li></ul><h3 id=5-性能>5. <strong>性能</strong>
<a class=anchor href=#5-%e6%80%a7%e8%83%bd>#</a></h3><ul><li><strong>Docker</strong>：由于容器直接运行在宿主操作系统上，资源占用少，性能接近宿主机本身的性能。容器化应用在性能方面相对虚拟机来说更加高效。</li><li><strong>VMware</strong>：虚拟机需要模拟硬件资源，运行完整的操作系统，因此性能相较于容器会有一定的损耗。尤其是当虚拟机数量增多时，性能下降会更加明显。</li></ul><h3 id=6-操作系统支持>6. <strong>操作系统支持</strong>
<a class=anchor href=#6-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%94%af%e6%8c%81>#</a></h3><ul><li><strong>Docker</strong>：容器通常需要依赖宿主操作系统的内核。例如，Docker 在 Linux 上运行的容器使用 Linux 内核，而在 Windows 上的容器则使用 Windows 内核。Docker 仅能在兼容的操作系统上运行。</li><li><strong>VMware</strong>：虚拟机可以运行不同的操作系统（包括 Linux、Windows、macOS 等），每个虚拟机都带有完整的操作系统和内核，因此可以在同一硬件上运行不同的操作系统。</li></ul><h3 id=7-应用场景>7. <strong>应用场景</strong>
<a class=anchor href=#7-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><ul><li><p>Docker</p><p>：</p><ul><li><strong>微服务架构</strong>：由于容器启动快、资源消耗少，适合部署微服务应用。</li><li><strong>开发和测试</strong>：开发人员可以使用 Docker 快速构建、共享和运行应用程序，方便测试和持续集成。</li><li><strong>CI/CD</strong>：容器化环境使得持续集成和持续交付变得更加高效，能够快速迭代和部署应用。</li></ul></li><li><p>VMware</p><p>：</p><ul><li><strong>虚拟化数据中心</strong>：VMware 是数据中心虚拟化的主流技术，适合企业级虚拟化部署。可以虚拟化整个服务器，提供资源的独立性和完整性。</li><li><strong>多种操作系统支持</strong>：适合需要多种不同操作系统和软件栈的场景，如同时运行多个操作系统。</li><li><strong>企业级高可用性</strong>：VMware 提供了包括高可用性、容错、灾难恢复等企业级功能。</li></ul></li></ul><h3 id=8-资源分配>8. <strong>资源分配</strong>
<a class=anchor href=#8-%e8%b5%84%e6%ba%90%e5%88%86%e9%85%8d>#</a></h3><ul><li><strong>Docker</strong>：容器使用宿主机的操作系统内核，通常直接共享宿主机的硬件资源（CPU、内存、磁盘等）。Docker 支持资源限制（如 CPU 限制、内存限制等），但不会像虚拟机那样为每个容器分配完整的虚拟硬件资源。</li><li><strong>VMware</strong>：每个虚拟机都有自己的虚拟硬件（包括 CPU、内存、硬盘等），需要为每个虚拟机分配特定的资源。虚拟机的资源管理通常更加独立。</li></ul><h3 id=9-迁移与扩展性>9. <strong>迁移与扩展性</strong>
<a class=anchor href=#9-%e8%bf%81%e7%a7%bb%e4%b8%8e%e6%89%a9%e5%b1%95%e6%80%a7>#</a></h3><ul><li><strong>Docker</strong>：容器的迁移通常更简单，可以轻松将容器从一台机器迁移到另一台机器上。Docker 也支持在云环境中快速扩展和部署。</li><li><strong>VMware</strong>：虚拟机迁移和扩展通常需要更多的配置和资源调配，尤其是在跨不同硬件和虚拟化平台时。VMware 提供了 vMotion 等工具来实现虚拟机迁移，但仍然比容器迁移要复杂。</li></ul><hr><h3 id=总结-40>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-40>#</a></h3><ul><li><strong>Docker</strong> 更加轻量级，适合应用级别的虚拟化，资源开销小，启动速度快，适用于微服务、开发/测试环境和 CI/CD 等场景。</li><li><strong>VMware</strong> 更适合进行硬件虚拟化，提供完全的隔离和更强的安全性，适合运行不同操作系统的虚拟机，常用于企业级数据中心和多操作系统支持的场景。</li></ul><p>根据需求，选择适合的虚拟化技术可以更高效地利用资源。</p><h1 id=五kubernetes>五、kubernetes
<a class=anchor href=#%e4%ba%94kubernetes>#</a></h1><h1 id=1-k8s的集群组件有哪些功能是什么>1. k8s的集群组件有哪些？功能是什么？
<a class=anchor href=#1-k8s%e7%9a%84%e9%9b%86%e7%be%a4%e7%bb%84%e4%bb%b6%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012826510.png alt=image-20250224012826510></p><p>Kubernetes（K8s）是一个开源的容器编排平台，旨在自动化容器化应用程序的部署、扩展和管理。K8s 集群由多个组件组成，主要分为 <strong>控制平面</strong>（Control Plane）和 <strong>工作节点</strong>（Node）。以下是 Kubernetes 集群的核心组件及其功能：</p><h3 id=1-控制平面组件>1. <strong>控制平面组件</strong>
<a class=anchor href=#1-%e6%8e%a7%e5%88%b6%e5%b9%b3%e9%9d%a2%e7%bb%84%e4%bb%b6>#</a></h3><p>控制平面负责管理 Kubernetes 集群，处理所有的控制任务，确保集群的工作状态与期望状态一致。</p><h4 id=11-kube-apiserver>1.1 <strong>kube-apiserver</strong>
<a class=anchor href=#11-kube-apiserver>#</a></h4><ul><li><strong>功能</strong>：API 服务器是 Kubernetes 控制平面的入口点。它接收来自客户端（如 kubectl）、内部组件（如 kube-scheduler 和 kube-controller-manager）和外部系统的 REST 请求，并将其转发到适当的组件。API 服务器也提供了集群的配置和状态信息接口。</li><li><strong>作用</strong>：作为集群的前端，所有的操作和请求都通过它，所有的对象都在 etcd 中存储，通过它进行 CRUD 操作。</li></ul><h4 id=12-etcd>1.2 <strong>etcd</strong>
<a class=anchor href=#12-etcd>#</a></h4><ul><li><strong>功能</strong>：etcd 是一个高可用的键值存储数据库，存储 Kubernetes 集群的所有配置数据、状态信息和元数据。</li><li><strong>作用</strong>：所有的集群数据（如节点、Pod、服务等资源对象）都保存在 etcd 中。它是 Kubernetes 的 &ldquo;单一数据源&rdquo;，保证了集群数据的持久性。</li></ul><h4 id=13-kube-scheduler>1.3 <strong>kube-scheduler</strong>
<a class=anchor href=#13-kube-scheduler>#</a></h4><ul><li><strong>功能</strong>：kube-scheduler 是 Kubernetes 控制平面的一个组件，负责监控待调度的 Pod，并根据一系列调度策略将其分配到合适的工作节点上。</li><li><strong>作用</strong>：它根据集群的资源情况、约束条件和调度策略将 Pod 分配到最合适的节点上，确保负载均衡和资源的合理利用。</li></ul><h4 id=14-kube-controller-manager>1.4 <strong>kube-controller-manager</strong>
<a class=anchor href=#14-kube-controller-manager>#</a></h4><ul><li><strong>功能</strong>：kube-controller-manager 是一个控制器的集合，管理 Kubernetes 集群中各类控制循环。每个控制器负责监视集群的某个资源，并根据需要采取行动。</li><li><strong>作用</strong>：如：ReplicaSet 控制器确保有指定数量的 Pod 副本在运行，Deployment 控制器管理应用程序的版本升级等。</li></ul><h4 id=15-cloud-controller-manager>1.5 <strong>cloud-controller-manager</strong>
<a class=anchor href=#15-cloud-controller-manager>#</a></h4><ul><li><strong>功能</strong>：cloud-controller-manager 是 Kubernetes 控制平面的一个可选组件，旨在与云服务提供商的 API 进行集成。它使得 Kubernetes 可以与不同的云平台（如 AWS、GCP、Azure）进行交互。</li><li><strong>作用</strong>：它通过与云平台的 API 交互，管理节点、负载均衡器和存储卷等云资源。</li></ul><h3 id=2-工作节点组件>2. <strong>工作节点组件</strong>
<a class=anchor href=#2-%e5%b7%a5%e4%bd%9c%e8%8a%82%e7%82%b9%e7%bb%84%e4%bb%b6>#</a></h3><p>工作节点负责运行容器化应用和服务，承载实际的业务负载。</p><h4 id=21-kubelet>2.1 <strong>kubelet</strong>
<a class=anchor href=#21-kubelet>#</a></h4><ul><li><strong>功能</strong>：kubelet 是运行在每个工作节点上的代理，负责管理该节点上的容器和 Pod。它与 Kubernetes API 服务器进行通信，确保容器按照预期运行。</li><li><strong>作用</strong>：它从 API 服务器获取 Pod 描述，并确保 Pod 中的容器处于运行状态。如果容器崩溃，kubelet 会重新启动它们。</li></ul><h4 id=22-kube-proxy>2.2 <strong>kube-proxy</strong>
<a class=anchor href=#22-kube-proxy>#</a></h4><ul><li><strong>功能</strong>：kube-proxy 是一个网络代理，运行在每个节点上，负责处理 Pod 的网络通信。它通过负载均衡将流量路由到合适的 Pod 中。</li><li><strong>作用</strong>：提供服务抽象（如 Kubernetes 服务），并将流量从集群外部或集群内部路由到正确的 Pod。它可以使用 iptables 或 IPVS 来实现负载均衡。</li></ul><h4 id=23-container-runtime>2.3 <strong>Container Runtime</strong>
<a class=anchor href=#23-container-runtime>#</a></h4><ul><li><strong>功能</strong>：容器运行时是负责在节点上运行容器的工具，kubelet 会调用容器运行时来创建和管理容器。Kubernetes 支持多种容器运行时（如 Docker、containerd、CRI-O 等）。</li><li><strong>作用</strong>：它是运行容器的基础，负责容器的生命周期管理（如拉取镜像、启动容器等）。</li></ul><h3 id=3-其他组件>3. <strong>其他组件</strong>
<a class=anchor href=#3-%e5%85%b6%e4%bb%96%e7%bb%84%e4%bb%b6>#</a></h3><p>这些组件有助于集群的管理、监控和运行。</p><h4 id=31-helm>3.1 <strong>Helm</strong>
<a class=anchor href=#31-helm>#</a></h4><ul><li><strong>功能</strong>：Helm 是 Kubernetes 的包管理工具，类似于 Linux 的 apt 或 yum，它使得在 Kubernetes 中部署应用变得更加简单。</li><li><strong>作用</strong>：Helm 使用 <strong>Charts</strong>（Kubernetes 应用程序的包）来管理和部署应用程序，支持版本控制和应用配置的共享。</li></ul><h4 id=32-ingress-controller>3.2 <strong>Ingress Controller</strong>
<a class=anchor href=#32-ingress-controller>#</a></h4><ul><li><strong>功能</strong>：Ingress Controller 负责处理进出 Kubernetes 集群的 HTTP 和 HTTPS 流量。它可以通过设置规则，将外部流量路由到集群内部的服务。</li><li><strong>作用</strong>：它通过配置 Ingress 资源，定义外部访问 Kubernetes 服务的 URL 路由规则。</li></ul><h4 id=33-cni-插件>3.3 <strong>CNI 插件</strong>
<a class=anchor href=#33-cni-%e6%8f%92%e4%bb%b6>#</a></h4><ul><li><strong>功能</strong>：CNI（Container Network Interface）插件提供容器网络功能，它决定了 Pod 和服务之间如何进行通信。</li><li><strong>作用</strong>：它是容器网络的重要组成部分，负责容器之间的网络连接和网络策略的执行。常见的 CNI 插件有 Flannel、Calico、Weave 等。</li></ul><h4 id=34-监控与日志管理>3.4 <strong>监控与日志管理</strong>
<a class=anchor href=#34-%e7%9b%91%e6%8e%a7%e4%b8%8e%e6%97%a5%e5%bf%97%e7%ae%a1%e7%90%86>#</a></h4><ul><li><strong>功能</strong>：监控工具（如 Prometheus 和 Grafana）和日志管理工具（如 ELK Stack、Fluentd）用于收集和展示集群及容器的监控指标、日志信息。</li><li><strong>作用</strong>：通过监控和日志收集，可以及时发现系统问题、优化资源、提升可用性。</li></ul><hr><h3 id=总结-41>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-41>#</a></h3><p>Kubernetes 集群的核心组件包括 <strong>控制平面组件</strong>（kube-apiserver、etcd、kube-scheduler、kube-controller-manager、cloud-controller-manager）和 <strong>工作节点组件</strong>（kubelet、kube-proxy、容器运行时）。这些组件协同工作，保证集群的高效运行与自动化管理，同时也有助于扩展、监控和维护 Kubernetes 集群。</p><h1 id=2-kubectl命令相关如何修改副本数如何滚动更新和回滚如何查看pod的详细信息如何进入pod交互>2. kubectl命令相关：如何修改副本数，如何滚动更新和回滚，如何查看pod的详细信息，如何进入pod交互？
<a class=anchor href=#2-kubectl%e5%91%bd%e4%bb%a4%e7%9b%b8%e5%85%b3%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9%e5%89%af%e6%9c%ac%e6%95%b0%e5%a6%82%e4%bd%95%e6%bb%9a%e5%8a%a8%e6%9b%b4%e6%96%b0%e5%92%8c%e5%9b%9e%e6%bb%9a%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8bpod%e7%9a%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af%e5%a6%82%e4%bd%95%e8%bf%9b%e5%85%a5pod%e4%ba%a4%e4%ba%92>#</a></h1><ul><li>修改副本数 kubectl scale deployment redis &ndash;replicas=3</li><li>活动更新kubectl set image deployments myapp-deploy myapp=myapp:v2</li><li>回滚kubectl rollout undo deployments myapp-deploy</li><li>查看pod详细信息kubectl describe pods/</li><li>进入pod交互kubectl exec -it -c bash</li></ul><p>以下是 <code>kubectl</code> 命令相关操作，用于修改副本数、滚动更新、回滚、查看 Pod 的详细信息以及进入 Pod 进行交互。</p><h3 id=1-修改副本数>1. <strong>修改副本数</strong>
<a class=anchor href=#1-%e4%bf%ae%e6%94%b9%e5%89%af%e6%9c%ac%e6%95%b0>#</a></h3><p>要修改部署（Deployment）中 Pod 的副本数，可以使用 <code>kubectl scale</code> 命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale deployment &lt;deployment-name&gt; --replicas<span style=color:#f92672>=</span>&lt;number-of-replicas&gt;
</span></span></code></pre></div><p>例如，将名为 <code>my-app</code> 的部署副本数修改为 5：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale deployment my-app --replicas<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>
</span></span></code></pre></div><h3 id=2-滚动更新>2. <strong>滚动更新</strong>
<a class=anchor href=#2-%e6%bb%9a%e5%8a%a8%e6%9b%b4%e6%96%b0>#</a></h3><p>滚动更新是 Kubernetes 中一种无停机的更新方式，使用 <code>kubectl apply</code> 或 <code>kubectl rollout</code> 进行：</p><h4 id=使用-kubectl-apply-更新-deployment>使用 <code>kubectl apply</code> 更新 Deployment：
<a class=anchor href=#%e4%bd%bf%e7%94%a8-kubectl-apply-%e6%9b%b4%e6%96%b0-deployment>#</a></h4><p>修改 Deployment 的配置文件，然后使用 <code>kubectl apply</code> 更新。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f &lt;deployment-file.yaml&gt;
</span></span></code></pre></div><h4 id=使用-kubectl-rollout-进行滚动更新>使用 <code>kubectl rollout</code> 进行滚动更新：
<a class=anchor href=#%e4%bd%bf%e7%94%a8-kubectl-rollout-%e8%bf%9b%e8%a1%8c%e6%bb%9a%e5%8a%a8%e6%9b%b4%e6%96%b0>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl rollout restart deployment &lt;deployment-name&gt;
</span></span></code></pre></div><p>例如，重启 <code>my-app</code> 部署：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl rollout restart deployment my-app
</span></span></code></pre></div><h3 id=3-回滚>3. <strong>回滚</strong>
<a class=anchor href=#3-%e5%9b%9e%e6%bb%9a>#</a></h3><p>回滚到上一个版本的部署，可以使用 <code>kubectl rollout undo</code> 命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl rollout undo deployment &lt;deployment-name&gt;
</span></span></code></pre></div><p>例如，回滚 <code>my-app</code> 部署：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl rollout undo deployment my-app
</span></span></code></pre></div><p>如果你希望回滚到指定版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl rollout undo deployment &lt;deployment-name&gt; --to-revision<span style=color:#f92672>=</span>&lt;revision-number&gt;
</span></span></code></pre></div><h3 id=4-查看-pod-的详细信息>4. <strong>查看 Pod 的详细信息</strong>
<a class=anchor href=#4-%e6%9f%a5%e7%9c%8b-pod-%e7%9a%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af>#</a></h3><p>要查看 Pod 的详细信息，可以使用 <code>kubectl describe</code> 命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>例如，查看名为 <code>my-app-pod</code> 的 Pod 的详细信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod my-app-pod
</span></span></code></pre></div><p>这将显示 Pod 的详细信息，包括容器状态、事件、挂载的卷、环境变量等。</p><h3 id=5-进入-pod-进行交互>5. <strong>进入 Pod 进行交互</strong>
<a class=anchor href=#5-%e8%bf%9b%e5%85%a5-pod-%e8%bf%9b%e8%a1%8c%e4%ba%a4%e4%ba%92>#</a></h3><p>要进入一个运行中的 Pod 进行交互，可以使用 <code>kubectl exec</code> 命令。你可以进入 Pod 并执行命令（如进入 shell）：</p><h4 id=进入-pod-并启动交互式终端>进入 Pod 并启动交互式终端：
<a class=anchor href=#%e8%bf%9b%e5%85%a5-pod-%e5%b9%b6%e5%90%af%e5%8a%a8%e4%ba%a4%e4%ba%92%e5%bc%8f%e7%bb%88%e7%ab%af>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec -it &lt;pod-name&gt; -- /bin/bash
</span></span></code></pre></div><p>例如，进入 <code>my-app-pod</code> 的交互式终端：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec -it my-app-pod -- /bin/bash
</span></span></code></pre></div><p>如果容器使用的是 <code>sh</code> 而不是 <code>bash</code>，可以使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec -it my-app-pod -- /bin/sh
</span></span></code></pre></div><p>通过这些命令，你可以方便地修改副本数、执行滚动更新、查看 Pod 的详细信息以及进入 Pod 进行交互操作。</p><h1 id=3-etcd数据如何备份>3. etcd数据如何备份？
<a class=anchor href=#3-etcd%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e5%a4%87%e4%bb%bd>#</a></h1><ul><li>etcdctl &ndash;endpoints=“https://192.168.32.129:2379,https://192.168.32.130:2379,192.168.32.128:2379” &ndash;cacert=/etc/kubernetes/cert/ca.pem &ndash;key=/etc/etcd/cert/etcd-key.pem &ndash;cert=/etc/etcd/cert/etcd.pem snapshot save snashot1.db</li><li>Snapshot saved at snashot1.db</li></ul><p>etcd 数据备份是确保集群数据安全和恢复的关键步骤。etcd 提供了命令行工具来进行备份和恢复。以下是备份和恢复 etcd 数据的步骤：</p><h3 id=1-备份-etcd-数据>1. <strong>备份 etcd 数据</strong>
<a class=anchor href=#1-%e5%a4%87%e4%bb%bd-etcd-%e6%95%b0%e6%8d%ae>#</a></h3><p>etcd 使用 <code>etcdctl</code> 工具来执行备份操作，备份是对 etcd 数据的快照。</p><h4 id=备份命令>备份命令：
<a class=anchor href=#%e5%a4%87%e4%bb%bd%e5%91%bd%e4%bb%a4>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ETCDCTL_API<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> etcdctl snapshot save &lt;backup-path&gt;
</span></span></code></pre></div><p>例如，将备份保存到 <code>/tmp/etcd-backup.db</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ETCDCTL_API<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> etcdctl snapshot save /tmp/etcd-backup.db
</span></span></code></pre></div><h4 id=备份选项>备份选项：
<a class=anchor href=#%e5%a4%87%e4%bb%bd%e9%80%89%e9%a1%b9>#</a></h4><ul><li><code>ETCDCTL_API=3</code>：指定使用 etcd 3.x API。</li><li><code>&lt;backup-path></code>：备份文件的路径。</li></ul><p>确保运行该命令的机器可以访问 etcd 集群，或者你需要设置相关的认证参数（如证书和密钥）。</p><h3 id=2-指定备份时使用的-etcd-集群信息>2. <strong>指定备份时使用的 etcd 集群信息</strong>
<a class=anchor href=#2-%e6%8c%87%e5%ae%9a%e5%a4%87%e4%bb%bd%e6%97%b6%e4%bd%bf%e7%94%a8%e7%9a%84-etcd-%e9%9b%86%e7%be%a4%e4%bf%a1%e6%81%af>#</a></h3><p>如果 etcd 集群有多个节点或启用了身份验证，可能需要添加额外的参数：</p><ul><li><code>--endpoints</code>：指定 etcd 集群的节点地址。</li><li><code>--cert-file</code> 和 <code>--key-file</code>：如果启用了 SSL 加密通信。</li><li><code>--cacert</code>：指定 CA 证书的路径（用于身份验证）。</li></ul><p>例如，备份时指定集群端点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ETCDCTL_API<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> etcdctl snapshot save /tmp/etcd-backup.db <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --endpoints<span style=color:#f92672>=</span>https://etcd1:2379,https://etcd2:2379,https://etcd3:2379 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --cert-file<span style=color:#f92672>=</span>/path/to/cert <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --key-file<span style=color:#f92672>=</span>/path/to/key <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --cacert<span style=color:#f92672>=</span>/path/to/ca-cert
</span></span></code></pre></div><h3 id=3-恢复-etcd-数据>3. <strong>恢复 etcd 数据</strong>
<a class=anchor href=#3-%e6%81%a2%e5%a4%8d-etcd-%e6%95%b0%e6%8d%ae>#</a></h3><p>如果需要恢复 etcd 数据，使用 <code>etcdctl snapshot restore</code> 命令。</p><h4 id=恢复命令>恢复命令：
<a class=anchor href=#%e6%81%a2%e5%a4%8d%e5%91%bd%e4%bb%a4>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ETCDCTL_API<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> etcdctl snapshot restore &lt;backup-path&gt; <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --data-dir<span style=color:#f92672>=</span>&lt;new-data-dir&gt; <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --name<span style=color:#f92672>=</span>&lt;node-name&gt; <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --initial-cluster<span style=color:#f92672>=</span>&lt;cluster-config&gt; <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --initial-cluster-token<span style=color:#f92672>=</span>&lt;cluster-token&gt;
</span></span></code></pre></div><p>例如，恢复备份到 <code>/tmp/etcd-backup.db</code>，并将数据存储到 <code>/var/lib/etcd</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ETCDCTL_API<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> etcdctl snapshot restore /tmp/etcd-backup.db <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --data-dir<span style=color:#f92672>=</span>/var/lib/etcd <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --name<span style=color:#f92672>=</span>etcd-node-1 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --initial-cluster<span style=color:#f92672>=</span>etcd-node-1<span style=color:#f92672>=</span>https://etcd-node-1:2380,etcd-node-2<span style=color:#f92672>=</span>https://etcd-node-2:2380,etcd-node-3<span style=color:#f92672>=</span>https://etcd-node-3:2380 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --initial-cluster-token<span style=color:#f92672>=</span>etcd-cluster-1
</span></span></code></pre></div><ul><li><code>--data-dir</code>：指定恢复后的数据存储目录。</li><li><code>--name</code>：指定节点的名称。</li><li><code>--initial-cluster</code>：指定集群节点的地址。</li><li><code>--initial-cluster-token</code>：集群的标识。</li></ul><p>恢复操作后，需要重新启动 etcd 服务。</p><h3 id=4-定期备份>4. <strong>定期备份</strong>
<a class=anchor href=#4-%e5%ae%9a%e6%9c%9f%e5%a4%87%e4%bb%bd>#</a></h3><p>建议定期备份 etcd 数据，以防止意外数据丢失。可以使用脚本或定时任务（如 cron）来定期执行备份操作。</p><h3 id=5-检查备份有效性>5. <strong>检查备份有效性</strong>
<a class=anchor href=#5-%e6%a3%80%e6%9f%a5%e5%a4%87%e4%bb%bd%e6%9c%89%e6%95%88%e6%80%a7>#</a></h3><p>备份后，建议检查备份文件的完整性，确保在需要时能够恢复。</p><h1 id=4-k8s控制器有哪些>4. k8s控制器有哪些？
<a class=anchor href=#4-k8s%e6%8e%a7%e5%88%b6%e5%99%a8%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>副本集（ReplicaSet）</li><li>部署（Deployment）</li><li>状态集（StatefulSet）</li><li>Daemon集（DaemonSet）</li><li>一次任务（Job）</li><li>计划任务（CronJob）</li><li>有状态集（StatefulSet）</li></ul><p>Kubernetes 控制器是用于管理 Kubernetes 集群中资源和对象的控制循环（control loop）。这些控制器定期检查集群状态并根据当前状态与期望状态之间的差异进行调整。以下是 Kubernetes 中一些常见的控制器及其功能：</p><h3 id=1-replicationcontroller>1. <strong>ReplicationController</strong>
<a class=anchor href=#1-replicationcontroller>#</a></h3><ul><li><strong>功能</strong>：确保某个特定的 Pod 副本数始终运行。当 Pod 数量低于指定副本数时，ReplicationController 会创建新的 Pod；当 Pod 数量超过指定副本数时，它会删除多余的 Pod。</li><li><strong>用途</strong>：确保应用程序的高可用性和负载均衡。</li></ul><h3 id=2-replicaset>2. <strong>ReplicaSet</strong>
<a class=anchor href=#2-replicaset>#</a></h3><ul><li><strong>功能</strong>：ReplicaSet 是 ReplicationController 的增强版，用于确保某个特定副本数的 Pod 始终在集群中运行。通常用于支持 Deployment 资源，确保部署的 Pod 数量正确。</li><li><strong>用途</strong>：与 Deployment 一起工作，确保在滚动更新时的稳定性。</li></ul><h3 id=3-deployment>3. <strong>Deployment</strong>
<a class=anchor href=#3-deployment>#</a></h3><ul><li><strong>功能</strong>：Deployment 控制器负责管理应用程序的部署，支持零停机的滚动更新、回滚等操作。它使用 ReplicaSet 来管理 Pod 副本。</li><li><strong>用途</strong>：简化应用程序的部署和版本管理。</li></ul><h3 id=4-statefulset>4. <strong>StatefulSet</strong>
<a class=anchor href=#4-statefulset>#</a></h3><ul><li><strong>功能</strong>：StatefulSet 是用于管理有状态应用的控制器。它确保 Pod 在更新时能够保持其稳定的标识（如 Pod 名称和存储卷），适用于有持久化存储要求的应用，如数据库。</li><li><strong>用途</strong>：管理有状态服务，例如数据库、缓存等，提供稳定的网络身份和持久化存储。</li></ul><h3 id=5-daemonset>5. <strong>DaemonSet</strong>
<a class=anchor href=#5-daemonset>#</a></h3><ul><li><strong>功能</strong>：DaemonSet 控制器确保每个节点上运行一个特定的 Pod。通常用于需要在每个节点上运行的守护进程（如日志收集、监控代理等）。</li><li><strong>用途</strong>：确保每个节点上都有 Pod（例如：fluentd、prometheus-node-exporter 等）。</li></ul><h3 id=6-job>6. <strong>Job</strong>
<a class=anchor href=#6-job>#</a></h3><ul><li><strong>功能</strong>：Job 控制器用于管理批处理任务的执行。它确保指定数量的 Pod 成功执行一次任务。Job 会创建 Pod 来执行一次性任务，完成后 Pod 会被删除。</li><li><strong>用途</strong>：用于执行短期批处理任务，例如数据迁移、批量计算等。</li></ul><h3 id=7-cronjob>7. <strong>CronJob</strong>
<a class=anchor href=#7-cronjob>#</a></h3><ul><li><strong>功能</strong>：CronJob 是 Job 控制器的扩展，允许定期执行任务，类似于 Linux 系统中的 Cron 作业。它定期创建 Job 来执行计划任务。</li><li><strong>用途</strong>：例如定期备份、定时任务等。</li></ul><h3 id=8-horizontalpodautoscaler-hpa>8. <strong>HorizontalPodAutoscaler (HPA)</strong>
<a class=anchor href=#8-horizontalpodautoscaler-hpa>#</a></h3><ul><li><strong>功能</strong>：HPA 控制器根据 Pod 的 CPU 或内存使用情况自动调整 Pod 的副本数，以应对负载的变化。</li><li><strong>用途</strong>：自动水平扩展应用程序的 Pod，适应流量的波动。</li></ul><h3 id=9-networkpolicy>9. <strong>NetworkPolicy</strong>
<a class=anchor href=#9-networkpolicy>#</a></h3><ul><li><strong>功能</strong>：NetworkPolicy 控制器用于定义和管理 Pod 之间的网络访问策略。它允许你控制哪些 Pod 可以通信，哪些不能。</li><li><strong>用途</strong>：增强集群内的安全性，通过限制 Pod 之间的网络流量来隔离不同服务。</li></ul><h3 id=10-ingresscontroller>10. <strong>IngressController</strong>
<a class=anchor href=#10-ingresscontroller>#</a></h3><ul><li><strong>功能</strong>：IngressController 控制器管理 Ingress 资源，负责将外部请求路由到集群内的服务。它通常使用反向代理的形式，如 Nginx 或 Traefik，来处理 HTTP/S 流量。</li><li><strong>用途</strong>：暴露服务给外部网络，并提供负载均衡、SSL 终止等功能。</li></ul><h3 id=11-custom-controller>11. <strong>Custom Controller</strong>
<a class=anchor href=#11-custom-controller>#</a></h3><ul><li><strong>功能</strong>：Kubernetes 允许用户创建自定义控制器，以便根据特定的业务需求自动化资源管理。用户可以根据自己的需求编写自定义控制器，并将其作为 Kubernetes 的一部分运行。</li><li><strong>用途</strong>：满足一些特定需求的自动化任务，例如定期清理日志、资源调整等。</li></ul><h3 id=12-certmanager>12. <strong>CertManager</strong>
<a class=anchor href=#12-certmanager>#</a></h3><ul><li><strong>功能</strong>：CertManager 是一个 Kubernetes 控制器，用于自动化管理和签发 SSL/TLS 证书。它通过与外部证书颁发机构（如 Let&rsquo;s Encrypt）交互来自动更新证书。</li><li><strong>用途</strong>：为 Kubernetes 集群中的应用提供自动化证书管理。</li></ul><h3 id=总结-42>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-42>#</a></h3><p>Kubernetes 控制器的核心作用是确保集群中的资源按照预期方式运行，并自动处理集群资源的管理与维护。不同的控制器满足了不同场景下的需求，包括无状态服务的管理（Deployment），有状态服务的管理（StatefulSet），批处理任务的管理（Job、CronJob），以及对网络和安全的管理（NetworkPolicy、IngressController）等。</p><h1 id=5-哪些是集群级别的资源>5. 哪些是集群级别的资源？
<a class=anchor href=#5-%e5%93%aa%e4%ba%9b%e6%98%af%e9%9b%86%e7%be%a4%e7%ba%a7%e5%88%ab%e7%9a%84%e8%b5%84%e6%ba%90>#</a></h1><ul><li>Namespace</li><li>Node</li><li>Role</li><li>ClusterRole</li><li>RoleBinding</li><li>ClusterRoleBinding</li></ul><p>在 Kubernetes 中，集群级别的资源是指跨整个集群范围的资源，它们的作用通常涉及对集群的管理、调度和配置。以下是一些常见的集群级别资源：</p><h3 id=1-node>1. <strong>Node</strong>
<a class=anchor href=#1-node>#</a></h3><ul><li><strong>功能</strong>：节点（Node）是 Kubernetes 集群中的物理或虚拟机器，它为 Pod 提供计算资源。每个节点都包含运行 Pod 的 Kubelet、容器运行时（如 Docker）以及其他必要的组件。</li><li><strong>用途</strong>：管理集群中的计算资源，决定 Pod 的调度位置。</li></ul><h3 id=2-namespace>2. <strong>Namespace</strong>
<a class=anchor href=#2-namespace>#</a></h3><ul><li><strong>功能</strong>：命名空间（Namespace）用于在 Kubernetes 中划分集群中的资源。通过使用不同的命名空间，可以将资源分隔开，以便于不同团队或项目的管理。</li><li><strong>用途</strong>：用于逻辑上分隔和组织集群中的资源，例如服务、Pod 和其他对象，可以在同一集群中支持多租户环境。</li></ul><h3 id=3-persistentvolume-pv>3. <strong>PersistentVolume (PV)</strong>
<a class=anchor href=#3-persistentvolume-pv>#</a></h3><ul><li><strong>功能</strong>：持久化卷（PersistentVolume）是集群级别的存储资源，用于提供持久化的存储，以便容器在 Pod 之间可以持久化数据。PV 是由管理员创建的，管理员定义了存储的大小、访问模式等属性。</li><li><strong>用途</strong>：为集群中的 Pod 提供存储卷。</li></ul><h3 id=4-persistentvolumeclaim-pvc>4. <strong>PersistentVolumeClaim (PVC)</strong>
<a class=anchor href=#4-persistentvolumeclaim-pvc>#</a></h3><ul><li><strong>功能</strong>：持久化卷声明（PVC）是用户请求存储资源的方式。它是 Pod 访问持久化存储的接口，用户可以通过 PVC 来申请持久化存储，PVC 会与 PV 绑定。</li><li><strong>用途</strong>：在集群中申请并绑定到合适的 PV，确保 Pod 获得持久化存储。</li></ul><h3 id=5-storageclass>5. <strong>StorageClass</strong>
<a class=anchor href=#5-storageclass>#</a></h3><ul><li><strong>功能</strong>：存储类（StorageClass）是管理员定义的存储策略，用于动态地供应存储卷。它定义了存储的类型、访问模式和其他属性。</li><li><strong>用途</strong>：为 PVC 提供具体的存储供应方式，控制持久化存储的分配和使用策略。</li></ul><h3 id=6-clusterrole-和-clusterrolebinding>6. <strong>ClusterRole 和 ClusterRoleBinding</strong>
<a class=anchor href=#6-clusterrole-%e5%92%8c-clusterrolebinding>#</a></h3><ul><li><strong>功能</strong>：ClusterRole 和 ClusterRoleBinding 是与权限管理相关的集群级别资源。ClusterRole 定义了一组集群范围内的权限，而 ClusterRoleBinding 将这些权限授予用户、组或服务账户。</li><li><strong>用途</strong>：管理集群级别的访问控制和权限。</li></ul><h3 id=7-configmap>7. <strong>ConfigMap</strong>
<a class=anchor href=#7-configmap>#</a></h3><ul><li><strong>功能</strong>：ConfigMap 用于存储集群级别的配置信息。它允许您将配置数据与应用程序容器分离，便于管理和更新。</li><li><strong>用途</strong>：存储应用程序配置或集群配置，不包含敏感数据。</li></ul><h3 id=8-secret>8. <strong>Secret</strong>
<a class=anchor href=#8-secret>#</a></h3><ul><li><strong>功能</strong>：Secret 用于存储敏感数据（如密码、密钥等）。它提供了一种安全的方式来存储和访问敏感信息。</li><li><strong>用途</strong>：存储和管理集群中应用程序的敏感信息。</li></ul><h3 id=9-ingress>9. <strong>Ingress</strong>
<a class=anchor href=#9-ingress>#</a></h3><ul><li><strong>功能</strong>：Ingress 是集群级别的资源，用于管理外部 HTTP/S 流量的路由。它提供了一种通过负载均衡器将外部请求路由到集群内部服务的方式。</li><li><strong>用途</strong>：暴露服务到集群外部，并通过反向代理进行流量控制。</li></ul><h3 id=10-resourcequota>10. <strong>ResourceQuota</strong>
<a class=anchor href=#10-resourcequota>#</a></h3><ul><li><strong>功能</strong>：ResourceQuota 用于限制命名空间内可用的资源数量和种类（如 CPU、内存、存储等）。它是在集群级别对资源使用进行管控的机制。</li><li><strong>用途</strong>：帮助管理员限制和控制集群中资源的使用，防止某些命名空间消耗过多资源。</li></ul><h3 id=11-limitrange>11. <strong>LimitRange</strong>
<a class=anchor href=#11-limitrange>#</a></h3><ul><li><strong>功能</strong>：LimitRange 是用于限制命名空间中容器资源（如 CPU、内存）的请求和限制值。它是集群级别的资源，用于设置资源的默认限制。</li><li><strong>用途</strong>：为命名空间内的容器设置资源使用的范围。</li></ul><h3 id=12-horizontalpodautoscaler-hpa>12. <strong>HorizontalPodAutoscaler (HPA)</strong>
<a class=anchor href=#12-horizontalpodautoscaler-hpa>#</a></h3><ul><li><strong>功能</strong>：HPA 控制器在集群级别运行，自动调整 Pod 的副本数以响应负载变化，通常基于 CPU 或内存使用情况。</li><li><strong>用途</strong>：动态调整 Pod 副本数，确保集群资源能够自动适应流量的变化。</li></ul><h3 id=13-serviceaccount>13. <strong>ServiceAccount</strong>
<a class=anchor href=#13-serviceaccount>#</a></h3><ul><li><strong>功能</strong>：ServiceAccount 是 Kubernetes 中用于为 Pod 提供身份的集群级别资源。它关联了 API 访问权限，允许 Pod 在集群中进行身份验证和访问控制。</li><li><strong>用途</strong>：为运行在 Kubernetes 上的应用程序分配身份，允许它们安全地访问集群中的资源。</li></ul><h3 id=14-clusteroperator>14. <strong>ClusterOperator</strong>
<a class=anchor href=#14-clusteroperator>#</a></h3><ul><li><strong>功能</strong>：ClusterOperator 是一个由 Operator 管理的集群级别资源，用于对集群进行自动化管理。它负责维护应用程序或基础设施的生命周期管理。</li><li><strong>用途</strong>：简化集群管理过程，自动化常见任务。</li></ul><h3 id=15-api-aggregation-layer-api-server>15. <strong>API Aggregation Layer (API Server)</strong>
<a class=anchor href=#15-api-aggregation-layer-api-server>#</a></h3><ul><li><strong>功能</strong>：API Aggregation Layer 使得不同版本和功能的 API 被聚合到 Kubernetes API Server 中，这样可以让用户或系统使用不同的 API 资源。</li><li><strong>用途</strong>：为集群提供统一的 API 接入点。</li></ul><h3 id=总结-43>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-43>#</a></h3><p>集群级别的资源一般是跨整个 Kubernetes 集群的管理资源，涉及集群的配置、权限管理、存储管理等。它们通常由管理员来配置和管理，以确保集群内资源的合理使用、访问控制以及集群的安全性与稳定性。</p><h1 id=6-pod状态有哪些>6. pod状态有哪些？
<a class=anchor href=#6-pod%e7%8a%b6%e6%80%81%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>Pending 等待中</li><li>Running 运行中</li><li>Succeeded 正常终止</li><li>Failed 异常停止</li><li>Unkonwn 未知状态</li></ul><p>在 Kubernetes 中，Pod 的状态反映了 Pod 的生命周期和运行状况。Pod 状态由 Kubelet 和 API Server 更新，并且每个 Pod 会经历不同的阶段。以下是 Pod 状态的常见类型：</p><h3 id=1-pending>1. <strong>Pending</strong>
<a class=anchor href=#1-pending>#</a></h3><ul><li><p><strong>描述</strong>：Pod 已经被 Kubernetes 调度到某个节点上，但某些容器还没有被创建或启动。通常是因为容器镜像正在拉取、资源请求尚未满足、或者是其他初始化过程尚未完成。</p></li><li><p>可能的原因</p><p>：</p><ul><li>节点资源不足</li><li>容器镜像还在下载</li><li>需要挂载的卷还未准备好</li></ul></li></ul><h3 id=2-running>2. <strong>Running</strong>
<a class=anchor href=#2-running>#</a></h3><ul><li><p><strong>描述</strong>：Pod 中的容器正在运行，并且至少有一个容器处于运行状态。Pod 被调度到一个节点，并且容器已经启动并在运行中。</p></li><li><p>可能的原因</p><p>：</p><ul><li>容器已启动且健康</li><li>Pod 正在执行指定的任务</li></ul></li></ul><h3 id=3-succeeded>3. <strong>Succeeded</strong>
<a class=anchor href=#3-succeeded>#</a></h3><ul><li><p><strong>描述</strong>：Pod 中的所有容器都已成功运行并退出，且退出状态码为 0。这个状态通常表示 Pod 中的任务（例如批处理任务）已经完成。</p></li><li><p>可能的原因</p><p>：</p><ul><li>容器执行任务并成功退出</li><li>没有错误退出</li></ul></li></ul><h3 id=4-failed>4. <strong>Failed</strong>
<a class=anchor href=#4-failed>#</a></h3><ul><li><p><strong>描述</strong>：Pod 中的至少一个容器已经结束，但退出状态码非 0。该状态表示 Pod 中的容器执行过程中发生了错误或故障。</p></li><li><p>可能的原因</p><p>：</p><ul><li>容器执行错误并退出</li><li>程序崩溃或其他失败</li></ul></li></ul><h3 id=5-crashloopbackoff>5. <strong>CrashLoopBackOff</strong>
<a class=anchor href=#5-crashloopbackoff>#</a></h3><ul><li><p><strong>描述</strong>：Pod 中的容器持续崩溃并重启。Kubernetes 会尝试重新启动容器，但容器未能成功运行。这通常是由应用程序崩溃或容器配置错误引起的。</p></li><li><p>可能的原因</p><p>：</p><ul><li>容器启动后失败并退出，Kubernetes 尝试重启容器</li><li>容器配置错误或应用程序 bug</li></ul></li></ul><h3 id=6-unknown>6. <strong>Unknown</strong>
<a class=anchor href=#6-unknown>#</a></h3><ul><li><p><strong>描述</strong>：Kubernetes 无法确定 Pod 的状态。这个状态通常是由于 Kubelet 与 API Server 之间的通信中断或节点失联。</p></li><li><p>可能的原因</p><p>：</p><ul><li>节点不可用</li><li>Kubelet 或 API Server 出现问题</li></ul></li></ul><h3 id=7-terminating>7. <strong>Terminating</strong>
<a class=anchor href=#7-terminating>#</a></h3><ul><li><p><strong>描述</strong>：Pod 正在终止过程中。这通常表示 Pod 正在被删除，所有容器和相关资源正在被清理。</p></li><li><p>可能的原因</p><p>：</p><ul><li>用户或控制器删除 Pod</li><li>正在执行正常的关闭过程</li></ul></li></ul><h3 id=8-initializing-仅适用于-statefulset>8. <strong>Initializing</strong> (仅适用于 StatefulSet)
<a class=anchor href=#8-initializing-%e4%bb%85%e9%80%82%e7%94%a8%e4%ba%8e-statefulset>#</a></h3><ul><li><p><strong>描述</strong>：Pod 正在初始化阶段。在 StatefulSet 中，当某个 Pod 启动时，容器可能会按照顺序启动，并且 Pod 的状态会经历“Initializing”阶段。</p></li><li><p>可能的原因</p><p>：</p><ul><li>StatefulSet 中的 Pod 初始化时需要等待其他 Pod 完成启动</li></ul></li></ul><h3 id=总结-44>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-44>#</a></h3><p>Pod 的状态反映了其在 Kubernetes 集群中的生命周期。管理员可以通过这些状态来诊断和排查问题，比如容器崩溃、资源不足、网络问题等。理解 Pod 的各种状态有助于有效地管理和调度应用程序。</p><h1 id=7-pod创建过程是什么>7. pod创建过程是什么？
<a class=anchor href=#7-pod%e5%88%9b%e5%bb%ba%e8%bf%87%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012857876.png alt=image-20250224012857876></p><p>在 Kubernetes 中，Pod 的创建过程是 Kubernetes 调度和管理 Pod 的一系列步骤。Pod 是 Kubernetes 中最小的部署单位，由一个或多个容器组成。以下是 Pod 创建过程的详细步骤：</p><h3 id=1-用户提交请求>1. <strong>用户提交请求</strong>
<a class=anchor href=#1-%e7%94%a8%e6%88%b7%e6%8f%90%e4%ba%a4%e8%af%b7%e6%b1%82>#</a></h3><ul><li>用户通过 <code>kubectl</code> 或 Kubernetes API 提交一个 Pod 资源对象的定义，通常是一个 YAML 或 JSON 文件，描述了 Pod 的配置、容器、卷挂载等信息。</li><li>请求可以来自：<ul><li><code>kubectl</code> 命令行工具</li><li>Kubernetes 控制器（如 Deployment、StatefulSet、DaemonSet 等）</li><li>其他系统（如 Helm 等）</li></ul></li></ul><h3 id=2-api-server-接收请求>2. <strong>API Server 接收请求</strong>
<a class=anchor href=#2-api-server-%e6%8e%a5%e6%94%b6%e8%af%b7%e6%b1%82>#</a></h3><ul><li>用户提交的 Pod 定义会被 Kubernetes API Server 接收。</li><li>API Server 将请求转化为集群中的资源对象，并将其存储在 <strong>etcd</strong>（Kubernetes 的分布式存储系统）中。</li><li>这个 Pod 对象进入 <strong>etcd</strong> 中的队列，等待调度。</li></ul><h3 id=3-调度scheduler选择节点>3. <strong>调度（Scheduler）选择节点</strong>
<a class=anchor href=#3-%e8%b0%83%e5%ba%a6scheduler%e9%80%89%e6%8b%a9%e8%8a%82%e7%82%b9>#</a></h3><ul><li><p>Kubernetes Scheduler</p><p>负责选择一个合适的节点来运行这个 Pod。调度过程基于 Pod 的资源请求、节点的资源状况、标签匹配等条件。</p><ul><li>资源请求（如 CPU 和内存）</li><li>节点亲和性（如节点的标签和 Pod 的调度要求）</li><li>Taints 和 Tolerations（节点的污点和 Pod 的容忍度）</li><li>其他调度策略（如 Pod 的优先级和抢占）</li></ul></li><li><p>调度器根据这些条件选择一个符合要求的节点，并将 Pod 分配到该节点。</p></li></ul><h3 id=4-node-接收-pod-配置>4. <strong>Node 接收 Pod 配置</strong>
<a class=anchor href=#4-node-%e6%8e%a5%e6%94%b6-pod-%e9%85%8d%e7%bd%ae>#</a></h3><ul><li>一旦调度完成，API Server 将调度结果发送给选定的节点（Node）。</li><li>该节点的 Kubelet（Kubernetes 节点代理）接收到 Pod 的配置并开始处理。</li></ul><h3 id=5-kubelet-创建容器>5. <strong>Kubelet 创建容器</strong>
<a class=anchor href=#5-kubelet-%e5%88%9b%e5%bb%ba%e5%ae%b9%e5%99%a8>#</a></h3><ul><li><strong>Kubelet</strong> 在目标节点上创建 Pod。Kubelet 会根据 Pod 配置文件中的容器信息启动相应的容器。</li><li>容器的启动过程包括：<ul><li>拉取镜像：Kubelet 会确保容器镜像已经被拉取到本地节点（如果镜像尚未存在）。</li><li>配置容器：Kubelet 会按照 Pod 配置设置容器的 CPU、内存、环境变量、挂载卷等配置。</li><li>启动容器：Kubelet 会通过容器运行时（如 Docker、containerd）启动容器。</li></ul></li></ul><h3 id=6-pod-启动和就绪检查>6. <strong>Pod 启动和就绪检查</strong>
<a class=anchor href=#6-pod-%e5%90%af%e5%8a%a8%e5%92%8c%e5%b0%b1%e7%bb%aa%e6%a3%80%e6%9f%a5>#</a></h3><ul><li>容器启动后，Kubelet 会执行 Pod 中定义的 <strong>就绪探针（Readiness Probe）</strong> 和 <strong>存活探针（Liveness Probe）</strong>，以确保容器正常工作。</li><li>如果就绪探针返回成功，Pod 会被标记为 <strong>Ready</strong> 状态，表示它已经可以开始接受流量。</li><li>如果存活探针失败，Kubelet 会尝试重新启动容器。</li></ul><h3 id=7-网络和服务关联>7. <strong>网络和服务关联</strong>
<a class=anchor href=#7-%e7%bd%91%e7%bb%9c%e5%92%8c%e6%9c%8d%e5%8a%a1%e5%85%b3%e8%81%94>#</a></h3><ul><li>一旦容器启动并且健康检查通过，Kubelet 会为容器分配一个 IP 地址。</li><li>Kubernetes 内部的 <strong>CNI（容器网络接口）插件</strong> 会为 Pod 配置网络，使得 Pod 中的容器能够通过内部网络相互通信。</li><li>如果 Pod 被关联到某个 Service，Kubernetes 会更新 Service 的 Endpoints，使得流量能够通过 Service 路由到新创建的 Pod。</li></ul><h3 id=8-pod-完成启动>8. <strong>Pod 完成启动</strong>
<a class=anchor href=#8-pod-%e5%ae%8c%e6%88%90%e5%90%af%e5%8a%a8>#</a></h3><ul><li>一旦容器成功运行并且健康检查通过，Pod 被标记为 <strong>Running</strong> 状态。</li><li>如果是通过 Controller（如 Deployment 或 StatefulSet）创建的 Pod，控制器会继续监控该 Pod 的运行状态，以确保副本数保持一致。</li></ul><h3 id=9-监控和维护>9. <strong>监控和维护</strong>
<a class=anchor href=#9-%e7%9b%91%e6%8e%a7%e5%92%8c%e7%bb%b4%e6%8a%a4>#</a></h3><ul><li><strong>Kubelet</strong> 会继续监控 Pod 的状态和运行情况。如果 Pod 中的容器崩溃或死锁，Kubelet 会尝试重启容器或重建 Pod。</li><li>如果 Pod 所在的节点不可用或失败，调度器会根据策略重新调度该 Pod 到其他可用节点。</li></ul><h3 id=总结pod-创建的整个流程>总结：Pod 创建的整个流程
<a class=anchor href=#%e6%80%bb%e7%bb%93pod-%e5%88%9b%e5%bb%ba%e7%9a%84%e6%95%b4%e4%b8%aa%e6%b5%81%e7%a8%8b>#</a></h3><ol><li><strong>用户提交 Pod 配置</strong>，通过 API Server 接收。</li><li><strong>调度器选择节点</strong>，确定在哪个节点上运行 Pod。</li><li><strong>Kubelet 在节点上创建容器</strong>，并启动容器。</li><li><strong>网络配置和服务关联</strong>，Pod 配置好网络并准备好接受流量。</li><li><strong>Pod 运行并就绪</strong>，容器完成启动，Pod 状态转为 Running。</li></ol><p>通过这一过程，Kubernetes 管理和调度 Pod，实现容器化应用的高效运行与自动化管理。</p><h1 id=8-pod重启策略有哪些>8. pod重启策略有哪些？
<a class=anchor href=#8-pod%e9%87%8d%e5%90%af%e7%ad%96%e7%95%a5%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><p>Pod的重启策略有3种，默认值为Always。</p><ul><li>Always ： 容器失效时，kubelet 自动重启该容器；</li><li>OnFailure ： 容器终止运行且退出码不为0时重启；</li><li>Never ： 不论状态为何， kubelet 都不重启该容器</li></ul><p>在 Kubernetes 中，Pod 的重启策略定义了容器如何在失败后重新启动。Kubernetes 提供了三种常见的重启策略，每种策略适用于不同的场景。Pod 的重启策略是在 Pod 的规格文件中定义的，特别是对于容器化应用，重启策略的选择非常重要。</p><h3 id=1-always>1. <strong>Always</strong>
<a class=anchor href=#1-always>#</a></h3><ul><li><p><strong>描述</strong>：无论容器退出的状态是什么，Kubernetes 都会重新启动容器。这是最常用的重启策略，适用于那些需要始终运行的服务。</p></li><li><p>应用场景</p><p>：</p><ul><li>持续运行的应用程序，例如 Web 服务、数据库、后台任务等。</li></ul></li><li><p><strong>默认值</strong>：如果你没有在 Pod 规范中显式设置重启策略，Kubernetes 会默认使用 <code>Always</code>。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Always</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>example-image</span>
</span></span></code></pre></div></li></ul><h3 id=2-onfailure>2. <strong>OnFailure</strong>
<a class=anchor href=#2-onfailure>#</a></h3><ul><li><p><strong>描述</strong>：当容器正常退出时（即退出码为 0）不会重启容器，但如果容器因错误退出（即退出码非 0）时，Kubernetes 会尝试重新启动容器。适用于那些正常结束时无需重启的应用。</p></li><li><p>应用场景</p><p>：</p><ul><li>用于执行一次性任务的容器，如果任务失败则需要重新启动进行重试，但如果任务成功就不需要重启。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>OnFailure</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>example-image</span>
</span></span></code></pre></div></li></ul><h3 id=3-never>3. <strong>Never</strong>
<a class=anchor href=#3-never>#</a></h3><ul><li><p><strong>描述</strong>：Kubernetes 在容器退出后不会自动重启容器。适用于那些不需要容器重新启动的场景，通常用于批处理任务或一次性作业。</p></li><li><p>应用场景</p><p>：</p><ul><li>执行完任务后容器终止，且不需要再次启动。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>example-image</span>
</span></span></code></pre></div></li></ul><h3 id=4-pod-重启策略与控制器的关系>4. <strong>Pod 重启策略与控制器的关系</strong>
<a class=anchor href=#4-pod-%e9%87%8d%e5%90%af%e7%ad%96%e7%95%a5%e4%b8%8e%e6%8e%a7%e5%88%b6%e5%99%a8%e7%9a%84%e5%85%b3%e7%b3%bb>#</a></h3><ul><li>当 Pod 是由控制器（如 Deployment、StatefulSet、DaemonSet 等）管理时，Kubernetes 会自动使用 <code>Always</code> 重启策略，因为控制器的目标是始终保持 Pod 的期望副本数。</li><li>在这种情况下，重启策略通常不需要显式设置，因为控制器会自动处理 Pod 的调度和重启。</li></ul><h3 id=总结-45>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-45>#</a></h3><ul><li><strong>Always</strong>：适用于需要持续运行的应用，容器退出时会自动重启。</li><li><strong>OnFailure</strong>：适用于有可能失败的任务，容器异常退出时重启。</li><li><strong>Never</strong>：适用于一次性任务或不希望重启的容器，容器退出后不会重启。</li></ul><p>选择正确的重启策略有助于 Kubernetes 高效管理容器生命周期，提高服务的可用性和容错能力。</p><h1 id=9-资源探针有哪些>9. 资源探针有哪些？
<a class=anchor href=#9-%e8%b5%84%e6%ba%90%e6%8e%a2%e9%92%88%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>ExecAction：在容器中执行一个命令，并根据其返回的状态码进行诊断的操作称为Exec探测，状态码为0表示成功，否则即为不健康状态。</li><li>TCPSocketAction：通过与容器的某TCP端口尝试建立连接进行诊断，端口能够成功打开即为正常，否则为不健康状态。</li><li>HTTPGetAction：通过向容器IP地址的某指定端口的指定path发起HTTP GET请求进行诊断，响应码为2xx或3xx时即为成功，否则为失败。</li></ul><p>在 Kubernetes 中，资源探针（Probes）是用来检测容器的健康状况和可用性的机制。探针帮助 Kubernetes 了解容器的状态，以便采取相应的措施，例如重新启动容器、停止请求流量等。Kubernetes 主要有三种类型的探针，分别是 <strong>存活探针（Liveness Probe）</strong>、<strong>就绪探针（Readiness Probe）</strong> 和 <strong>启动探针（Startup Probe）</strong>。</p><h3 id=1-存活探针liveness-probe>1. <strong>存活探针（Liveness Probe）</strong>
<a class=anchor href=#1-%e5%ad%98%e6%b4%bb%e6%8e%a2%e9%92%88liveness-probe>#</a></h3><ul><li><p><strong>目的</strong>：检查容器是否处于健康状态。如果容器不健康（即探测失败），Kubernetes 会重新启动容器。</p></li><li><p><strong>适用场景</strong>：适用于判断应用是否死锁、挂起或进入无法恢复的状态，及时重启容器恢复服务。</p></li><li><p>常见配置</p><p>：</p><ul><li><code>httpGet</code>：通过 HTTP 请求检查容器健康。</li><li><code>tcpSocket</code>：通过 TCP 连接检查容器的健康状况。</li><li><code>exec</code>：执行指定的命令检查容器是否健康。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>livenessProbe</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/healthz</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>failureThreshold</span>: <span style=color:#ae81ff>3</span>
</span></span></code></pre></div></li></ul><h3 id=2-就绪探针readiness-probe>2. <strong>就绪探针（Readiness Probe）</strong>
<a class=anchor href=#2-%e5%b0%b1%e7%bb%aa%e6%8e%a2%e9%92%88readiness-probe>#</a></h3><ul><li><p><strong>目的</strong>：检查容器是否已准备好接受流量。如果探测失败，Kubernetes 会停止将流量路由到该容器。这个探针可以帮助 Kubernetes 确保容器处于就绪状态后才开始接收请求。</p></li><li><p><strong>适用场景</strong>：适用于判断容器是否准备好对外提供服务。例如，应用启动期间可能需要时间加载资源或者连接外部服务，准备好后再开始接收流量。</p></li><li><p>常见配置</p><p>：</p><ul><li><code>httpGet</code>：通过 HTTP 请求检查容器是否准备好接收流量。</li><li><code>tcpSocket</code>：通过 TCP 连接检查容器是否准备好接收流量。</li><li><code>exec</code>：执行指定的命令检查容器是否准备好接收流量。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>readinessProbe</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/readiness</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>10</span>
</span></span></code></pre></div></li></ul><h3 id=3-启动探针startup-probe>3. <strong>启动探针（Startup Probe）</strong>
<a class=anchor href=#3-%e5%90%af%e5%8a%a8%e6%8e%a2%e9%92%88startup-probe>#</a></h3><ul><li><p><strong>目的</strong>：检查容器是否已成功启动，适用于启动时间较长的应用。如果启动探针失败，Kubernetes 会终止容器并根据重启策略重新启动容器。启动探针通常用于长时间启动的应用，如数据库或其他大型应用。</p></li><li><p><strong>适用场景</strong>：用于容器启动过程较长，且不希望在启动阶段因存活探针失败而误判容器不健康的情况。</p></li><li><p>常见配置</p><p>：</p><ul><li><code>httpGet</code>：通过 HTTP 请求检查容器是否成功启动。</li><li><code>tcpSocket</code>：通过 TCP 连接检查容器是否成功启动。</li><li><code>exec</code>：执行指定的命令检查容器是否成功启动。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>startupProbe</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/startup</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>failureThreshold</span>: <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>10</span>
</span></span></code></pre></div></li></ul><h3 id=4-探针配置的常见字段>4. <strong>探针配置的常见字段</strong>
<a class=anchor href=#4-%e6%8e%a2%e9%92%88%e9%85%8d%e7%bd%ae%e7%9a%84%e5%b8%b8%e8%a7%81%e5%ad%97%e6%ae%b5>#</a></h3><ul><li><strong><code>initialDelaySeconds</code></strong>：探针开始检查容器状态之前的延迟时间（秒）。通常在容器启动后需要等待一段时间才能开始检查。</li><li><strong><code>periodSeconds</code></strong>：探针检查的间隔时间（秒）。即每隔多久执行一次探针。</li><li><strong><code>timeoutSeconds</code></strong>：探针请求的超时时间（秒）。如果探针在这个时间内没有响应，则会被视为失败。</li><li><strong><code>failureThreshold</code></strong>：探针失败的最大次数。如果探针连续失败超过该次数，容器会被认为不健康并进行重启（仅适用于存活探针）。</li><li><strong><code>successThreshold</code></strong>：探针成功的最小次数。如果探针成功超过该次数，容器才会被认为是健康的（仅适用于就绪探针）。</li></ul><h3 id=5-探针之间的区别>5. <strong>探针之间的区别</strong>
<a class=anchor href=#5-%e6%8e%a2%e9%92%88%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><ul><li><strong>存活探针（Liveness Probe）</strong>：用于检查容器是否健康，探测失败时会触发重启。</li><li><strong>就绪探针（Readiness Probe）</strong>：用于检查容器是否准备好接受流量，探测失败时会停止流量的路由。</li><li><strong>启动探针（Startup Probe）</strong>：用于容器启动期间的检查，防止启动慢的应用因为存活探针误判失败，适用于启动较慢的应用。</li></ul><h3 id=总结-46>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-46>#</a></h3><ul><li><strong>存活探针（Liveness Probe）</strong>：判断容器是否健康，若失败则重新启动容器。</li><li><strong>就绪探针（Readiness Probe）</strong>：判断容器是否准备好接受流量，若失败则停止将流量路由到容器。</li><li><strong>启动探针（Startup Probe）</strong>：判断容器是否启动完成，通常用于启动时间较长的容器。</li></ul><p>配置探针可以帮助 Kubernetes 更加精确地管理容器的生命周期，确保容器在正常情况下提供服务，减少服务中断和故障恢复时间。</p><h1 id=10-requests和limits用途是什么>10. requests和limits用途是什么？
<a class=anchor href=#10-requests%e5%92%8climits%e7%94%a8%e9%80%94%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>“requests”属性定义其请求的确保可用值，即容器运行可能用不到这些额度的资源，但用到时必须要确保有如此多的资源可用</li><li>”limits”属性则用于限制资源可用的最大值，即硬限制</li></ul><p>在 Kubernetes 中，<code>requests</code> 和 <code>limits</code> 是容器资源管理的重要配置项，用来控制容器在运行时的 CPU 和内存资源使用情况。它们可以在 Pod 的规格中为每个容器指定，帮助 Kubernetes 更好地管理资源分配和调度。以下是 <code>requests</code> 和 <code>limits</code> 的详细说明及用途：</p><h3 id=1-requests>1. <strong>Requests</strong>
<a class=anchor href=#1-requests>#</a></h3><ul><li><p><strong>用途</strong>：<code>requests</code> 是容器在运行时请求的资源量，Kubernetes 调度器基于这些请求来决定在哪个节点上运行容器。<code>requests</code> 表示容器正常运行时所需的最小资源。它是容器启动时必须分配的资源量，调度器将根据 <code>requests</code> 值来安排 Pod 运行的节点。</p></li><li><p>功能</p><p>：</p><ul><li>控制容器所需的最小资源。</li><li>用于调度容器到合适的节点上。</li><li>如果容器实际使用的资源量低于请求的资源量，系统不会强制回收资源，保证容器在该节点上运行时能有足够的资源。</li></ul></li><li><p>例子</p><p>：容器请求 100 毫核 CPU 和 256 MiB 内存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m  </span> <span style=color:#75715e># 100毫核</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>256Mi</span> <span style=color:#75715e># 256 MiB 内存</span>
</span></span></code></pre></div></li></ul><h3 id=2-limits>2. <strong>Limits</strong>
<a class=anchor href=#2-limits>#</a></h3><ul><li><p><strong>用途</strong>：<code>limits</code> 是容器允许使用的最大资源量。如果容器使用的资源超过了 <code>limits</code> 的限制，Kubernetes 会采取措施（例如，CPU 资源限制会导致容器被限制使用更多的 CPU，内存资源限制则可能导致容器被杀死并重启）。<code>limits</code> 用来防止容器在消耗大量资源时影响到其他容器和服务。</p></li><li><p>功能</p><p>：</p><ul><li>设置容器允许使用的最大资源量。</li><li>防止容器消耗过多资源，影响集群中的其他工作负载。</li><li>在内存限制（memory limit）超出时，容器会被 OOM（Out of Memory）杀死。</li></ul></li><li><p>例子</p><p>：容器最大使用 200 毫核 CPU 和 512 MiB 内存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>200m  </span> <span style=color:#75715e># 最大 200毫核 CPU</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>512Mi</span> <span style=color:#75715e># 最大 512 MiB 内存</span>
</span></span></code></pre></div></li></ul><h3 id=3-requests-和-limits-的关系>3. <strong>Requests 和 Limits 的关系</strong>
<a class=anchor href=#3-requests-%e5%92%8c-limits-%e7%9a%84%e5%85%b3%e7%b3%bb>#</a></h3><ul><li><p>请求资源 vs 限制资源</p><p>：</p><ul><li><code>requests</code> 是容器实际启动时的资源需求，决定容器的调度。</li><li><code>limits</code> 是容器可以消耗的最大资源量，一旦超出此限制，Kubernetes 会限制容器使用更多资源，或者在内存超过时会杀死容器。</li></ul></li><li><p>在资源请求和限制上最好设定相同的值</p><p>：</p><ul><li>如果 <code>requests</code> 和 <code>limits</code> 设置得差不多，可以确保容器能在稳定的资源使用下运行。</li><li>如果 <code>requests</code> 设置较低而 <code>limits</code> 设置较高，则容器可以在不超过 <code>limits</code> 的情况下，使用更多的资源，但调度时会考虑请求的最小资源。</li></ul></li></ul><h3 id=4-cpu-和-内存的不同处理>4. <strong>CPU 和 内存的不同处理</strong>
<a class=anchor href=#4-cpu-%e5%92%8c-%e5%86%85%e5%ad%98%e7%9a%84%e4%b8%8d%e5%90%8c%e5%a4%84%e7%90%86>#</a></h3><ul><li><p>CPU</p><p>：</p><ul><li>Kubernetes 的 CPU 资源是以“毫核”计算的。<code>requests</code> 指定了容器启动时所需的 CPU 资源，<code>limits</code> 指定了容器可以使用的最大 CPU。</li><li>资源限制在 CPU 上是通过 <strong>CPU 限制</strong> 来实现的，超出时容器会被“限制”而不是终止。</li></ul></li><li><p>内存</p><p>：</p><ul><li>对于内存，<code>requests</code> 是容器启动时请求的内存量，而 <code>limits</code> 是容器能够使用的最大内存。</li><li>如果容器的内存使用超过 <code>limits</code>，Kubernetes 会 <strong>杀死容器</strong>，并尝试根据策略重新启动它（通常是根据 <code>restartPolicy</code> 来控制）。</li></ul></li></ul><h3 id=5-例子>5. <strong>例子</strong>
<a class=anchor href=#5-%e4%be%8b%e5%ad%90>#</a></h3><p>假设你有一个 Pod，其中的容器请求 100m 的 CPU 和 200Mi 的内存，并且设置了资源限制，最多使用 200m 的 CPU 和 400Mi 的内存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>example-image</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>100m  </span> <span style=color:#75715e># 请求 100 毫核 CPU</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>200Mi</span> <span style=color:#75715e># 请求 200 MiB 内存</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>cpu</span>: <span style=color:#ae81ff>200m  </span> <span style=color:#75715e># 限制最大 200 毫核 CPU</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>memory</span>: <span style=color:#ae81ff>400Mi</span> <span style=color:#75715e># 限制最大 400 MiB 内存</span>
</span></span></code></pre></div><h3 id=6-总结>6. <strong>总结</strong>
<a class=anchor href=#6-%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong>Requests</strong>：容器在启动时需要的最小资源量，决定了 Pod 调度时所需的资源，保证容器运行时有足够资源。</li><li><strong>Limits</strong>：容器能够使用的最大资源量，防止容器过度消耗资源，影响其他容器。</li><li>设置合理的 <code>requests</code> 和 <code>limits</code>，可以提高资源的利用率，避免容器过度占用资源，也有助于 Kubernetes 集群资源的合理分配和调度。</li></ul><h1 id=11-kubeconfig文件包含什么内容用途是什么>11. kubeconfig文件包含什么内容，用途是什么？
<a class=anchor href=#11-kubeconfig%e6%96%87%e4%bb%b6%e5%8c%85%e5%90%ab%e4%bb%80%e4%b9%88%e5%86%85%e5%ae%b9%e7%94%a8%e9%80%94%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><p>包含集群参数（CA证书、API Server地址），客户端参数（上面生成的证书和私钥），集群context 信息（集群名称、用户名）。</p><p><code>kubeconfig</code> 文件是 Kubernetes 的配置文件，它包含了连接到 Kubernetes 集群所需要的信息。Kubernetes 的 <code>kubeconfig</code> 文件存储了与集群交互所需的认证、访问控制和连接信息。它通常用于配置 <code>kubectl</code>（Kubernetes 命令行工具）和其他 Kubernetes 客户端与集群的连接。</p><h3 id=kubeconfig-文件的内容结构><code>kubeconfig</code> 文件的内容结构
<a class=anchor href=#kubeconfig-%e6%96%87%e4%bb%b6%e7%9a%84%e5%86%85%e5%ae%b9%e7%bb%93%e6%9e%84>#</a></h3><p><code>kubeconfig</code> 文件是一个 YAML 格式的文件，通常包含以下几部分内容：</p><ol><li><p><strong><code>apiVersion</code></strong>:</p><ul><li><code>apiVersion</code> 字段指定了 <code>kubeconfig</code> 文件的版本，通常是 <code>v1</code>。</li></ul></li><li><p><strong><code>clusters</code></strong>:</p><ul><li><p><code>clusters</code> 字段定义了集群的配置。每个集群包括集群的名称和 Kubernetes API 服务器的地址及证书信息。通过这些信息，<code>kubectl</code> 可以连接到指定的 Kubernetes 集群。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>clusters</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-cluster</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cluster</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server</span>: <span style=color:#ae81ff>https://my-cluster-api-server:6443</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>certificate-authority</span>: <span style=color:#ae81ff>/path/to/ca.crt</span>
</span></span></code></pre></div></li></ul></li><li><p><strong><code>contexts</code></strong>:</p><ul><li><p><code>contexts</code> 字段包含了多个上下文配置。每个上下文定义了与集群交互的方式，包括集群名称、用户、命名空间等信息。上下文是 Kubernetes 配置中的一个组合，它将集群、用户和命名空间关联起来。用户可以通过切换上下文来在不同的集群和用户环境中工作。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>contexts</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-context</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>context</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>cluster</span>: <span style=color:#ae81ff>my-cluster</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>user</span>: <span style=color:#ae81ff>my-user</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span></code></pre></div></li></ul></li><li><p><strong><code>current-context</code></strong>:</p><ul><li><p><code>current-context</code> 字段指定当前使用的上下文名称。<code>kubectl</code> 会使用该上下文进行所有后续操作，直到切换到其他上下文。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>current-context</span>: <span style=color:#ae81ff>my-context</span>
</span></span></code></pre></div></li></ul></li><li><p><strong><code>users</code></strong>:</p><ul><li><p><code>users</code> 字段定义了用于访问 Kubernetes API 的用户信息。每个用户包含认证信息，例如用户名、密码、令牌或客户端证书。通过这些认证信息，<code>kubectl</code> 可以验证用户身份。</p></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>users</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-user</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>user</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>client-certificate</span>: <span style=color:#ae81ff>/path/to/cert.crt</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>client-key</span>: <span style=color:#ae81ff>/path/to/cert.key</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>token</span>: <span style=color:#ae81ff>my-token</span>
</span></span></code></pre></div></li></ul></li></ol><h3 id=kubeconfig-文件示例><code>kubeconfig</code> 文件示例
<a class=anchor href=#kubeconfig-%e6%96%87%e4%bb%b6%e7%a4%ba%e4%be%8b>#</a></h3><p>以下是一个完整的 <code>kubeconfig</code> 文件示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Config</span>
</span></span><span style=display:flex><span><span style=color:#f92672>clusters</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-cluster</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cluster</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server</span>: <span style=color:#ae81ff>https://my-cluster-api-server:6443</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>certificate-authority</span>: <span style=color:#ae81ff>/path/to/ca.crt</span>
</span></span><span style=display:flex><span><span style=color:#f92672>contexts</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-context</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>context</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>cluster</span>: <span style=color:#ae81ff>my-cluster</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>user</span>: <span style=color:#ae81ff>my-user</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span><span style=color:#f92672>current-context</span>: <span style=color:#ae81ff>my-context</span>
</span></span><span style=display:flex><span><span style=color:#f92672>users</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-user</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>user</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>client-certificate</span>: <span style=color:#ae81ff>/path/to/cert.crt</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>client-key</span>: <span style=color:#ae81ff>/path/to/cert.key</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>token</span>: <span style=color:#ae81ff>my-token</span>
</span></span></code></pre></div><h3 id=kubeconfig-的用途><code>kubeconfig</code> 的用途
<a class=anchor href=#kubeconfig-%e7%9a%84%e7%94%a8%e9%80%94>#</a></h3><ol><li><strong>配置 <code>kubectl</code> 和其他客户端工具</strong>：<ul><li><code>kubeconfig</code> 文件为 <code>kubectl</code> 等客户端工具提供了所需的集群信息和认证信息。当用户运行 <code>kubectl</code> 命令时，工具会自动从 <code>kubeconfig</code> 中获取集群的连接信息并使用正确的认证方式。</li></ul></li><li><strong>支持多个集群和上下文</strong>：<ul><li>一个 <code>kubeconfig</code> 文件可以存储多个集群的配置信息，以及多个上下文。用户可以通过切换上下文（<code>kubectl config use-context</code>）来在不同的集群之间切换工作。</li></ul></li><li><strong>用户认证</strong>：<ul><li><code>kubeconfig</code> 文件存储了与集群交互所需的认证信息，支持多种认证方式，如证书、令牌、用户名和密码等。这些认证信息保证了用户能够访问集群，并在集群中执行相应的操作。</li></ul></li><li><strong>命名空间管理</strong>：<ul><li><code>kubeconfig</code> 文件还可以指定与集群交互时使用的命名空间。通过设置上下文中的 <code>namespace</code> 字段，用户可以在默认命名空间之外指定特定的命名空间。</li></ul></li></ol><h3 id=kubeconfig-文件的管理><code>kubeconfig</code> 文件的管理
<a class=anchor href=#kubeconfig-%e6%96%87%e4%bb%b6%e7%9a%84%e7%ae%a1%e7%90%86>#</a></h3><ul><li><strong>文件位置</strong>：<ul><li>默认情况下，<code>kubeconfig</code> 文件位于用户的主目录下 <code>~/.kube/config</code>。也可以通过 <code>KUBECONFIG</code> 环境变量指定自定义位置。</li></ul></li><li><strong>合并多个 <code>kubeconfig</code> 文件</strong>：<ul><li>可以将多个 <code>kubeconfig</code> 文件合并为一个文件。<code>kubectl</code> 会合并并优先使用 <code>KUBECONFIG</code> 环境变量中指定的文件。通过配置文件中的 <code>contexts</code> 字段，可以同时管理多个集群的访问。</li></ul></li><li><strong>修改当前上下文</strong>：<ul><li>使用 <code>kubectl config use-context &lt;context-name></code> 来切换当前上下文，这样可以在不同的集群或用户间切换操作。</li></ul></li></ul><h3 id=总结-47>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-47>#</a></h3><p><code>kubeconfig</code> 文件是 Kubernetes 集群管理的核心配置文件，包含了集群、用户认证和上下文等信息，用于指导客户端工具（如 <code>kubectl</code>）如何访问集群。通过合理配置 <code>kubeconfig</code> 文件，可以方便地管理多个集群和用户，同时确保操作的安全性和准确性。</p><h1 id=12-rbac中role和clusterrole区别rolebinding和-clusterrolebinding区别>12. RBAC中role和clusterrole区别，rolebinding和 clusterrolebinding区别？
<a class=anchor href=#12-rbac%e4%b8%adrole%e5%92%8cclusterrole%e5%8c%ba%e5%88%abrolebinding%e5%92%8c-clusterrolebinding%e5%8c%ba%e5%88%ab>#</a></h1><ul><li>Role 可以定义在一个 namespace 中，如果想要跨 namespace则可以创建ClusterRole，ClusterRole 具有与 Role相同的权限角色控制能力，不同的是 ClusterRole 是集群级别的</li><li>RoleBinding 适用于某个命名空间内授权，而 ClusterRoleBinding 适用于集群范围内的授权</li></ul><p>在 Kubernetes 中，RBAC（基于角色的访问控制）用于控制用户或服务账户对集群资源的访问权限。<code>Role</code> 和 <code>ClusterRole</code>，以及 <code>RoleBinding</code> 和 <code>ClusterRoleBinding</code> 是 RBAC 中的关键对象，它们定义了权限和如何分配这些权限。它们之间的区别如下：</p><h3 id=1-role-和-clusterrole-的区别>1. <code>Role</code> 和 <code>ClusterRole</code> 的区别
<a class=anchor href=#1-role-%e5%92%8c-clusterrole-%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><ul><li><strong><code>Role</code></strong>：<ul><li><code>Role</code> 是一个集群范围内（namespace 内）的角色，定义了在特定命名空间中对资源的访问权限。它只限于该命名空间内的资源。</li><li>只能授予对特定命名空间内的资源进行访问的权限（例如 Pod、Service 等）。</li><li>典型场景：当你需要在某个命名空间内限制某个用户或服务账户的权限时使用。</li></ul></li><li><strong><code>ClusterRole</code></strong>：<ul><li><code>ClusterRole</code> 是一个集群范围内的角色，定义了对集群中的资源进行访问的权限。它不受命名空间的限制，适用于整个集群。</li><li>可以授予集群级别的权限（例如访问集群中的节点、PersistentVolume 等资源），也可以授予跨命名空间的权限（例如访问所有命名空间中的 Pod、Deployment 等资源）。</li><li>典型场景：当你需要跨多个命名空间或集群级别的权限时使用。</li></ul></li></ul><h3 id=2-rolebinding-和-clusterrolebinding-的区别>2. <code>RoleBinding</code> 和 <code>ClusterRoleBinding</code> 的区别
<a class=anchor href=#2-rolebinding-%e5%92%8c-clusterrolebinding-%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><ul><li><strong><code>RoleBinding</code></strong>：<ul><li><code>RoleBinding</code> 将 <code>Role</code>（命名空间范围内的角色）绑定到一个用户、组或服务账户，并赋予该角色定义的权限。</li><li>只能将 <code>Role</code> 绑定到特定命名空间内的资源上，作用范围仅限于该命名空间。</li><li>典型场景：当你想将一个特定的权限绑定到某个命名空间的用户或服务账户时使用。</li></ul></li><li><strong><code>ClusterRoleBinding</code></strong>：<ul><li><code>ClusterRoleBinding</code> 将 <code>ClusterRole</code>（集群范围内的角色）绑定到一个用户、组或服务账户，并赋予该角色定义的权限。</li><li>适用于集群范围的权限，能够绑定跨多个命名空间的用户或服务账户，或授予集群级别的权限。</li><li>典型场景：当你需要为一个用户或服务账户分配跨命名空间或集群级别的权限时使用。</li></ul></li></ul><h3 id=总结-48>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-48>#</a></h3><ul><li><code>Role</code> 和 <code>ClusterRole</code> 都定义了权限，但 <code>Role</code> 限制在单一命名空间内，而 <code>ClusterRole</code> 是集群级别的，可以跨命名空间或授予集群级别的权限。</li><li><code>RoleBinding</code> 和 <code>ClusterRoleBinding</code> 都将角色绑定到用户或服务账户，但 <code>RoleBinding</code> 只在特定命名空间内有效，而 <code>ClusterRoleBinding</code> 可以绑定到整个集群，应用于多个命名空间或集群级别的资源。</li></ul><h3 id=示例-40>示例
<a class=anchor href=#%e7%a4%ba%e4%be%8b-40>#</a></h3><ol><li><p><strong>Role</strong>（命名空间内权限）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Role</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pod-reader</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>apiGroups</span>: [<span style=color:#e6db74>&#34;&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;pods&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span>]
</span></span></code></pre></div></li><li><p><strong>ClusterRole</strong>（集群范围权限）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ClusterRole</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># No namespace field needed for ClusterRole</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>cluster-admin</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>apiGroups</span>: [<span style=color:#e6db74>&#34;&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes&#34;</span>]
</span></span><span style=display:flex><span>    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span>, <span style=color:#e6db74>&#34;create&#34;</span>]
</span></span></code></pre></div></li><li><p><strong>RoleBinding</strong>（将 Role 绑定到用户）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>RoleBinding</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>read-pods</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span><span style=color:#f92672>subjects</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>User</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>jane</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>apiGroup</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io</span>
</span></span><span style=display:flex><span><span style=color:#f92672>roleRef</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Role</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pod-reader</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>apiGroup</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io</span>
</span></span></code></pre></div></li><li><p><strong>ClusterRoleBinding</strong>（将 ClusterRole 绑定到用户）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ClusterRoleBinding</span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>admin-binding</span>
</span></span><span style=display:flex><span><span style=color:#f92672>subjects</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>User</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>jane</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>apiGroup</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io</span>
</span></span><span style=display:flex><span><span style=color:#f92672>roleRef</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ClusterRole</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>cluster-admin</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>apiGroup</span>: <span style=color:#ae81ff>rbac.authorization.k8s.io</span>
</span></span></code></pre></div></li></ol><p>通过这些对象，Kubernetes 可以灵活地控制用户和服务账户在集群中的权限。</p><h1 id=13-ipvs为啥比iptables效率高>13. ipvs为啥比iptables效率高？
<a class=anchor href=#13-ipvs%e4%b8%ba%e5%95%a5%e6%af%94iptables%e6%95%88%e7%8e%87%e9%ab%98>#</a></h1><p>IPVS模式与iptables同样基于Netfilter，但是ipvs采用的hash表，iptables采用一条条的规则列表。iptables又是为了防火墙设计的，集群数量越多iptables规则就越多，而iptables规则是从上到下匹配，所以效率就越是低下。因此当service数量达到一定规模时，hash查表的速度优势就会显现出来，从而提高service的服务性能</p><p>IPVS（IP Virtual Server）比 iptables 更高效的原因主要在于它们的工作原理、性能优化和用途上的差异。下面是两者效率差异的几个关键因素：</p><h3 id=1-工作方式不同>1. <strong>工作方式不同</strong>
<a class=anchor href=#1-%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f%e4%b8%8d%e5%90%8c>#</a></h3><ul><li><strong>iptables</strong>：<ul><li><code>iptables</code> 是基于包过滤的工具，主要用于流量的过滤、NAT（网络地址转换）和路由转发。它对每个传入的网络包都会进行处理，包括检查每个包的目标端口、源地址、目标地址等，来决定如何处理。</li><li><code>iptables</code> 主要通过链（chains）来过滤网络包，这在复杂的网络流量处理中可能会引入较大的性能开销。</li></ul></li><li><strong>IPVS</strong>：<ul><li><code>IPVS</code> 是一个专门为负载均衡设计的解决方案。它工作在网络层（L4），并且直接使用了内核的负载均衡机制，处理的是传入的流量，而不是每个独立的包。IPVS 通过定义虚拟服务器、负载均衡算法（如轮询、加权轮询、最少连接等），将流量定向到后端真实服务器。</li><li>IPVS 基于流（connection-based）进行处理，它一次性建立一个流的映射，而不是逐个包进行检查。这减少了不必要的处理，因此能在高并发环境中提供更高的效率。</li></ul></li></ul><h3 id=2-性能优化>2. <strong>性能优化</strong>
<a class=anchor href=#2-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96>#</a></h3><ul><li><strong>iptables</strong>：<ul><li><code>iptables</code> 由于需要逐个包进行检查，其性能会受到规则复杂度、包量以及匹配条件的影响，尤其在流量大、规则多时，可能导致性能瓶颈。</li></ul></li><li><strong>IPVS</strong>：<ul><li><code>IPVS</code> 在内核级别实现负载均衡，它在数据包到达时，会直接通过查找流表来决定如何转发流量，从而避免了对每个包的逐一处理。IPVS 通过利用内核提供的高效机制，在性能上优于 <code>iptables</code>。</li><li>它使用了特定的高效算法来管理流量映射，减少了计算的开销。</li></ul></li></ul><h3 id=3-用途差异>3. <strong>用途差异</strong>
<a class=anchor href=#3-%e7%94%a8%e9%80%94%e5%b7%ae%e5%bc%82>#</a></h3><ul><li><strong>iptables</strong> 主要用于包过滤、防火墙规则、NAT 和简单的路由控制，它并不专门针对负载均衡优化。</li><li><strong>IPVS</strong> 则是专门为大规模负载均衡设计的系统，特别适用于处理大量的并发连接和高性能的流量转发。它能够处理非常高的吞吐量，尤其在服务端和客户端之间有大量的连接时，能够显著提高效率。</li></ul><h3 id=4-流量转发方式>4. <strong>流量转发方式</strong>
<a class=anchor href=#4-%e6%b5%81%e9%87%8f%e8%bd%ac%e5%8f%91%e6%96%b9%e5%bc%8f>#</a></h3><ul><li><strong>iptables</strong>：每次收到新的连接包时，<code>iptables</code> 都需要进行规则检查，尤其在规则复杂或者流量大的情况下，效率会下降。</li><li><strong>IPVS</strong>：采用的是基于连接的负载均衡，它将每个连接映射到一个后端服务器，而不是每次处理单个包。这样，在流量较大时，减少了每个包都需要处理的负担，从而提高了处理效率。</li></ul><h3 id=总结-49>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-49>#</a></h3><ul><li><strong>效率高</strong>：由于 <code>IPVS</code> 是为负载均衡专门设计的，且基于流的转发机制，减少了对每个包的处理开销，因此在大规模流量的场景下，性能要优于 <code>iptables</code>。</li><li><strong>适用场景</strong>：<code>iptables</code> 是通用的包过滤工具，而 <code>IPVS</code> 是为负载均衡设计的专用工具，在需要高性能、高吞吐量的负载均衡环境中，<code>IPVS</code> 更具优势。</li></ul><p>因此，IPVS 在进行负载均衡时，能够更高效地处理大规模并发连接，而 iptables 更适合用于防火墙和包过滤任务。</p><h1 id=14-sc-pv-pvc用途容器挂载存储整个流程是什么>14. sc pv pvc用途，容器挂载存储整个流程是什么？
<a class=anchor href=#14-sc-pv-pvc%e7%94%a8%e9%80%94%e5%ae%b9%e5%99%a8%e6%8c%82%e8%bd%bd%e5%ad%98%e5%82%a8%e6%95%b4%e4%b8%aa%e6%b5%81%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>PVC：Pod 想要使用的持久化存储的属性，比如存储的大小、读写权限等。</li><li>PV ：具体的 Volume 的属性，比如 Volume 的类型、挂载目录、远程存储服务器地址等。</li><li>StorageClass：充当 PV 的模板。并且，只有同属于一个 StorageClass 的 PV 和 PVC，才可以绑定在一起。当然，StorageClass 的另一个重要作用，是指定 PV 的 Provisioner（存储插件）。这时候，如果你的存储插件支持 Dynamic Provisioning 的话，Kubernetes 就可以自动为你创建 PV 了。</li></ul><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224012940609.png alt=image-20250224012940609></p><p>在 Kubernetes 中，<strong>SC（StorageClass）</strong>、<strong>PV（PersistentVolume）</strong> 和 <strong>PVC（PersistentVolumeClaim）</strong> 是管理和使用存储资源的关键组件。下面是它们的用途以及容器挂载存储的整个流程。</p><h3 id=1-storageclass-sc>1. <strong>StorageClass (SC)</strong>
<a class=anchor href=#1-storageclass-sc>#</a></h3><p><strong>用途</strong>：</p><ul><li><strong>StorageClass</strong> 是一种 Kubernetes 资源类型，它为存储提供了一个抽象层，用于定义不同类型的存储，指定如何动态地分配存储资源。</li><li><code>StorageClass</code> 可以指定存储提供者、存储类型、存储的性能要求（如 IOPS，延迟等）、存储的生命周期等。</li><li>它允许用户通过声明 PVC 时指定存储类型（例如高性能存储、标准存储等），从而实现存储的动态管理。</li></ul><h3 id=2-persistentvolume-pv>2. <strong>PersistentVolume (PV)</strong>
<a class=anchor href=#2-persistentvolume-pv>#</a></h3><p><strong>用途</strong>：</p><ul><li><strong>PersistentVolume</strong> 是一个持久化存储资源，表示一个已分配给 Kubernetes 集群的存储资源。</li><li>它的生命周期独立于 Pod。也就是说，即使 Pod 被销毁，PV 仍然存在，数据不会丢失。</li><li><code>PV</code> 可以是由管理员手动创建，也可以通过 <code>StorageClass</code> 动态创建。它通常与底层存储（如本地磁盘、NFS、云存储等）关联。</li></ul><h3 id=3-persistentvolumeclaim-pvc>3. <strong>PersistentVolumeClaim (PVC)</strong>
<a class=anchor href=#3-persistentvolumeclaim-pvc>#</a></h3><p><strong>用途</strong>：</p><ul><li><strong>PersistentVolumeClaim</strong> 是用户对存储资源的请求，它指定了存储的大小、访问模式等。</li><li>PVC 允许用户声明他们需要的存储资源，并与集群中的 PV 进行绑定。</li><li>PVC 是对存储资源的需求声明，Kubernetes 会根据 PVC 的请求找到一个合适的 PV 并进行绑定。</li></ul><h3 id=4-容器挂载存储的整个流程>4. <strong>容器挂载存储的整个流程</strong>
<a class=anchor href=#4-%e5%ae%b9%e5%99%a8%e6%8c%82%e8%bd%bd%e5%ad%98%e5%82%a8%e7%9a%84%e6%95%b4%e4%b8%aa%e6%b5%81%e7%a8%8b>#</a></h3><p>容器挂载存储的整个流程包括以下步骤：</p><h4 id=1-定义-storageclass可选>1. <strong>定义 StorageClass（可选）</strong>
<a class=anchor href=#1-%e5%ae%9a%e4%b9%89-storageclass%e5%8f%af%e9%80%89>#</a></h4><ul><li><p>用户定义一个 <code>StorageClass</code>，指定动态分配存储的细节，如存储类型、参数等。如果不指定，Kubernetes 默认使用标准的存储类。</p></li><li><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>storage.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StorageClass</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>fast-storage</span>
</span></span><span style=display:flex><span><span style=color:#f92672>provisioner</span>: <span style=color:#ae81ff>kubernetes.io/aws-ebs</span>
</span></span><span style=display:flex><span><span style=color:#f92672>parameters</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>gp2</span>
</span></span></code></pre></div></li></ul><h4 id=2-定义-pvc>2. <strong>定义 PVC</strong>
<a class=anchor href=#2-%e5%ae%9a%e4%b9%89-pvc>#</a></h4><ul><li><p>用户创建一个 <code>PersistentVolumeClaim</code>，它声明了对特定大小的存储的需求，并可以指定存储的访问模式（如 ReadWriteOnce, ReadOnlyMany 等）。</p></li><li><p>Kubernetes 根据 PVC 请求来寻找合适的 PV 进行绑定。</p></li><li><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolumeClaim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-claim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>10Gi</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>storageClassName</span>: <span style=color:#ae81ff>fast-storage</span>
</span></span></code></pre></div></li></ul><h4 id=3-动态创建-pv如果没有现成的-pv>3. <strong>动态创建 PV（如果没有现成的 PV）</strong>
<a class=anchor href=#3-%e5%8a%a8%e6%80%81%e5%88%9b%e5%bb%ba-pv%e5%a6%82%e6%9e%9c%e6%b2%a1%e6%9c%89%e7%8e%b0%e6%88%90%e7%9a%84-pv>#</a></h4><ul><li>如果没有符合 PVC 的 PV，Kubernetes 会根据 PVC 中的 <code>StorageClass</code> 自动创建一个 PV。</li><li>创建的 PV 会根据 <code>StorageClass</code> 中指定的存储类型和参数进行配置。</li></ul><h4 id=4-pvc-和-pv-绑定>4. <strong>PVC 和 PV 绑定</strong>
<a class=anchor href=#4-pvc-%e5%92%8c-pv-%e7%bb%91%e5%ae%9a>#</a></h4><ul><li>Kubernetes 会将符合条件的 <code>PersistentVolumeClaim</code> 与 <code>PersistentVolume</code> 进行绑定。PVC 和 PV 绑定后，存储资源就分配给用户使用。</li></ul><h4 id=5-挂载到-pod>5. <strong>挂载到 Pod</strong>
<a class=anchor href=#5-%e6%8c%82%e8%bd%bd%e5%88%b0-pod>#</a></h4><ul><li><p>在 Pod 配置文件中，用户声明需要挂载的 PVC，Kubernetes 会将绑定的 PV 挂载到 Pod 中的容器。</p></li><li><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mypod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mycontainer</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/usr/share/nginx/html</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pvc</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pvc</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>persistentVolumeClaim</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>claimName</span>: <span style=color:#ae81ff>my-claim</span>
</span></span></code></pre></div></li></ul><h4 id=6-容器访问存储>6. <strong>容器访问存储</strong>
<a class=anchor href=#6-%e5%ae%b9%e5%99%a8%e8%ae%bf%e9%97%ae%e5%ad%98%e5%82%a8>#</a></h4><ul><li>容器内的应用程序可以通过指定的挂载路径（如 <code>/usr/share/nginx/html</code>）来访问持久化存储中的数据。</li><li>存储会在 Pod 生命周期内持续存在，即使 Pod 被删除，数据仍然保存在 PV 中，除非指定 PV 被删除。</li></ul><h3 id=总结-50>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-50>#</a></h3><ul><li><strong>StorageClass</strong>：定义存储的类型和配置。</li><li><strong>PersistentVolume (PV)</strong>：表示一个具体的存储资源，生命周期与 Pod 无关。</li><li><strong>PersistentVolumeClaim (PVC)</strong>：用户请求存储资源，它将请求映射到 PV。</li><li><strong>Pod挂载存储</strong>：Pod 配置中引用 PVC，Kubernetes 将 PV 挂载到容器中。</li></ul><p>这个流程通过 Kubernetes 的存储管理实现了对存储资源的动态配置和管理，使得容器化应用可以方便地使用持久化存储。</p><h1 id=15-nginx-ingress的原理本质是什么>15. nginx ingress的原理本质是什么？
<a class=anchor href=#15-nginx-ingress%e7%9a%84%e5%8e%9f%e7%90%86%e6%9c%ac%e8%b4%a8%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><ul><li>ingress controller通过和kubernetes api交互，动态的去感知集群中ingress规则变化，</li><li>然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段nginx配置，</li><li>再写到nginx-ingress-controller的pod里，这个Ingress
controller的pod里运行着一个Nginx服务，控制器会把生成的nginx配置写入/etc/nginx.conf文件中，</li><li>然后reload一下使配置生效。以此达到域名分配置和动态更新的问题。</li></ul><p><strong>Ingress</strong> 是 Kubernetes 中用于管理外部访问集群内服务的资源类型。其本质是提供一种 HTTP 和 HTTPS 路由机制，允许从外部网络访问集群内的应用服务。Ingress 资源配置了一些路由规则，这些规则将外部请求根据 URL 路径或主机名转发到集群中的不同服务。</p><h3 id=ingress-的原理本质><strong>Ingress 的原理本质：</strong>
<a class=anchor href=#ingress-%e7%9a%84%e5%8e%9f%e7%90%86%e6%9c%ac%e8%b4%a8>#</a></h3><ol><li><strong>反向代理</strong>：<ul><li>Ingress 实际上是一个 <strong>反向代理</strong>，它处理来自外部的请求，将这些请求根据配置的规则路由到集群中的相应服务。</li><li>例如，可以根据请求的路径（如 <code>/api</code>、<code>/web</code>）或主机名（如 <code>api.example.com</code>、<code>www.example.com</code>）来决定将请求转发到哪个服务。</li></ul></li><li><strong>基于规则的路由</strong>：<ul><li>Ingress 通过定义一组规则来指定如何路由流量。这些规则可以基于 HTTP 请求的 <strong>host</strong>、<strong>path</strong>，或者基于其他请求头进行路由。</li><li>这些规则会由 Ingress 控制器（如 NGINX Ingress Controller）解析，并根据规则将请求转发到相应的后端服务。</li></ul></li><li><strong>Ingress Controller</strong>：<ul><li><strong>Ingress Controller</strong> 是一个处理实际请求的组件，它根据定义在 Ingress 中的规则将流量路由到相应的服务。</li><li>Ingress 本身并不处理流量，它只是一个资源类型。真正处理流量的逻辑由 Ingress Controller 实现。常见的 Ingress Controller 有 NGINX、Traefik、HAProxy、Istio 等。</li><li>Ingress Controller 实际上在 Kubernetes 集群中运行，是集群外部流量的入口点。</li></ul></li><li><strong>SSL/TLS 终结</strong>：<ul><li>Ingress 还可以配置 HTTPS 路由，允许在入口处终止 SSL/TLS 连接。这意味着 Ingress Controller 负责解密 HTTPS 请求，然后将明文的 HTTP 请求转发到集群内的服务。</li></ul></li><li><strong>负载均衡</strong>：<ul><li>Ingress 也支持负载均衡，可以将流量均匀地分发到多个后端服务实例。</li><li>在一些 Ingress Controller（如 NGINX）中，负载均衡的方式可以是轮询（Round Robin）、最少连接（Least Connections）等。</li></ul></li></ol><h3 id=ingress-路由流程><strong>Ingress 路由流程：</strong>
<a class=anchor href=#ingress-%e8%b7%af%e7%94%b1%e6%b5%81%e7%a8%8b>#</a></h3><ol><li>外部用户通过浏览器或其他 HTTP 客户端发送请求，指定的主机名和路径。</li><li>这些请求首先由外部的负载均衡器或 DNS 服务传递到集群中的 Ingress Controller。</li><li>Ingress Controller 根据 Ingress 资源中定义的规则对请求进行匹配。</li><li>Ingress Controller 根据匹配的规则将请求转发到正确的服务和相应的 Pod。</li><li>服务和 Pod 响应请求并返回数据，数据最终通过 Ingress Controller 返回给外部客户端。</li></ol><h3 id=总结-51><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-51>#</a></h3><p>Ingress 的本质是提供一种 <strong>基于 HTTP(S) 请求的路由机制</strong>，通过 Ingress Controller 实现将外部请求转发到集群内的服务，支持负载均衡、路径路由、主机名路由以及 SSL/TLS 终结等功能。</p><h1 id=16-描述不同node上的pod之间的通信流程>16. 描述不同node上的Pod之间的通信流程
<a class=anchor href=#16-%e6%8f%8f%e8%bf%b0%e4%b8%8d%e5%90%8cnode%e4%b8%8a%e7%9a%84pod%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e6%b5%81%e7%a8%8b>#</a></h1><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224013011845.png alt=image-20250224013011845></p><p>在 Kubernetes 中，不同节点（Node）上的 Pod 之间的通信是通过 Kubernetes 网络模型来实现的。根据 Kubernetes 的网络模型，集群内的每个 Pod 都有一个唯一的 IP 地址，并且任何 Pod 都可以与其他 Pod 进行通信，而无需考虑它们是否位于同一个节点上。</p><p>以下是不同 Node 上的 Pod 之间通信的基本流程：</p><h3 id=1-kubernetes-网络模型><strong>1. Kubernetes 网络模型</strong>
<a class=anchor href=#1-kubernetes-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b>#</a></h3><p>Kubernetes 的网络模型确保了以下几点：</p><ul><li>每个 Pod 在集群中都有一个唯一的 IP 地址。</li><li>每个 Pod 可以与其他 Pod 通信，不论它们位于同一节点还是不同节点。</li><li>网络插件（如 Calico、Flannel、Weave 等）负责提供集群内部的网络连接。</li></ul><h3 id=2-通信流程><strong>2. 通信流程</strong>
<a class=anchor href=#2-%e9%80%9a%e4%bf%a1%e6%b5%81%e7%a8%8b>#</a></h3><p>假设有两个 Pod，分别位于两个不同的 Node 上，Pod1 位于 Node1 上，Pod2 位于 Node2 上。Pod1 想要访问 Pod2：</p><h4 id=步骤-1dns-查询或直接-ip-访问><strong>步骤 1：DNS 查询或直接 IP 访问</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-1dns-%e6%9f%a5%e8%af%a2%e6%88%96%e7%9b%b4%e6%8e%a5-ip-%e8%ae%bf%e9%97%ae>#</a></h4><ul><li>如果 Pod1 知道 Pod2 的 IP 地址，它可以直接通过该 IP 地址进行通信。</li><li>如果 Pod1 通过 DNS 进行通信（Kubernetes 中的服务会为 Pod 提供 DNS 名称解析），则 Pod1 会查询 Kubernetes DNS 服务来解析 Pod2 所在服务的 IP 地址。</li></ul><h4 id=步骤-2请求到达节点的网络插件><strong>步骤 2：请求到达节点的网络插件</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-2%e8%af%b7%e6%b1%82%e5%88%b0%e8%be%be%e8%8a%82%e7%82%b9%e7%9a%84%e7%bd%91%e7%bb%9c%e6%8f%92%e4%bb%b6>#</a></h4><ul><li>当 Pod1 发送请求时，请求首先到达 Pod1 所在节点（Node1）的网络插件。网络插件负责将请求发送到 Kubernetes 集群中其他节点。</li><li>如果 Pod1 访问的目标 Pod2 在 Node2 上，Node1 的网络插件会将请求转发给 Node2。</li></ul><h4 id=步骤-3跨节点通信通过-overlay-网络或路由><strong>步骤 3：跨节点通信（通过 Overlay 网络或路由）</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-3%e8%b7%a8%e8%8a%82%e7%82%b9%e9%80%9a%e4%bf%a1%e9%80%9a%e8%bf%87-overlay-%e7%bd%91%e7%bb%9c%e6%88%96%e8%b7%af%e7%94%b1>#</a></h4><ul><li><p>在跨节点通信中，网络插件（如 Flannel、Calico、Weave 等）会为 Pod 之间的流量提供</p><p>Overlay 网络</p><p>或直接使用</p><p>路由</p><p>。</p><ul><li><strong>Overlay 网络</strong>：网络插件会创建一个虚拟网络，将每个节点的虚拟网络接口通过隧道（如 VXLAN 或 GRE）连接起来。这允许不同节点上的 Pod 通过虚拟网络进行通信，即使它们位于物理上不同的服务器上。</li><li><strong>直接路由</strong>：某些网络插件可能会采用直接路由的方式，直接使用集群内的路由来实现跨节点的流量转发。</li></ul></li></ul><h4 id=步骤-4node2-上的网络插件接收请求><strong>步骤 4：Node2 上的网络插件接收请求</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-4node2-%e4%b8%8a%e7%9a%84%e7%bd%91%e7%bb%9c%e6%8f%92%e4%bb%b6%e6%8e%a5%e6%94%b6%e8%af%b7%e6%b1%82>#</a></h4><ul><li>请求到达 Node2 后，Node2 上的网络插件会处理该请求，并将其转发到 Pod2。</li><li>网络插件确保请求通过正确的路由或隧道送到 Pod2。</li></ul><h4 id=步骤-5pod2-响应请求><strong>步骤 5：Pod2 响应请求</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-5pod2-%e5%93%8d%e5%ba%94%e8%af%b7%e6%b1%82>#</a></h4><ul><li>Pod2 接收到请求后，处理该请求并返回响应。响应过程与请求过程类似，Pod2 通过其所在节点的网络插件将响应发送回 Pod1。</li></ul><h4 id=步骤-6返回响应><strong>步骤 6：返回响应</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-6%e8%bf%94%e5%9b%9e%e5%93%8d%e5%ba%94>#</a></h4><ul><li>网络插件会将 Pod2 的响应传递给 Pod1，最终请求和响应通过网络插件成功传递到 Pod1。</li></ul><h3 id=3-使用-service-实现-pod-访问><strong>3. 使用 Service 实现 Pod 访问</strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8-service-%e5%ae%9e%e7%8e%b0-pod-%e8%ae%bf%e9%97%ae>#</a></h3><p>在 Kubernetes 中，直接通过 Pod 的 IP 地址进行通信并不推荐，通常通过 Kubernetes 的 <strong>Service</strong> 机制来实现 Pod 之间的通信。Service 提供了负载均衡和 DNS 解析服务，可以跨多个 Pod 实现高可用。</p><h4 id=service-的作用><strong>Service 的作用：</strong>
<a class=anchor href=#service-%e7%9a%84%e4%bd%9c%e7%94%a8>#</a></h4><ul><li><strong>DNS 解析</strong>：Kubernetes 会为 Service 分配一个 DNS 名称（如 <code>my-service.default.svc.cluster.local</code>），其他 Pod 可以通过这个 DNS 名称访问该 Service。</li><li><strong>负载均衡</strong>：Service 会将请求均衡地转发到其背后所有 Pod，无论这些 Pod 是否位于同一个节点上。</li><li><strong>透明通信</strong>：Service 对客户端透明，它会根据 Pod 的 IP 地址变化动态更新后端 Pod 的列表，确保负载均衡。</li></ul><h3 id=4-安全性和网络策略><strong>4. 安全性和网络策略</strong>
<a class=anchor href=#4-%e5%ae%89%e5%85%a8%e6%80%a7%e5%92%8c%e7%bd%91%e7%bb%9c%e7%ad%96%e7%95%a5>#</a></h3><p>在跨节点通信时，Kubernetes 还可以通过 <strong>网络策略</strong>（Network Policies）来限制或允许不同 Pod 之间的通信。例如，可以限制某些 Pod 只能与同一命名空间下的 Pod 通信，或者允许特定的 Pod 之间的流量通过防火墙策略控制。</p><h3 id=总结-52><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-52>#</a></h3><ol><li><strong>Kubernetes 网络模型</strong>确保每个 Pod 都有一个唯一的 IP 地址，并支持跨节点通信。</li><li><strong>跨节点通信</strong>通过网络插件实现，通常采用 Overlay 网络（如 VXLAN）或直接路由。</li><li><strong>Service</strong> 提供了 Pod 间的高层通信抽象，支持 DNS 名称解析和负载均衡。</li><li><strong>网络策略</strong>可以控制 Pod 间的访问权限，增强集群的安全性。</li></ol><p>这个过程确保了在不同 Node 上的 Pod 之间能够高效、安全地进行通信。</p><h1 id=17-k8s集群节点需要关机维护需要怎么操作>17. k8s集群节点需要关机维护，需要怎么操作
<a class=anchor href=#17-k8s%e9%9b%86%e7%be%a4%e8%8a%82%e7%82%b9%e9%9c%80%e8%a6%81%e5%85%b3%e6%9c%ba%e7%bb%b4%e6%8a%a4%e9%9c%80%e8%a6%81%e6%80%8e%e4%b9%88%e6%93%8d%e4%bd%9c>#</a></h1><ul><li>进行pod驱逐：kubelet drain &lt;node_name></li><li>检查node上是否无pod运行，切被驱逐的pod已经在其他节点运行正常</li><li>关机维护</li><li>开机启动相关服务（注意启动顺序）</li><li>解除node节点不可调度：kubectl uncordon node</li><li>创建测试pod，并使用节点标签测试节点可以被正常调度</li></ul><p>在 Kubernetes 集群中，如果需要对某个节点进行关机维护，必须采取一些操作步骤来确保服务不中断，同时避免出现 Pod 的意外丢失或服务中断。以下是进行节点关机维护的推荐步骤：</p><h3 id=步骤-1驱逐节点上的-pod><strong>步骤 1：驱逐节点上的 Pod</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-1%e9%a9%b1%e9%80%90%e8%8a%82%e7%82%b9%e4%b8%8a%e7%9a%84-pod>#</a></h3><p>首先，需要将节点上的 Pod 移动到其他健康节点。Kubernetes 会在节点关闭时自动将 Pod 从该节点驱逐，但为了保证在维护时不会影响服务，可以提前手动驱逐 Pod。</p><ol><li><p><strong>标记节点为不可调度</strong>
将该节点标记为 <code>cordon</code>，使 Kubernetes 不再在该节点上调度新的 Pod：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cordon &lt;node-name&gt;
</span></span></code></pre></div></li><li><p><strong>驱逐节点上的 Pod</strong>
使用 <code>kubectl drain</code> 命令来驱逐该节点上的所有 Pod（除了 <code>DaemonSet</code> 和 <code>PodDisruptionBudget</code> 控制的 Pod）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl drain &lt;node-name&gt; --ignore-daemonsets --delete-local-data
</span></span></code></pre></div><ul><li><code>--ignore-daemonsets</code>：保留由 <code>DaemonSet</code> 管理的 Pod。</li><li><code>--delete-local-data</code>：删除节点上没有持久化存储的 Pod（如有本地存储）。</li></ul><p>该命令会将该节点上的 Pod 逐个迁移到集群中的其他健康节点。</p></li><li><p><strong>等待 Pod 被迁移</strong>
等待 Kubernetes 将节点上的 Pod 调度到其他健康的节点，确保 Pod 状态恢复正常。</p></li></ol><h3 id=步骤-2检查集群状态><strong>步骤 2：检查集群状态</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-2%e6%a3%80%e6%9f%a5%e9%9b%86%e7%be%a4%e7%8a%b6%e6%80%81>#</a></h3><p>在节点被驱逐之后，需要检查集群的状态，确保所有的服务和 Pod 都已经成功调度到其他节点上，并且没有出现新的故障。</p><ul><li><p>查看节点状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>节点状态应该是 <code>SchedulingDisabled</code>。</p></li><li><p>查看 Pod 的状态，确保它们都已迁移并正常运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pods --all-namespaces
</span></span></code></pre></div></li></ul><h3 id=步骤-3关闭维护节点><strong>步骤 3：关闭维护节点</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-3%e5%85%b3%e9%97%ad%e7%bb%b4%e6%8a%a4%e8%8a%82%e7%82%b9>#</a></h3><p>在确保节点上没有重要任务运行，且其他节点上的 Pod 已经调度完毕后，可以开始关闭该节点进行维护。</p><ul><li><p>如果是物理机或者虚拟机，直接在操作系统层面执行关机命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo shutdown -h now
</span></span></code></pre></div></li><li><p>如果是云环境中的虚拟机，可以通过云平台的控制台关闭该虚拟机。</p></li></ul><h3 id=步骤-4维护完成后重新启动节点><strong>步骤 4：维护完成后重新启动节点</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-4%e7%bb%b4%e6%8a%a4%e5%ae%8c%e6%88%90%e5%90%8e%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8%e8%8a%82%e7%82%b9>#</a></h3><p>节点维护完成后，需要重新启动节点。</p><ol><li><p><strong>启动节点</strong>
启动节点并确保它能够恢复正常运行。</p></li><li><p><strong>标记节点为可调度</strong>
一旦节点重启并恢复正常运行，使用以下命令将节点标记为可调度状态，使其可以再次接收 Pod：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl uncordon &lt;node-name&gt;
</span></span></code></pre></div></li><li><p><strong>检查节点状态</strong>
确保节点恢复为 <code>Ready</code> 状态，表示其正常加入集群：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div></li><li><p><strong>验证 Pod 状态</strong>
确保节点上的 Pod 能够正常运行。如果该节点之前有被驱逐的 Pod，可以确认它们是否已成功重新调度并运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pods -o wide
</span></span></code></pre></div></li></ol><h3 id=步骤-5确保服务正常><strong>步骤 5：确保服务正常</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-5%e7%a1%ae%e4%bf%9d%e6%9c%8d%e5%8a%a1%e6%ad%a3%e5%b8%b8>#</a></h3><p>维护完成后，需要确保所有的服务、Pod 和应用程序正常运行，检查是否有 Pod 无法调度或服务不可用的情况。</p><h3 id=注意事项-3><strong>注意事项：</strong>
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9-3>#</a></h3><ul><li><strong>PodDisruptionBudget (PDB)</strong>：如果你有设置 PodDisruptionBudget，确保在执行 <code>kubectl drain</code> 时不会违反 PDB 规则。PDB 可以保证在维护节点时，最小副本数和应用程序可用性。</li><li><strong>DaemonSets</strong>：DaemonSet 会自动在每个节点上创建 Pod，所以在节点关闭时，它们不会被删除。维护节点时，DaemonSet 管理的 Pod 不会被驱逐。如果需要停止 DaemonSet 的 Pod，可以先删除相应的 DaemonSet。</li><li><strong>持久化存储</strong>：确保有持久化存储的 Pod 在驱逐时能够正常挂载到其他节点，否则会出现数据丢失或服务中断的问题。</li><li><strong>集群资源健康</strong>：维护过程中，确保集群中的资源（如 CPU、内存、网络等）能够满足其他 Pod 的需求，以避免资源瓶颈影响服务。</li></ul><p>通过这些步骤，可以确保在节点维护期间，Kubernetes 集群中的服务不会受到影响，维护工作完成后，节点可以安全地恢复并重新加入集群。</p><h1 id=18-calico和flannel区别>18. Calico和flannel区别
<a class=anchor href=#18-calico%e5%92%8cflannel%e5%8c%ba%e5%88%ab>#</a></h1><ul><li>Flannel（简单、使用居多）：基于Vxlan技术（叠加网络+二层隧道），不支持网络策略</li><li>Calico（较复杂，使用率少于Flannel）：也可以支持隧道网络，但是是三层隧道（IPIP），支持网络策略</li><li>Calico项目既能够独立地为Kubernetes集群提供网络解决方案和网络策略，也能与flannel结合在一起，由flannel提供网络解决方案，而Calico此时仅用于提供网络策略。</li></ul><p>Calico 和 Flannel 都是 Kubernetes 中常用的网络插件，用于为容器提供网络连接。它们都可以实现跨 Pod 的网络通信，但是在架构、功能和性能方面有所不同。下面是它们的主要区别：</p><h3 id=1-网络模型和架构><strong>1. 网络模型和架构</strong>
<a class=anchor href=#1-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e5%92%8c%e6%9e%b6%e6%9e%84>#</a></h3><ul><li><p>Flannel</p><p>：</p><ul><li>Flannel 是一个简单的 Overlay 网络插件。它为 Kubernetes 集群中的 Pod 提供虚拟网络，将不同节点的 Pod 通过隧道连接起来。Flannel 使用 VXLAN 或其他隧道协议来创建跨节点的虚拟网络。</li><li>Flannel 的网络模型一般是 <strong>Layer 3 Overlay</strong>，它会为每个 Pod 分配一个 IP 地址并通过隧道进行通信。</li></ul></li><li><p>Calico</p><p>：</p><ul><li>Calico 是一个功能更强大的网络插件，支持多种模式，包括 <strong>Overlay 网络</strong> 和 <strong>路由模式</strong>。Calico 的核心功能是基于 BGP（边界网关协议）进行 IP 路由，因此它可以在 Kubernetes 集群中提供高性能的 L3 网络。</li><li>Calico 支持 <strong>无代理的网络模型</strong>，通过直接路由实现容器之间的通信，这使得其在某些场景下具有更高的性能。</li></ul></li></ul><h3 id=2-网络类型><strong>2. 网络类型</strong>
<a class=anchor href=#2-%e7%bd%91%e7%bb%9c%e7%b1%bb%e5%9e%8b>#</a></h3><ul><li><p>Flannel</p><p>：</p><ul><li><strong>Overlay 网络</strong>：Flannel 创建一个虚拟的 Overlay 网络，通过 VXLAN、GRE 或其他协议将不同节点的网络连接起来。Flannel 会在每个节点上创建一个虚拟网卡，利用隧道协议将 Pod 之间的流量转发。</li></ul></li><li><p>Calico</p><p>：</p><ul><li><strong>Overlay 网络</strong>：Calico 也支持 Overlay 模式，但它同时支持 <strong>路由模式</strong>，即不需要额外的隧道协议。在路由模式下，Calico 会通过直接路由的方式连接集群中的不同节点。这使得它的性能在大多数情况下比 Flannel 要好。</li><li><strong>无代理模式</strong>：Calico 不使用网络代理（如 Flannel 中的 VXLAN）来转发流量，而是直接使用主机路由表，从而减少了网络开销。</li></ul></li></ul><h3 id=3-性能><strong>3. 性能</strong>
<a class=anchor href=#3-%e6%80%a7%e8%83%bd>#</a></h3><ul><li><strong>Flannel</strong>：<ul><li>Flannel 的性能受限于其使用的隧道协议（如 VXLAN）。虽然 VXLAN 为跨节点通信提供了灵活性，但它引入了额外的开销，可能导致网络性能较差，尤其在大规模集群中。</li><li>隧道协议可能会导致额外的延迟和带宽消耗，尤其在集群规模增大时，性能可能会受到影响。</li></ul></li><li><strong>Calico</strong>：<ul><li>Calico 的性能通常较好，因为它通过路由模式（而非隧道）来实现节点间的通信。Calico 可以直接将流量路由到目标节点，无需通过额外的隧道协议。</li><li>在支持路由模式的情况下，Calico 提供了比 Flannel 更低的延迟和更高的吞吐量，特别是在大规模集群中。</li></ul></li></ul><h3 id=4-安全性><strong>4. 安全性</strong>
<a class=anchor href=#4-%e5%ae%89%e5%85%a8%e6%80%a7>#</a></h3><ul><li><strong>Flannel</strong>：<ul><li>Flannel 本身不提供强大的安全性功能，它仅负责网络通信，通常与网络策略（Network Policies）配合使用。</li><li>安全性依赖于其他工具或服务（例如，Kubernetes 本身的网络策略）。</li></ul></li><li><strong>Calico</strong>：<ul><li>Calico 内置了强大的网络安全功能，包括 <strong>网络策略</strong>（Network Policies）。这些策略允许用户根据网络流量的来源和目的控制通信，从而提高集群的安全性。</li><li>Calico 支持更细粒度的流量控制，可以定义哪些 Pod 或服务可以进行通信，哪些不能，从而提升网络的安全性。</li></ul></li></ul><h3 id=5-网络策略><strong>5. 网络策略</strong>
<a class=anchor href=#5-%e7%bd%91%e7%bb%9c%e7%ad%96%e7%95%a5>#</a></h3><ul><li><p>Flannel</p><p>：</p><ul><li>Flannel 本身不提供网络策略功能，但可以与 Kubernetes 的 <strong>NetworkPolicy</strong> 进行集成，来实现访问控制。</li></ul></li><li><p>Calico</p><p>：</p><ul><li>Calico 内置了强大的网络策略功能，支持复杂的访问控制和流量过滤。通过 Calico，你可以创建更细粒度的安全策略，控制哪些 Pod 或 IP 之间的流量可以通过。</li></ul></li></ul><h3 id=6-可扩展性><strong>6. 可扩展性</strong>
<a class=anchor href=#6-%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7>#</a></h3><ul><li><p>Flannel</p><p>：</p><ul><li>Flannel 设计较简单，适用于小型和中型集群，但在大规模集群中可能会受到性能瓶颈的影响。</li></ul></li><li><p>Calico</p><p>：</p><ul><li>Calico 适用于大规模集群，并且可以与 BGP（边界网关协议）等协议一起工作，实现跨数据中心的容器网络。Calico 的可扩展性比 Flannel 更强，适用于更复杂的网络需求。</li></ul></li></ul><h3 id=7-安装和配置><strong>7. 安装和配置</strong>
<a class=anchor href=#7-%e5%ae%89%e8%a3%85%e5%92%8c%e9%85%8d%e7%bd%ae>#</a></h3><ul><li><strong>Flannel</strong>：<ul><li>Flannel 安装和配置较为简单，易于上手。它通常用于简单的 Kubernetes 集群，适合没有复杂网络需求的场景。</li></ul></li><li><strong>Calico</strong>：<ul><li>Calico 配置更复杂一些，虽然它也支持简单的安装方式，但由于其强大的功能和灵活性，可能需要更精细的配置。特别是在使用 Calico 的网络策略时，管理员需要更多的管理和配置工作。</li></ul></li></ul><h3 id=8-支持的环境><strong>8. 支持的环境</strong>
<a class=anchor href=#8-%e6%94%af%e6%8c%81%e7%9a%84%e7%8e%af%e5%a2%83>#</a></h3><ul><li><strong>Flannel</strong>：<ul><li>Flannel 支持多种环境，包括本地部署的 Kubernetes 集群、云环境以及混合云环境。它也支持多种存储插件和网络插件。</li></ul></li><li><strong>Calico</strong>：<ul><li>Calico 除了支持 Kubernetes 外，还可以与 OpenShift、Docker EE、Mesos 等其他容器编排平台一起使用。它支持多种类型的云环境，并且可以跨数据中心实现连接。</li></ul></li></ul><h3 id=总结-53><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-53>#</a></h3><table><thead><tr><th>特性</th><th><strong>Flannel</strong></th><th><strong>Calico</strong></th></tr></thead><tbody><tr><td><strong>网络模型</strong></td><td>Overlay 网络（VXLAN, GRE）</td><td>Overlay 网络或路由模式（BGP）</td></tr><tr><td><strong>性能</strong></td><td>较低（有隧道协议开销）</td><td>较高（路由模式，低延迟）</td></tr><tr><td><strong>网络策略</strong></td><td>依赖 Kubernetes 的 NetworkPolicy</td><td>内置强大的网络策略功能</td></tr><tr><td><strong>安全性</strong></td><td>基础安全性，依赖外部工具</td><td>内置强大的安全性控制，支持流量过滤</td></tr><tr><td><strong>可扩展性</strong></td><td>适合小中型集群</td><td>适合大规模集群，支持跨数据中心</td></tr><tr><td><strong>安装复杂度</strong></td><td>简单易安装</td><td>配置和安装较复杂</td></tr><tr><td><strong>支持的环境</strong></td><td>本地云环境、混合云环境</td><td>本地云环境、跨数据中心支持</td></tr></tbody></table><h3 id=选择建议><strong>选择建议</strong>：
<a class=anchor href=#%e9%80%89%e6%8b%a9%e5%bb%ba%e8%ae%ae>#</a></h3><ul><li>如果你的 Kubernetes 集群规模较小，且对性能没有严格要求，可以使用 <strong>Flannel</strong>，它安装简单，适合快速部署。</li><li>如果你需要高性能的网络、跨数据中心连接或者更复杂的网络安全控制，建议使用 <strong>Calico</strong>。它适用于更大规模的集群，并提供内置的网络策略和安全功能。</li></ul><h1 id=六prometheus>六、prometheus
<a class=anchor href=#%e5%85%adprometheus>#</a></h1><h1 id=1-prometheus对比zabbix有哪些优势>1. prometheus对比zabbix有哪些优势？
<a class=anchor href=#1-prometheus%e5%af%b9%e6%af%94zabbix%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8a%bf>#</a></h1><blockquote><p><a href=https://blog.csdn.net/wangyiyungw/article/details/85774969>https://blog.csdn.net/wangyiyungw/article/details/85774969</a>**</p></blockquote><p>Prometheus 和 Zabbix 都是非常流行的监控工具，但它们的设计理念和实现方式有所不同。以下是 <strong>Prometheus</strong> 相对于 <strong>Zabbix</strong> 的一些优势：</p><h3 id=1-监控模式pull-vs-push>1. <strong>监控模式：Pull vs Push</strong>
<a class=anchor href=#1-%e7%9b%91%e6%8e%a7%e6%a8%a1%e5%bc%8fpull-vs-push>#</a></h3><ul><li><strong>Prometheus</strong>：采用 <strong>Pull</strong> 模式，定期从目标（如应用、服务器、数据库、容器等）主动拉取监控数据。这使得 Prometheus 可以轻松适应动态变化的环境（如容器、微服务等），并且可以通过多种方式实现监控（例如使用 <strong>exporters</strong> 进行自定义指标采集）。</li><li><strong>Zabbix</strong>：主要采用 <strong>Push</strong> 模式，通过代理或被监控设备主动推送数据，或者使用被动的 <strong>Pull</strong> 模式。虽然 Zabbix 支持 Push 模式，但它的监控主要还是依赖于代理的推送，因此对于大规模动态环境的适应性较差。</li></ul><p><strong>优势</strong>：Prometheus 的 Pull 模式使其更加适应云原生和容器化环境，尤其是 Kubernetes 等动态变化的集群环境。</p><h3 id=2-时序数据存储和查询>2. <strong>时序数据存储和查询</strong>
<a class=anchor href=#2-%e6%97%b6%e5%ba%8f%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e5%92%8c%e6%9f%a5%e8%af%a2>#</a></h3><ul><li><strong>Prometheus</strong>：专门为时序数据设计，具有高效的时间序列数据存储引擎。Prometheus 存储的所有数据都有时间戳，允许对时间序列数据进行强大的查询和聚合操作，支持 <strong>PromQL</strong> 查询语言，可以轻松进行复杂的数据分析。</li><li><strong>Zabbix</strong>：使用传统的关系型数据库（如 MySQL、PostgreSQL）存储数据。虽然 Zabbix 支持时间序列数据的存储，但它的存储引擎和查询语言没有 Prometheus 的时序数据库那么高效，特别是在大规模数据量下。</li></ul><p><strong>优势</strong>：Prometheus 的时序数据库设计和强大的查询能力使其在大数据量的监控和高效查询方面比 Zabbix 更具优势。</p><h3 id=3-动态环境支持>3. <strong>动态环境支持</strong>
<a class=anchor href=#3-%e5%8a%a8%e6%80%81%e7%8e%af%e5%a2%83%e6%94%af%e6%8c%81>#</a></h3><ul><li><strong>Prometheus</strong>：具有出色的支持云原生和容器化环境的能力。通过与 Kubernetes 的集成，可以自动发现和监控集群中的所有容器和服务。同时，Prometheus 对动态 IP、服务发现等场景有很好的适应能力。</li><li><strong>Zabbix</strong>：虽然 Zabbix 支持动态环境，但相对于 Prometheus，它的配置和维护较为复杂，特别是在大规模动态环境（如 Kubernetes、Docker）中，Zabbix 的自动发现和动态监控能力相对较弱。</li></ul><p><strong>优势</strong>：Prometheus 在动态环境（如微服务、容器化）中的自动化、灵活性和可扩展性更强。</p><h3 id=4-集成与生态系统>4. <strong>集成与生态系统</strong>
<a class=anchor href=#4-%e9%9b%86%e6%88%90%e4%b8%8e%e7%94%9f%e6%80%81%e7%b3%bb%e7%bb%9f>#</a></h3><ul><li><strong>Prometheus</strong>：具有丰富的生态系统，支持多种数据采集方式和监控工具集成。例如，通过 <strong>exporters</strong> 可以从各种第三方服务（如数据库、消息队列等）收集指标，并且可以与 <strong>Grafana</strong> 等可视化工具无缝集成，提供强大的监控面板和仪表盘。</li><li><strong>Zabbix</strong>：虽然也有丰富的插件和集成工具，但与 Prometheus 相比，Zabbix 的集成方式和灵活性较为有限，尤其在容器化、微服务架构的集成上，Prometheus 更加友好和高效。</li></ul><p><strong>优势</strong>：Prometheus 的生态系统更加开放，能够轻松集成各种监控需求，尤其适用于微服务和容器化应用。</p><h3 id=5-告警和通知>5. <strong>告警和通知</strong>
<a class=anchor href=#5-%e5%91%8a%e8%ad%a6%e5%92%8c%e9%80%9a%e7%9f%a5>#</a></h3><ul><li><strong>Prometheus</strong>：通过 <strong>Alertmanager</strong> 提供强大的告警功能，支持灵活的告警规则、告警抑制、告警分组等功能。同时，Prometheus 的告警系统与数据查询紧密集成，能够根据 PromQL 查询结果动态触发告警。</li><li><strong>Zabbix</strong>：提供内置的告警系统，支持自定义告警条件、自动化恢复和通知。Zabbix 的告警系统较为传统，灵活性和可扩展性略逊色于 Prometheus，尤其在大规模系统中的复杂告警配置可能需要更多的人工干预。</li></ul><p><strong>优势</strong>：Prometheus 的告警机制更加灵活、易于配置，并且能与监控数据和查询紧密结合，能够为云原生应用提供更好的告警体验。</p><h3 id=6-安装和配置>6. <strong>安装和配置</strong>
<a class=anchor href=#6-%e5%ae%89%e8%a3%85%e5%92%8c%e9%85%8d%e7%bd%ae>#</a></h3><ul><li><strong>Prometheus</strong>：相对简单，尤其在容器化环境中，可以通过 Docker 或 Kubernetes 等快速部署 Prometheus 集群，具有很好的易用性和自动化配置能力。</li><li><strong>Zabbix</strong>：安装和配置相对复杂，尤其在大规模分布式环境中，Zabbix 需要配置数据库、代理、服务器等多个组件，较为繁琐。</li></ul><p><strong>优势</strong>：Prometheus 的安装和配置更加简便，尤其在现代 DevOps 环境和云原生环境中更加高效。</p><h3 id=7-资源消耗>7. <strong>资源消耗</strong>
<a class=anchor href=#7-%e8%b5%84%e6%ba%90%e6%b6%88%e8%80%97>#</a></h3><ul><li><strong>Prometheus</strong>：由于其设计为轻量级的时序数据存储，Prometheus 在资源消耗上相对较低，特别是在小型或中型集群中。</li><li><strong>Zabbix</strong>：在资源消耗方面，Zabbix 可能会较为沉重，尤其是当需要通过代理收集大量数据时，资源消耗可能会增加。</li></ul><p><strong>优势</strong>：Prometheus 在资源消耗和扩展性方面比 Zabbix 更具优势，尤其是在大规模环境中。</p><h3 id=8-水平扩展>8. <strong>水平扩展</strong>
<a class=anchor href=#8-%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95>#</a></h3><ul><li><strong>Prometheus</strong>：支持水平扩展，Prometheus 可以与 <strong>Thanos</strong> 或 <strong>Cortex</strong> 等工具配合，进行跨集群查询和高可用性部署。通过将多个 Prometheus 实例集成，可以支持大规模集群监控。</li><li><strong>Zabbix</strong>：Zabbix 的扩展性较差，虽然支持分布式监控，但相比 Prometheus 的水平扩展，Zabbix 更依赖集中式架构，扩展性和灵活性较差。</li></ul><p><strong>优势</strong>：Prometheus 提供更好的水平扩展能力，适应大规模集群和跨区域监控。</p><h3 id=总结-54>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-54>#</a></h3><p>Prometheus 相对于 Zabbix 的优势在于：</p><ul><li>更适合容器化、云原生和微服务架构。</li><li>支持 Pull 模式，灵活应对动态变化的环境。</li><li>高效的时序数据库和强大的查询语言（PromQL）。</li><li>灵活的告警系统和自动化集成。</li><li>良好的生态系统与其他工具（如 Grafana）集成。</li><li>安装、配置简单，易于扩展和维护。</li></ul><p>当然，Zabbix 也有其优点，特别是在传统 IT 环境中的监控和大规模基础设施的管理，但对于现代化的应用监控和云原生架构，Prometheus 无疑是更优的选择。</p><h1 id=2-prometheus组件有哪些功能是什么>2. prometheus组件有哪些，功能是什么？
<a class=anchor href=#2-prometheus%e7%bb%84%e4%bb%b6%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250224013105889.png alt=image-20250224013105889></p><p>Prometheus 是一个开源的监控系统，专门用于监控多种微服务架构、容器化环境等场景。它由多个组件构成，每个组件都负责不同的功能。以下是 Prometheus 的主要组件及其功能：</p><h3 id=1-prometheus-server>1. <strong>Prometheus Server</strong>
<a class=anchor href=#1-prometheus-server>#</a></h3><ul><li><p><strong>功能</strong>：Prometheus 服务器是核心组件，负责数据的采集、存储、查询和管理。它通过 <strong>Pull</strong> 模式定期从配置的目标（如应用程序、服务或节点）拉取时间序列数据。</p></li><li><p>主要功能</p><p>：</p><ul><li>拉取数据：根据配置从 <strong>exporter</strong> 或其他 Prometheus 实例拉取指标数据。</li><li>存储：将拉取的数据存储在时序数据库中，支持高效查询。</li><li>查询：使用 PromQL（Prometheus 查询语言）提供灵活的数据查询能力。</li><li>警报：根据配置的规则，触发告警并将告警信息发送到 Alertmanager。</li></ul></li></ul><h3 id=2-alertmanager>2. <strong>Alertmanager</strong>
<a class=anchor href=#2-alertmanager>#</a></h3><ul><li><p><strong>功能</strong>：Alertmanager 负责接收来自 Prometheus 的告警信息，处理告警并进行相应的通知（例如，通过邮件、Slack、PagerDuty 等）。</p></li><li><p>主要功能</p><p>：</p><ul><li>告警聚合：Alertmanager 可以聚合多个相同类型的告警，并合并重复的告警信息。</li><li>告警路由：根据告警的不同标签（如严重性、团队等）将告警路由到不同的接收器（如 Slack、邮件等）。</li><li>告警抑制：可以设置告警抑制规则，避免相同问题的重复告警。</li><li>告警分组：可以将多个告警按时间或内容分组，减少告警的噪声。</li></ul></li></ul><h3 id=3-prometheus-exporters>3. <strong>Prometheus Exporters</strong>
<a class=anchor href=#3-prometheus-exporters>#</a></h3><ul><li><p><strong>功能</strong>：Exporters 是用于从不同的系统（如操作系统、数据库、硬件等）收集监控数据的应用程序或服务。它们将系统的度量指标暴露为 Prometheus 可以拉取的 HTTP 格式。</p></li><li><p>常见的 Exporter</p><p>：</p><ul><li><strong>Node Exporter</strong>：用于暴露 Linux/Unix 系统级别的度量指标，如 CPU 使用率、内存使用量、磁盘 I/O 等。</li><li><strong>Blackbox Exporter</strong>：用于测试外部服务的可用性，比如 HTTP 请求、TCP 连接等。</li><li><strong>MySQL Exporter</strong>、<strong>Redis Exporter</strong>：用于暴露数据库或中间件的指标数据。</li><li><strong>Kube-state-metrics</strong>：用于暴露 Kubernetes 资源（如 Pod、Node、Deployment 等）相关的度量指标。</li></ul></li></ul><h3 id=4-prometheus-query-language-promql>4. <strong>Prometheus Query Language (PromQL)</strong>
<a class=anchor href=#4-prometheus-query-language-promql>#</a></h3><ul><li><p><strong>功能</strong>：PromQL 是 Prometheus 提供的查询语言，用于从 Prometheus 数据库中提取、聚合和过滤时间序列数据。</p></li><li><p>主要功能</p><p>：</p><ul><li>查询：用户可以通过 PromQL 编写复杂的查询，从 Prometheus 存储的时间序列数据中提取所需的信息。</li><li>聚合：PromQL 支持多种聚合操作（如 sum、avg、max、min 等）来对时间序列数据进行处理。</li><li>时间操作：PromQL 提供时间范围选择功能，可以指定查询的时间范围，支持相对时间（如过去 5 分钟）和绝对时间。</li></ul></li></ul><h3 id=5-prometheus-ui>5. <strong>Prometheus UI</strong>
<a class=anchor href=#5-prometheus-ui>#</a></h3><ul><li><p><strong>功能</strong>：Prometheus 提供了一个 Web 界面，用户可以通过它查看查询结果、配置告警规则、查看存储的时序数据等。</p></li><li><p>主要功能</p><p>：</p><ul><li>查询功能：可以直接在界面上执行 PromQL 查询。</li><li>查看指标：查看所有可用的指标以及其时间序列数据。</li><li>配置告警：可以通过 UI 配置告警规则，进行告警通知设置。</li></ul></li></ul><h3 id=6-prometheus-pushgateway>6. <strong>Prometheus Pushgateway</strong>
<a class=anchor href=#6-prometheus-pushgateway>#</a></h3><ul><li><p><strong>功能</strong>：Pushgateway 允许应用程序将度量指标主动推送到 Prometheus，而不是通过 Prometheus 的 Pull 方式来拉取数据。常用于短生命周期的批处理作业或定时任务（例如 ETL 作业），它们在运行时将数据推送到 Pushgateway。</p></li><li><p>主要功能</p><p>：</p><ul><li>Push：应用程序将指标推送到 Pushgateway。</li><li>Pull：Prometheus 从 Pushgateway 拉取数据。</li><li>用于短期存在的任务，避免 Prometheus 无法拉取数据的情况。</li></ul></li></ul><h3 id=7-thanos-可选>7. <strong>Thanos (可选)</strong>
<a class=anchor href=#7-thanos-%e5%8f%af%e9%80%89>#</a></h3><ul><li><p><strong>功能</strong>：Thanos 是一个用于扩展 Prometheus 的组件，提供高可用性、长期存储和全局查询的功能。Thanos 通过集成多个 Prometheus 实例，将多个 Prometheus 集群的数据汇聚到一个全局查询层。</p></li><li><p>主要功能</p><p>：</p><ul><li><strong>高可用</strong>：Thanos 可以使 Prometheus 集群成为高可用，多个 Prometheus 实例可以同时工作，避免单点故障。</li><li><strong>长期存储</strong>：Thanos 支持将 Prometheus 存储的数据迁移到对象存储（如 AWS S3），从而提供长期存储功能。</li><li><strong>全局查询</strong>：Thanos 允许跨多个 Prometheus 实例查询数据，提供全局视图。</li></ul></li></ul><h3 id=8-cortex-可选>8. <strong>Cortex (可选)</strong>
<a class=anchor href=#8-cortex-%e5%8f%af%e9%80%89>#</a></h3><ul><li><p><strong>功能</strong>：Cortex 是另一种用于扩展 Prometheus 的解决方案，支持多租户、长期存储和水平扩展。它支持将 Prometheus 的时间序列数据存储在分布式对象存储（如 Amazon S3）中，并提供高可用性和扩展性。</p></li><li><p>主要功能</p><p>：</p><ul><li><strong>多租户</strong>：Cortex 支持多租户环境，每个租户有独立的存储和查询空间。</li><li><strong>长期存储</strong>：支持将 Prometheus 数据持久化到外部存储后端，如 S3。</li><li><strong>水平扩展</strong>：Cortex 设计为高度可扩展，可以根据需求动态增加存储和查询能力。</li></ul></li></ul><h3 id=总结-55>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-55>#</a></h3><p>Prometheus 由多个关键组件组成，各自负责不同的功能：</p><ul><li><strong>Prometheus Server</strong>：负责数据的采集、存储和查询。</li><li><strong>Alertmanager</strong>：处理告警信息并进行通知。</li><li><strong>Exporters</strong>：从不同的服务和系统收集指标数据。</li><li><strong>PromQL</strong>：查询 Prometheus 数据库的查询语言。</li><li><strong>Pushgateway</strong>：允许应用主动推送数据到 Prometheus。</li><li><strong>Thanos</strong> 或 <strong>Cortex</strong>：扩展 Prometheus 提供高可用性、长期存储和跨集群查询功能。</li></ul><h1 id=3-指标类型有哪些>3. 指标类型有哪些？
<a class=anchor href=#3-%e6%8c%87%e6%a0%87%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h1><ul><li>Counter（计数器）</li><li>Guage（仪表盘）</li><li>Histogram（直方图）</li><li>Summary（摘要）</li></ul><p>Prometheus 支持多种类型的指标（metrics），每种指标类型都有不同的用途和特性。以下是 Prometheus 中常见的指标类型：</p><h3 id=1-counter计数器>1. <strong>Counter（计数器）</strong>
<a class=anchor href=#1-counter%e8%ae%a1%e6%95%b0%e5%99%a8>#</a></h3><ul><li><p><strong>定义</strong>：计数器是单调递增的值。它只能增加或重置为零。常用于记录事件的总次数，比如请求次数、错误次数等。</p></li><li><p><strong>用途</strong>：适用于记录某个事件发生的总数，如请求数、成功数、失败数等。</p></li><li><p>特点</p><p>：</p><ul><li>只能递增，无法减少。</li><li>在 Prometheus 查询中，经常与 <code>rate()</code> 或 <code>increase()</code> 函数一起使用来计算某个事件的增长速率。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>http_requests_total</span>{<span style=color:#a6e22e>status</span>=<span style=color:#e6db74>&#34;200&#34;</span>}  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>记录</span> <span style=color:#a6e22e>HTTP</span> <span style=color:#a6e22e>请求总数</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>状态为</span> <span style=color:#ae81ff>200</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span></code></pre></div></li></ul><h3 id=2-gauge仪表盘>2. <strong>Gauge（仪表盘）</strong>
<a class=anchor href=#2-gauge%e4%bb%aa%e8%a1%a8%e7%9b%98>#</a></h3><ul><li><p><strong>定义</strong>：仪表盘指标表示一个可以任意增加或减少的值。适用于表示当前状态或度量。</p></li><li><p><strong>用途</strong>：用于表示一些瞬时变化的值，如内存使用量、CPU 使用率、当前活跃的连接数等。</p></li><li><p>特点</p><p>：</p><ul><li>值可以递增，也可以递减。</li><li>可以表示“当前”某个状态的实时值。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>memory_usage_bytes</span>  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>当前内存使用量</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>单位</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#a6e22e>字节</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span></code></pre></div></li></ul><h3 id=3-histogram直方图>3. <strong>Histogram（直方图）</strong>
<a class=anchor href=#3-histogram%e7%9b%b4%e6%96%b9%e5%9b%be>#</a></h3><ul><li><p><strong>定义</strong>：直方图用于记录数据分布。它将数据分成多个“桶”，可以记录每个桶的计数值，并且可以计算数据的分布情况（例如请求时延的分布）。</p></li><li><p><strong>用途</strong>：用于统计某些值的分布，如请求时延、响应大小等。可以通过设置不同的桶（buckets）来统计不同范围内的数据。</p></li><li><p>特点</p><p>：</p><ul><li>提供多个桶，以便对数据进行分布统计。</li><li>可通过 <code>rate()</code> 函数计算事件的平均时间、请求时延等指标。</li><li>可以与 <code>sum()</code> 和 <code>count()</code> 一起使用计算平均值等。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>http_request_duration_seconds_bucket</span>  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>HTTP</span> <span style=color:#a6e22e>请求持续时间的桶</span>
</span></span></code></pre></div></li></ul><h3 id=4-summary摘要>4. <strong>Summary（摘要）</strong>
<a class=anchor href=#4-summary%e6%91%98%e8%a6%81>#</a></h3><ul><li><p><strong>定义</strong>：摘要用于计算观测值的分位数（percentiles）。它是对直方图的扩展，除了提供直方图的桶计数，还提供如 <code>0.5</code>（50th percentile）等分位数的估算值。</p></li><li><p><strong>用途</strong>：用于获取值的分位数，比如计算 95% 请求的响应时延。Summary 能够直接给出某个百分位（如 90th、95th）的数据。</p></li><li><p>特点</p><p>：</p><ul><li>会提供统计数据的分位数，如 <code>p50</code>、<code>p90</code> 等。</li><li>比直方图更加精确地计算分位数，但它的存储开销和计算开销相对较高。</li></ul></li><li><p>示例</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>http_request_duration_seconds_sum</span>  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>HTTP</span> <span style=color:#a6e22e>请求持续时间的总和</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>http_request_duration_seconds_count</span>  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>HTTP</span> <span style=color:#a6e22e>请求持续时间的请求计数</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>http_request_duration_seconds</span>{<span style=color:#a6e22e>quantile</span>=<span style=color:#e6db74>&#34;0.9&#34;</span>}  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>HTTP</span> <span style=color:#a6e22e>请求持续时间的</span> <span style=color:#ae81ff>90</span><span style=color:#a6e22e>th</span> <span style=color:#a6e22e>百分位</span>
</span></span></code></pre></div></li></ul><h3 id=总结-56>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-56>#</a></h3><ul><li><strong>Counter</strong>：只增不减，用于表示累计的总数（例如，请求数量、错误次数）。</li><li><strong>Gauge</strong>：可以增可以减，用于表示当前瞬时的数值（例如，CPU 使用率、内存占用）。</li><li><strong>Histogram</strong>：用于记录数据分布，支持多个桶，适合用于计算数据的分布情况（如请求时延分布）。</li><li><strong>Summary</strong>：用于计算分位数（百分位），能够获取某些统计值的分位数，适合用于监控响应时间等。</li></ul><p>Prometheus 的指标类型可以根据不同的监控需求选择和使用，在云原生应用、微服务架构和容器化环境中，合理选择这些指标类型可以帮助精确地监控系统的状态和性能。</p><h1 id=4-在应对上千节点监控时如何保障性能>4. 在应对上千节点监控时，如何保障性能
<a class=anchor href=#4-%e5%9c%a8%e5%ba%94%e5%af%b9%e4%b8%8a%e5%8d%83%e8%8a%82%e7%82%b9%e7%9b%91%e6%8e%a7%e6%97%b6%e5%a6%82%e4%bd%95%e4%bf%9d%e9%9a%9c%e6%80%a7%e8%83%bd>#</a></h1><ul><li>降低采集频率</li><li>缩小历史数据保存天数，</li><li>使用集群联邦和远程存储</li></ul><p>在处理大规模 Kubernetes 集群或包含上千个节点的监控时，Prometheus 可能面临性能瓶颈，包括存储、查询延迟、数据收集速度等问题。为了保障 Prometheus 在这种大规模环境下的性能，可以采取以下几种策略：</p><h3 id=1-水平扩展horizontal-scaling>1. <strong>水平扩展（Horizontal Scaling）</strong>
<a class=anchor href=#1-%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95horizontal-scaling>#</a></h3><ul><li><p>Prometheus 分区（Sharding）</p><p>：</p><ul><li>将 Prometheus 集群水平扩展，通过多个 Prometheus 实例进行分片（shard）。每个实例负责监控集群的一部分节点，这样可以减轻单个实例的负载。</li><li>在分片时，需要在 <code>Prometheus</code> 配置中使用 <code>federation</code> 或外部聚合方式，将多个 Prometheus 实例的数据汇总到一个集中的查询接口。</li></ul></li><li><p>多集群 Prometheus 集群</p><p>：</p><ul><li>使用多个 Prometheus 实例，每个实例负责不同的数据中心或 Kubernetes 集群。然后使用 Prometheus 的 <strong>联邦（federation）</strong> 功能将多个集群中的指标汇聚到一个中央 Prometheus 进行统一查询和存储。</li><li>这种方式可以避免单个 Prometheus 实例承载全部负载，提高可扩展性和高可用性。</li></ul></li></ul><h3 id=2-使用->2. <strong>使用 *<em>Prometheus Operator*</em></strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8->#</a></h3><ul><li><strong>Prometheus Operator</strong> 可以简化多实例 Prometheus 集群的管理。它支持自动化部署、配置管理和扩展，帮助简化 Prometheus 集群的维护。</li><li>配置 Prometheus Operator 时，可以使用 <strong>k8s CustomResourceDefinitions (CRD)</strong> 来管理 Prometheus 实例、Alertmanager 和其他组件，确保系统能够根据需求动态扩展。</li></ul><h3 id=3-优化数据存储>3. <strong>优化数据存储</strong>
<a class=anchor href=#3-%e4%bc%98%e5%8c%96%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8>#</a></h3><ul><li><strong>长期存储（Long-Term Storage）</strong>：<ul><li>对于大规模集群，单个 Prometheus 实例的存储很可能会成为瓶颈。可以将 Prometheus 数据存储与外部持久化存储（如 <strong>Thanos</strong> 或 <strong>Cortex</strong>）集成，以提供高可用和高扩展性的长期存储。</li><li><strong>Thanos</strong>：Thanos 是一个针对 Prometheus 的聚合层，它将 Prometheus 存储与长期存储（如对象存储）结合起来，支持查询多个 Prometheus 实例的聚合数据。</li><li><strong>Cortex</strong>：Cortex 是另一种支持 Prometheus 数据长期存储的方案，提供了分布式和可扩展的存储解决方案，适用于大规模环境。</li></ul></li><li><strong>数据压缩与降采样</strong>：<ul><li>配置适当的数据采集频率，减少无用的数据采集，可以通过 <code>scrape_interval</code> 和 <code>scrape_timeout</code> 来调优。</li><li>使用 <strong>数据降采样</strong>（downsampling）技术，减少存储中的数据精度。例如，存储高精度数据只有一段时间，然后对其进行降采样。</li></ul></li></ul><h3 id=4-优化指标收集>4. <strong>优化指标收集</strong>
<a class=anchor href=#4-%e4%bc%98%e5%8c%96%e6%8c%87%e6%a0%87%e6%94%b6%e9%9b%86>#</a></h3><ul><li><strong>控制 Scrape 频率</strong>：<ul><li>对不同的指标设置合理的采集频率，例如，对于某些不频繁变化的指标（如主机负载、磁盘空间等），可以减少 scrape 频率，避免过多的数据采集。</li></ul></li><li><strong>分组采集指标</strong>：<ul><li>将同一类型的指标聚合在一起，避免每个指标独立采集。通过调整采集配置，减少不必要的指标收集，降低负载。</li></ul></li><li><strong>使用 Pushgateway</strong>：<ul><li>对于短期存在的批量作业（如批量任务或一次性任务），可以使用 <strong>Pushgateway</strong> 将数据推送到 Prometheus，而不是通过 scrape 进行轮询。Pushgateway 可以减少 Prometheus 本身的 scrape 负担。</li></ul></li></ul><h3 id=5-优化查询性能>5. <strong>优化查询性能</strong>
<a class=anchor href=#5-%e4%bc%98%e5%8c%96%e6%9f%a5%e8%af%a2%e6%80%a7%e8%83%bd>#</a></h3><ul><li><strong>查询优化</strong>：<ul><li>为了避免 Prometheus 查询时的性能瓶颈，尽量避免查询过于复杂的多维度数据。尽量简化查询条件，减少聚合和 Join 操作。</li><li>适当调整查询缓存配置，减少不必要的实时计算。</li></ul></li><li><strong>PromQL 查询优化</strong>：<ul><li>使用高效的 <strong>PromQL</strong> 查询语法，避免不必要的 <code>rate</code>、<code>avg</code> 等聚合操作。尽量将查询范围限制在必要的数据范围内，避免全量查询。</li></ul></li></ul><h3 id=6-引入->6. <strong>引入 *<em>Thanos*</em> 或 *<em>Cortex*</em> 来实现高可用和长期存储</strong>
<a class=anchor href=#6-%e5%bc%95%e5%85%a5->#</a></h3><ul><li><strong>Thanos</strong> 或 <strong>Cortex</strong> 是 Prometheus 的外部聚合层，提供高可用、持久化存储以及全局查询功能，可以帮助处理超大规模数据。</li><li><strong>Thanos</strong>：将多个 Prometheus 实例的数据集中到一个全局查询层，支持对象存储后端，解决了数据冗余和高可用问题。</li><li><strong>Cortex</strong>：与 Thanos 类似，Cortex 提供了高度可扩展的存储后端，适用于大规模 Prometheus 集群，支持多租户和跨集群查询。</li></ul><h3 id=7-使用-alertmanager-的集群模式>7. <strong>使用 Alertmanager 的集群模式</strong>
<a class=anchor href=#7-%e4%bd%bf%e7%94%a8-alertmanager-%e7%9a%84%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f>#</a></h3><ul><li>在大规模集群中，<strong>Alertmanager</strong> 的配置也需要优化。使用 <strong>Alertmanager 的集群模式</strong>，可以将告警请求分散到多个实例，从而提高告警的处理能力。</li></ul><h3 id=8-使用外部高效的存储后端>8. <strong>使用外部高效的存储后端</strong>
<a class=anchor href=#8-%e4%bd%bf%e7%94%a8%e5%a4%96%e9%83%a8%e9%ab%98%e6%95%88%e7%9a%84%e5%ad%98%e5%82%a8%e5%90%8e%e7%ab%af>#</a></h3><ul><li>考虑将数据存储引入更为高效的存储系统，如 <strong>分布式对象存储</strong>（例如 Amazon S3、Google Cloud Storage）以提高读写性能。</li></ul><h3 id=9-优化网络>9. <strong>优化网络</strong>
<a class=anchor href=#9-%e4%bc%98%e5%8c%96%e7%bd%91%e7%bb%9c>#</a></h3><ul><li>通过合适的网络带宽、延迟优化，确保 Prometheus 与所有节点的连接稳定，避免网络瓶颈导致数据丢失或延迟。</li></ul><h3 id=总结-57><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-57>#</a></h3><p>在大规模 Kubernetes 集群或包含上千节点的环境中，Prometheus 的性能可以通过以下几种方式保障：</p><ol><li><strong>水平扩展</strong>：通过分片和联邦部署多个 Prometheus 实例来减轻单实例负载。</li><li><strong>长期存储解决方案</strong>：使用 Thanos 或 Cortex 进行数据的长期存储和高可用。</li><li><strong>查询和存储优化</strong>：通过合理的查询语句、数据降采样和减少不必要的采集频率来降低系统负担。</li><li><strong>数据收集优化</strong>：合理配置 Scrape 间隔、使用 Pushgateway 等方式减少不必要的数据流量。</li><li><strong>监控网络性能</strong>：通过优化 Prometheus 集群的网络、存储及告警管理等各方面的配置，保障整体性能。</li></ol><h1 id=5-简述从添加节点监控到grafana成图的整个流程>5. 简述从添加节点监控到grafana成图的整个流程
<a class=anchor href=#5-%e7%ae%80%e8%bf%b0%e4%bb%8e%e6%b7%bb%e5%8a%a0%e8%8a%82%e7%82%b9%e7%9b%91%e6%8e%a7%e5%88%b0grafana%e6%88%90%e5%9b%be%e7%9a%84%e6%95%b4%e4%b8%aa%e6%b5%81%e7%a8%8b>#</a></h1><ul><li>被监控节点安装exporter</li><li>prometheus服务端添加监控项</li><li>查看prometheus web界面——status——targets</li><li>grafana创建图表</li></ul><p>在 Prometheus + Grafana 环境下，添加监控节点并在 Grafana 上生成图表的整个流程通常包含以下几个步骤：</p><h3 id=1-安装-prometheus-监控系统>1. <strong>安装 Prometheus 监控系统</strong>
<a class=anchor href=#1-%e5%ae%89%e8%a3%85-prometheus-%e7%9b%91%e6%8e%a7%e7%b3%bb%e7%bb%9f>#</a></h3><ul><li><p><strong>安装 Prometheus</strong>：首先确保 Prometheus 已经安装并启动。Prometheus 作为监控系统，负责从各种节点（如应用服务器、容器、数据库等）收集指标。</p></li><li><p>配置 Prometheus 配置文件（prometheus.yml）</p><p>：配置 Prometheus 从哪些目标（节点）采集数据。</p><ul><li><p>scrape_configs</p><p>：在</p><pre tabindex=0><code>prometheus.yml
</code></pre><p>中，使用</p><pre tabindex=0><code>scrape_configs
</code></pre><p>配置需要监控的目标节点及其端口。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;node_exporter&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>static_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>targets</span>: [<span style=color:#e6db74>&#39;&lt;node-ip&gt;:9100&#39;</span>]
</span></span></code></pre></div></li></ul></li></ul><h3 id=2-安装并配置-node-exporter在被监控节点上>2. <strong>安装并配置 Node Exporter（在被监控节点上）</strong>
<a class=anchor href=#2-%e5%ae%89%e8%a3%85%e5%b9%b6%e9%85%8d%e7%bd%ae-node-exporter%e5%9c%a8%e8%a2%ab%e7%9b%91%e6%8e%a7%e8%8a%82%e7%82%b9%e4%b8%8a>#</a></h3><ul><li><p><strong>安装 Node Exporter</strong>：Node Exporter 是 Prometheus 用来收集服务器硬件和操作系统指标（如 CPU 使用率、内存、磁盘等）的工具。</p></li><li><p>启动 Node Exporter</p><p>：在每个被监控的节点上安装并启动 Node Exporter。默认端口为</p><pre tabindex=0><code>9100
</code></pre><p>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 在每个被监控的节点上启动 Node Exporter</span>
</span></span><span style=display:flex><span>./node_exporter
</span></span></code></pre></div></li><li><p><strong>确保节点可以被 Prometheus 访问</strong>：Prometheus 需要能够访问节点的 <code>9100</code> 端口。</p></li></ul><h3 id=3-prometheus-收集数据>3. <strong>Prometheus 收集数据</strong>
<a class=anchor href=#3-prometheus-%e6%94%b6%e9%9b%86%e6%95%b0%e6%8d%ae>#</a></h3><ul><li>Prometheus 会根据配置的 <code>scrape_interval</code> 定期从每个节点（通过 Node Exporter）拉取指标数据。例如，Prometheus 每 15 秒拉取一次数据。</li><li>通过 <code>http://&lt;node-ip>:9100/metrics</code> 访问 Node Exporter 提供的监控数据（例如 CPU 使用率、内存、磁盘空间等）。</li></ul><h3 id=4-安装-grafana>4. <strong>安装 Grafana</strong>
<a class=anchor href=#4-%e5%ae%89%e8%a3%85-grafana>#</a></h3><ul><li><p>安装 Grafana</p><p>：Grafana 是一个开源的数据可视化工具，它与 Prometheus 配合使用，提供图形化的监控面板。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 安装 Grafana</span>
</span></span><span style=display:flex><span>sudo apt-get install grafana
</span></span></code></pre></div></li></ul><h3 id=5-配置-grafana-数据源>5. <strong>配置 Grafana 数据源</strong>
<a class=anchor href=#5-%e9%85%8d%e7%bd%ae-grafana-%e6%95%b0%e6%8d%ae%e6%ba%90>#</a></h3><ul><li><p>登录 Grafana</p><p>：默认情况下，Grafana 在</p><pre tabindex=0><code>http://&lt;grafana-server-ip&gt;:3000
</code></pre><p>上提供 Web 界面。</p><ul><li>默认用户名和密码是 <code>admin</code> / <code>admin</code>。</li></ul></li><li><p>添加 Prometheus 数据源</p><p>：</p><ul><li>进入 Grafana 控制台后，点击左侧菜单的 “Configuration” > “Data Sources”。</li><li>选择 “Prometheus” 数据源，并填写 Prometheus 的 URL（例如：<code>http://&lt;prometheus-server-ip>:9090</code>）。</li><li>保存并测试连接。</li></ul></li></ul><h3 id=6-创建仪表板和图表>6. <strong>创建仪表板和图表</strong>
<a class=anchor href=#6-%e5%88%9b%e5%bb%ba%e4%bb%aa%e8%a1%a8%e6%9d%bf%e5%92%8c%e5%9b%be%e8%a1%a8>#</a></h3><ul><li><p>创建仪表板</p><p>：</p><ul><li>进入 Grafana 后，点击左侧菜单的 “+” > “Dashboard” 创建新的仪表板。</li><li>在新仪表板中，可以添加多个面板（Panel）来展示不同的监控指标。</li></ul></li><li><p>选择指标</p><p>：</p><ul><li><p>每个面板都可以选择一个 Prometheus 查询，Grafana 会显示该查询的实时结果。例如，查询 CPU 使用率：</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>avg(rate(node_cpu_seconds_total{mode=&#34;user&#34;}[5m])) by (instance)
</code></pre></li><li><p>选择不同的时间范围和图表类型（如时间序列图、条形图、饼图等）。</p></li></ul></li></ul><h3 id=7-设置警报可选>7. <strong>设置警报（可选）</strong>
<a class=anchor href=#7-%e8%ae%be%e7%bd%ae%e8%ad%a6%e6%8a%a5%e5%8f%af%e9%80%89>#</a></h3><ul><li><p>设置警报</p><p>：可以为某些面板设置告警规则，当某个指标超出预定范围时，Grafana 会通过邮件、Slack、Webhook 等方式发送通知。</p><ul><li>在面板的设置中，进入 “Alert” 标签页，配置警报规则。</li></ul></li></ul><h3 id=8-查看监控数据>8. <strong>查看监控数据</strong>
<a class=anchor href=#8-%e6%9f%a5%e7%9c%8b%e7%9b%91%e6%8e%a7%e6%95%b0%e6%8d%ae>#</a></h3><ul><li>完成配置后，Grafana 会开始通过 Prometheus 数据源实时获取数据，并以图表的形式展示在仪表板上。您可以通过 Grafana 控制面板来监控不同节点的各种性能指标，如 CPU 使用率、内存、磁盘 IO、网络流量等。</li></ul><h3 id=9-优化和调整>9. <strong>优化和调整</strong>
<a class=anchor href=#9-%e4%bc%98%e5%8c%96%e5%92%8c%e8%b0%83%e6%95%b4>#</a></h3><ul><li><strong>优化 Prometheus 配置</strong>：根据监控需求，可以调整 <code>prometheus.yml</code> 中的 <code>scrape_interval</code>、<code>scrape_timeout</code> 等参数，以获得更高的采集频率或更低的延迟。</li><li><strong>调整 Grafana 面板</strong>：可以根据需要调整面板的布局、查询频率、时间范围等。</li></ul><h3 id=总结-58>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-58>#</a></h3><ol><li><strong>安装 Prometheus 和配置目标节点</strong>，确保 Prometheus 能定期从 Node Exporter 等数据源拉取指标。</li><li><strong>安装 Grafana</strong>，并在 Grafana 中配置 Prometheus 作为数据源。</li><li><strong>创建 Grafana 仪表板</strong>，并设置相应的查询和图表。</li><li><strong>查看和监控节点数据</strong>，使用 Grafana 可视化数据，并根据需要设置警报。</li></ol><p>通过以上步骤，您就能实现从添加节点监控到 Grafana 上生成实时图表的完整流程。</p><h1 id=6-在工作中用到了哪些exporter>6. 在工作中用到了哪些exporter
<a class=anchor href=#6-%e5%9c%a8%e5%b7%a5%e4%bd%9c%e4%b8%ad%e7%94%a8%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9bexporter>#</a></h1><ul><li>node-exporter监控linux主机</li><li>cAdvisor监控容器</li><li>MySQLD Exporter监控mysql</li><li>Blackbox Exporter网络探测</li><li>Pushgateway采集自定义指标监控</li><li>process exporter进程监控</li></ul><p>在工作中，常用的 exporter 主要有以下几种：</p><ol><li><strong>Node Exporter</strong>：<ul><li>用于收集主机的硬件和操作系统指标，如 CPU、内存、磁盘使用情况、网络流量等。通常用于监控整个主机的性能。</li></ul></li><li><strong>Blackbox Exporter</strong>：<ul><li>用于监控外部服务的可达性（如 HTTP、HTTPS、TCP、DNS 等）。可以用来监控网站、API、数据库等外部服务的健康状况。</li></ul></li><li><strong>MySQL Exporter</strong>：<ul><li>用于从 MySQL 数据库收集各种性能指标，如连接数、查询执行情况、慢查询等。帮助监控数据库的性能和健康状况。</li></ul></li><li><strong>Redis Exporter</strong>：<ul><li>用于收集 Redis 的性能指标，包括内存使用、连接数、命令执行情况等。适用于 Redis 的性能监控和优化。</li></ul></li><li><strong>JMX Exporter</strong>：<ul><li>用于从 Java 应用程序（如 Tomcat、Kafka、Hadoop 等）收集指标。通过暴露 JMX（Java Management Extensions）指标，将 Java 应用的性能数据提供给 Prometheus。</li></ul></li><li><strong>Kubernetes Metrics Server</strong>：<ul><li>Kubernetes 集群中用于收集各个 Pod 和 Node 的资源使用数据（如 CPU、内存使用量）。通常与 Prometheus 配合使用，提供集群级别的监控数据。</li></ul></li><li><strong>NGINX Exporter</strong>：<ul><li>用于收集 Nginx 服务器的运行指标，如请求数量、响应时间、连接数等。帮助监控 Nginx 的负载和健康状况。</li></ul></li><li><strong>Kafka Exporter</strong>：<ul><li>用于监控 Kafka 集群的健康和性能指标，如主题（topic）大小、分区状态、消费者延迟等。</li></ul></li><li><strong>PostgreSQL Exporter</strong>：<ul><li>用于从 PostgreSQL 数据库收集指标，包括连接数、查询性能、索引使用情况等，帮助分析数据库的运行状态。</li></ul></li><li><strong>Docker Exporter</strong>：<ul><li>用于收集 Docker 容器的资源使用情况，如 CPU、内存、磁盘等，适用于容器化环境的监控。</li></ul></li><li><strong>Consul Exporter</strong>：<ul><li>用于从 HashiCorp Consul 中收集监控数据，主要是关于服务健康检查的状态和元数据。</li></ul></li></ol><p>这些 exporters 使得 Prometheus 能够全面地监控基础设施、应用程序和数据库等关键组件，并结合 Grafana 提供实时的可视化数据。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#1-加电自检-post>1. <strong>加电自检 (POST)</strong></a></li><li><a href=#2-加载引导程序-bootloader>2. <strong>加载引导程序 (Bootloader)</strong></a></li><li><a href=#3-加载内核-kernel>3. <strong>加载内核 (Kernel)</strong></a></li><li><a href=#4-初始化硬件和挂载根文件系统-root-filesystem>4. <strong>初始化硬件和挂载根文件系统 (Root Filesystem)</strong></a></li><li><a href=#5-启动-init-进程>5. <strong>启动 init 进程</strong></a></li><li><a href=#6-运行-init-脚本或服务管理器>6. <strong>运行 init 脚本或服务管理器</strong></a></li><li><a href=#7-启动用户空间进程>7. <strong>启动用户空间进程</strong></a></li><li><a href=#8-登录界面>8. <strong>登录界面</strong></a></li><li><a href=#9-用户登录>9. <strong>用户登录</strong></a></li><li><a href=#简要总结>简要总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-普通文件regular-file>1. <strong>普通文件（Regular File）</strong></a></li><li><a href=#2-目录文件directory-file>2. <strong>目录文件（Directory File）</strong></a></li><li><a href=#3-符号链接文件symbolic-link或-symlink>3. <strong>符号链接文件（Symbolic Link，或 Symlink）</strong></a></li><li><a href=#4-字符设备文件character-device-file>4. <strong>字符设备文件（Character Device File）</strong></a></li><li><a href=#5-块设备文件block-device-file>5. <strong>块设备文件（Block Device File）</strong></a></li><li><a href=#6-fifo-文件fifo-也叫命名管道>6. <strong>FIFO 文件（FIFO, 也叫命名管道）</strong></a></li><li><a href=#7-套接字文件socket-file>7. <strong>套接字文件（Socket File）</strong></a></li><li><a href=#8-空文件empty-file>8. <strong>空文件（Empty File）</strong></a></li><li><a href=#查看文件类型>查看文件类型</a></li><li><a href=#总结>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#centos-6-和-centos-7-开机自启动的基本步骤>CentOS 6 和 CentOS 7 开机自启动的基本步骤</a></li><li><a href=#总结-1>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#lvmlogical-volume-management简介>LVM（Logical Volume Management）简介</a></li><li><a href=#如何给使用-lvm-的--分区扩容>如何给使用 LVM 的 <code>/</code> 分区扩容</a></li></ul></li></ul><ul><li><ul><li><a href=#1-du>1. <strong><code>du</code> 命令的工作原理</strong></a></li><li><a href=#2-df>2. <strong><code>df</code> 命令的工作原理</strong></a></li><li><a href=#3-为什么>3. <strong>为什么 <code>du</code> 和 <code>df</code> 显示不一致？</strong></a></li><li><a href=#4-常见场景示例>4. <strong>常见场景示例</strong></a></li><li><a href=#5-如何让>5. <strong>如何让 <code>du</code> 和 <code>df</code> 的结果更接近？</strong></a></li><li><a href=#总结-3>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-通过官方仓库更新内核centos-7>1. <strong>通过官方仓库更新内核（CentOS 7）</strong></a></li><li><a href=#2-通过-elrepo-安装最新的内核centos-7>2. <strong>通过 ELRepo 安装最新的内核（CentOS 7）</strong></a></li><li><a href=#3-通过源代码手动编译安装内核适用于所有版本>3. <strong>通过源代码手动编译安装内核（适用于所有版本）</strong></a></li><li><a href=#4-常见问题和注意事项>4. <strong>常见问题和注意事项</strong></a></li><li><a href=#总结-4>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-基本的-nginx-访问日志格式>1. <strong>基本的 Nginx 访问日志格式</strong></a></li><li><a href=#2-通过命令统计访问量前十的-ip>2. <strong>通过命令统计访问量前十的 IP</strong></a></li><li><a href=#3-详细的字段输出>3. <strong>详细的字段输出</strong></a></li><li><a href=#4-按日期时间过滤日志>4. <strong>按日期/时间过滤日志</strong></a></li><li><a href=#5-按请求类型如-get-post进行过滤>5. <strong>按请求类型（如 GET, POST）进行过滤</strong></a></li><li><a href=#6-自动化统计并输出到文件>6. <strong>自动化统计并输出到文件</strong></a></li><li><a href=#总结-5>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-查看>1. <strong>查看 <code>.log</code> 文件中超过 30 天的文件</strong></a></li><li><a href=#2-删除超过-30-天的>2. <strong>删除超过 30 天的 <code>.log</code> 文件</strong></a></li><li><a href=#3-在删除前进行确认>3. <strong>在删除前进行确认</strong></a></li><li><a href=#4-使用>4. <strong>使用 <code>logrotate</code> 自动管理日志</strong></a></li><li><a href=#总结-6>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-文件和目录管理模块>1. <strong>文件和目录管理模块</strong></a></li><li><a href=#2-系统管理模块>2. <strong>系统管理模块</strong></a></li><li><a href=#3-网络管理模块>3. <strong>网络管理模块</strong></a></li><li><a href=#4-包管理模块>4. <strong>包管理模块</strong></a></li><li><a href=#5-数据库管理模块>5. <strong>数据库管理模块</strong></a></li><li><a href=#6-云服务模块>6. <strong>云服务模块</strong></a></li><li><a href=#7-监控与报警模块>7. <strong>监控与报警模块</strong></a></li><li><a href=#8-用户输入和通知模块>8. <strong>用户输入和通知模块</strong></a></li><li><a href=#9-容器和虚拟化管理模块>9. <strong>容器和虚拟化管理模块</strong></a></li><li><a href=#总结-7>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-事件驱动架构>1. <strong>事件驱动架构</strong></a></li><li><a href=#2-内存消耗>2. <strong>内存消耗</strong></a></li><li><a href=#3-高效的静态内容处理>3. <strong>高效的静态内容处理</strong></a></li><li><a href=#4-非阻塞-io>4. <strong>非阻塞 I/O</strong></a></li><li><a href=#5-更低的-cpu-和内存开销>5. <strong>更低的 CPU 和内存开销</strong></a></li><li><a href=#6-负载均衡和反向代理能力>6. <strong>负载均衡和反向代理能力</strong></a></li><li><a href=#7-配置简洁与优化>7. <strong>配置简洁与优化</strong></a></li><li><a href=#总结-8>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-osi模型层次>1. <strong>OSI模型层次</strong></a></li><li><a href=#2-负载均衡决策依据>2. <strong>负载均衡决策依据</strong></a></li><li><a href=#3-处理复杂度和性能>3. <strong>处理复杂度和性能</strong></a></li><li><a href=#4-应用场景>4. <strong>应用场景</strong></a></li><li><a href=#5-功能特性>5. <strong>功能特性</strong></a></li><li><a href=#6-ssltls-终止>6. <strong>SSL/TLS 终止</strong></a></li><li><a href=#总结-9>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-nat-network-address-translation-模式>1. <strong>NAT (Network Address Translation) 模式</strong></a></li><li><a href=#2-dr-direct-routing-模式>2. <strong>DR (Direct Routing) 模式</strong></a></li><li><a href=#3-tun-ip-tunneling-模式>3. <strong>TUN (IP Tunneling) 模式</strong></a></li><li><a href=#性能对比>性能对比：</a></li><li><a href=#总结-10>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-lvs-linux-virtual-server>1. <strong>LVS (Linux Virtual Server)</strong></a></li><li><a href=#2-nginx>2. <strong>Nginx</strong></a></li><li><a href=#3-haproxy>3. <strong>HAProxy</strong></a></li><li><a href=#4-keepalived>4. <strong>Keepalived</strong></a></li><li><a href=#总结与适用场景>总结与适用场景：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-协议部分https>1. <strong>协议部分</strong>：<code>https://</code></a></li><li><a href=#2-主机名部分wwwbaiducom>2. <strong>主机名部分</strong>：<code>www.baidu.com</code></a></li><li><a href=#3-路径部分s>3. <strong>路径部分</strong>：<code>/s</code></a></li><li><a href=#4-查询参数部分word123ieutf-8>4. <strong>查询参数部分</strong>：<code>?word=123&amp;ie=utf-8</code></a></li><li><a href=#总结-11>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#tomcat-目录结构含义>Tomcat 目录结构含义</a></li><li><a href=#如何修改-tomcat-的端口>如何修改 Tomcat 的端口？</a></li><li><a href=#如何修改-tomcat-的内存设置>如何修改 Tomcat 的内存设置？</a></li><li><a href=#总结-12>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#步骤-3>步骤：</a></li><li><a href=#重要提示>重要提示：</a></li><li><a href=#总结-13>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-轮询round-robin>1. <strong>轮询（Round Robin）</strong></a></li><li><a href=#2-最少连接least-connections>2. <strong>最少连接（Least Connections）</strong></a></li><li><a href=#3-ip-哈希ip-hash>3. <strong>IP 哈希（IP Hash）</strong></a></li><li><a href=#4-加权轮询weighted-round-robin>4. <strong>加权轮询（Weighted Round Robin）</strong></a></li><li><a href=#5-加权最少连接weighted-least-connections>5. <strong>加权最少连接（Weighted Least Connections）</strong></a></li><li><a href=#6-随机random>6. <strong>随机（Random）</strong></a></li><li><a href=#7-最少响应时间least-time-nginx-plus>7. <strong>最少响应时间（Least Time）</strong> (Nginx Plus)</a></li><li><a href=#总结-14>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用-apache-jmeter-进行压力测试>1. <strong>使用 Apache JMeter 进行压力测试</strong></a></li><li><a href=#2-使用-locust-进行压力测试>2. <strong>使用 Locust 进行压力测试</strong></a></li><li><a href=#3-使用-ab-apache-bench-进行压力测试>3. <strong>使用 ab (Apache Bench) 进行压力测试</strong></a></li><li><a href=#4-使用-siege-进行压力测试>4. <strong>使用 siege 进行压力测试</strong></a></li><li><a href=#5-使用-gatling-进行压力测试>5. <strong>使用 Gatling 进行压力测试</strong></a></li><li><a href=#6-使用-artillery-进行压力测试>6. <strong>使用 Artillery 进行压力测试</strong></a></li><li><a href=#总结-15>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-发送-https-请求>1. <strong>发送 HTTPS 请求</strong></a></li><li><a href=#2-查看响应头信息>2. <strong>查看响应头信息</strong></a></li><li><a href=#3-发送-get-请求>3. <strong>发送 GET 请求</strong></a></li><li><a href=#4-发送-post-请求>4. <strong>发送 POST 请求</strong></a></li><li><a href=#5-发送带自定义头的请求>5. <strong>发送带自定义头的请求</strong></a></li><li><a href=#总结-16>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#为什么索引能加快查询><strong>为什么索引能加快查询？</strong></a></li><li><a href=#索引的缺点和限制><strong>索引的缺点和限制</strong></a></li><li><a href=#总结-17><strong>总结：</strong></a></li></ul></li><li><a href=#2-sql语句左外连接-右外连接-内连接-全连接区别>2. sql语句左外连接 右外连接 内连接 全连接区别</a><ul><li><a href=#1-内连接-inner-join>1. <strong>内连接 (INNER JOIN)</strong></a></li><li><a href=#2-左外连接-left-join-或-left-outer-join>2. <strong>左外连接 (LEFT JOIN 或 LEFT OUTER JOIN)</strong></a></li><li><a href=#3-右外连接-right-join-或-right-outer-join>3. <strong>右外连接 (RIGHT JOIN 或 RIGHT OUTER JOIN)</strong></a></li><li><a href=#4-全外连接-full-join-或-full-outer-join>4. <strong>全外连接 (FULL JOIN 或 FULL OUTER JOIN)</strong></a></li><li><a href=#总结-18><strong>总结：</strong></a></li><li><a href=#举例说明><strong>举例说明：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#常见的-mysql-数据备份方式><strong>常见的 MySQL 数据备份方式</strong></a></li><li><a href=#恢复的常见方式><strong>恢复的常见方式</strong></a></li><li><a href=#mysql-备份策略><strong>MySQL 备份策略</strong></a></li><li><a href=#总结-19><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#数据库主从同步配置><strong>数据库主从同步配置</strong></a></li><li><a href=#1-配置主服务器master><strong>1. 配置主服务器（Master）</strong></a></li><li><a href=#2-配置从服务器slave><strong>2. 配置从服务器（Slave）</strong></a></li><li><a href=#3-验证同步是否正常><strong>3. 验证同步是否正常</strong></a></li><li><a href=#实际工作中遇到的数据不一致问题><strong>实际工作中遇到的数据不一致问题</strong></a></li><li><a href=#总结-20><strong>总结</strong></a></li></ul></li><li><a href=#5-mysql约束有哪些>5. mysql约束有哪些？</a><ul><li><a href=#1-主键约束primary-key><strong>1. 主键约束（PRIMARY KEY）</strong></a></li><li><a href=#2-唯一约束unique><strong>2. 唯一约束（UNIQUE）</strong></a></li><li><a href=#3-外键约束foreign-key><strong>3. 外键约束（FOREIGN KEY）</strong></a></li><li><a href=#4-检查约束check><strong>4. 检查约束（CHECK）</strong></a></li><li><a href=#5-非空约束not-null><strong>5. 非空约束（NOT NULL）</strong></a></li><li><a href=#6-默认值约束default><strong>6. 默认值约束（DEFAULT）</strong></a></li><li><a href=#7-自动递增约束auto_><strong>7. 自动递增约束（AUTO_INCREMENT）</strong></a></li><li><a href=#8-索引约束index><strong>8. 索引约束（INDEX）</strong></a></li><li><a href=#9-联合唯一约束unique-constraint><strong>9. 联合唯一约束（UNIQUE CONSTRAINT）</strong></a></li><li><a href=#总结-21><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#主要用途><strong>主要用途：</strong></a></li><li><a href=#binlog-格式><strong>binlog 格式：</strong></a></li><li><a href=#启用与配置-binlog><strong>启用与配置 binlog：</strong></a></li><li><a href=#总结-22><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-innodb><strong>1. InnoDB</strong></a></li><li><a href=#2-myisam><strong>2. MyISAM</strong></a></li><li><a href=#3-memoryheap><strong>3. MEMORY（HEAP）</strong></a></li><li><a href=#4-csv><strong>4. CSV</strong></a></li><li><a href=#5-archive><strong>5. ARCHIVE</strong></a></li><li><a href=#6-ndb-cluster><strong>6. NDB (Cluster)</strong></a></li><li><a href=#7-blackhole><strong>7. BLACKHOLE</strong></a></li><li><a href=#8-tokudb><strong>8. TokuDB</strong></a></li><li><a href=#总结-23><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-查询-mysql-数据目录配置>1. <strong>查询 MySQL 数据目录配置</strong></a></li><li><a href=#2-检查-mysql-配置文件>2. <strong>检查 MySQL 配置文件</strong></a></li><li><a href=#3-查看操作系统文件系统>3. <strong>查看操作系统文件系统</strong></a></li><li><a href=#4-通过-mysql-启动命令检查>4. <strong>通过 MySQL 启动命令检查</strong></a></li><li><a href=#总结-24><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-frm>1. <strong>.frm</strong></a></li><li><a href=#2-ibd>2. <strong>.ibd</strong></a></li><li><a href=#3-myd>3. <strong>.myd</strong></a></li><li><a href=#4-myi>4. <strong>.myi</strong></a></li><li><a href=#5-log日志文件>5. <strong>.log</strong>（日志文件）</a></li><li><a href=#6-ib_>6. <strong>.ib_logfile</strong></a></li><li><a href=#7-cnd>7. <strong>.cnd</strong></a></li><li><a href=#8-tmp>8. <strong>.tmp</strong></a></li><li><a href=#9-ibdata>9. <strong>.ibdata</strong></a></li><li><a href=#总结-25><strong>总结</strong></a></li></ul></li><li><a href=#10-如何修改数据库用户的密码>10. 如何修改数据库用户的密码？</a><ul><li><a href=#1-使用>1. <strong>使用 <code>ALTER USER</code> 语句（推荐）</strong></a></li><li><a href=#2-使用>2. <strong>使用 <code>SET PASSWORD</code> 语句</strong></a></li><li><a href=#3-使用>3. <strong>使用 <code>UPDATE</code> 语句修改 <code>mysql.user</code> 表</strong></a></li><li><a href=#4-重置>4. <strong>重置 <code>root</code> 密码</strong></a></li><li><a href=#总结-26>总结：</a></li><li><a href=#1-使用-1>1. <strong>使用 <code>ALTER USER</code> 语句（推荐）</strong></a></li><li><a href=#2-使用-1>2. <strong>使用 <code>SET PASSWORD</code> 语句</strong></a></li><li><a href=#3-直接修改>3. <strong>直接修改 <code>mysql.user</code> 表（不推荐）</strong></a></li><li><a href=#4-重置-1>4. <strong>重置 <code>root</code> 密码（如果忘记密码）</strong></a></li><li><a href=#5-查看密码加密方式>5. <strong>查看密码加密方式</strong></a></li><li><a href=#总结-27>总结</a></li></ul></li><li><a href=#11-如何修改用户权限如何查看>11. 如何修改用户权限？如何查看？</a><ul><li><a href=#1-查看用户权限>1. <strong>查看用户权限</strong></a></li><li><a href=#2-修改用户权限>2. <strong>修改用户权限</strong></a></li><li><a href=#3-刷新权限>3. <strong>刷新权限</strong></a></li><li><a href=#4-删除用户权限>4. <strong>删除用户权限</strong></a></li><li><a href=#总结-28>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-rdbredis-数据库快照>1. <strong>RDB（Redis 数据库快照）</strong></a></li><li><a href=#2-aofappend-only-file>2. <strong>AOF（Append Only File）</strong></a></li><li><a href=#3-混合持久化rdb--aof>3. <strong>混合持久化（RDB + AOF）</strong></a></li><li><a href=#4-持久化相关配置的选择>4. <strong>持久化相关配置的选择</strong></a></li><li><a href=#5-如何优化-aof-文件>5. <strong>如何优化 AOF 文件</strong></a></li><li><a href=#总结-29>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#redis-集群方案主要有以下几种>Redis 集群方案主要有以下几种：</a></li><li><a href=#1-原生-redis-集群redis-cluster>1. <strong>原生 Redis 集群（Redis Cluster）</strong></a></li><li><a href=#2-redis-sentinel>2. <strong>Redis Sentinel</strong></a></li><li><a href=#3-redis-代理方案如-twemproxy>3. <strong>Redis 代理方案（如 Twemproxy）</strong></a></li><li><a href=#4-redis-sharding手动分片>4. <strong>Redis Sharding（手动分片）</strong></a></li><li><a href=#总结-30>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-rdb-持久化备份与恢复>1. <strong>RDB 持久化备份与恢复</strong></a></li><li><a href=#2-aof-持久化备份与恢复>2. <strong>AOF 持久化备份与恢复</strong></a></li><li><a href=#3-混合持久化rdb--aof-1>3. <strong>混合持久化（RDB + AOF）</strong></a></li><li><a href=#4-手动备份通过文件复制>4. <strong>手动备份（通过文件复制）</strong></a></li><li><a href=#5-增量备份>5. <strong>增量备份</strong></a></li><li><a href=#6-备份策略与最佳实践>6. <strong>备份策略与最佳实践</strong></a></li><li><a href=#总结-31>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用-2>1. <strong>使用 <code>mongodump</code> 进行备份</strong></a></li><li><a href=#2-使用-2>2. <strong>使用 <code>mongorestore</code> 进行恢复</strong></a></li><li><a href=#3-使用文件系统级备份>3. <strong>使用文件系统级备份</strong></a></li><li><a href=#4-使用-mongodb-atlas-进行备份云托管服务>4. <strong>使用 MongoDB Atlas 进行备份（云托管服务）</strong></a></li><li><a href=#5-增量备份-1>5. <strong>增量备份</strong></a></li><li><a href=#6-定期备份和自动化>6. <strong>定期备份和自动化</strong></a></li><li><a href=#总结-32>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-顺序写入与高效磁盘存储>1. <strong>顺序写入与高效磁盘存储</strong></a></li><li><a href=#2-持久化与内存管理>2. <strong>持久化与内存管理</strong></a></li><li><a href=#3-分布式架构与水平扩展>3. <strong>分布式架构与水平扩展</strong></a></li><li><a href=#4-消息顺序和消费模型>4. <strong>消息顺序和消费模型</strong></a></li><li><a href=#5-消息存储机制>5. <strong>消息存储机制</strong></a></li><li><a href=#6-延迟与吞吐量>6. <strong>延迟与吞吐量</strong></a></li><li><a href=#7-容错性和数据持久化>7. <strong>容错性和数据持久化</strong></a></li><li><a href=#总结-33>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-from>1. <strong>FROM</strong></a></li><li><a href=#2-run>2. <strong>RUN</strong></a></li><li><a href=#3-cmd>3. <strong>CMD</strong></a></li><li><a href=#4-entrypoint>4. <strong>ENTRYPOINT</strong></a></li><li><a href=#5-copy>5. <strong>COPY</strong></a></li><li><a href=#6-add>6. <strong>ADD</strong></a></li><li><a href=#7-expose>7. <strong>EXPOSE</strong></a></li><li><a href=#8-env>8. <strong>ENV</strong></a></li><li><a href=#9-arg>9. <strong>ARG</strong></a></li><li><a href=#10-volume>10. <strong>VOLUME</strong></a></li><li><a href=#11-workdir>11. <strong>WORKDIR</strong></a></li><li><a href=#12-user>12. <strong>USER</strong></a></li><li><a href=#13-label>13. <strong>LABEL</strong></a></li><li><a href=#14-shell>14. <strong>SHELL</strong></a></li><li><a href=#15-stopsignal>15. <strong>STOPSIGNAL</strong></a></li><li><a href=#总结-34>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-选择合适的基础镜像>1. <strong>选择合适的基础镜像</strong></a></li><li><a href=#2-尽量减少>2. <strong>尽量减少 <code>RUN</code> 指令的层数</strong></a></li><li><a href=#3-删除临时文件和缓存>3. <strong>删除临时文件和缓存</strong></a></li><li><a href=#4-使用-1>4. <strong>使用 <code>.dockerignore</code> 文件</strong></a></li><li><a href=#5-使用多阶段构建multi-stage-build>5. <strong>使用多阶段构建（Multi-stage Build）</strong></a></li><li><a href=#6-使用压缩格式的文件>6. <strong>使用压缩格式的文件</strong></a></li><li><a href=#7-避免使用>7. <strong>避免使用 <code>ADD</code> 除非需要</strong></a></li><li><a href=#8-精简镜像中的文件和依赖>8. <strong>精简镜像中的文件和依赖</strong></a></li><li><a href=#9-使用合适的压缩格式>9. <strong>使用合适的压缩格式</strong></a></li><li><a href=#10-减少日志文件和调试信息>10. <strong>减少日志文件和调试信息</strong></a></li><li><a href=#总结-35>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-cmd命令>1. <strong>CMD（命令）</strong></a></li><li><a href=#2-entrypoint入口点>2. <strong>ENTRYPOINT（入口点）</strong></a></li><li><a href=#区别总结><strong>区别总结</strong></a></li><li><a href=#常见的组合方式><strong>常见的组合方式</strong></a></li><li><a href=#结论>结论</a></li></ul></li></ul><ul><li><ul><li><a href=#1-copy>1. <strong>COPY</strong></a></li><li><a href=#2-add>2. <strong>ADD</strong></a></li><li><a href=#区别总结-1><strong>区别总结</strong></a></li><li><a href=#使用建议><strong>使用建议</strong></a></li><li><a href=#示例-39><strong>示例</strong></a></li><li><a href=#结论-1><strong>结论</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-docker-client客户端>1. <strong>Docker Client（客户端）</strong></a></li><li><a href=#2-docker-daemon守护进程>2. <strong>Docker Daemon（守护进程）</strong></a></li><li><a href=#3-docker-registry镜像仓库>3. <strong>Docker Registry（镜像仓库）</strong></a></li><li><a href=#4-docker-image镜像>4. <strong>Docker Image（镜像）</strong></a></li><li><a href=#5-docker-container容器>5. <strong>Docker Container（容器）</strong></a></li><li><a href=#6-docker-volume数据卷>6. <strong>Docker Volume（数据卷）</strong></a></li><li><a href=#7-docker-network网络>7. <strong>Docker Network（网络）</strong></a></li><li><a href=#8-docker-swarm集群管理>8. <strong>Docker Swarm（集群管理）</strong></a></li><li><a href=#9-docker-compose编排工具>9. <strong>Docker Compose（编排工具）</strong></a></li><li><a href=#10-docker-cli命令行工具>10. <strong>Docker CLI（命令行工具）</strong></a></li><li><a href=#总结-36>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-bridge-network桥接网络>1. <strong>Bridge Network（桥接网络）</strong></a></li><li><a href=#2-host-network主机网络>2. <strong>Host Network（主机网络）</strong></a></li><li><a href=#3-overlay-network覆盖网络>3. <strong>Overlay Network（覆盖网络）</strong></a></li><li><a href=#4-macvlan-networkmacvlan-网络>4. <strong>Macvlan Network（Macvlan 网络）</strong></a></li><li><a href=#5-none-network无网络>5. <strong>None Network（无网络）</strong></a></li><li><a href=#6-container-network容器网络>6. <strong>Container Network（容器网络）</strong></a></li><li><a href=#总结-37>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-修改-docker-配置文件>1. 修改 Docker 配置文件</a></li><li><a href=#2-配置防火墙>2. 配置防火墙</a></li><li><a href=#3-重启-docker-服务>3. 重启 Docker 服务</a></li><li><a href=#4-测试远程访问>4. 测试远程访问</a></li><li><a href=#5-使用-tls-安全连接推荐>5. 使用 TLS 安全连接（推荐）</a></li><li><a href=#6-在客户端连接时使用-tls>6. 在客户端连接时使用 TLS</a></li><li><a href=#总结-38>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-namespace命名空间>1. <strong>Namespace（命名空间）</strong></a></li><li><a href=#2-cgroups控制组>2. <strong>Cgroups（控制组）</strong></a></li><li><a href=#3-union-file-system联合文件系统>3. <strong>Union File System（联合文件系统）</strong></a></li><li><a href=#综合总结>综合总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-导入和导出镜像>1. <strong>导入和导出镜像</strong></a></li><li><a href=#2-进入容器>2. <strong>进入容器</strong></a></li><li><a href=#3-设置重启策略>3. <strong>设置重启策略</strong></a></li><li><a href=#4-查看镜像环境变量>4. <strong>查看镜像环境变量</strong></a></li><li><a href=#5-查看容器占用资源>5. <strong>查看容器占用资源</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-通过-dockerfile-构建镜像>1. <strong>通过 Dockerfile 构建镜像</strong></a></li><li><a href=#2-使用-3>2. <strong>使用 <code>docker commit</code> 构建镜像</strong></a></li><li><a href=#3-从现有镜像创建自定义镜像>3. <strong>从现有镜像创建自定义镜像</strong></a></li><li><a href=#4-通过>4. <strong>通过 <code>docker buildx</code> 构建多平台镜像</strong></a></li><li><a href=#5-使用-buildkit-构建镜像>5. <strong>使用 BuildKit 构建镜像</strong></a></li><li><a href=#6-使用-docker-compose-构建镜像>6. <strong>使用 Docker Compose 构建镜像</strong></a></li><li><a href=#总结-39>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-虚拟化类型>1. <strong>虚拟化类型</strong></a></li><li><a href=#2-资源开销>2. <strong>资源开销</strong></a></li><li><a href=#3-启动时间>3. <strong>启动时间</strong></a></li><li><a href=#4-隔离级别>4. <strong>隔离级别</strong></a></li><li><a href=#5-性能>5. <strong>性能</strong></a></li><li><a href=#6-操作系统支持>6. <strong>操作系统支持</strong></a></li><li><a href=#7-应用场景>7. <strong>应用场景</strong></a></li><li><a href=#8-资源分配>8. <strong>资源分配</strong></a></li><li><a href=#9-迁移与扩展性>9. <strong>迁移与扩展性</strong></a></li><li><a href=#总结-40>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-控制平面组件>1. <strong>控制平面组件</strong></a></li><li><a href=#2-工作节点组件>2. <strong>工作节点组件</strong></a></li><li><a href=#3-其他组件>3. <strong>其他组件</strong></a></li><li><a href=#总结-41>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-修改副本数>1. <strong>修改副本数</strong></a></li><li><a href=#2-滚动更新>2. <strong>滚动更新</strong></a></li><li><a href=#3-回滚>3. <strong>回滚</strong></a></li><li><a href=#4-查看-pod-的详细信息>4. <strong>查看 Pod 的详细信息</strong></a></li><li><a href=#5-进入-pod-进行交互>5. <strong>进入 Pod 进行交互</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-备份-etcd-数据>1. <strong>备份 etcd 数据</strong></a></li><li><a href=#2-指定备份时使用的-etcd-集群信息>2. <strong>指定备份时使用的 etcd 集群信息</strong></a></li><li><a href=#3-恢复-etcd-数据>3. <strong>恢复 etcd 数据</strong></a></li><li><a href=#4-定期备份>4. <strong>定期备份</strong></a></li><li><a href=#5-检查备份有效性>5. <strong>检查备份有效性</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-replicationcontroller>1. <strong>ReplicationController</strong></a></li><li><a href=#2-replicaset>2. <strong>ReplicaSet</strong></a></li><li><a href=#3-deployment>3. <strong>Deployment</strong></a></li><li><a href=#4-statefulset>4. <strong>StatefulSet</strong></a></li><li><a href=#5-daemonset>5. <strong>DaemonSet</strong></a></li><li><a href=#6-job>6. <strong>Job</strong></a></li><li><a href=#7-cronjob>7. <strong>CronJob</strong></a></li><li><a href=#8-horizontalpodautoscaler-hpa>8. <strong>HorizontalPodAutoscaler (HPA)</strong></a></li><li><a href=#9-networkpolicy>9. <strong>NetworkPolicy</strong></a></li><li><a href=#10-ingresscontroller>10. <strong>IngressController</strong></a></li><li><a href=#11-custom-controller>11. <strong>Custom Controller</strong></a></li><li><a href=#12-certmanager>12. <strong>CertManager</strong></a></li><li><a href=#总结-42>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-node>1. <strong>Node</strong></a></li><li><a href=#2-namespace>2. <strong>Namespace</strong></a></li><li><a href=#3-persistentvolume-pv>3. <strong>PersistentVolume (PV)</strong></a></li><li><a href=#4-persistentvolumeclaim-pvc>4. <strong>PersistentVolumeClaim (PVC)</strong></a></li><li><a href=#5-storageclass>5. <strong>StorageClass</strong></a></li><li><a href=#6-clusterrole-和-clusterrolebinding>6. <strong>ClusterRole 和 ClusterRoleBinding</strong></a></li><li><a href=#7-configmap>7. <strong>ConfigMap</strong></a></li><li><a href=#8-secret>8. <strong>Secret</strong></a></li><li><a href=#9-ingress>9. <strong>Ingress</strong></a></li><li><a href=#10-resourcequota>10. <strong>ResourceQuota</strong></a></li><li><a href=#11-limitrange>11. <strong>LimitRange</strong></a></li><li><a href=#12-horizontalpodautoscaler-hpa>12. <strong>HorizontalPodAutoscaler (HPA)</strong></a></li><li><a href=#13-serviceaccount>13. <strong>ServiceAccount</strong></a></li><li><a href=#14-clusteroperator>14. <strong>ClusterOperator</strong></a></li><li><a href=#15-api-aggregation-layer-api-server>15. <strong>API Aggregation Layer (API Server)</strong></a></li><li><a href=#总结-43>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-pending>1. <strong>Pending</strong></a></li><li><a href=#2-running>2. <strong>Running</strong></a></li><li><a href=#3-succeeded>3. <strong>Succeeded</strong></a></li><li><a href=#4-failed>4. <strong>Failed</strong></a></li><li><a href=#5-crashloopbackoff>5. <strong>CrashLoopBackOff</strong></a></li><li><a href=#6-unknown>6. <strong>Unknown</strong></a></li><li><a href=#7-terminating>7. <strong>Terminating</strong></a></li><li><a href=#8-initializing-仅适用于-statefulset>8. <strong>Initializing</strong> (仅适用于 StatefulSet)</a></li><li><a href=#总结-44>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-用户提交请求>1. <strong>用户提交请求</strong></a></li><li><a href=#2-api-server-接收请求>2. <strong>API Server 接收请求</strong></a></li><li><a href=#3-调度scheduler选择节点>3. <strong>调度（Scheduler）选择节点</strong></a></li><li><a href=#4-node-接收-pod-配置>4. <strong>Node 接收 Pod 配置</strong></a></li><li><a href=#5-kubelet-创建容器>5. <strong>Kubelet 创建容器</strong></a></li><li><a href=#6-pod-启动和就绪检查>6. <strong>Pod 启动和就绪检查</strong></a></li><li><a href=#7-网络和服务关联>7. <strong>网络和服务关联</strong></a></li><li><a href=#8-pod-完成启动>8. <strong>Pod 完成启动</strong></a></li><li><a href=#9-监控和维护>9. <strong>监控和维护</strong></a></li><li><a href=#总结pod-创建的整个流程>总结：Pod 创建的整个流程</a></li></ul></li></ul><ul><li><ul><li><a href=#1-always>1. <strong>Always</strong></a></li><li><a href=#2-onfailure>2. <strong>OnFailure</strong></a></li><li><a href=#3-never>3. <strong>Never</strong></a></li><li><a href=#4-pod-重启策略与控制器的关系>4. <strong>Pod 重启策略与控制器的关系</strong></a></li><li><a href=#总结-45>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-存活探针liveness-probe>1. <strong>存活探针（Liveness Probe）</strong></a></li><li><a href=#2-就绪探针readiness-probe>2. <strong>就绪探针（Readiness Probe）</strong></a></li><li><a href=#3-启动探针startup-probe>3. <strong>启动探针（Startup Probe）</strong></a></li><li><a href=#4-探针配置的常见字段>4. <strong>探针配置的常见字段</strong></a></li><li><a href=#5-探针之间的区别>5. <strong>探针之间的区别</strong></a></li><li><a href=#总结-46>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-requests>1. <strong>Requests</strong></a></li><li><a href=#2-limits>2. <strong>Limits</strong></a></li><li><a href=#3-requests-和-limits-的关系>3. <strong>Requests 和 Limits 的关系</strong></a></li><li><a href=#4-cpu-和-内存的不同处理>4. <strong>CPU 和 内存的不同处理</strong></a></li><li><a href=#5-例子>5. <strong>例子</strong></a></li><li><a href=#6-总结>6. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#kubeconfig-文件的内容结构><code>kubeconfig</code> 文件的内容结构</a></li><li><a href=#kubeconfig-文件示例><code>kubeconfig</code> 文件示例</a></li><li><a href=#kubeconfig-的用途><code>kubeconfig</code> 的用途</a></li><li><a href=#kubeconfig-文件的管理><code>kubeconfig</code> 文件的管理</a></li><li><a href=#总结-47>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-role-和-clusterrole-的区别>1. <code>Role</code> 和 <code>ClusterRole</code> 的区别</a></li><li><a href=#2-rolebinding-和-clusterrolebinding-的区别>2. <code>RoleBinding</code> 和 <code>ClusterRoleBinding</code> 的区别</a></li><li><a href=#总结-48>总结</a></li><li><a href=#示例-40>示例</a></li></ul></li></ul><ul><li><ul><li><a href=#1-工作方式不同>1. <strong>工作方式不同</strong></a></li><li><a href=#2-性能优化>2. <strong>性能优化</strong></a></li><li><a href=#3-用途差异>3. <strong>用途差异</strong></a></li><li><a href=#4-流量转发方式>4. <strong>流量转发方式</strong></a></li><li><a href=#总结-49>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-storageclass-sc>1. <strong>StorageClass (SC)</strong></a></li><li><a href=#2-persistentvolume-pv>2. <strong>PersistentVolume (PV)</strong></a></li><li><a href=#3-persistentvolumeclaim-pvc>3. <strong>PersistentVolumeClaim (PVC)</strong></a></li><li><a href=#4-容器挂载存储的整个流程>4. <strong>容器挂载存储的整个流程</strong></a></li><li><a href=#总结-50>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#ingress-的原理本质><strong>Ingress 的原理本质：</strong></a></li><li><a href=#ingress-路由流程><strong>Ingress 路由流程：</strong></a></li><li><a href=#总结-51><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-kubernetes-网络模型><strong>1. Kubernetes 网络模型</strong></a></li><li><a href=#2-通信流程><strong>2. 通信流程</strong></a></li><li><a href=#3-使用-service-实现-pod-访问><strong>3. 使用 Service 实现 Pod 访问</strong></a></li><li><a href=#4-安全性和网络策略><strong>4. 安全性和网络策略</strong></a></li><li><a href=#总结-52><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#步骤-1驱逐节点上的-pod><strong>步骤 1：驱逐节点上的 Pod</strong></a></li><li><a href=#步骤-2检查集群状态><strong>步骤 2：检查集群状态</strong></a></li><li><a href=#步骤-3关闭维护节点><strong>步骤 3：关闭维护节点</strong></a></li><li><a href=#步骤-4维护完成后重新启动节点><strong>步骤 4：维护完成后重新启动节点</strong></a></li><li><a href=#步骤-5确保服务正常><strong>步骤 5：确保服务正常</strong></a></li><li><a href=#注意事项-3><strong>注意事项：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-网络模型和架构><strong>1. 网络模型和架构</strong></a></li><li><a href=#2-网络类型><strong>2. 网络类型</strong></a></li><li><a href=#3-性能><strong>3. 性能</strong></a></li><li><a href=#4-安全性><strong>4. 安全性</strong></a></li><li><a href=#5-网络策略><strong>5. 网络策略</strong></a></li><li><a href=#6-可扩展性><strong>6. 可扩展性</strong></a></li><li><a href=#7-安装和配置><strong>7. 安装和配置</strong></a></li><li><a href=#8-支持的环境><strong>8. 支持的环境</strong></a></li><li><a href=#总结-53><strong>总结：</strong></a></li><li><a href=#选择建议><strong>选择建议</strong>：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-监控模式pull-vs-push>1. <strong>监控模式：Pull vs Push</strong></a></li><li><a href=#2-时序数据存储和查询>2. <strong>时序数据存储和查询</strong></a></li><li><a href=#3-动态环境支持>3. <strong>动态环境支持</strong></a></li><li><a href=#4-集成与生态系统>4. <strong>集成与生态系统</strong></a></li><li><a href=#5-告警和通知>5. <strong>告警和通知</strong></a></li><li><a href=#6-安装和配置>6. <strong>安装和配置</strong></a></li><li><a href=#7-资源消耗>7. <strong>资源消耗</strong></a></li><li><a href=#8-水平扩展>8. <strong>水平扩展</strong></a></li><li><a href=#总结-54>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-prometheus-server>1. <strong>Prometheus Server</strong></a></li><li><a href=#2-alertmanager>2. <strong>Alertmanager</strong></a></li><li><a href=#3-prometheus-exporters>3. <strong>Prometheus Exporters</strong></a></li><li><a href=#4-prometheus-query-language-promql>4. <strong>Prometheus Query Language (PromQL)</strong></a></li><li><a href=#5-prometheus-ui>5. <strong>Prometheus UI</strong></a></li><li><a href=#6-prometheus-pushgateway>6. <strong>Prometheus Pushgateway</strong></a></li><li><a href=#7-thanos-可选>7. <strong>Thanos (可选)</strong></a></li><li><a href=#8-cortex-可选>8. <strong>Cortex (可选)</strong></a></li><li><a href=#总结-55>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-counter计数器>1. <strong>Counter（计数器）</strong></a></li><li><a href=#2-gauge仪表盘>2. <strong>Gauge（仪表盘）</strong></a></li><li><a href=#3-histogram直方图>3. <strong>Histogram（直方图）</strong></a></li><li><a href=#4-summary摘要>4. <strong>Summary（摘要）</strong></a></li><li><a href=#总结-56>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-水平扩展horizontal-scaling>1. <strong>水平扩展（Horizontal Scaling）</strong></a></li><li><a href=#2-使用->2. <strong>使用 *<em>Prometheus Operator*</em></strong></a></li><li><a href=#3-优化数据存储>3. <strong>优化数据存储</strong></a></li><li><a href=#4-优化指标收集>4. <strong>优化指标收集</strong></a></li><li><a href=#5-优化查询性能>5. <strong>优化查询性能</strong></a></li><li><a href=#6-引入->6. <strong>引入 *<em>Thanos*</em> 或 *<em>Cortex*</em> 来实现高可用和长期存储</strong></a></li><li><a href=#7-使用-alertmanager-的集群模式>7. <strong>使用 Alertmanager 的集群模式</strong></a></li><li><a href=#8-使用外部高效的存储后端>8. <strong>使用外部高效的存储后端</strong></a></li><li><a href=#9-优化网络>9. <strong>优化网络</strong></a></li><li><a href=#总结-57><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-安装-prometheus-监控系统>1. <strong>安装 Prometheus 监控系统</strong></a></li><li><a href=#2-安装并配置-node-exporter在被监控节点上>2. <strong>安装并配置 Node Exporter（在被监控节点上）</strong></a></li><li><a href=#3-prometheus-收集数据>3. <strong>Prometheus 收集数据</strong></a></li><li><a href=#4-安装-grafana>4. <strong>安装 Grafana</strong></a></li><li><a href=#5-配置-grafana-数据源>5. <strong>配置 Grafana 数据源</strong></a></li><li><a href=#6-创建仪表板和图表>6. <strong>创建仪表板和图表</strong></a></li><li><a href=#7-设置警报可选>7. <strong>设置警报（可选）</strong></a></li><li><a href=#8-查看监控数据>8. <strong>查看监控数据</strong></a></li><li><a href=#9-优化和调整>9. <strong>优化和调整</strong></a></li><li><a href=#总结-58>总结：</a></li></ul></li></ul></nav></div></aside></main></body></html>