<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package statefulset

import (
	"context"
	"fmt"
	"strings"

	apps "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	errorutils "k8s.io/apimachinery/pkg/util/errors"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	utilfeature "k8s.io/apiserver/pkg/util/feature"
	clientset "k8s.io/client-go/kubernetes"
	corelisters "k8s.io/client-go/listers/core/v1"
	"k8s.io/client-go/tools/record"
	"k8s.io/client-go/util/retry"
	"k8s.io/kubernetes/pkg/features"
)

// StatefulPodControlObjectManager abstracts the manipulation of Pods and PVCs. The real controller implements this
// with a clientset for writes and listers for reads; for tests we provide stubs.
type StatefulPodControlObjectManager interface {
	CreatePod(ctx context.Context, pod *v1.Pod) error
	GetPod(namespace, podName string) (*v1.Pod, error)
	UpdatePod(pod *v1.Pod) error
	DeletePod(pod *v1.Pod) error
	CreateClaim(claim *v1.PersistentVolumeClaim) error
	GetClaim(namespace, claimName string) (*v1.PersistentVolumeClaim, error)
	UpdateClaim(claim *v1.PersistentVolumeClaim) error
}

// 这是一个StatefulPodControlObjectManager接口，定义了对有状态Pod和持久卷声明的操作方法，包括创建、获取、更新和删除Pod以及创建、获取、更新持久卷声明。
// StatefulPodControl defines the interface that StatefulSetController uses to create, update, and delete Pods,
// and to update the Status of a StatefulSet. It follows the design paradigms used for PodControl, but its
// implementation provides for PVC creation, ordered Pod creation, ordered Pod termination, and Pod identity enforcement.
// Manipulation of objects is provided through objectMgr, which allows the k8s API to be mocked out for testing.
type StatefulPodControl struct {
	objectMgr StatefulPodControlObjectManager
	recorder  record.EventRecorder
}

//该代码定义了一个名为StatefulPodControl的结构体，它是一个接口，用于创建、更新和删除Pods，以及更新StatefulSet的状态。
//它采用了与PodControl相同的设计模式，但其实现提供了PVC创建、有序Pod创建、有序Pod终止和Pod身份强制执行等功能。
//通过objectMgr对象提供对对象的操作，允许在测试中模拟k8s API。

// NewStatefulPodControl constructs a StatefulPodControl using a realStatefulPodControlObjectManager with the given
// clientset, listers and EventRecorder.
func NewStatefulPodControl(
	client clientset.Interface,
	podLister corelisters.PodLister,
	claimLister corelisters.PersistentVolumeClaimLister,
	recorder record.EventRecorder,
) *StatefulPodControl {
	return &amp;StatefulPodControl{&amp;realStatefulPodControlObjectManager{client, podLister, claimLister}, recorder}
}

// 该函数用于构造一个StatefulPodControl对象，使用给定的clientset、listers和EventRecorder。
// 函数通过传入的参数创建一个realStatefulPodControlObjectManager对象，并将其与传入的EventRecorder对象一起封装到StatefulPodControl对象中，最后返回该对象。
// NewStatefulPodControlFromManager creates a StatefulPodControl using the given StatefulPodControlObjectManager and recorder.
func NewStatefulPodControlFromManager(om StatefulPodControlObjectManager, recorder record.EventRecorder) *StatefulPodControl {
	return &amp;StatefulPodControl{om, recorder}
}

// 该函数使用给定的StatefulPodControlObjectManager和record.EventRecorder创建一个StatefulPodControl，并返回其指针。
// realStatefulPodControlObjectManager uses a clientset.Interface and listers.
type realStatefulPodControlObjectManager struct {
	client      clientset.Interface
	podLister   corelisters.PodLister
	claimLister corelisters.PersistentVolumeClaimLister
}

// 该代码定义了一个名为realStatefulPodControlObjectManager的结构体，它使用了clientset.Interface和listers。
// 结构体中有三个字段：client、podLister和claimLister，分别用于存储客户端接口、Pod列表和持久卷申领列表。
func (om *realStatefulPodControlObjectManager) CreatePod(ctx context.Context, pod *v1.Pod) error {
	_, err := om.client.CoreV1().Pods(pod.Namespace).Create(ctx, pod, metav1.CreateOptions{})
	return err
}

// 该函数是一个Go语言函数，它使用了上下文（Context）来控制请求的超时和取消。
// 该函数的功能是在指定的命名空间中创建一个Pod，并返回创建操作的结果（成功或错误）。
// 具体来说，该函数的实现步骤如下：
// 1. 使用om.client获取CoreV1接口，该接口提供了对Kubernetes集群中Pod资源的操作方法。
// 2. 调用Create方法，在指定的命名空间中创建Pod，并传入上下文（Context）和Pod对象。
// 3. 返回创建操作的结果，即错误信息（Error）。
// 需要注意的是，该函数中使用了context.Context参数，它允许调用者控制请求的超时和取消。在实际应用中，这非常有用，比如在处理大量请求或需要及时响应的场景中。
func (om *realStatefulPodControlObjectManager) GetPod(namespace, podName string) (*v1.Pod, error) {
	return om.podLister.Pods(namespace).Get(podName)
}

// 该函数是一个Go语言的方法，定义在一个名为realStatefulPodControlObjectManager的结构体类型上。该方法的功能是在指定的命名空间
// (namespace)中获取指定名称(podName)的Pod对象，并返回该Pod对象及其可能发生的错误。  具体实现上，
// 该方法通过调用om.podLister.Pods(namespace)来获取指定命名空间下的所有Pods的列表器，
// 然后进一步调用Get(podName)方法来获取指定名称的Pod对象。如果获取成功，则将该Pod对象返回；
// 如果获取失败，则将发生的错误返回。
func (om *realStatefulPodControlObjectManager) UpdatePod(pod *v1.Pod) error {
	_, err := om.client.CoreV1().Pods(pod.Namespace).Update(context.TODO(), pod, metav1.UpdateOptions{})
	return err
}

// 该函数用于更新指定命名空间下的Pod。函数接收一个指向v1.Pod类型的指针作为参数，通过调用om.client.CoreV1().Pods
// (pod.Namespace).Update()方法，将该Pod对象更新至Kubernetes集群中。若更新成功，则返回nil；若更新失败，
// 则返回相应的错误信息。
func (om *realStatefulPodControlObjectManager) DeletePod(pod *v1.Pod) error {
	return om.client.CoreV1().Pods(pod.Namespace).Delete(context.TODO(), pod.Name, metav1.DeleteOptions{})
}

func (om *realStatefulPodControlObjectManager) CreateClaim(claim *v1.PersistentVolumeClaim) error {
	_, err := om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Create(context.TODO(), claim, metav1.CreateOptions{})
	return err
}

// 该函数用于删除指定命名空间下的Pod。函数接收一个指向v1.Pod类型的指针作为参数，通过调用om.client.CoreV1().Pods
// (pod.Namespace).Delete()方法，根据传入的Pod的Namespace和Name属性，在Kubernetes集群中删除该Pod实例。
// 若删除成功，则返回nil；否则，返回相应的错误信息。
func (om *realStatefulPodControlObjectManager) GetClaim(namespace, claimName string) (*v1.PersistentVolumeClaim, error) {
	return om.claimLister.PersistentVolumeClaims(namespace).Get(claimName)
}

//该函数用于获取指定命名空间下名为claimName的PersistentVolumeClaim资源。函数接收两个字符串参数：namespace（命名空间）和claimName
//（PersistentVolumeClaim名称）。它通过调用om.claimLister.PersistentVolumeClaims(namespace).Get(claimName)从缓存列表中获取指定的
//PersistentVolumeClaim对象，并将其以*v1.PersistentVolumeClaim类型返回。如果获取成功，则返回PersistentVolumeClaim实例及其nil错误；
//如果未能找到对应资源，则返回nil及可能的错误信息。

func (om *realStatefulPodControlObjectManager) UpdateClaim(claim *v1.PersistentVolumeClaim) error {
	_, err := om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Update(context.TODO(), claim, metav1.UpdateOptions{})
	return err
}

//该函数用于更新指定命名空间下的PersistentVolumeClaim资源。函数接收一个指向v1.PersistentVolumeClaim类型的指针作为参数。
//通过调用om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Update()方法，根据传入的PersistentVolumeClaim对象的Namespace属性，
//在Kubernetes集群中更新该PersistentVolumeClaim实例。若更新操作成功，则返回nil；若出现错误，则返回相应的错误信息。

func (spc *StatefulPodControl) CreateStatefulPod(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	// Create the Pod&#39;s PVCs prior to creating the Pod
	if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
		spc.recordPodEvent("create", set, pod, err)
		return err
	}
	// If we created the PVCs attempt to create the Pod
	err := spc.objectMgr.CreatePod(ctx, pod)
	// sink already exists errors
	if apierrors.IsAlreadyExists(err) {
		return err
	}
	if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) {
		// Set PVC policy as much as is possible at this point.
		if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil {
			spc.recordPodEvent("update", set, pod, err)
			return err
		}
	}
	spc.recordPodEvent("create", set, pod, err)
	return err
}

// 该函数用于创建有状态的Pod。在创建Pod之前，它会先创建Pod所需的PVC（持久卷声明）。如果创建PVC时出现错误，则会记录Pod事件并返回错误。
// 接下来，它会尝试创建Pod，如果Pod已存在，则直接返回错误。如果启用了StatefulSetAutoDeletePVC功能，则会更新Pod的PVC保留策略。
// 最后，它会记录Pod的创建事件并返回可能的错误
func (spc *StatefulPodControl) UpdateStatefulPod(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	attemptedUpdate := false
	err := retry.RetryOnConflict(retry.DefaultBackoff, func() error {
		// assume the Pod is consistent
		consistent := true
		// if the Pod does not conform to its identity, update the identity and dirty the Pod
		if !identityMatches(set, pod) {
			updateIdentity(set, pod)
			consistent = false
		}
		//该函数是一个Go语言函数，它用于更新一个有状态的Pod（StatefulPod）的状态。函数的参数包括一个上下文对象ctx、一个StatefulSet对象set和一个Pod对象pod。
		//函数通过使用retry.RetryOnConflict方法，在遇到冲突时进行重试，以更新Pod的状态。在重试的过程中，
		//函数会检查Pod是否符合其身份要求和StatefulSet的存储要求。如果不符合，函数会相应地更新Pod的身份和PVCs，并标记Pod为“dirty”。
		//如果在更新过程中出现错误，则会返回错误信息。
		// if the Pod does not conform to the StatefulSet&#39;s storage requirements, update the Pod&#39;s PVC&#39;s,
		// dirty the Pod, and create any missing PVCs
		if !storageMatches(set, pod) {
			updateStorage(set, pod)
			consistent = false
			if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
				spc.recordPodEvent("update", set, pod, err)
				return err
			}
		}
		//该函数主要检查Pod是否符合StatefulSet的存储要求，如果不符合，则更新Pod的PVCs，标记Pod为dirty，并创建任何缺失的PVCs。
		//具体流程如下：  1. 检查Pod是否符合StatefulSet的存储要求，调用storageMatches(set, pod)函数。
		//2. 如果Pod不符合存储要求，则执行以下操作： - 调用updateStorage(set, pod)函数更新Pod的PVCs。 - 将consistent标记为false。 -
		//调用spc.createPersistentVolumeClaims(set, pod)函数创建任何缺失的PVCs，如果创建失败，则记录Pod事件并返回错误。
		//3. 如果Pod符合存储要求，则继续后续流程。
		if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) {
			// if the Pod&#39;s PVCs are not consistent with the StatefulSet&#39;s PVC deletion policy, update the PVC
			// and dirty the pod.
			if match, err := spc.ClaimsMatchRetentionPolicy(ctx, set, pod); err != nil {
				spc.recordPodEvent("update", set, pod, err)
				return err
			} else if !match {
				if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil {
					spc.recordPodEvent("update", set, pod, err)
					return err
				}
				consistent = false
			}
		}
		//这段Go代码是关于StatefulSet自动删除PVC的逻辑。 首先，检查是否启用了StatefulSetAutoDeletePVC功能门。
		//如果启用了，则进一步判断Pod的PVC是否与StatefulSet的PVC删除策略一致。如果不一致，则更新PVC并标记Pod为dirty。
		//如果匹配失败，则调用UpdatePodClaimForRetentionPolicy函数来更新Pod的PVC，并将consistent标记为false。
		//在更新过程中，如果出现错误，则记录Pod事件并返回错误。
		// if the Pod is not dirty, do nothing
		if consistent {
			return nil
		}

		attemptedUpdate = true
		// commit the update, retrying on conflicts

		updateErr := spc.objectMgr.UpdatePod(pod)
		if updateErr == nil {
			return nil
		}

		if updated, err := spc.objectMgr.GetPod(set.Namespace, pod.Name); err == nil {
			// make a copy so we don&#39;t mutate the shared cache
			pod = updated.DeepCopy()
		} else {
			utilruntime.HandleError(fmt.Errorf("error getting updated Pod %s/%s: %w", set.Namespace, pod.Name, err))
		}
		//这段Go代码主要做的是更新Pod的操作。具体流程如下：
		//1. 首先判断consistent是否为true，如果是，则直接返回nil。
		//2. 设置attemptedUpdate为true，表示已经尝试更新Pod。
		//3. 调用spc.objectMgr.UpdatePod(pod)方法更新Pod，如果更新成功，则直接返回nil。
		//4. 如果更新失败，则尝试获取最新的Pod信息。
		//5. 如果获取成功，则将获取到的Pod深拷贝一份，防止对共享缓存的污染。
		//6. 如果获取失败，则打印错误信息。  整体来说，这段代码的逻辑比较简单，主要是通过调用UpdatePod方法更新Pod，如果更新失败则尝试重新获取Pod信息。
		return updateErr
	})
	if attemptedUpdate {
		spc.recordPodEvent("update", set, pod, err)
	}
	return err
}

// 这段Go代码是一个函数片段，它在一个匿名函数中执行了某种更新操作，并通过参数set和pod记录了事件。如果更新操作尝试过，
// 它会通过spc.recordPodEvent方法记录一个名为"update"的事件。最后，该函数返回一个错误值err。
func (spc *StatefulPodControl) DeleteStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error {
	err := spc.objectMgr.DeletePod(pod)
	spc.recordPodEvent("delete", set, pod, err)
	return err
}

// 此函数用于删除一个有状态的Pod。它通过调用spc.objectMgr.DeletePod(pod)来删除指定的Pod，并记录事件。最后返回删除操作的错误（如果有）。
// ClaimsMatchRetentionPolicy returns false if the PVCs for pod are not consistent with set&#39;s PVC deletion policy.
// An error is returned if something is not consistent. This is expected if the pod is being otherwise updated,
// but a problem otherwise (see usage of this method in UpdateStatefulPod).
func (spc *StatefulPodControl) ClaimsMatchRetentionPolicy(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) (bool, error) {
	logger := klog.FromContext(ctx)
	ordinal := getOrdinal(pod)
	templates := set.Spec.VolumeClaimTemplates
	for i := range templates {
		claimName := getPersistentVolumeClaimName(set, &amp;templates[i], ordinal)
		claim, err := spc.objectMgr.GetClaim(set.Namespace, claimName)
		switch {
		case apierrors.IsNotFound(err):
			klog.FromContext(ctx).V(4).Info("Expected claim missing, continuing to pick up in next iteration", "PVC", klog.KObj(claim))
		case err != nil:
			return false, fmt.Errorf("Could not retrieve claim %s for %s when checking PVC deletion policy", claimName, pod.Name)
		default:
			if !claimOwnerMatchesSetAndPod(logger, claim, set, pod) {
				return false, nil
			}
		}
	}
	return true, nil
}

//该函数用于检查Pod的PVC是否符合StatefulSet的PVC删除策略。
//它遍历StatefulSet的VolumeClaimTemplates，并根据模板生成PVC名称。
//然后它尝试获取该PVC，根据获取结果进行判断：
//- 如果PVC不存在，则记录日志并继续下一次迭代。
//- 如果获取PVC出现错误，则返回错误。
//- 如果PVC存在但其owner不是StatefulSet和Pod，则返回false。
//如果所有PVC都符合要求，则返回true。

// UpdatePodClaimForRetentionPolicy updates the PVCs used by pod to match the PVC deletion policy of set.
func (spc *StatefulPodControl) UpdatePodClaimForRetentionPolicy(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	logger := klog.FromContext(ctx)
	ordinal := getOrdinal(pod)
	templates := set.Spec.VolumeClaimTemplates
	for i := range templates {
		claimName := getPersistentVolumeClaimName(set, &amp;templates[i], ordinal)
		claim, err := spc.objectMgr.GetClaim(set.Namespace, claimName)
		switch {
		case apierrors.IsNotFound(err):
			logger.V(4).Info("Expected claim missing, continuing to pick up in next iteration", "PVC", klog.KObj(claim))
		case err != nil:
			return fmt.Errorf("Could not retrieve claim %s not found for %s when checking PVC deletion policy: %w", claimName, pod.Name, err)
		default:
			if !claimOwnerMatchesSetAndPod(logger, claim, set, pod) {
				claim = claim.DeepCopy() // Make a copy so we don&#39;t mutate the shared cache.
				needsUpdate := updateClaimOwnerRefForSetAndPod(logger, claim, set, pod)
				if needsUpdate {
					err := spc.objectMgr.UpdateClaim(claim)
					if err != nil {
						return fmt.Errorf("Could not update claim %s for delete policy ownerRefs: %w", claimName, err)
					}
				}
			}
		}
	}
	return nil
}

//该函数用于更新StatefulSet中的Pod的PersistentVolumeClaim（PVC）的所有者引用，以确保它们与Pod和StatefulSet正确关联。
//它遍历StatefulSet的VolumeClaimTemplates，并根据Pod的序号生成相应的PVC名称。然后，它尝试获取该PVC，根据获取结果进行不同的处理：
//- 如果PVC不存在，则记录一条日志，并继续处理下一个PVC。
//- 如果获取PVC时出现错误，则返回错误。
//- 如果PVC存在但其所有者引用与Pod和StatefulSet不匹配，则创建PVC的深拷贝，并更新其所有者引用。
//如果更新后的PVC与原始PVC不同，则将其更新到Kubernetes集群中。  最终，如果所有PVC都已正确处理，则函数返回nil。

// PodClaimIsStale returns true for a stale PVC that should block pod creation. If the scaling
// policy is deletion, and a PVC has an ownerRef that does not match the pod, the PVC is stale. This
// includes pods whose UID has not been created.
func (spc *StatefulPodControl) PodClaimIsStale(set *apps.StatefulSet, pod *v1.Pod) (bool, error) {
	policy := getPersistentVolumeClaimRetentionPolicy(set)
	if policy.WhenScaled == apps.RetainPersistentVolumeClaimRetentionPolicyType {
		// PVCs are meant to be reused and so can&#39;t be stale.
		return false, nil
	}
	for _, claim := range getPersistentVolumeClaims(set, pod) {
		pvc, err := spc.objectMgr.GetClaim(claim.Namespace, claim.Name)
		switch {
		case apierrors.IsNotFound(err):
			// If the claim doesn&#39;t exist yet, it can&#39;t be stale.
			continue
		case err != nil:
			return false, err
		case err == nil:
			// A claim is stale if it doesn&#39;t match the pod&#39;s UID, including if the pod has no UID.
			if hasStaleOwnerRef(pvc, pod) {
				return true, nil
			}
		}
	}
	return false, nil
}

// SstatefulSet和Pod对应的PersistentVolumeClaim该函数用于判断Pod所使用的PVC是否为旧的（stale），如果为旧的则会阻止Pod的创建。
// 在StatefulSet缩容策略为删除时，如果PVC的ownerRef与Pod不匹配，则认为PVC是旧的。
// 函数首先根据StatefulSet的设置获取PVC的保留策略，如果策略为保留（Retain），则PVC会被重用，不会被认为是旧的。
// 然后遍历获取与Pod相关的PVC，通过查询PVC的详细信息判断PVC是否与Pod的UID匹配，如果不匹配则认为PVC是旧的。
// 如果查询PVC时发生错误，则返回错误信息。最后，如果没有发现旧的PVC，则返回false。
// recordPodEvent records an event for verb applied to a Pod in a StatefulSet. If err is nil the generated event will
// have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a reason of v1.EventTypeWarning.
func (spc *StatefulPodControl) recordPodEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, err error) {
	if err == nil {
		reason := fmt.Sprintf("Successful%s", strings.Title(verb))
		message := fmt.Sprintf("%s Pod %s in StatefulSet %s successful",
			strings.ToLower(verb), pod.Name, set.Name)
		spc.recorder.Event(set, v1.EventTypeNormal, reason, message)
	} else {
		reason := fmt.Sprintf("Failed%s", strings.Title(verb))
		message := fmt.Sprintf("%s Pod %s in StatefulSet %s failed error: %s",
			strings.ToLower(verb), pod.Name, set.Name, err)
		spc.recorder.Event(set, v1.EventTypeWarning, reason, message)
	}
}

// 该函数是一个名为recordPodEvent的方法，它属于StatefulPodControl类型。
// 该方法用于记录关于Pod的事件，该Pod属于一个StatefulSet。根据err参数的值，生成的事件会有不同的原因，
// 如果err为nil，则事件原因为v1.EventTypeNormal，否则为v1.EventTypeWarning。
// 根据verb参数，会生成成功或失败的事件消息，并通过spc.recorder.Event方法记录事件。
// recordClaimEvent records an event for verb applied to the PersistentVolumeClaim of a Pod in a StatefulSet. If err is
// nil the generated event will have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a
// reason of v1.EventTypeWarning.
func (spc *StatefulPodControl) recordClaimEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, claim *v1.PersistentVolumeClaim, err error) {
	if err == nil {
		reason := fmt.Sprintf("Successful%s", strings.Title(verb))
		message := fmt.Sprintf("%s Claim %s Pod %s in StatefulSet %s success",
			strings.ToLower(verb), claim.Name, pod.Name, set.Name)
		spc.recorder.Event(set, v1.EventTypeNormal, reason, message)
	} else {
		reason := fmt.Sprintf("Failed%s", strings.Title(verb))
		message := fmt.Sprintf("%s Claim %s for Pod %s in StatefulSet %s failed error: %s",
			strings.ToLower(verb), claim.Name, pod.Name, set.Name, err)
		spc.recorder.Event(set, v1.EventTypeWarning, reason, message)
	}
}

// 该函数名为recordClaimEvent，用于记录StatefulSet中Pod的PersistentVolumeClaim的事件。
// 根据err是否为nil，生成的事件会有不同的原因，如果err为nil，则事件原因为v1.EventTypeNormal，否则为v1.EventTypeWarning。
// 函数通过spc.recorder.Event方法记录事件。
// createMissingPersistentVolumeClaims creates all of the required PersistentVolumeClaims for pod, and updates its retention policy
func (spc *StatefulPodControl) createMissingPersistentVolumeClaims(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
		return err
	}

	if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) {
		// Set PVC policy as much as is possible at this point.
		if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil {
			spc.recordPodEvent("update", set, pod, err)
			return err
		}
	}
	return nil
}

//该函数是一个Go语言函数，用于创建缺失的PersistentVolumeClaims（PVCs）并更新其保留策略，适用于StatefulPodControl类型。
//函数首先调用createPersistentVolumeClaims函数创建所需的PVCs，如果创建失败，则返回错误。
//接下来，如果启用了StatefulSetAutoDeletePVC功能，则调用UpdatePodClaimForRetentionPolicy函数来更新PVC的保留策略。
//如果更新失败，则记录事件并返回错误。最后，如果上述步骤都成功，则返回nil。

// createPersistentVolumeClaims creates all of the required PersistentVolumeClaims for pod, which must be a member of
// set. If all of the claims for Pod are successfully created, the returned error is nil. If creation fails, this method
// may be called again until no error is returned, indicating the PersistentVolumeClaims for pod are consistent with
// set&#39;s Spec.
func (spc *StatefulPodControl) createPersistentVolumeClaims(set *apps.StatefulSet, pod *v1.Pod) error {
	var errs []error
	for _, claim := range getPersistentVolumeClaims(set, pod) {
		pvc, err := spc.objectMgr.GetClaim(claim.Namespace, claim.Name)
		switch {
		case apierrors.IsNotFound(err):
			err := spc.objectMgr.CreateClaim(&amp;claim)
			if err != nil {
				errs = append(errs, fmt.Errorf("failed to create PVC %s: %s", claim.Name, err))
			}
			if err == nil || !apierrors.IsAlreadyExists(err) {
				spc.recordClaimEvent("create", set, pod, &amp;claim, err)
			}
		case err != nil:
			errs = append(errs, fmt.Errorf("failed to retrieve PVC %s: %s", claim.Name, err))
			spc.recordClaimEvent("create", set, pod, &amp;claim, err)
		default:
			if pvc.DeletionTimestamp != nil {
				errs = append(errs, fmt.Errorf("pvc %s is being deleted", claim.Name))
			}
		}
		// TODO: Check resource requirements and accessmodes, update if necessary
	}
	return errorutils.NewAggregate(errs)
}

//该函数用于创建StatefulSet中的PersistentVolumeClaims（PVCs）。
//1. 遍历获取需要创建的PVCs。
//2. 对于每个PVC，先尝试从objectMgr中获取，根据获取结果进行不同处理：
//- 如果未找到，则创建该PVC，并记录事件。
//- 如果获取发生错误，则将错误信息记录并返回。
//- 如果已存在该PVC，检查其DeletionTimestamp是否为空，若非空则将错误信息记录并返回。
//3. 返回所有错误的聚合。  注意：该函数未完成，最后还有一行TODO注释，提示需要检查资源需求和访问模式并进行更新。
'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2024-04-10 K8S控制器之stateful_pod_control.go源码解读"><meta property="og:description" content='/* Copyright 2016 The Kubernetes Authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ package statefulset import ( "context" "fmt" "strings" apps "k8s.io/api/apps/v1" v1 "k8s.io/api/core/v1" apierrors "k8s.io/apimachinery/pkg/api/errors" metav1 "k8s.io/apimachinery/pkg/apis/meta/v1" errorutils "k8s.io/apimachinery/pkg/util/errors" utilruntime "k8s.io/apimachinery/pkg/util/runtime" utilfeature "k8s.io/apiserver/pkg/util/feature" clientset "k8s.io/client-go/kubernetes" corelisters "k8s.io/client-go/listers/core/v1" "k8s.io/client-go/tools/record" "k8s.io/client-go/util/retry" "k8s.io/kubernetes/pkg/features" ) // StatefulPodControlObjectManager abstracts the manipulation of Pods and PVCs. The real controller implements this // with a clientset for writes and listers for reads; for tests we provide stubs. type StatefulPodControlObjectManager interface { CreatePod(ctx context.Context, pod *v1.Pod) error GetPod(namespace, podName string) (*v1.Pod, error) UpdatePod(pod *v1.Pod) error DeletePod(pod *v1.Pod) error CreateClaim(claim *v1.PersistentVolumeClaim) error GetClaim(namespace, claimName string) (*v1.PersistentVolumeClaim, error) UpdateClaim(claim *v1.PersistentVolumeClaim) error } // 这是一个StatefulPodControlObjectManager接口，定义了对有状态Pod和持久卷声明的操作方法，包括创建、获取、更新和删除Pod以及创建、获取、更新持久卷声明。 // StatefulPodControl defines the interface that StatefulSetController uses to create, update, and delete Pods, // and to update the Status of a StatefulSet. It follows the design paradigms used for PodControl, but its // implementation provides for PVC creation, ordered Pod creation, ordered Pod termination, and Pod identity enforcement. // Manipulation of objects is provided through objectMgr, which allows the k8s API to be mocked out for testing. type StatefulPodControl struct { objectMgr StatefulPodControlObjectManager recorder record.EventRecorder } //该代码定义了一个名为StatefulPodControl的结构体，它是一个接口，用于创建、更新和删除Pods，以及更新StatefulSet的状态。 //它采用了与PodControl相同的设计模式，但其实现提供了PVC创建、有序Pod创建、有序Pod终止和Pod身份强制执行等功能。 //通过objectMgr对象提供对对象的操作，允许在测试中模拟k8s API。 // NewStatefulPodControl constructs a StatefulPodControl using a realStatefulPodControlObjectManager with the given // clientset, listers and EventRecorder. func NewStatefulPodControl( client clientset.Interface, podLister corelisters.PodLister, claimLister corelisters.PersistentVolumeClaimLister, recorder record.EventRecorder, ) *StatefulPodControl { return &amp;StatefulPodControl{&amp;realStatefulPodControlObjectManager{client, podLister, claimLister}, recorder} } // 该函数用于构造一个StatefulPodControl对象，使用给定的clientset、listers和EventRecorder。 // 函数通过传入的参数创建一个realStatefulPodControlObjectManager对象，并将其与传入的EventRecorder对象一起封装到StatefulPodControl对象中，最后返回该对象。 // NewStatefulPodControlFromManager creates a StatefulPodControl using the given StatefulPodControlObjectManager and recorder. func NewStatefulPodControlFromManager(om StatefulPodControlObjectManager, recorder record.EventRecorder) *StatefulPodControl { return &amp;StatefulPodControl{om, recorder} } // 该函数使用给定的StatefulPodControlObjectManager和record.EventRecorder创建一个StatefulPodControl，并返回其指针。 // realStatefulPodControlObjectManager uses a clientset.Interface and listers. type realStatefulPodControlObjectManager struct { client clientset.Interface podLister corelisters.PodLister claimLister corelisters.PersistentVolumeClaimLister } // 该代码定义了一个名为realStatefulPodControlObjectManager的结构体，它使用了clientset.Interface和listers。 // 结构体中有三个字段：client、podLister和claimLister，分别用于存储客户端接口、Pod列表和持久卷申领列表。 func (om *realStatefulPodControlObjectManager) CreatePod(ctx context.Context, pod *v1.Pod) error { _, err := om.client.CoreV1().Pods(pod.Namespace).Create(ctx, pod, metav1.CreateOptions{}) return err } // 该函数是一个Go语言函数，它使用了上下文（Context）来控制请求的超时和取消。 // 该函数的功能是在指定的命名空间中创建一个Pod，并返回创建操作的结果（成功或错误）。 // 具体来说，该函数的实现步骤如下： // 1. 使用om.client获取CoreV1接口，该接口提供了对Kubernetes集群中Pod资源的操作方法。 // 2. 调用Create方法，在指定的命名空间中创建Pod，并传入上下文（Context）和Pod对象。 // 3. 返回创建操作的结果，即错误信息（Error）。 // 需要注意的是，该函数中使用了context.Context参数，它允许调用者控制请求的超时和取消。在实际应用中，这非常有用，比如在处理大量请求或需要及时响应的场景中。 func (om *realStatefulPodControlObjectManager) GetPod(namespace, podName string) (*v1.Pod, error) { return om.podLister.Pods(namespace).Get(podName) } // 该函数是一个Go语言的方法，定义在一个名为realStatefulPodControlObjectManager的结构体类型上。该方法的功能是在指定的命名空间 // (namespace)中获取指定名称(podName)的Pod对象，并返回该Pod对象及其可能发生的错误。 具体实现上， // 该方法通过调用om.podLister.Pods(namespace)来获取指定命名空间下的所有Pods的列表器， // 然后进一步调用Get(podName)方法来获取指定名称的Pod对象。如果获取成功，则将该Pod对象返回； // 如果获取失败，则将发生的错误返回。 func (om *realStatefulPodControlObjectManager) UpdatePod(pod *v1.Pod) error { _, err := om.client.CoreV1().Pods(pod.Namespace).Update(context.TODO(), pod, metav1.UpdateOptions{}) return err } // 该函数用于更新指定命名空间下的Pod。函数接收一个指向v1.Pod类型的指针作为参数，通过调用om.client.CoreV1().Pods // (pod.Namespace).Update()方法，将该Pod对象更新至Kubernetes集群中。若更新成功，则返回nil；若更新失败， // 则返回相应的错误信息。 func (om *realStatefulPodControlObjectManager) DeletePod(pod *v1.Pod) error { return om.client.CoreV1().Pods(pod.Namespace).Delete(context.TODO(), pod.Name, metav1.DeleteOptions{}) } func (om *realStatefulPodControlObjectManager) CreateClaim(claim *v1.PersistentVolumeClaim) error { _, err := om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Create(context.TODO(), claim, metav1.CreateOptions{}) return err } // 该函数用于删除指定命名空间下的Pod。函数接收一个指向v1.Pod类型的指针作为参数，通过调用om.client.CoreV1().Pods // (pod.Namespace).Delete()方法，根据传入的Pod的Namespace和Name属性，在Kubernetes集群中删除该Pod实例。 // 若删除成功，则返回nil；否则，返回相应的错误信息。 func (om *realStatefulPodControlObjectManager) GetClaim(namespace, claimName string) (*v1.PersistentVolumeClaim, error) { return om.claimLister.PersistentVolumeClaims(namespace).Get(claimName) } //该函数用于获取指定命名空间下名为claimName的PersistentVolumeClaim资源。函数接收两个字符串参数：namespace（命名空间）和claimName //（PersistentVolumeClaim名称）。它通过调用om.claimLister.PersistentVolumeClaims(namespace).Get(claimName)从缓存列表中获取指定的 //PersistentVolumeClaim对象，并将其以*v1.PersistentVolumeClaim类型返回。如果获取成功，则返回PersistentVolumeClaim实例及其nil错误； //如果未能找到对应资源，则返回nil及可能的错误信息。 func (om *realStatefulPodControlObjectManager) UpdateClaim(claim *v1.PersistentVolumeClaim) error { _, err := om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Update(context.TODO(), claim, metav1.UpdateOptions{}) return err } //该函数用于更新指定命名空间下的PersistentVolumeClaim资源。函数接收一个指向v1.PersistentVolumeClaim类型的指针作为参数。 //通过调用om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Update()方法，根据传入的PersistentVolumeClaim对象的Namespace属性， //在Kubernetes集群中更新该PersistentVolumeClaim实例。若更新操作成功，则返回nil；若出现错误，则返回相应的错误信息。 func (spc *StatefulPodControl) CreateStatefulPod(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error { // Create the Pod&#39;s PVCs prior to creating the Pod if err := spc.createPersistentVolumeClaims(set, pod); err != nil { spc.recordPodEvent("create", set, pod, err) return err } // If we created the PVCs attempt to create the Pod err := spc.objectMgr.CreatePod(ctx, pod) // sink already exists errors if apierrors.IsAlreadyExists(err) { return err } if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) { // Set PVC policy as much as is possible at this point. if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil { spc.recordPodEvent("update", set, pod, err) return err } } spc.recordPodEvent("create", set, pod, err) return err } // 该函数用于创建有状态的Pod。在创建Pod之前，它会先创建Pod所需的PVC（持久卷声明）。如果创建PVC时出现错误，则会记录Pod事件并返回错误。 // 接下来，它会尝试创建Pod，如果Pod已存在，则直接返回错误。如果启用了StatefulSetAutoDeletePVC功能，则会更新Pod的PVC保留策略。 // 最后，它会记录Pod的创建事件并返回可能的错误 func (spc *StatefulPodControl) UpdateStatefulPod(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error { attemptedUpdate := false err := retry.RetryOnConflict(retry.DefaultBackoff, func() error { // assume the Pod is consistent consistent := true // if the Pod does not conform to its identity, update the identity and dirty the Pod if !identityMatches(set, pod) { updateIdentity(set, pod) consistent = false } //该函数是一个Go语言函数，它用于更新一个有状态的Pod（StatefulPod）的状态。函数的参数包括一个上下文对象ctx、一个StatefulSet对象set和一个Pod对象pod。 //函数通过使用retry.RetryOnConflict方法，在遇到冲突时进行重试，以更新Pod的状态。在重试的过程中， //函数会检查Pod是否符合其身份要求和StatefulSet的存储要求。如果不符合，函数会相应地更新Pod的身份和PVCs，并标记Pod为“dirty”。 //如果在更新过程中出现错误，则会返回错误信息。 // if the Pod does not conform to the StatefulSet&#39;s storage requirements, update the Pod&#39;s PVC&#39;s, // dirty the Pod, and create any missing PVCs if !storageMatches(set, pod) { updateStorage(set, pod) consistent = false if err := spc.createPersistentVolumeClaims(set, pod); err != nil { spc.recordPodEvent("update", set, pod, err) return err } } //该函数主要检查Pod是否符合StatefulSet的存储要求，如果不符合，则更新Pod的PVCs，标记Pod为dirty，并创建任何缺失的PVCs。 //具体流程如下： 1. 检查Pod是否符合StatefulSet的存储要求，调用storageMatches(set, pod)函数。 //2. 如果Pod不符合存储要求，则执行以下操作： - 调用updateStorage(set, pod)函数更新Pod的PVCs。 - 将consistent标记为false。 - //调用spc.createPersistentVolumeClaims(set, pod)函数创建任何缺失的PVCs，如果创建失败，则记录Pod事件并返回错误。 //3. 如果Pod符合存储要求，则继续后续流程。 if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) { // if the Pod&#39;s PVCs are not consistent with the StatefulSet&#39;s PVC deletion policy, update the PVC // and dirty the pod. if match, err := spc.ClaimsMatchRetentionPolicy(ctx, set, pod); err != nil { spc.recordPodEvent("update", set, pod, err) return err } else if !match { if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil { spc.recordPodEvent("update", set, pod, err) return err } consistent = false } } //这段Go代码是关于StatefulSet自动删除PVC的逻辑。 首先，检查是否启用了StatefulSetAutoDeletePVC功能门。 //如果启用了，则进一步判断Pod的PVC是否与StatefulSet的PVC删除策略一致。如果不一致，则更新PVC并标记Pod为dirty。 //如果匹配失败，则调用UpdatePodClaimForRetentionPolicy函数来更新Pod的PVC，并将consistent标记为false。 //在更新过程中，如果出现错误，则记录Pod事件并返回错误。 // if the Pod is not dirty, do nothing if consistent { return nil } attemptedUpdate = true // commit the update, retrying on conflicts updateErr := spc.objectMgr.UpdatePod(pod) if updateErr == nil { return nil } if updated, err := spc.objectMgr.GetPod(set.Namespace, pod.Name); err == nil { // make a copy so we don&#39;t mutate the shared cache pod = updated.DeepCopy() } else { utilruntime.HandleError(fmt.Errorf("error getting updated Pod %s/%s: %w", set.Namespace, pod.Name, err)) } //这段Go代码主要做的是更新Pod的操作。具体流程如下： //1. 首先判断consistent是否为true，如果是，则直接返回nil。 //2. 设置attemptedUpdate为true，表示已经尝试更新Pod。 //3. 调用spc.objectMgr.UpdatePod(pod)方法更新Pod，如果更新成功，则直接返回nil。 //4. 如果更新失败，则尝试获取最新的Pod信息。 //5. 如果获取成功，则将获取到的Pod深拷贝一份，防止对共享缓存的污染。 //6. 如果获取失败，则打印错误信息。 整体来说，这段代码的逻辑比较简单，主要是通过调用UpdatePod方法更新Pod，如果更新失败则尝试重新获取Pod信息。 return updateErr }) if attemptedUpdate { spc.recordPodEvent("update", set, pod, err) } return err } // 这段Go代码是一个函数片段，它在一个匿名函数中执行了某种更新操作，并通过参数set和pod记录了事件。如果更新操作尝试过， // 它会通过spc.recordPodEvent方法记录一个名为"update"的事件。最后，该函数返回一个错误值err。 func (spc *StatefulPodControl) DeleteStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error { err := spc.objectMgr.DeletePod(pod) spc.recordPodEvent("delete", set, pod, err) return err } // 此函数用于删除一个有状态的Pod。它通过调用spc.objectMgr.DeletePod(pod)来删除指定的Pod，并记录事件。最后返回删除操作的错误（如果有）。 // ClaimsMatchRetentionPolicy returns false if the PVCs for pod are not consistent with set&#39;s PVC deletion policy. // An error is returned if something is not consistent. This is expected if the pod is being otherwise updated, // but a problem otherwise (see usage of this method in UpdateStatefulPod). func (spc *StatefulPodControl) ClaimsMatchRetentionPolicy(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) (bool, error) { logger := klog.FromContext(ctx) ordinal := getOrdinal(pod) templates := set.Spec.VolumeClaimTemplates for i := range templates { claimName := getPersistentVolumeClaimName(set, &amp;templates[i], ordinal) claim, err := spc.objectMgr.GetClaim(set.Namespace, claimName) switch { case apierrors.IsNotFound(err): klog.FromContext(ctx).V(4).Info("Expected claim missing, continuing to pick up in next iteration", "PVC", klog.KObj(claim)) case err != nil: return false, fmt.Errorf("Could not retrieve claim %s for %s when checking PVC deletion policy", claimName, pod.Name) default: if !claimOwnerMatchesSetAndPod(logger, claim, set, pod) { return false, nil } } } return true, nil } //该函数用于检查Pod的PVC是否符合StatefulSet的PVC删除策略。 //它遍历StatefulSet的VolumeClaimTemplates，并根据模板生成PVC名称。 //然后它尝试获取该PVC，根据获取结果进行判断： //- 如果PVC不存在，则记录日志并继续下一次迭代。 //- 如果获取PVC出现错误，则返回错误。 //- 如果PVC存在但其owner不是StatefulSet和Pod，则返回false。 //如果所有PVC都符合要求，则返回true。 // UpdatePodClaimForRetentionPolicy updates the PVCs used by pod to match the PVC deletion policy of set. func (spc *StatefulPodControl) UpdatePodClaimForRetentionPolicy(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error { logger := klog.FromContext(ctx) ordinal := getOrdinal(pod) templates := set.Spec.VolumeClaimTemplates for i := range templates { claimName := getPersistentVolumeClaimName(set, &amp;templates[i], ordinal) claim, err := spc.objectMgr.GetClaim(set.Namespace, claimName) switch { case apierrors.IsNotFound(err): logger.V(4).Info("Expected claim missing, continuing to pick up in next iteration", "PVC", klog.KObj(claim)) case err != nil: return fmt.Errorf("Could not retrieve claim %s not found for %s when checking PVC deletion policy: %w", claimName, pod.Name, err) default: if !claimOwnerMatchesSetAndPod(logger, claim, set, pod) { claim = claim.DeepCopy() // Make a copy so we don&#39;t mutate the shared cache. needsUpdate := updateClaimOwnerRefForSetAndPod(logger, claim, set, pod) if needsUpdate { err := spc.objectMgr.UpdateClaim(claim) if err != nil { return fmt.Errorf("Could not update claim %s for delete policy ownerRefs: %w", claimName, err) } } } } } return nil } //该函数用于更新StatefulSet中的Pod的PersistentVolumeClaim（PVC）的所有者引用，以确保它们与Pod和StatefulSet正确关联。 //它遍历StatefulSet的VolumeClaimTemplates，并根据Pod的序号生成相应的PVC名称。然后，它尝试获取该PVC，根据获取结果进行不同的处理： //- 如果PVC不存在，则记录一条日志，并继续处理下一个PVC。 //- 如果获取PVC时出现错误，则返回错误。 //- 如果PVC存在但其所有者引用与Pod和StatefulSet不匹配，则创建PVC的深拷贝，并更新其所有者引用。 //如果更新后的PVC与原始PVC不同，则将其更新到Kubernetes集群中。 最终，如果所有PVC都已正确处理，则函数返回nil。 // PodClaimIsStale returns true for a stale PVC that should block pod creation. If the scaling // policy is deletion, and a PVC has an ownerRef that does not match the pod, the PVC is stale. This // includes pods whose UID has not been created. func (spc *StatefulPodControl) PodClaimIsStale(set *apps.StatefulSet, pod *v1.Pod) (bool, error) { policy := getPersistentVolumeClaimRetentionPolicy(set) if policy.WhenScaled == apps.RetainPersistentVolumeClaimRetentionPolicyType { // PVCs are meant to be reused and so can&#39;t be stale. return false, nil } for _, claim := range getPersistentVolumeClaims(set, pod) { pvc, err := spc.objectMgr.GetClaim(claim.Namespace, claim.Name) switch { case apierrors.IsNotFound(err): // If the claim doesn&#39;t exist yet, it can&#39;t be stale. continue case err != nil: return false, err case err == nil: // A claim is stale if it doesn&#39;t match the pod&#39;s UID, including if the pod has no UID. if hasStaleOwnerRef(pvc, pod) { return true, nil } } } return false, nil } // SstatefulSet和Pod对应的PersistentVolumeClaim该函数用于判断Pod所使用的PVC是否为旧的（stale），如果为旧的则会阻止Pod的创建。 // 在StatefulSet缩容策略为删除时，如果PVC的ownerRef与Pod不匹配，则认为PVC是旧的。 // 函数首先根据StatefulSet的设置获取PVC的保留策略，如果策略为保留（Retain），则PVC会被重用，不会被认为是旧的。 // 然后遍历获取与Pod相关的PVC，通过查询PVC的详细信息判断PVC是否与Pod的UID匹配，如果不匹配则认为PVC是旧的。 // 如果查询PVC时发生错误，则返回错误信息。最后，如果没有发现旧的PVC，则返回false。 // recordPodEvent records an event for verb applied to a Pod in a StatefulSet. If err is nil the generated event will // have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a reason of v1.EventTypeWarning. func (spc *StatefulPodControl) recordPodEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, err error) { if err == nil { reason := fmt.Sprintf("Successful%s", strings.Title(verb)) message := fmt.Sprintf("%s Pod %s in StatefulSet %s successful", strings.ToLower(verb), pod.Name, set.Name) spc.recorder.Event(set, v1.EventTypeNormal, reason, message) } else { reason := fmt.Sprintf("Failed%s", strings.Title(verb)) message := fmt.Sprintf("%s Pod %s in StatefulSet %s failed error: %s", strings.ToLower(verb), pod.Name, set.Name, err) spc.recorder.Event(set, v1.EventTypeWarning, reason, message) } } // 该函数是一个名为recordPodEvent的方法，它属于StatefulPodControl类型。 // 该方法用于记录关于Pod的事件，该Pod属于一个StatefulSet。根据err参数的值，生成的事件会有不同的原因， // 如果err为nil，则事件原因为v1.EventTypeNormal，否则为v1.EventTypeWarning。 // 根据verb参数，会生成成功或失败的事件消息，并通过spc.recorder.Event方法记录事件。 // recordClaimEvent records an event for verb applied to the PersistentVolumeClaim of a Pod in a StatefulSet. If err is // nil the generated event will have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a // reason of v1.EventTypeWarning. func (spc *StatefulPodControl) recordClaimEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, claim *v1.PersistentVolumeClaim, err error) { if err == nil { reason := fmt.Sprintf("Successful%s", strings.Title(verb)) message := fmt.Sprintf("%s Claim %s Pod %s in StatefulSet %s success", strings.ToLower(verb), claim.Name, pod.Name, set.Name) spc.recorder.Event(set, v1.EventTypeNormal, reason, message) } else { reason := fmt.Sprintf("Failed%s", strings.Title(verb)) message := fmt.Sprintf("%s Claim %s for Pod %s in StatefulSet %s failed error: %s", strings.ToLower(verb), claim.Name, pod.Name, set.Name, err) spc.recorder.Event(set, v1.EventTypeWarning, reason, message) } } // 该函数名为recordClaimEvent，用于记录StatefulSet中Pod的PersistentVolumeClaim的事件。 // 根据err是否为nil，生成的事件会有不同的原因，如果err为nil，则事件原因为v1.EventTypeNormal，否则为v1.EventTypeWarning。 // 函数通过spc.recorder.Event方法记录事件。 // createMissingPersistentVolumeClaims creates all of the required PersistentVolumeClaims for pod, and updates its retention policy func (spc *StatefulPodControl) createMissingPersistentVolumeClaims(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error { if err := spc.createPersistentVolumeClaims(set, pod); err != nil { return err } if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) { // Set PVC policy as much as is possible at this point. if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil { spc.recordPodEvent("update", set, pod, err) return err } } return nil } //该函数是一个Go语言函数，用于创建缺失的PersistentVolumeClaims（PVCs）并更新其保留策略，适用于StatefulPodControl类型。 //函数首先调用createPersistentVolumeClaims函数创建所需的PVCs，如果创建失败，则返回错误。 //接下来，如果启用了StatefulSetAutoDeletePVC功能，则调用UpdatePodClaimForRetentionPolicy函数来更新PVC的保留策略。 //如果更新失败，则记录事件并返回错误。最后，如果上述步骤都成功，则返回nil。 // createPersistentVolumeClaims creates all of the required PersistentVolumeClaims for pod, which must be a member of // set. If all of the claims for Pod are successfully created, the returned error is nil. If creation fails, this method // may be called again until no error is returned, indicating the PersistentVolumeClaims for pod are consistent with // set&#39;s Spec. func (spc *StatefulPodControl) createPersistentVolumeClaims(set *apps.StatefulSet, pod *v1.Pod) error { var errs []error for _, claim := range getPersistentVolumeClaims(set, pod) { pvc, err := spc.objectMgr.GetClaim(claim.Namespace, claim.Name) switch { case apierrors.IsNotFound(err): err := spc.objectMgr.CreateClaim(&amp;claim) if err != nil { errs = append(errs, fmt.Errorf("failed to create PVC %s: %s", claim.Name, err)) } if err == nil || !apierrors.IsAlreadyExists(err) { spc.recordClaimEvent("create", set, pod, &amp;claim, err) } case err != nil: errs = append(errs, fmt.Errorf("failed to retrieve PVC %s: %s", claim.Name, err)) spc.recordClaimEvent("create", set, pod, &amp;claim, err) default: if pvc.DeletionTimestamp != nil { errs = append(errs, fmt.Errorf("pvc %s is being deleted", claim.Name)) } } // TODO: Check resource requirements and accessmodes, update if necessary } return errorutils.NewAggregate(errs) } //该函数用于创建StatefulSet中的PersistentVolumeClaims（PVCs）。 //1. 遍历获取需要创建的PVCs。 //2. 对于每个PVC，先尝试从objectMgr中获取，根据获取结果进行不同处理： //- 如果未找到，则创建该PVC，并记录事件。 //- 如果获取发生错误，则将错误信息记录并返回。 //- 如果已存在该PVC，检查其DeletionTimestamp是否为空，若非空则将错误信息记录并返回。 //3. 返回所有错误的聚合。 注意：该函数未完成，最后还有一行TODO注释，提示需要检查资源需求和访问模式并进行更新。'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2024-04-10 K8S控制器之stateful_pod_control.go源码解读 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.0c65b28a757263a709f5fc2373f69dd0bc2f6b9260a8fbb927fc1d7b7a5ee3ce.js integrity="sha256-DGWyinVyY6cJ9fwjc/ad0Lwva5JgqPu5J/wde3pe484=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-6-23-ingress-nginx-contrller-%E5%88%86%E6%9E%90/>2025-6-23 ingress nginx contrller 内存使用过高分析</a></li><li><a href=/docs/2025-6-20-oom/>2025-6-20 oom排查思路</a></li><li><a href=/docs/2025-6-16-fire%E8%A7%84%E5%88%99/>2025-6-16 Cursor RIPER-5规则</a></li><li><a href=/docs/2025-6-12-karmada/>2025-6-12 karmada介绍</a></li><li><a href=/docs/2025-6-12-flutter%E8%A7%84%E5%88%99/>2025-6-12 flutter规则</a></li><li><a href=/docs/2025-6-10-%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/>2025-6-10 独立开发</a></li><li><a href=/docs/2025-5-29-%E9%94%99%E9%A2%98%E5%88%86%E6%9E%902/>2025-5-29 错题分析2</a></li><li><a href=/docs/2025-5-29-%E9%94%99%E9%A2%98%E5%88%86%E6%9E%901/>2025-5-29 错题分析1</a></li><li><a href=/docs/2025-5-21-ingress%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/>2025-5-21 主Ingress副本变为0后报503问题分析</a></li><li><a href=/docs/2025-5-7-%E6%8E%A5%E5%8D%95app/>2025-5-07 接单app设计</a></li><li><a href=/docs/2025-5-7-%E5%A5%BD%E5%BF%83%E6%80%81-app/>2025-5-07 好心态app</a></li><li><a href=/docs/2025-4-28-cursor-agent-%E6%8F%90%E7%A4%BA%E5%99%A8/>2025-4-28 cursor agent 提示器</a></li><li><a href=/docs/2025-4-16-%E8%87%AA%E7%A0%94k8s%E5%B9%B3%E5%8F%B0/>2025-4-16 自研k8s平台</a></li><li><a href=/docs/2025-4-16-sleep%E7%9D%A1%E7%9C%A0%E5%BA%94%E7%94%A8/>2025-4-16 sleep睡眠应用</a></li><li><a href=/docs/2025-4-16-paas%E8%AE%BE%E8%AE%A1/>2025-4-16 paas开发记录</a></li><li><a href=/docs/2025-4-16-cursoe-free-vip/>2025-4-16 Cursor Free VIP</a></li><li><a href=/docs/2025-4-16-boss%E7%9B%B4%E8%81%98%E8%87%AA%E5%8A%A8%E6%8A%95%E9%80%92/>2025-4-16 BOSS直聘自动投递</a></li><li><a href=/docs/2025-4-14-github%E6%8E%A8%E9%80%81/>2025-4-14 github推送</a></li><li><a href=/docs/2025-3-30-metallb/>2025-3-30 metallb</a></li><li><a href=/docs/2025-3-24-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/>2025-3-24 自我介绍</a></li><li><a href=/docs/2025-3-20-victoriametrics-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics高可用架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 thanos高可用架构</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-08-01 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 k8s面试题</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-05-01 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-04-17 面试总结</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/ class=active>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-03-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-03-08 面试</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2024-03-04 k8s流量链路剖析</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2024-03-04 CSI剖析演进</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-03-04 CNI剖析演进</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-02-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-02-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-02-22 k8s架构师面试大全</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/2025-4-20-%E6%80%A7%E5%90%8C%E6%84%8Fapp/>2025 4 20 性同意app</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><pre tabindex=0><code>/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package statefulset

import (
	&#34;context&#34;
	&#34;fmt&#34;
	&#34;strings&#34;

	apps &#34;k8s.io/api/apps/v1&#34;
	v1 &#34;k8s.io/api/core/v1&#34;
	apierrors &#34;k8s.io/apimachinery/pkg/api/errors&#34;
	metav1 &#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;
	errorutils &#34;k8s.io/apimachinery/pkg/util/errors&#34;
	utilruntime &#34;k8s.io/apimachinery/pkg/util/runtime&#34;
	utilfeature &#34;k8s.io/apiserver/pkg/util/feature&#34;
	clientset &#34;k8s.io/client-go/kubernetes&#34;
	corelisters &#34;k8s.io/client-go/listers/core/v1&#34;
	&#34;k8s.io/client-go/tools/record&#34;
	&#34;k8s.io/client-go/util/retry&#34;
	&#34;k8s.io/kubernetes/pkg/features&#34;
)

// StatefulPodControlObjectManager abstracts the manipulation of Pods and PVCs. The real controller implements this
// with a clientset for writes and listers for reads; for tests we provide stubs.
type StatefulPodControlObjectManager interface {
	CreatePod(ctx context.Context, pod *v1.Pod) error
	GetPod(namespace, podName string) (*v1.Pod, error)
	UpdatePod(pod *v1.Pod) error
	DeletePod(pod *v1.Pod) error
	CreateClaim(claim *v1.PersistentVolumeClaim) error
	GetClaim(namespace, claimName string) (*v1.PersistentVolumeClaim, error)
	UpdateClaim(claim *v1.PersistentVolumeClaim) error
}

// 这是一个StatefulPodControlObjectManager接口，定义了对有状态Pod和持久卷声明的操作方法，包括创建、获取、更新和删除Pod以及创建、获取、更新持久卷声明。
// StatefulPodControl defines the interface that StatefulSetController uses to create, update, and delete Pods,
// and to update the Status of a StatefulSet. It follows the design paradigms used for PodControl, but its
// implementation provides for PVC creation, ordered Pod creation, ordered Pod termination, and Pod identity enforcement.
// Manipulation of objects is provided through objectMgr, which allows the k8s API to be mocked out for testing.
type StatefulPodControl struct {
	objectMgr StatefulPodControlObjectManager
	recorder  record.EventRecorder
}

//该代码定义了一个名为StatefulPodControl的结构体，它是一个接口，用于创建、更新和删除Pods，以及更新StatefulSet的状态。
//它采用了与PodControl相同的设计模式，但其实现提供了PVC创建、有序Pod创建、有序Pod终止和Pod身份强制执行等功能。
//通过objectMgr对象提供对对象的操作，允许在测试中模拟k8s API。

// NewStatefulPodControl constructs a StatefulPodControl using a realStatefulPodControlObjectManager with the given
// clientset, listers and EventRecorder.
func NewStatefulPodControl(
	client clientset.Interface,
	podLister corelisters.PodLister,
	claimLister corelisters.PersistentVolumeClaimLister,
	recorder record.EventRecorder,
) *StatefulPodControl {
	return &amp;StatefulPodControl{&amp;realStatefulPodControlObjectManager{client, podLister, claimLister}, recorder}
}

// 该函数用于构造一个StatefulPodControl对象，使用给定的clientset、listers和EventRecorder。
// 函数通过传入的参数创建一个realStatefulPodControlObjectManager对象，并将其与传入的EventRecorder对象一起封装到StatefulPodControl对象中，最后返回该对象。
// NewStatefulPodControlFromManager creates a StatefulPodControl using the given StatefulPodControlObjectManager and recorder.
func NewStatefulPodControlFromManager(om StatefulPodControlObjectManager, recorder record.EventRecorder) *StatefulPodControl {
	return &amp;StatefulPodControl{om, recorder}
}

// 该函数使用给定的StatefulPodControlObjectManager和record.EventRecorder创建一个StatefulPodControl，并返回其指针。
// realStatefulPodControlObjectManager uses a clientset.Interface and listers.
type realStatefulPodControlObjectManager struct {
	client      clientset.Interface
	podLister   corelisters.PodLister
	claimLister corelisters.PersistentVolumeClaimLister
}

// 该代码定义了一个名为realStatefulPodControlObjectManager的结构体，它使用了clientset.Interface和listers。
// 结构体中有三个字段：client、podLister和claimLister，分别用于存储客户端接口、Pod列表和持久卷申领列表。
func (om *realStatefulPodControlObjectManager) CreatePod(ctx context.Context, pod *v1.Pod) error {
	_, err := om.client.CoreV1().Pods(pod.Namespace).Create(ctx, pod, metav1.CreateOptions{})
	return err
}

// 该函数是一个Go语言函数，它使用了上下文（Context）来控制请求的超时和取消。
// 该函数的功能是在指定的命名空间中创建一个Pod，并返回创建操作的结果（成功或错误）。
// 具体来说，该函数的实现步骤如下：
// 1. 使用om.client获取CoreV1接口，该接口提供了对Kubernetes集群中Pod资源的操作方法。
// 2. 调用Create方法，在指定的命名空间中创建Pod，并传入上下文（Context）和Pod对象。
// 3. 返回创建操作的结果，即错误信息（Error）。
// 需要注意的是，该函数中使用了context.Context参数，它允许调用者控制请求的超时和取消。在实际应用中，这非常有用，比如在处理大量请求或需要及时响应的场景中。
func (om *realStatefulPodControlObjectManager) GetPod(namespace, podName string) (*v1.Pod, error) {
	return om.podLister.Pods(namespace).Get(podName)
}

// 该函数是一个Go语言的方法，定义在一个名为realStatefulPodControlObjectManager的结构体类型上。该方法的功能是在指定的命名空间
// (namespace)中获取指定名称(podName)的Pod对象，并返回该Pod对象及其可能发生的错误。  具体实现上，
// 该方法通过调用om.podLister.Pods(namespace)来获取指定命名空间下的所有Pods的列表器，
// 然后进一步调用Get(podName)方法来获取指定名称的Pod对象。如果获取成功，则将该Pod对象返回；
// 如果获取失败，则将发生的错误返回。
func (om *realStatefulPodControlObjectManager) UpdatePod(pod *v1.Pod) error {
	_, err := om.client.CoreV1().Pods(pod.Namespace).Update(context.TODO(), pod, metav1.UpdateOptions{})
	return err
}

// 该函数用于更新指定命名空间下的Pod。函数接收一个指向v1.Pod类型的指针作为参数，通过调用om.client.CoreV1().Pods
// (pod.Namespace).Update()方法，将该Pod对象更新至Kubernetes集群中。若更新成功，则返回nil；若更新失败，
// 则返回相应的错误信息。
func (om *realStatefulPodControlObjectManager) DeletePod(pod *v1.Pod) error {
	return om.client.CoreV1().Pods(pod.Namespace).Delete(context.TODO(), pod.Name, metav1.DeleteOptions{})
}

func (om *realStatefulPodControlObjectManager) CreateClaim(claim *v1.PersistentVolumeClaim) error {
	_, err := om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Create(context.TODO(), claim, metav1.CreateOptions{})
	return err
}

// 该函数用于删除指定命名空间下的Pod。函数接收一个指向v1.Pod类型的指针作为参数，通过调用om.client.CoreV1().Pods
// (pod.Namespace).Delete()方法，根据传入的Pod的Namespace和Name属性，在Kubernetes集群中删除该Pod实例。
// 若删除成功，则返回nil；否则，返回相应的错误信息。
func (om *realStatefulPodControlObjectManager) GetClaim(namespace, claimName string) (*v1.PersistentVolumeClaim, error) {
	return om.claimLister.PersistentVolumeClaims(namespace).Get(claimName)
}

//该函数用于获取指定命名空间下名为claimName的PersistentVolumeClaim资源。函数接收两个字符串参数：namespace（命名空间）和claimName
//（PersistentVolumeClaim名称）。它通过调用om.claimLister.PersistentVolumeClaims(namespace).Get(claimName)从缓存列表中获取指定的
//PersistentVolumeClaim对象，并将其以*v1.PersistentVolumeClaim类型返回。如果获取成功，则返回PersistentVolumeClaim实例及其nil错误；
//如果未能找到对应资源，则返回nil及可能的错误信息。

func (om *realStatefulPodControlObjectManager) UpdateClaim(claim *v1.PersistentVolumeClaim) error {
	_, err := om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Update(context.TODO(), claim, metav1.UpdateOptions{})
	return err
}

//该函数用于更新指定命名空间下的PersistentVolumeClaim资源。函数接收一个指向v1.PersistentVolumeClaim类型的指针作为参数。
//通过调用om.client.CoreV1().PersistentVolumeClaims(claim.Namespace).Update()方法，根据传入的PersistentVolumeClaim对象的Namespace属性，
//在Kubernetes集群中更新该PersistentVolumeClaim实例。若更新操作成功，则返回nil；若出现错误，则返回相应的错误信息。

func (spc *StatefulPodControl) CreateStatefulPod(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	// Create the Pod&#39;s PVCs prior to creating the Pod
	if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
		spc.recordPodEvent(&#34;create&#34;, set, pod, err)
		return err
	}
	// If we created the PVCs attempt to create the Pod
	err := spc.objectMgr.CreatePod(ctx, pod)
	// sink already exists errors
	if apierrors.IsAlreadyExists(err) {
		return err
	}
	if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) {
		// Set PVC policy as much as is possible at this point.
		if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil {
			spc.recordPodEvent(&#34;update&#34;, set, pod, err)
			return err
		}
	}
	spc.recordPodEvent(&#34;create&#34;, set, pod, err)
	return err
}

// 该函数用于创建有状态的Pod。在创建Pod之前，它会先创建Pod所需的PVC（持久卷声明）。如果创建PVC时出现错误，则会记录Pod事件并返回错误。
// 接下来，它会尝试创建Pod，如果Pod已存在，则直接返回错误。如果启用了StatefulSetAutoDeletePVC功能，则会更新Pod的PVC保留策略。
// 最后，它会记录Pod的创建事件并返回可能的错误
func (spc *StatefulPodControl) UpdateStatefulPod(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	attemptedUpdate := false
	err := retry.RetryOnConflict(retry.DefaultBackoff, func() error {
		// assume the Pod is consistent
		consistent := true
		// if the Pod does not conform to its identity, update the identity and dirty the Pod
		if !identityMatches(set, pod) {
			updateIdentity(set, pod)
			consistent = false
		}
		//该函数是一个Go语言函数，它用于更新一个有状态的Pod（StatefulPod）的状态。函数的参数包括一个上下文对象ctx、一个StatefulSet对象set和一个Pod对象pod。
		//函数通过使用retry.RetryOnConflict方法，在遇到冲突时进行重试，以更新Pod的状态。在重试的过程中，
		//函数会检查Pod是否符合其身份要求和StatefulSet的存储要求。如果不符合，函数会相应地更新Pod的身份和PVCs，并标记Pod为“dirty”。
		//如果在更新过程中出现错误，则会返回错误信息。
		// if the Pod does not conform to the StatefulSet&#39;s storage requirements, update the Pod&#39;s PVC&#39;s,
		// dirty the Pod, and create any missing PVCs
		if !storageMatches(set, pod) {
			updateStorage(set, pod)
			consistent = false
			if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
				spc.recordPodEvent(&#34;update&#34;, set, pod, err)
				return err
			}
		}
		//该函数主要检查Pod是否符合StatefulSet的存储要求，如果不符合，则更新Pod的PVCs，标记Pod为dirty，并创建任何缺失的PVCs。
		//具体流程如下：  1. 检查Pod是否符合StatefulSet的存储要求，调用storageMatches(set, pod)函数。
		//2. 如果Pod不符合存储要求，则执行以下操作： - 调用updateStorage(set, pod)函数更新Pod的PVCs。 - 将consistent标记为false。 -
		//调用spc.createPersistentVolumeClaims(set, pod)函数创建任何缺失的PVCs，如果创建失败，则记录Pod事件并返回错误。
		//3. 如果Pod符合存储要求，则继续后续流程。
		if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) {
			// if the Pod&#39;s PVCs are not consistent with the StatefulSet&#39;s PVC deletion policy, update the PVC
			// and dirty the pod.
			if match, err := spc.ClaimsMatchRetentionPolicy(ctx, set, pod); err != nil {
				spc.recordPodEvent(&#34;update&#34;, set, pod, err)
				return err
			} else if !match {
				if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil {
					spc.recordPodEvent(&#34;update&#34;, set, pod, err)
					return err
				}
				consistent = false
			}
		}
		//这段Go代码是关于StatefulSet自动删除PVC的逻辑。 首先，检查是否启用了StatefulSetAutoDeletePVC功能门。
		//如果启用了，则进一步判断Pod的PVC是否与StatefulSet的PVC删除策略一致。如果不一致，则更新PVC并标记Pod为dirty。
		//如果匹配失败，则调用UpdatePodClaimForRetentionPolicy函数来更新Pod的PVC，并将consistent标记为false。
		//在更新过程中，如果出现错误，则记录Pod事件并返回错误。
		// if the Pod is not dirty, do nothing
		if consistent {
			return nil
		}

		attemptedUpdate = true
		// commit the update, retrying on conflicts

		updateErr := spc.objectMgr.UpdatePod(pod)
		if updateErr == nil {
			return nil
		}

		if updated, err := spc.objectMgr.GetPod(set.Namespace, pod.Name); err == nil {
			// make a copy so we don&#39;t mutate the shared cache
			pod = updated.DeepCopy()
		} else {
			utilruntime.HandleError(fmt.Errorf(&#34;error getting updated Pod %s/%s: %w&#34;, set.Namespace, pod.Name, err))
		}
		//这段Go代码主要做的是更新Pod的操作。具体流程如下：
		//1. 首先判断consistent是否为true，如果是，则直接返回nil。
		//2. 设置attemptedUpdate为true，表示已经尝试更新Pod。
		//3. 调用spc.objectMgr.UpdatePod(pod)方法更新Pod，如果更新成功，则直接返回nil。
		//4. 如果更新失败，则尝试获取最新的Pod信息。
		//5. 如果获取成功，则将获取到的Pod深拷贝一份，防止对共享缓存的污染。
		//6. 如果获取失败，则打印错误信息。  整体来说，这段代码的逻辑比较简单，主要是通过调用UpdatePod方法更新Pod，如果更新失败则尝试重新获取Pod信息。
		return updateErr
	})
	if attemptedUpdate {
		spc.recordPodEvent(&#34;update&#34;, set, pod, err)
	}
	return err
}

// 这段Go代码是一个函数片段，它在一个匿名函数中执行了某种更新操作，并通过参数set和pod记录了事件。如果更新操作尝试过，
// 它会通过spc.recordPodEvent方法记录一个名为&#34;update&#34;的事件。最后，该函数返回一个错误值err。
func (spc *StatefulPodControl) DeleteStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error {
	err := spc.objectMgr.DeletePod(pod)
	spc.recordPodEvent(&#34;delete&#34;, set, pod, err)
	return err
}

// 此函数用于删除一个有状态的Pod。它通过调用spc.objectMgr.DeletePod(pod)来删除指定的Pod，并记录事件。最后返回删除操作的错误（如果有）。
// ClaimsMatchRetentionPolicy returns false if the PVCs for pod are not consistent with set&#39;s PVC deletion policy.
// An error is returned if something is not consistent. This is expected if the pod is being otherwise updated,
// but a problem otherwise (see usage of this method in UpdateStatefulPod).
func (spc *StatefulPodControl) ClaimsMatchRetentionPolicy(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) (bool, error) {
	logger := klog.FromContext(ctx)
	ordinal := getOrdinal(pod)
	templates := set.Spec.VolumeClaimTemplates
	for i := range templates {
		claimName := getPersistentVolumeClaimName(set, &amp;templates[i], ordinal)
		claim, err := spc.objectMgr.GetClaim(set.Namespace, claimName)
		switch {
		case apierrors.IsNotFound(err):
			klog.FromContext(ctx).V(4).Info(&#34;Expected claim missing, continuing to pick up in next iteration&#34;, &#34;PVC&#34;, klog.KObj(claim))
		case err != nil:
			return false, fmt.Errorf(&#34;Could not retrieve claim %s for %s when checking PVC deletion policy&#34;, claimName, pod.Name)
		default:
			if !claimOwnerMatchesSetAndPod(logger, claim, set, pod) {
				return false, nil
			}
		}
	}
	return true, nil
}

//该函数用于检查Pod的PVC是否符合StatefulSet的PVC删除策略。
//它遍历StatefulSet的VolumeClaimTemplates，并根据模板生成PVC名称。
//然后它尝试获取该PVC，根据获取结果进行判断：
//- 如果PVC不存在，则记录日志并继续下一次迭代。
//- 如果获取PVC出现错误，则返回错误。
//- 如果PVC存在但其owner不是StatefulSet和Pod，则返回false。
//如果所有PVC都符合要求，则返回true。

// UpdatePodClaimForRetentionPolicy updates the PVCs used by pod to match the PVC deletion policy of set.
func (spc *StatefulPodControl) UpdatePodClaimForRetentionPolicy(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	logger := klog.FromContext(ctx)
	ordinal := getOrdinal(pod)
	templates := set.Spec.VolumeClaimTemplates
	for i := range templates {
		claimName := getPersistentVolumeClaimName(set, &amp;templates[i], ordinal)
		claim, err := spc.objectMgr.GetClaim(set.Namespace, claimName)
		switch {
		case apierrors.IsNotFound(err):
			logger.V(4).Info(&#34;Expected claim missing, continuing to pick up in next iteration&#34;, &#34;PVC&#34;, klog.KObj(claim))
		case err != nil:
			return fmt.Errorf(&#34;Could not retrieve claim %s not found for %s when checking PVC deletion policy: %w&#34;, claimName, pod.Name, err)
		default:
			if !claimOwnerMatchesSetAndPod(logger, claim, set, pod) {
				claim = claim.DeepCopy() // Make a copy so we don&#39;t mutate the shared cache.
				needsUpdate := updateClaimOwnerRefForSetAndPod(logger, claim, set, pod)
				if needsUpdate {
					err := spc.objectMgr.UpdateClaim(claim)
					if err != nil {
						return fmt.Errorf(&#34;Could not update claim %s for delete policy ownerRefs: %w&#34;, claimName, err)
					}
				}
			}
		}
	}
	return nil
}

//该函数用于更新StatefulSet中的Pod的PersistentVolumeClaim（PVC）的所有者引用，以确保它们与Pod和StatefulSet正确关联。
//它遍历StatefulSet的VolumeClaimTemplates，并根据Pod的序号生成相应的PVC名称。然后，它尝试获取该PVC，根据获取结果进行不同的处理：
//- 如果PVC不存在，则记录一条日志，并继续处理下一个PVC。
//- 如果获取PVC时出现错误，则返回错误。
//- 如果PVC存在但其所有者引用与Pod和StatefulSet不匹配，则创建PVC的深拷贝，并更新其所有者引用。
//如果更新后的PVC与原始PVC不同，则将其更新到Kubernetes集群中。  最终，如果所有PVC都已正确处理，则函数返回nil。

// PodClaimIsStale returns true for a stale PVC that should block pod creation. If the scaling
// policy is deletion, and a PVC has an ownerRef that does not match the pod, the PVC is stale. This
// includes pods whose UID has not been created.
func (spc *StatefulPodControl) PodClaimIsStale(set *apps.StatefulSet, pod *v1.Pod) (bool, error) {
	policy := getPersistentVolumeClaimRetentionPolicy(set)
	if policy.WhenScaled == apps.RetainPersistentVolumeClaimRetentionPolicyType {
		// PVCs are meant to be reused and so can&#39;t be stale.
		return false, nil
	}
	for _, claim := range getPersistentVolumeClaims(set, pod) {
		pvc, err := spc.objectMgr.GetClaim(claim.Namespace, claim.Name)
		switch {
		case apierrors.IsNotFound(err):
			// If the claim doesn&#39;t exist yet, it can&#39;t be stale.
			continue
		case err != nil:
			return false, err
		case err == nil:
			// A claim is stale if it doesn&#39;t match the pod&#39;s UID, including if the pod has no UID.
			if hasStaleOwnerRef(pvc, pod) {
				return true, nil
			}
		}
	}
	return false, nil
}

// SstatefulSet和Pod对应的PersistentVolumeClaim该函数用于判断Pod所使用的PVC是否为旧的（stale），如果为旧的则会阻止Pod的创建。
// 在StatefulSet缩容策略为删除时，如果PVC的ownerRef与Pod不匹配，则认为PVC是旧的。
// 函数首先根据StatefulSet的设置获取PVC的保留策略，如果策略为保留（Retain），则PVC会被重用，不会被认为是旧的。
// 然后遍历获取与Pod相关的PVC，通过查询PVC的详细信息判断PVC是否与Pod的UID匹配，如果不匹配则认为PVC是旧的。
// 如果查询PVC时发生错误，则返回错误信息。最后，如果没有发现旧的PVC，则返回false。
// recordPodEvent records an event for verb applied to a Pod in a StatefulSet. If err is nil the generated event will
// have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a reason of v1.EventTypeWarning.
func (spc *StatefulPodControl) recordPodEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, err error) {
	if err == nil {
		reason := fmt.Sprintf(&#34;Successful%s&#34;, strings.Title(verb))
		message := fmt.Sprintf(&#34;%s Pod %s in StatefulSet %s successful&#34;,
			strings.ToLower(verb), pod.Name, set.Name)
		spc.recorder.Event(set, v1.EventTypeNormal, reason, message)
	} else {
		reason := fmt.Sprintf(&#34;Failed%s&#34;, strings.Title(verb))
		message := fmt.Sprintf(&#34;%s Pod %s in StatefulSet %s failed error: %s&#34;,
			strings.ToLower(verb), pod.Name, set.Name, err)
		spc.recorder.Event(set, v1.EventTypeWarning, reason, message)
	}
}

// 该函数是一个名为recordPodEvent的方法，它属于StatefulPodControl类型。
// 该方法用于记录关于Pod的事件，该Pod属于一个StatefulSet。根据err参数的值，生成的事件会有不同的原因，
// 如果err为nil，则事件原因为v1.EventTypeNormal，否则为v1.EventTypeWarning。
// 根据verb参数，会生成成功或失败的事件消息，并通过spc.recorder.Event方法记录事件。
// recordClaimEvent records an event for verb applied to the PersistentVolumeClaim of a Pod in a StatefulSet. If err is
// nil the generated event will have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a
// reason of v1.EventTypeWarning.
func (spc *StatefulPodControl) recordClaimEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, claim *v1.PersistentVolumeClaim, err error) {
	if err == nil {
		reason := fmt.Sprintf(&#34;Successful%s&#34;, strings.Title(verb))
		message := fmt.Sprintf(&#34;%s Claim %s Pod %s in StatefulSet %s success&#34;,
			strings.ToLower(verb), claim.Name, pod.Name, set.Name)
		spc.recorder.Event(set, v1.EventTypeNormal, reason, message)
	} else {
		reason := fmt.Sprintf(&#34;Failed%s&#34;, strings.Title(verb))
		message := fmt.Sprintf(&#34;%s Claim %s for Pod %s in StatefulSet %s failed error: %s&#34;,
			strings.ToLower(verb), claim.Name, pod.Name, set.Name, err)
		spc.recorder.Event(set, v1.EventTypeWarning, reason, message)
	}
}

// 该函数名为recordClaimEvent，用于记录StatefulSet中Pod的PersistentVolumeClaim的事件。
// 根据err是否为nil，生成的事件会有不同的原因，如果err为nil，则事件原因为v1.EventTypeNormal，否则为v1.EventTypeWarning。
// 函数通过spc.recorder.Event方法记录事件。
// createMissingPersistentVolumeClaims creates all of the required PersistentVolumeClaims for pod, and updates its retention policy
func (spc *StatefulPodControl) createMissingPersistentVolumeClaims(ctx context.Context, set *apps.StatefulSet, pod *v1.Pod) error {
	if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
		return err
	}

	if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) {
		// Set PVC policy as much as is possible at this point.
		if err := spc.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil {
			spc.recordPodEvent(&#34;update&#34;, set, pod, err)
			return err
		}
	}
	return nil
}

//该函数是一个Go语言函数，用于创建缺失的PersistentVolumeClaims（PVCs）并更新其保留策略，适用于StatefulPodControl类型。
//函数首先调用createPersistentVolumeClaims函数创建所需的PVCs，如果创建失败，则返回错误。
//接下来，如果启用了StatefulSetAutoDeletePVC功能，则调用UpdatePodClaimForRetentionPolicy函数来更新PVC的保留策略。
//如果更新失败，则记录事件并返回错误。最后，如果上述步骤都成功，则返回nil。

// createPersistentVolumeClaims creates all of the required PersistentVolumeClaims for pod, which must be a member of
// set. If all of the claims for Pod are successfully created, the returned error is nil. If creation fails, this method
// may be called again until no error is returned, indicating the PersistentVolumeClaims for pod are consistent with
// set&#39;s Spec.
func (spc *StatefulPodControl) createPersistentVolumeClaims(set *apps.StatefulSet, pod *v1.Pod) error {
	var errs []error
	for _, claim := range getPersistentVolumeClaims(set, pod) {
		pvc, err := spc.objectMgr.GetClaim(claim.Namespace, claim.Name)
		switch {
		case apierrors.IsNotFound(err):
			err := spc.objectMgr.CreateClaim(&amp;claim)
			if err != nil {
				errs = append(errs, fmt.Errorf(&#34;failed to create PVC %s: %s&#34;, claim.Name, err))
			}
			if err == nil || !apierrors.IsAlreadyExists(err) {
				spc.recordClaimEvent(&#34;create&#34;, set, pod, &amp;claim, err)
			}
		case err != nil:
			errs = append(errs, fmt.Errorf(&#34;failed to retrieve PVC %s: %s&#34;, claim.Name, err))
			spc.recordClaimEvent(&#34;create&#34;, set, pod, &amp;claim, err)
		default:
			if pvc.DeletionTimestamp != nil {
				errs = append(errs, fmt.Errorf(&#34;pvc %s is being deleted&#34;, claim.Name))
			}
		}
		// TODO: Check resource requirements and accessmodes, update if necessary
	}
	return errorutils.NewAggregate(errs)
}

//该函数用于创建StatefulSet中的PersistentVolumeClaims（PVCs）。
//1. 遍历获取需要创建的PVCs。
//2. 对于每个PVC，先尝试从objectMgr中获取，根据获取结果进行不同处理：
//- 如果未找到，则创建该PVC，并记录事件。
//- 如果获取发生错误，则将错误信息记录并返回。
//- 如果已存在该PVC，检查其DeletionTimestamp是否为空，若非空则将错误信息记录并返回。
//3. 返回所有错误的聚合。  注意：该函数未完成，最后还有一行TODO注释，提示需要检查资源需求和访问模式并进行更新。
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>