<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Prometheus
  #


  Prometheus的工作流程
  #

Prometheus 的工作流程可以概括为以下几个主要步骤：

数据抓取（Scraping）：

Prometheus 会定期从配置好的目标（如应用程序、服务、节点等）抓取数据。这些目标通常通过 HTTP 接口暴露 Prometheus 格式的监控数据（通常是 /metrics 路径）。
这些数据包括各类指标，如 CPU 使用率、内存使用情况、请求数量等。


存储（Storage）：

抓取到的数据会被存储在 Prometheus 的本地时间序列数据库（TSDB）中。每个时间序列由一个指标名称和一组标签（如 instance, job, region 等）组成。


查询（Querying）：

Prometheus 提供了强大的查询语言——PromQL（Prometheus Query Language），可以通过 PromQL 查询已存储的数据。
Prometheus 可以通过其 Web 界面、API 或 Grafana 进行查询，显示时间序列数据的图表，或者用于告警规则的计算。


告警（Alerting）：

Prometheus 可以基于定义的告警规则（通过 PromQL 查询语句）进行告警。例如，当 CPU 使用率超过一定阈值时，触发告警。
告警规则可以定义在 Prometheus 配置文件中，告警信息可以通过 Alertmanager 发送到各类通知系统（如邮件、Slack、钉钉等）。


数据可视化（Visualization）：

Prometheus 本身也提供了简单的图表功能，但通常会与第三方工具（如 Grafana）结合使用，以便提供更丰富的可视化效果。
Grafana 可以从 Prometheus 查询数据，生成漂亮的仪表板，帮助团队实时监控系统健康状况。


服务发现与目标自动化（Service Discovery）：

Prometheus 支持多种服务发现机制，可以自动发现需要抓取数据的目标。常见的有 Kubernetes、Consul 等服务发现工具，也可以使用静态配置。



整体而言，Prometheus 的核心是周期性地抓取目标的监控数据，存储成时间序列，并通过查询、告警和可视化等功能帮助用户监控和维护系统的健康。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2025-2-28 prometheus面试题"><meta property="og:description" content="Prometheus # Prometheus的工作流程 # Prometheus 的工作流程可以概括为以下几个主要步骤：
数据抓取（Scraping）： Prometheus 会定期从配置好的目标（如应用程序、服务、节点等）抓取数据。这些目标通常通过 HTTP 接口暴露 Prometheus 格式的监控数据（通常是 /metrics 路径）。 这些数据包括各类指标，如 CPU 使用率、内存使用情况、请求数量等。 存储（Storage）： 抓取到的数据会被存储在 Prometheus 的本地时间序列数据库（TSDB）中。每个时间序列由一个指标名称和一组标签（如 instance, job, region 等）组成。 查询（Querying）： Prometheus 提供了强大的查询语言——PromQL（Prometheus Query Language），可以通过 PromQL 查询已存储的数据。 Prometheus 可以通过其 Web 界面、API 或 Grafana 进行查询，显示时间序列数据的图表，或者用于告警规则的计算。 告警（Alerting）： Prometheus 可以基于定义的告警规则（通过 PromQL 查询语句）进行告警。例如，当 CPU 使用率超过一定阈值时，触发告警。 告警规则可以定义在 Prometheus 配置文件中，告警信息可以通过 Alertmanager 发送到各类通知系统（如邮件、Slack、钉钉等）。 数据可视化（Visualization）： Prometheus 本身也提供了简单的图表功能，但通常会与第三方工具（如 Grafana）结合使用，以便提供更丰富的可视化效果。 Grafana 可以从 Prometheus 查询数据，生成漂亮的仪表板，帮助团队实时监控系统健康状况。 服务发现与目标自动化（Service Discovery）： Prometheus 支持多种服务发现机制，可以自动发现需要抓取数据的目标。常见的有 Kubernetes、Consul 等服务发现工具，也可以使用静态配置。 整体而言，Prometheus 的核心是周期性地抓取目标的监控数据，存储成时间序列，并通过查询、告警和可视化等功能帮助用户监控和维护系统的健康。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2025-2-28 prometheus面试题 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.1a5becdf9b12587671e0a18c1cf5fae4147c67649d7de8d4211c6063e9085a8c.js integrity="sha256-Glvs35sSWHZx4KGMHPX65BR8Z2SdfejUIRxgY+kIWow=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-3-20-victoriametrics-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics高可用架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 thanos高可用架构</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/ class=active>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-08-01 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 k8s面试题</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-05-01 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-04-17 面试总结</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-03-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-03-08 面试</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2024-03-04 k8s流量链路剖析</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2024-03-04 CSI剖析演进</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-03-04 CNI剖析演进</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-02-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-02-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-02-22 k8s架构师面试大全</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-2-28 prometheus面试题</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#prometheus>Prometheus</a></li><li><a href=#prometheus的工作流程>Prometheus的工作流程</a></li><li><a href=#metric的几种类型分别是什么>Metric的几种类型？分别是什么？☆</a><ul><li><a href=#总结>总结：</a></li></ul></li><li><a href=#prometheus有哪几种服务发现>Prometheus有哪几种服务发现☆</a><ul><li><a href=#1-kubernetes-服务发现>1. <strong>Kubernetes 服务发现</strong>：</a></li><li><a href=#2-consul-服务发现>2. <strong>Consul 服务发现</strong>：</a></li><li><a href=#3-ec2-服务发现>3. <strong>EC2 服务发现</strong>：</a></li><li><a href=#4-gcegoogle-compute-engine服务发现>4. <strong>GCE（Google Compute Engine）服务发现</strong>：</a></li><li><a href=#5-azure-服务发现>5. <strong>Azure 服务发现</strong>：</a></li><li><a href=#6-dns-服务发现>6. <strong>DNS 服务发现</strong>：</a></li><li><a href=#7-file-服务发现>7. <strong>File 服务发现</strong>：</a></li><li><a href=#8-static-服务发现>8. <strong>Static 服务发现</strong>：</a></li><li><a href=#9-openstack-服务发现>9. <strong>OpenStack 服务发现</strong>：</a></li><li><a href=#总结-1>总结：</a></li></ul></li><li><a href=#prometheus常用函数>Prometheus常用函数</a><ul><li><a href=#1-聚合函数aggregation-functions>1. <strong>聚合函数（Aggregation Functions）</strong></a></li><li><a href=#2-统计函数statistical-functions>2. <strong>统计函数（Statistical Functions）</strong></a></li><li><a href=#3-时间函数time-functions>3. <strong>时间函数（Time Functions）</strong></a></li><li><a href=#4-数值处理函数mathematical-functions>4. <strong>数值处理函数（Mathematical Functions）</strong></a></li><li><a href=#5-字符串处理函数string-functions>5. <strong>字符串处理函数（String Functions）</strong></a></li><li><a href=#6-查询时间函数time-interval-functions>6. <strong>查询时间函数（Time Interval Functions）</strong></a></li><li><a href=#7-率函数rate-functions>7. <strong>率函数（Rate Functions）</strong></a></li><li><a href=#8-逻辑函数logical-functions>8. <strong>逻辑函数（Logical Functions）</strong></a></li><li><a href=#9-过滤与条件filters--conditionals>9. <strong>过滤与条件（Filters & Conditionals）</strong></a></li><li><a href=#10-百分比计算percentile-calculation>10. <strong>百分比计算（Percentile Calculation）</strong></a></li><li><a href=#总结-2>总结：</a></li></ul></li><li><a href=#thanos架构>thanos架构☆</a><ul><li><a href=#thanos-架构概述>Thanos 架构概述</a></li><li><a href=#thanos-架构图>Thanos 架构图</a></li><li><a href=#thanos-核心功能>Thanos 核心功能</a></li><li><a href=#thanos-的使用场景>Thanos 的使用场景</a></li><li><a href=#总结-3>总结</a></li></ul></li><li><a href=#thanos与victoriametrics对比>thanos与VictoriaMetrics对比</a></li><li><a href=#1-概述><strong>1. 概述</strong></a></li><li><a href=#2-架构对比><strong>2. 架构对比</strong></a><ul><li><a href=#thanos><strong>Thanos</strong></a></li><li><a href=#victoriametrics><strong>VictoriaMetrics</strong></a></li></ul></li><li><a href=#3-关键特性对比><strong>3. 关键特性对比</strong></a></li><li><a href=#4-适用场景><strong>4. 适用场景</strong></a></li><li><a href=#5-总结><strong>5. 总结</strong></a></li><li><a href=#thanos-sidecar和receive区别>thanos sidecar和receive区别☆</a><ul><li><a href=#thanos-sidecar-vs-thanos-receive-对比><strong>Thanos Sidecar vs Thanos Receive 对比</strong></a></li></ul></li><li><a href=#1-主要用途><strong>1. 主要用途</strong></a></li><li><a href=#2-架构对比-1><strong>2. 架构对比</strong></a><ul><li><a href=#thanos-sidecar><strong>Thanos Sidecar</strong></a></li><li><a href=#thanos-receive><strong>Thanos Receive</strong></a></li></ul></li><li><a href=#3-详细功能对比><strong>3. 详细功能对比</strong></a></li><li><a href=#4-适用场景-1><strong>4. 适用场景</strong></a></li><li><a href=#5-选型建议><strong>5. 选型建议</strong></a></li><li><a href=#thanos-rule组件和prometheus区别>thanos rule组件和prometheus区别</a><ul><li><a href=#thanos-rule-vs-prometheus区别与对比><strong>Thanos Rule vs Prometheus：区别与对比</strong></a></li></ul></li><li><a href=#1-主要用途-1><strong>1. 主要用途</strong></a></li><li><a href=#2-组件介绍><strong>2. 组件介绍</strong></a><ul><li><a href=#-prometheus><strong>📌 Prometheus</strong></a></li><li><a href=#-thanos-rule><strong>📌 Thanos Rule</strong></a></li></ul></li><li><a href=#3-详细功能对比-1><strong>3. 详细功能对比</strong></a></li><li><a href=#4-适用场景-2><strong>4. 适用场景</strong></a></li><li><a href=#5-总结-1><strong>5. 总结</strong></a></li><li><a href=#prometheus告警从触发到收到通知延迟在哪>Prometheus告警从触发到收到通知延迟在哪</a></li><li><a href=#-prometheus-告警流程><strong>📌 Prometheus 告警流程</strong></a></li><li><a href=#-可能的延迟点><strong>📌 可能的延迟点</strong></a></li><li><a href=#-如何优化-prometheus-告警延迟><strong>📌 如何优化 Prometheus 告警延迟？</strong></a><ul><li><a href=#1-调整><strong>1. 调整 <code>scrape_interval</code></strong></a></li><li><a href=#2-调整><strong>2. 调整 <code>evaluation_interval</code></strong></a></li><li><a href=#3-调整><strong>3. 调整 <code>for</code> 参数</strong></a></li><li><a href=#4-调整-alertmanager-配置><strong>4. 调整 Alertmanager 配置</strong></a></li><li><a href=#5-优化通知方式><strong>5. 优化通知方式</strong></a></li></ul></li><li><a href=#-结论><strong>📌 结论</strong></a><ul><li><a href=#-优化建议>🚀 <strong>优化建议</strong></a></li><li><a href=#-推荐优化后的示例配置><strong>🔥 推荐优化后的示例配置</strong></a></li></ul></li><li><a href=#告警抑制怎么做>告警抑制怎么做☆</a></li><li><a href=#-告警抑制的工作原理><strong>📌 告警抑制的工作原理</strong></a></li><li><a href=#-告警抑制规则配置><strong>📌 告警抑制规则配置</strong></a><ul><li><a href=#示例-1屏蔽><strong>示例 1：屏蔽 <code>InstanceDown</code> 告警，若 <code>ClusterDown</code> 告警已触发</strong></a></li><li><a href=#示例-2某个服务><strong>示例 2：某个服务 <code>APIHighLatency</code> 时，屏蔽 <code>APIErrorRate</code></strong></a></li></ul></li><li><a href=#-配置><strong>📌 配置 <code>Alertmanager.yml</code> 规则</strong></a><ul><li><a href=#完整示例><strong>完整示例</strong></a></li></ul></li><li><a href=#-如何测试告警抑制><strong>📌 如何测试告警抑制</strong></a></li><li><a href=#-总结><strong>📌 总结</strong></a><ul><li><a href=#prometheus-告警抑制inhibition><strong>Prometheus 告警抑制（Inhibition）</strong></a></li></ul></li><li><a href=#-配置告警抑制的步骤><strong>📌 配置告警抑制的步骤</strong></a></li><li><a href=#-示例屏蔽-instancedown-告警><strong>📌 示例：屏蔽 InstanceDown 告警</strong></a></li><li><a href=#-示例屏蔽磁盘使用率高告警><strong>📌 示例：屏蔽磁盘使用率高告警</strong></a></li><li><a href=#-示例屏蔽><strong>📌 示例：屏蔽 <code>NodeDown</code>（节点宕机）告警</strong></a></li><li><a href=#heading><strong>📌 <code>inhibit_rules</code> 配置完整示例</strong></a></li><li><a href=#-如何测试告警抑制-1><strong>📌 如何测试告警抑制？</strong></a><ul><li><a href=#方式-1使用><strong>方式 1：使用 <code>amtool</code></strong></a></li><li><a href=#方式-2查看-alertmanager-ui><strong>方式 2：查看 Alertmanager UI</strong></a></li></ul></li><li><a href=#-结论-1><strong>📌 结论</strong></a></li><li><a href=#告警架构高可用怎么做>告警架构高可用怎么做☆</a></li><li><a href=#prometheus-告警系统高可用架构方案><strong>Prometheus 告警系统高可用架构方案</strong></a></li><li><a href=#-1-prometheus-高可用><strong>📌 1. Prometheus 高可用</strong></a><ul><li><a href=#-方案-1prometheus-双实例主备><strong>🔹 方案 1：Prometheus 双实例（主备）</strong></a></li><li><a href=#-方案-2prometheus--thanos-victoriametrics><strong>🔹 方案 2：Prometheus + Thanos/ VictoriaMetrics</strong></a></li></ul></li><li><a href=#-2-alertmanager-高可用><strong>📌 2. Alertmanager 高可用</strong></a><ul><li><a href=#-方案alertmanager-集群><strong>🔹 方案：Alertmanager 集群</strong></a></li></ul></li><li><a href=#-3-通知渠道高可用><strong>📌 3. 通知渠道高可用</strong></a><ul><li><a href=#-方案-1多个通知通道><strong>🔹 方案 1：多个通知通道</strong></a></li><li><a href=#-方案-2webhook-高可用><strong>🔹 方案 2：Webhook 高可用</strong></a></li></ul></li><li><a href=#-4-全局高可用架构><strong>📌 4. 全局高可用架构</strong></a></li><li><a href=#-结论-2><strong>📌 结论</strong></a></li><li><a href=#pod指标wss和rss区别>Pod指标WSS和RSS区别☆</a></li><li><a href=#-rssresident-set-size><strong>📌 RSS（Resident Set Size）</strong></a></li><li><a href=#-wssworking-set-size><strong>📌 WSS（Working Set Size）</strong></a></li><li><a href=#-wss-vs-rss-总结><strong>📌 WSS vs. RSS 总结</strong></a></li><li><a href=#-kubernetes-相关><strong>📌 Kubernetes 相关</strong></a></li><li><a href=#监控四个黄金指标>监控四个黄金指标</a></li><li><a href=#-1-latency延迟><strong>📌 1. Latency（延迟）</strong></a></li><li><a href=#-2-traffic流量><strong>📌 2. Traffic（流量）</strong></a></li><li><a href=#-3-errors错误率><strong>📌 3. Errors（错误率）</strong></a></li><li><a href=#-4-saturation饱和度><strong>📌 4. Saturation（饱和度）</strong></a></li><li><a href=#-总结-1><strong>📌 总结</strong></a></li><li><a href=#在大规模环境下如何优化prometheus性能>在大规模环境下，如何优化Prometheus性能</a><ul><li><a href=#1-分布式架构设计><strong>1. 分布式架构设计</strong></a></li><li><a href=#2-数据存储优化><strong>2. 数据存储优化</strong></a></li><li><a href=#3-查询优化><strong>3. 查询优化</strong></a></li><li><a href=#4-调整-scrape-配置><strong>4. 调整 Scrape 配置</strong></a></li><li><a href=#5-使用-external-storage><strong>5. 使用 External Storage</strong></a></li><li><a href=#6-优化-alerting-和-rules><strong>6. 优化 Alerting 和 Rules</strong></a></li><li><a href=#7-高可用和负载均衡><strong>7. 高可用和负载均衡</strong></a></li><li><a href=#总结-4><strong>总结：</strong></a></li></ul></li><li><a href=#如何实现告警的自动化响应>如何实现告警的自动化响应☆</a><ul><li><a href=#1-使用-prometheus--alertmanager-配置告警自动化响应><strong>1. 使用 Prometheus + Alertmanager 配置告警自动化响应</strong></a></li><li><a href=#2-集成自动化工具如-ansibleterraform进行响应><strong>2. 集成自动化工具（如 Ansible、Terraform）进行响应</strong></a></li><li><a href=#3-集成-chatops-进行自动化响应><strong>3. 集成 ChatOps 进行自动化响应</strong></a></li><li><a href=#4-使用-kubernetes-operator-进行自动化修复><strong>4. 使用 Kubernetes Operator 进行自动化修复</strong></a></li><li><a href=#5-使用-pagerdutyopsgenie-等工具的自动化响应><strong>5. 使用 PagerDuty、OpsGenie 等工具的自动化响应</strong></a></li><li><a href=#总结-5><strong>总结：</strong></a></li></ul></li><li><a href=#prometheus数据压缩和持久化实现原理>Prometheus数据压缩和持久化实现原理</a><ul><li><a href=#1-prometheus-数据存储架构><strong>1. Prometheus 数据存储架构</strong></a></li><li><a href=#2-数据存储与持久化原理><strong>2. 数据存储与持久化原理</strong></a></li><li><a href=#3-数据压缩与持久化的实现原理总结><strong>3. 数据压缩与持久化的实现原理总结</strong></a></li><li><a href=#4-持久化存储><strong>4. 持久化存储</strong></a></li></ul></li><li><a href=#kubectl-top输出与linux-free命令不一致原因>kubectl top输出与Linux free命令不一致原因☆</a><ul><li><a href=#1-数据来源的差异><strong>1. 数据来源的差异</strong></a></li><li><a href=#2-资源的计算方式><strong>2. 资源的计算方式</strong></a></li><li><a href=#3-资源隔离和容器化><strong>3. 资源隔离和容器化</strong></a></li><li><a href=#4-汇总与显示的不同><strong>4. 汇总与显示的不同</strong></a></li><li><a href=#总结-6><strong>总结</strong></a></li></ul></li><li><a href=#用到了哪些exporter功能是什么在-prometheus-监控中exporter-是一个重要的组件它用于从不同的应用或系统中收集指标并将这些指标以-prometheus-能够理解的格式暴露出来以下是一些常用的-prometheus-exporter-及其功能>用到了哪些exporter，功能是什么在 Prometheus 监控中，<strong>Exporter</strong> 是一个重要的组件，它用于从不同的应用或系统中收集指标，并将这些指标以 Prometheus 能够理解的格式暴露出来。以下是一些常用的 Prometheus Exporter 及其功能：</a><ul><li><a href=#1-node-exporter>1. <strong>Node Exporter</strong></a></li><li><a href=#2-kube-state-metrics>2. <strong>kube-state-metrics</strong></a></li><li><a href=#3-cadvisor>3. <strong>cAdvisor</strong></a></li><li><a href=#4-blackbox-exporter>4. <strong>Blackbox Exporter</strong></a></li><li><a href=#5-mysql-exporter>5. <strong>MySQL Exporter</strong></a></li><li><a href=#6-postgresql-exporter>6. <strong>PostgreSQL Exporter</strong></a></li><li><a href=#7-jmx-exporter>7. <strong>JMX Exporter</strong></a></li><li><a href=#8-redis-exporter>8. <strong>Redis Exporter</strong></a></li><li><a href=#9-mongodb-exporter>9. <strong>MongoDB Exporter</strong></a></li><li><a href=#10-elasticsearch-exporter>10. <strong>Elasticsearch Exporter</strong></a></li><li><a href=#11-nginx-exporter>11. <strong>Nginx Exporter</strong></a></li><li><a href=#12-kafka-exporter>12. <strong>Kafka Exporter</strong></a></li><li><a href=#总结-7><strong>总结</strong>：</a></li></ul></li><li><a href=#是否自己开发过exporter>是否自己开发过exporter☆</a><ul><li><a href=#自定义-exporter-开发的一般步骤>自定义 Exporter 开发的一般步骤：</a></li><li><a href=#示例用-go-开发一个简单的自定义-exporter>示例：用 Go 开发一个简单的自定义 Exporter</a></li><li><a href=#关键点>关键点：</a></li><li><a href=#开发过程中可能遇到的挑战>开发过程中可能遇到的挑战：</a></li></ul></li><li><a href=#target-down的情况如何进行故障排除>target down的情况如何进行故障排除？</a><ul><li><a href=#1-检查-prometheus-日志>1. <strong>检查 Prometheus 日志</strong></a></li><li><a href=#2-检查网络连接>2. <strong>检查网络连接</strong></a></li><li><a href=#3-检查目标服务状态>3. <strong>检查目标服务状态</strong></a></li><li><a href=#4-检查目标端点的配置>4. <strong>检查目标端点的配置</strong></a></li><li><a href=#5-目标服务的负载问题>5. <strong>目标服务的负载问题</strong></a></li><li><a href=#6-身份验证问题>6. <strong>身份验证问题</strong></a></li><li><a href=#7-检查-prometheus-配置文件>7. <strong>检查 Prometheus 配置文件</strong></a></li><li><a href=#8-查看-prometheus-目标状态>8. <strong>查看 Prometheus 目标状态</strong></a></li><li><a href=#9-重启-prometheus>9. <strong>重启 Prometheus</strong></a></li><li><a href=#10-目标端服务日志>10. <strong>目标端服务日志</strong></a></li><li><a href=#故障排除示例>故障排除示例：</a></li><li><a href=#总结-8>总结</a></li></ul></li><li><a href=#exporter-停止工作如何监控>Exporter 停止工作，如何监控？</a><ul><li><a href=#1-prometheus-自身的监控>1. <strong>Prometheus 自身的监控</strong></a></li><li><a href=#2-exporter-的健康检查>2. <strong>Exporter 的健康检查</strong></a></li><li><a href=#3-exporter-进程监控>3. <strong>Exporter 进程监控</strong></a></li><li><a href=#4-外部服务监控>4. <strong>外部服务监控</strong></a></li><li><a href=#5-日志监控>5. <strong>日志监控</strong></a></li><li><a href=#6-自动化修复措施>6. <strong>自动化修复措施</strong></a></li><li><a href=#7-外部监控工具>7. <strong>外部监控工具</strong></a></li><li><a href=#8-分析指标丢失>8. <strong>分析指标丢失</strong></a></li><li><a href=#总结-9>总结</a></li></ul></li><li><a href=#prometheus的拉取模式与zabbix推送模式有何区别各有什么优缺点>Prometheus的拉取模式与zabbix推送模式有何区别？各有什么优缺点？</a><ul><li><a href=#1-prometheus-拉取模式pull-model>1. <strong>Prometheus 拉取模式（Pull Model）</strong></a></li><li><a href=#2-zabbix-推送模式push-model>2. <strong>Zabbix 推送模式（Push Model）</strong></a></li><li><a href=#3-对比总结>3. <strong>对比总结</strong></a></li><li><a href=#4-适用场景-3>4. <strong>适用场景</strong></a></li><li><a href=#总结-10>总结</a></li></ul></li><li><a href=#prometheus-operator怎么添加targets和告警规则>Prometheus operator怎么添加targets和告警规则</a><ul><li><a href=#1-添加-targets-服务发现>1. 添加 Targets (服务发现)</a></li><li><a href=#2-添加告警规则>2. 添加告警规则</a></li><li><a href=#3-告警通知>3. 告警通知</a></li><li><a href=#总结-11>总结</a></li></ul></li><li><a href=#k8s集群外exporter怎么使用prometheus监控>k8s集群外exporter怎么使用Prometheus监控</a><ul><li><a href=#1-确保外部-exporter-可访问>1. 确保外部 Exporter 可访问</a></li><li><a href=#2-配置-prometheus-来抓取外部-exporter-数据>2. 配置 Prometheus 来抓取外部 Exporter 数据</a></li><li><a href=#3-验证-prometheus-是否可以正确抓取外部-exporter-数据>3. 验证 Prometheus 是否可以正确抓取外部 Exporter 数据</a></li><li><a href=#4-配置告警可选>4. 配置告警（可选）</a></li><li><a href=#5-配置告警通知可选>5. 配置告警通知（可选）</a></li><li><a href=#总结-12>总结：</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=prometheus>Prometheus
<a class=anchor href=#prometheus>#</a></h2><h2 id=prometheus的工作流程>Prometheus的工作流程
<a class=anchor href=#prometheus%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b>#</a></h2><p>Prometheus 的工作流程可以概括为以下几个主要步骤：</p><ol><li><strong>数据抓取（Scraping）</strong>：<ul><li>Prometheus 会定期从配置好的目标（如应用程序、服务、节点等）抓取数据。这些目标通常通过 HTTP 接口暴露 Prometheus 格式的监控数据（通常是 <code>/metrics</code> 路径）。</li><li>这些数据包括各类指标，如 CPU 使用率、内存使用情况、请求数量等。</li></ul></li><li><strong>存储（Storage）</strong>：<ul><li>抓取到的数据会被存储在 Prometheus 的本地时间序列数据库（TSDB）中。每个时间序列由一个指标名称和一组标签（如 <code>instance</code>, <code>job</code>, <code>region</code> 等）组成。</li></ul></li><li><strong>查询（Querying）</strong>：<ul><li>Prometheus 提供了强大的查询语言——PromQL（Prometheus Query Language），可以通过 PromQL 查询已存储的数据。</li><li>Prometheus 可以通过其 Web 界面、API 或 Grafana 进行查询，显示时间序列数据的图表，或者用于告警规则的计算。</li></ul></li><li><strong>告警（Alerting）</strong>：<ul><li>Prometheus 可以基于定义的告警规则（通过 PromQL 查询语句）进行告警。例如，当 CPU 使用率超过一定阈值时，触发告警。</li><li>告警规则可以定义在 Prometheus 配置文件中，告警信息可以通过 Alertmanager 发送到各类通知系统（如邮件、Slack、钉钉等）。</li></ul></li><li><strong>数据可视化（Visualization）</strong>：<ul><li>Prometheus 本身也提供了简单的图表功能，但通常会与第三方工具（如 Grafana）结合使用，以便提供更丰富的可视化效果。</li><li>Grafana 可以从 Prometheus 查询数据，生成漂亮的仪表板，帮助团队实时监控系统健康状况。</li></ul></li><li><strong>服务发现与目标自动化（Service Discovery）</strong>：<ul><li>Prometheus 支持多种服务发现机制，可以自动发现需要抓取数据的目标。常见的有 Kubernetes、Consul 等服务发现工具，也可以使用静态配置。</li></ul></li></ol><p>整体而言，Prometheus 的核心是周期性地抓取目标的监控数据，存储成时间序列，并通过查询、告警和可视化等功能帮助用户监控和维护系统的健康。</p><p>如果你有某个具体环节的疑问，欢迎随时问！</p><h2 id=metric的几种类型分别是什么>Metric的几种类型？分别是什么？☆
<a class=anchor href=#metric%e7%9a%84%e5%87%a0%e7%a7%8d%e7%b1%bb%e5%9e%8b%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88>#</a></h2><p>Prometheus 中有四种主要的 <strong>Metric（度量）类型</strong>，分别是：</p><ol><li><p><strong>Counter（计数器）</strong>：</p><ul><li><strong>定义</strong>：计数器是一种只增不减的度量类型。它表示一个累积值，比如请求的总数、处理的任务数等。</li><li><strong>特点</strong>：它的值始终是递增的，并且可以在某些情况下被重置（如重启应用）。</li><li><strong>例子</strong>：HTTP 请求的总数、错误发生次数等。</li><li><strong>常见用途</strong>：表示某种事件或状态发生的总次数。</li></ul><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_requests_total{method=&#34;GET&#34;, status=&#34;200&#34;}
</code></pre></li><li><p><strong>Gauge（仪表）</strong>：</p><ul><li><strong>定义</strong>：仪表度量类型表示一个可以任意增减的值。它适用于那些可能会增加或减少的度量，比如当前内存使用量、CPU 使用率等。</li><li><strong>特点</strong>：它的值可以上升或下降，适合表示某些瞬时的、可变的数值。</li><li><strong>例子</strong>：当前温度、内存使用、磁盘空间等。</li><li><strong>常见用途</strong>：表示某些动态的、瞬时的数值。</li></ul><pre tabindex=0><code class=language-prometheus data-lang=prometheus>memory_usage_bytes
</code></pre></li><li><p><strong>Histogram（直方图）</strong>：</p><ul><li><strong>定义</strong>：直方图用于记录一系列的分布数据，按指定的桶（bucket）来聚合样本数据。它能够提供数据的分布情况（如请求延迟的分布），并可以通过统计数据计算出一些聚合指标（如平均值、百分位数等）。</li><li><strong>特点</strong>：它会提供桶内的计数值，可以计算出值的分布（如请求延迟的 95th 百分位）。</li><li><strong>例子</strong>：HTTP 请求的响应时间，数据库查询时间等。</li><li><strong>常见用途</strong>：分布数据的度量，例如请求延迟、处理时间等。</li></ul><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_request_duration_seconds_bucket{le=&#34;0.1&#34;}
</code></pre></li><li><p><strong>Summary（摘要）</strong>：</p><ul><li><strong>定义</strong>：摘要与直方图类似，都是用来统计分布数据的。不同之处在于，摘要记录的是在某一时间段内发生的样本的摘要统计信息，如累计总数、累计和、最大值等，而直方图则通过分桶统计数据分布。</li><li><strong>特点</strong>：摘要度量提供了直接的统计值，如百分位数（p50, p90, p99等），不需要根据桶计算。</li><li><strong>例子</strong>：请求的延迟百分位数，API 响应时间等。</li><li><strong>常见用途</strong>：需要精确计算百分位数和其他统计量时，如请求响应时间的分位数。</li></ul><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_request_duration_seconds{quantile=&#34;0.95&#34;}
</code></pre></li></ol><h3 id=总结>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong>Counter</strong>：只增不减，表示累计总数。</li><li><strong>Gauge</strong>：可以增减，表示当前状态的瞬时值。</li><li><strong>Histogram</strong>：用于表示数据的分布，按桶聚合数据。</li><li><strong>Summary</strong>：类似于直方图，但直接提供百分位数等统计信息。</li></ul><p>这四种类型是 Prometheus 度量的核心构成，它们可以帮助你监控系统的不同方面，并从多个角度分析数据。如果有某个度量类型的具体应用场景或者细节需要进一步了解，随时告诉我！</p><h2 id=prometheus有哪几种服务发现>Prometheus有哪几种服务发现☆
<a class=anchor href=#prometheus%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h2><p>Prometheus 提供了多种服务发现（Service Discovery）机制，使其能够自动发现并抓取目标（如应用、服务器等）的监控数据。服务发现可以大大简化配置管理，尤其是在动态环境中（如 Kubernetes 或云平台）非常有用。Prometheus 支持以下几种服务发现方式：</p><h3 id=1-kubernetes-服务发现>1. <strong>Kubernetes 服务发现</strong>：
<a class=anchor href=#1-kubernetes-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：在 Kubernetes 环境中，Prometheus 可以通过 Kubernetes API 自动发现集群中的服务、Pod 和节点。它能够发现 K8s 中所有符合条件的目标（如通过标签选择器、命名空间等进行筛选）。</li><li><strong>配置</strong>：Prometheus 配置文件中使用 <code>kubernetes_sd_configs</code> 配置项来实现。</li><li><strong>应用场景</strong>：适用于容器化的环境，尤其是 Kubernetes 集群中的服务发现。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;kubernetes-pods&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kubernetes_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>api_server</span>: <span style=color:#e6db74>&#39;https://k8s-api-server&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>role</span>: <span style=color:#ae81ff>pod</span>
</span></span></code></pre></div><h3 id=2-consul-服务发现>2. <strong>Consul 服务发现</strong>：
<a class=anchor href=#2-consul-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：Prometheus 支持通过 Consul 进行服务发现。Consul 是一个服务网格工具，它可以管理服务注册和发现。Prometheus 会从 Consul 获取服务实例列表并进行抓取。</li><li><strong>配置</strong>：通过 <code>consul_sd_configs</code> 配置项。</li><li><strong>应用场景</strong>：适用于使用 Consul 作为服务注册和发现的环境。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;consul&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>consul_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>server</span>: <span style=color:#e6db74>&#39;localhost:8500&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>services</span>: [<span style=color:#e6db74>&#39;my-service&#39;</span>]
</span></span></code></pre></div><h3 id=3-ec2-服务发现>3. <strong>EC2 服务发现</strong>：
<a class=anchor href=#3-ec2-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：在 AWS 环境中，Prometheus 可以通过 AWS EC2 服务发现，自动抓取 EC2 实例的指标。它通过 AWS API 获取当前运行的 EC2 实例信息，基于标签、实例状态等进行筛选。</li><li><strong>配置</strong>：通过 <code>ec2_sd_configs</code> 配置项来实现。</li><li><strong>应用场景</strong>：适用于在 AWS EC2 上运行的服务或实例。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;ec2&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ec2_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>region</span>: <span style=color:#e6db74>&#39;us-west-2&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>access_key</span>: <span style=color:#e6db74>&#39;AWS_ACCESS_KEY&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>secret_key</span>: <span style=color:#e6db74>&#39;AWS_SECRET_KEY&#39;</span>
</span></span></code></pre></div><h3 id=4-gcegoogle-compute-engine服务发现>4. <strong>GCE（Google Compute Engine）服务发现</strong>：
<a class=anchor href=#4-gcegoogle-compute-engine%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：Prometheus 可以在 Google Cloud 环境中使用 GCE 服务发现来自动发现 Google Compute Engine 实例。</li><li><strong>配置</strong>：通过 <code>gce_sd_configs</code> 配置项来实现。</li><li><strong>应用场景</strong>：适用于 Google Cloud 平台的虚拟机实例。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;gce&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>gce_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>project</span>: <span style=color:#e6db74>&#39;my-gcp-project&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>zone</span>: <span style=color:#e6db74>&#39;us-central1-a&#39;</span>
</span></span></code></pre></div><h3 id=5-azure-服务发现>5. <strong>Azure 服务发现</strong>：
<a class=anchor href=#5-azure-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：Prometheus 支持在 Azure 环境中自动发现虚拟机、虚拟机规模集等服务实例。通过 Azure API 获取实例的 IP 地址、标签等信息。</li><li><strong>配置</strong>：通过 <code>azure_sd_configs</code> 配置项来实现。</li><li><strong>应用场景</strong>：适用于在 Azure 云平台上部署的服务。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;azure&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>azure_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>subscription_id</span>: <span style=color:#e6db74>&#39;your-subscription-id&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>tenant_id</span>: <span style=color:#e6db74>&#39;your-tenant-id&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>client_id</span>: <span style=color:#e6db74>&#39;your-client-id&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>client_secret</span>: <span style=color:#e6db74>&#39;your-client-secret&#39;</span>
</span></span></code></pre></div><h3 id=6-dns-服务发现>6. <strong>DNS 服务发现</strong>：
<a class=anchor href=#6-dns-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：Prometheus 可以使用 DNS 查询来发现目标。通过配置 DNS 名称解析获取需要监控的目标。</li><li><strong>配置</strong>：通过 <code>dns_sd_configs</code> 配置项。</li><li><strong>应用场景</strong>：适用于使用 DNS 进行动态服务发现的环境。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;dns&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dns_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>names</span>:
</span></span><span style=display:flex><span>          - <span style=color:#e6db74>&#39;myservice.local&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>type</span>: <span style=color:#e6db74>&#39;A&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span></code></pre></div><h3 id=7-file-服务发现>7. <strong>File 服务发现</strong>：
<a class=anchor href=#7-file-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：Prometheus 可以通过读取外部文件（如 JSON 或 YAML 格式）来进行静态服务发现。文件中的目标可以动态更新，Prometheus 会定期重新加载这些文件。</li><li><strong>配置</strong>：通过 <code>file_sd_configs</code> 配置项。</li><li><strong>应用场景</strong>：适用于较为静态的环境，或者当目标实例列表存储在外部文件中的情况。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;file&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>file_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>files</span>:
</span></span><span style=display:flex><span>          - <span style=color:#e6db74>&#39;/path/to/targets.json&#39;</span>
</span></span></code></pre></div><h3 id=8-static-服务发现>8. <strong>Static 服务发现</strong>：
<a class=anchor href=#8-static-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：Prometheus 也支持通过静态配置来发现目标。这种方式适用于目标列表不频繁变化的场景。</li><li><strong>配置</strong>：通过 <code>static_configs</code> 配置项，可以手动列出目标。</li><li><strong>应用场景</strong>：适用于目标数量较少且较为固定的环境。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;static&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>static_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>targets</span>: [<span style=color:#e6db74>&#39;localhost:9090&#39;</span>, <span style=color:#e6db74>&#39;localhost:8080&#39;</span>]
</span></span></code></pre></div><h3 id=9-openstack-服务发现>9. <strong>OpenStack 服务发现</strong>：
<a class=anchor href=#9-openstack-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><ul><li><strong>描述</strong>：Prometheus 支持 OpenStack 环境中的服务发现。通过与 OpenStack API 交互，自动发现相关的服务实例和节点。</li><li><strong>配置</strong>：通过 <code>openstack_sd_configs</code> 配置项来实现。</li><li><strong>应用场景</strong>：适用于 OpenStack 环境的服务发现。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;openstack&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>openstack_sd_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>auth_url</span>: <span style=color:#e6db74>&#39;https://openstack.example.com&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>username</span>: <span style=color:#e6db74>&#39;username&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>password</span>: <span style=color:#e6db74>&#39;password&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>project_name</span>: <span style=color:#e6db74>&#39;project&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>region</span>: <span style=color:#e6db74>&#39;region&#39;</span>
</span></span></code></pre></div><h3 id=总结-1>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-1>#</a></h3><p>Prometheus 支持多种服务发现机制，涵盖了云平台、容器平台、传统服务器和静态配置等多种场景。你可以根据自己的环境选择合适的服务发现方式，帮助 Prometheus 自动发现和抓取目标。</p><p>如果你对某种服务发现方式有更多问题或需要具体示例，欢迎继续提问！</p><h2 id=prometheus常用函数>Prometheus常用函数
<a class=anchor href=#prometheus%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0>#</a></h2><p>Prometheus 提供了丰富的函数和操作符，帮助用户在 PromQL 查询语言中处理和分析时间序列数据。以下是一些常用的 Prometheus 函数：</p><h3 id=1-聚合函数aggregation-functions>1. <strong>聚合函数（Aggregation Functions）</strong>
<a class=anchor href=#1-%e8%81%9a%e5%90%88%e5%87%bd%e6%95%b0aggregation-functions>#</a></h3><p>聚合函数用于按某些维度聚合数据，通常用于将多个时间序列合并为一个更具概括性的度量。</p><ul><li><p><code>avg()</code></p><p>：计算平均值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>avg(http_requests_total)
</code></pre></li><li><p><code>sum()</code></p><p>：计算总和</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>sum(http_requests_total)
</code></pre></li><li><p><code>min()</code></p><p>：计算最小值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>min(http_requests_total)
</code></pre></li><li><p><code>max()</code></p><p>：计算最大值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>max(http_requests_total)
</code></pre></li><li><p><code>count()</code></p><p>：计算数量</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>count(http_requests_total)
</code></pre></li><li><p><code>count_values()</code></p><p>：计算不同标签值的数量</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>count_values(&#34;method&#34;, http_requests_total)
</code></pre></li><li><p><code>topk(k, expr)</code></p><p>：返回值排名前</p><pre tabindex=0><code>k
</code></pre><p>的时间序列</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>topk(3, http_requests_total)
</code></pre></li><li><p><code>bottomk(k, expr)</code></p><p>：返回值排名后</p><pre tabindex=0><code>k
</code></pre><p>的时间序列</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>bottomk(3, http_requests_total)
</code></pre></li></ul><h3 id=2-统计函数statistical-functions>2. <strong>统计函数（Statistical Functions）</strong>
<a class=anchor href=#2-%e7%bb%9f%e8%ae%a1%e5%87%bd%e6%95%b0statistical-functions>#</a></h3><ul><li><p><code>rate()</code></p><p>：计算时间序列在某个时间段内的速率（适用于计数器类型）</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>rate(http_requests_total[5m])
</code></pre></li><li><p><code>irate()</code></p><p>：计算瞬时速率，适用于计数器类型</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>irate(http_requests_total[1m])
</code></pre></li><li><p><code>increase()</code></p><p>：计算计数器类型的增量值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>increase(http_requests_total[1h])
</code></pre></li><li><p><code>delta()</code></p><p>：计算某时间段内的值的变化量</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>delta(http_requests_total[5m])
</code></pre></li><li><p><code>avg_over_time()</code></p><p>：计算某个时间区间内的平均值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>avg_over_time(http_requests_total[1h])
</code></pre></li><li><p><code>min_over_time()</code></p><p>：计算某个时间区间内的最小值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>min_over_time(http_requests_total[1h])
</code></pre></li><li><p><code>max_over_time()</code></p><p>：计算某个时间区间内的最大值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>max_over_time(http_requests_total[1h])
</code></pre></li></ul><h3 id=3-时间函数time-functions>3. <strong>时间函数（Time Functions）</strong>
<a class=anchor href=#3-%e6%97%b6%e9%97%b4%e5%87%bd%e6%95%b0time-functions>#</a></h3><p>时间函数用于操作时间戳和时间序列。</p><ul><li><p><code>time()</code></p><p>：返回当前的时间戳（以秒为单位）</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>time()
</code></pre></li><li><p><code>timestamp()</code></p><p>：返回时间序列的时间戳</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>timestamp(http_requests_total)
</code></pre></li></ul><h3 id=4-数值处理函数mathematical-functions>4. <strong>数值处理函数（Mathematical Functions）</strong>
<a class=anchor href=#4-%e6%95%b0%e5%80%bc%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0mathematical-functions>#</a></h3><p>这些函数用于进行常见的数学运算。</p><ul><li><p><code>abs()</code></p><p>：返回绝对值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>abs(http_requests_total)
</code></pre></li><li><p><code>ceil()</code></p><p>：返回大于或等于该值的最小整数</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>ceil(http_requests_total)
</code></pre></li><li><p><code>floor()</code></p><p>：返回小于或等于该值的最大整数</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>floor(http_requests_total)
</code></pre></li><li><p><code>round()</code></p><p>：返回四舍五入的值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>round(http_requests_total)
</code></pre></li><li><p><code>sqrt()</code></p><p>：计算平方根</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>sqrt(http_requests_total)
</code></pre></li></ul><h3 id=5-字符串处理函数string-functions>5. <strong>字符串处理函数（String Functions）</strong>
<a class=anchor href=#5-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0string-functions>#</a></h3><p>字符串函数主要用于对标签值或字符串型数据进行处理。</p><ul><li><p><code>label_replace()</code></p><p>：用于替换标签中的部分内容</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>label_replace(http_requests_total, &#34;method&#34;, &#34;$1&#34;, &#34;status&#34;, &#34;(.*)&#34;)
</code></pre></li><li><p><code>label_join()</code></p><p>：将多个标签值连接为一个新标签</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>label_join(http_requests_total, &#34;method&#34;, &#34;-&#34;, &#34;status&#34;, &#34;code&#34;)
</code></pre></li></ul><h3 id=6-查询时间函数time-interval-functions>6. <strong>查询时间函数（Time Interval Functions）</strong>
<a class=anchor href=#6-%e6%9f%a5%e8%af%a2%e6%97%b6%e9%97%b4%e5%87%bd%e6%95%b0time-interval-functions>#</a></h3><p>这些函数用于处理时间区间。</p><ul><li><p><code>avg_over_time()</code></p><p>：计算某个时间范围内的平均值</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>avg_over_time(http_requests_total[1h])
</code></pre></li><li><p><code>rate()</code></p><p>：计算在某段时间内的速率</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>rate(http_requests_total[5m])
</code></pre></li></ul><h3 id=7-率函数rate-functions>7. <strong>率函数（Rate Functions）</strong>
<a class=anchor href=#7-%e7%8e%87%e5%87%bd%e6%95%b0rate-functions>#</a></h3><p>用于计算单位时间内的数据变化量。</p><ul><li><p><code>rate()</code></p><p>：适用于计数器类型，计算单位时间内的变化速率</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>rate(http_requests_total[5m])
</code></pre></li><li><p><code>irate()</code></p><p>：即时速率，适用于计数器类型，计算最近两个数据点的速率</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>irate(http_requests_total[1m])
</code></pre></li></ul><h3 id=8-逻辑函数logical-functions>8. <strong>逻辑函数（Logical Functions）</strong>
<a class=anchor href=#8-%e9%80%bb%e8%be%91%e5%87%bd%e6%95%b0logical-functions>#</a></h3><p>这些函数帮助进行逻辑判断和操作。</p><ul><li><p><code>and</code></p><p>：用于两个表达式的与操作</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_requests_total{status=&#34;200&#34;} and http_requests_total{status=&#34;500&#34;}
</code></pre></li><li><p><code>or</code></p><p>：用于两个表达式的或操作</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_requests_total{status=&#34;200&#34;} or http_requests_total{status=&#34;404&#34;}
</code></pre></li><li><p><code>unless</code></p><p>：排除某些条件</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_requests_total unless http_requests_total{status=&#34;500&#34;}
</code></pre></li></ul><h3 id=9-过滤与条件filters--conditionals>9. <strong>过滤与条件（Filters & Conditionals）</strong>
<a class=anchor href=#9-%e8%bf%87%e6%bb%a4%e4%b8%8e%e6%9d%a1%e4%bb%b6filters--conditionals>#</a></h3><ul><li><p><code>on()</code></p><p>：用于条件匹配，可以指定某些标签参与匹配</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_requests_total{status=&#34;200&#34;} on(method) http_requests_total{status=&#34;500&#34;}
</code></pre></li><li><p><code>ignoring()</code></p><p>：忽略特定的标签进行条件匹配</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>http_requests_total{status=&#34;200&#34;} ignoring(method) http_requests_total{status=&#34;500&#34;}
</code></pre></li></ul><h3 id=10-百分比计算percentile-calculation>10. <strong>百分比计算（Percentile Calculation）</strong>
<a class=anchor href=#10-%e7%99%be%e5%88%86%e6%af%94%e8%ae%a1%e7%ae%97percentile-calculation>#</a></h3><ul><li><p><code>histogram_quantile()</code></p><p>：用于计算直方图的指定分位数（如 95th 百分位）</p><pre tabindex=0><code class=language-prometheus data-lang=prometheus>histogram_quantile(0.95, http_request_duration_seconds_bucket)
</code></pre></li></ul><h3 id=总结-2>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-2>#</a></h3><p>Prometheus 提供了多种函数来帮助你处理和分析监控数据。你可以通过这些函数来进行聚合、时间序列计算、统计分析以及进行复杂的查询和可视化。</p><p>如果你对某个函数或用法有疑问，随时可以问我！</p><h2 id=thanos架构>thanos架构☆
<a class=anchor href=#thanos%e6%9e%b6%e6%9e%84>#</a></h2><p><strong>Thanos</strong> 是一个用于扩展 <strong>Prometheus</strong> 的高可用性、长期存储和全球查询的解决方案。它通过无缝地集成 Prometheus 和其他组件，提供了分布式、可扩展的监控架构，特别适用于大规模部署和多集群环境。</p><h3 id=thanos-架构概述>Thanos 架构概述
<a class=anchor href=#thanos-%e6%9e%b6%e6%9e%84%e6%a6%82%e8%bf%b0>#</a></h3><p>Thanos 的架构设计基于以下几个核心组件：</p><ol><li><p><strong>Prometheus</strong>：</p><ul><li><strong>作用</strong>：Prometheus 仍然是数据的抓取和存储核心，负责从各类目标（如服务、应用、节点等）抓取时间序列数据。</li><li><strong>特点</strong>：Thanos 并不替代 Prometheus，而是增强其功能，特别是在高可用、长期存储和多集群管理方面。</li></ul></li><li><p><strong>Thanos Sidecar</strong>：</p><ul><li><p>作用</p><p>：Thanos Sidecar 是运行在 Prometheus 实例旁边的一个代理，它负责：</p><ul><li>将 Prometheus 中的时间序列数据上传到远程存储（如 S3、GCS、HDFS 等）。</li><li>将 Prometheus 数据暴露给 Thanos Query 和其他组件。</li></ul></li><li><p><strong>特点</strong>：Sidecar 是 Thanos 架构中的关键组件之一，它帮助 Prometheus 实现持久化存储，并且为 Thanos Query 提供数据源。</p></li></ul><p><strong>Sidecar 配置</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- --<span style=color:#ae81ff>tsdb.path=/prometheus</span>
</span></span><span style=display:flex><span>- --<span style=color:#ae81ff>objstore.config=&#34;type: S3\nconfig:\n  bucket: my-bucket&#34;</span>
</span></span></code></pre></div></li><li><p><strong>Thanos Store</strong>：</p><ul><li><strong>作用</strong>：Thanos Store 是一个存储组件，负责从远程对象存储（如 S3、GCS 等）读取历史数据。它充当了 Prometheus 数据的长期存储。</li><li><strong>特点</strong>：Store 主要用于查询过去的历史数据，并提供了统一的接口来访问不同时间窗口内的数据。</li></ul></li><li><p><strong>Thanos Query</strong>：</p><ul><li><strong>作用</strong>：Thanos Query 是一个用于聚合查询的组件，它允许跨多个 Prometheus 和 Thanos 存储实例执行全局查询。它从多个 Prometheus 实例和 Thanos Store 获取数据，并提供统一的查询结果。</li><li><strong>特点</strong>：Thanos Query 实现了高效的分布式查询，支持从不同 Prometheus 实例和 Store 中读取数据，可以跨多个集群或多数据源执行联合查询。</li></ul></li><li><p><strong>Thanos Compact</strong>：</p><ul><li><strong>作用</strong>：Thanos Compact 负责合并、压缩和优化存储在对象存储中的时间序列数据。它将多个时间块（Block）合并为更大的存储块，以减少存储碎片并优化查询性能。</li><li><strong>特点</strong>：它定期运行，以确保数据在存储层面的优化和压缩。</li></ul></li><li><p><strong>Thanos Ruler</strong>：</p><ul><li><strong>作用</strong>：Thanos Ruler 是基于 Prometheus 的规则引擎，它允许你在 Thanos 集群中运行 Prometheus 规则、告警规则和录制规则。</li><li><strong>特点</strong>：它提供了一种在全局范围内执行告警和规则评估的机制。Thanos Ruler 支持在多个 Prometheus 实例之间共享规则和告警信息。</li></ul></li></ol><h3 id=thanos-架构图>Thanos 架构图
<a class=anchor href=#thanos-%e6%9e%b6%e6%9e%84%e5%9b%be>#</a></h3><pre tabindex=0><code>+----------------------+       +----------------------+       +----------------------+
|    Prometheus        |&lt;-----&gt;|    Thanos Sidecar    |&lt;-----&gt;|  Remote Object Store |
+----------------------+       +----------------------+       +----------------------+
        |                            |                          |
        |                            v                          v
        |                      +--------------------+       +------------------+
        |                      |   Thanos Query     |&lt;-----&gt;|    Thanos Store  |
        |                      +--------------------+       +------------------+
        |                               |
        |                               v
        |                        +------------------+
        |                        |   Thanos Ruler   |
        |                        +------------------+
        |
        v
   +------------------+
   | Thanos Compact   |
   +------------------+
</code></pre><h3 id=thanos-核心功能>Thanos 核心功能
<a class=anchor href=#thanos-%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd>#</a></h3><ol><li><strong>高可用性和水平扩展</strong>：<ul><li>Thanos 提供跨多个 Prometheus 实例和多个集群的查询能力，帮助实现 Prometheus 集群的高可用性。</li><li>多个 Prometheus 实例可以分别在不同的区域或集群中部署，Thanos Query 可以将其聚合成一个全局视图。</li></ul></li><li><strong>长期存储</strong>：<ul><li>通过将数据持久化到远程对象存储（如 S3、GCS、Azure Blob 等），Thanos 提供了可靠且成本效益高的长期存储解决方案。</li><li>对历史数据的访问可以通过 Thanos Store 组件来查询。</li></ul></li><li><strong>全球查询</strong>：<ul><li>Thanos Query 提供全局视图，支持跨多个集群或 Prometheus 实例执行统一查询。</li><li>即使数据分布在多个 Prometheus 实例上，Thanos Query 也能通过聚合各个数据源的结果，提供统一的查询接口。</li></ul></li><li><strong>压缩与存储优化</strong>：<ul><li>Thanos Compact 功能可以将存储中的多个数据块合并和压缩，降低存储成本，同时提升查询效率。</li></ul></li><li><strong>规则和告警</strong>：<ul><li>Thanos Ruler 允许在 Thanos 集群中执行 Prometheus 规则和告警，并支持跨 Prometheus 实例共享规则和告警配置。</li></ul></li><li><strong>数据流控制</strong>：<ul><li>使用 Thanos Sidecar，用户可以将 Prometheus 数据推送到远程存储，也可以实现多个 Prometheus 实例之间的数据复制和备份。</li></ul></li></ol><h3 id=thanos-的使用场景>Thanos 的使用场景
<a class=anchor href=#thanos-%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><ol><li><strong>跨地域和跨集群监控</strong>：<ul><li>Thanos 非常适合在多集群、多区域部署 Prometheus 实例的环境中使用，它能够聚合来自不同集群的数据，进行跨区域查询。</li></ul></li><li><strong>长期存储解决方案</strong>：<ul><li>Thanos 可以将 Prometheus 的数据持久化到对象存储（如 AWS S3、Google Cloud Storage 等），实现高效且成本低的长期存储解决方案。</li></ul></li><li><strong>高可用和高容错</strong>：<ul><li>通过在多个节点或集群中运行 Prometheus 和 Thanos，实现高可用性和容错能力，避免单点故障。</li></ul></li><li><strong>跨多个 Prometheus 实例的全局查询</strong>：<ul><li>对于需要跨多个 Prometheus 实例进行全局查询的场景，Thanos 提供了无缝的查询能力。</li></ul></li></ol><h3 id=总结-3>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-3>#</a></h3><p>Thanos 通过与 Prometheus 紧密集成，提供了对大规模、跨区域、多集群部署环境的支持。它解决了 Prometheus 在高可用、长期存储、分布式查询等方面的瓶颈，是一个强大的扩展解决方案，特别适用于需要全球查询和大规模监控环境的使用场景。</p><p>如果你有任何关于 Thanos 的具体问题，或者需要进一步了解配置和实践，随时问我！</p><h2 id=thanos与victoriametrics对比>thanos与VictoriaMetrics对比
<a class=anchor href=#thanos%e4%b8%8evictoriametrics%e5%af%b9%e6%af%94>#</a></h2><p>Thanos 和 VictoriaMetrics 都是 Prometheus 生态系统中的监控存储解决方案，但它们的设计目标、架构和适用场景有所不同。以下是两者的详细对比：</p><hr><h2 id=1-概述><strong>1. 概述</strong>
<a class=anchor href=#1-%e6%a6%82%e8%bf%b0>#</a></h2><table><thead><tr><th>特性</th><th><strong>Thanos</strong></th><th><strong>VictoriaMetrics</strong></th></tr></thead><tbody><tr><td><strong>主要用途</strong></td><td>分布式长时间存储、全局查询、数据去重</td><td>高性能、低资源消耗的时间序列数据库</td></tr><tr><td><strong>与 Prometheus 关系</strong></td><td>Prometheus 的扩展组件</td><td>兼容 Prometheus 的独立 TSDB</td></tr><tr><td><strong>架构</strong></td><td>组件化（多个独立组件）</td><td>单体应用（轻量级）</td></tr><tr><td><strong>存储方式</strong></td><td>对象存储（S3、GCS、OSS等）</td><td>本地磁盘/对象存储（可选）</td></tr></tbody></table><hr><h2 id=2-架构对比><strong>2. 架构对比</strong>
<a class=anchor href=#2-%e6%9e%b6%e6%9e%84%e5%af%b9%e6%af%94>#</a></h2><h3 id=thanos><strong>Thanos</strong>
<a class=anchor href=#thanos>#</a></h3><ul><li>作为 Prometheus 的扩展组件，增加高可用性、长时间存储和全局查询功能。</li><li>主要组件：<ul><li><strong>Thanos Sidecar</strong>：附加到 Prometheus，提供长期存储和查询能力。</li><li><strong>Thanos Store</strong>：从对象存储（S3/GCS等）读取历史数据。</li><li><strong>Thanos Query</strong>：支持跨多个 Prometheus 实例的全局查询。</li><li><strong>Thanos Compact</strong>：合并和去重数据，优化存储空间。</li><li><strong>Thanos Ruler</strong>：类似 Prometheus Rules，可在全局范围内执行告警规则。</li></ul></li></ul><h3 id=victoriametrics><strong>VictoriaMetrics</strong>
<a class=anchor href=#victoriametrics>#</a></h3><ul><li>作为一个独立的 TSDB，支持高效存储和查询。</li><li>主要组件：<ul><li><strong>VictoriaMetrics（单机版）</strong>：高效的单实例存储，可替代 Prometheus TSDB。</li><li><strong>VictoriaMetrics Cluster</strong>：支持大规模集群部署，提供可扩展性。</li><li><strong>vmalert</strong>：替代 Prometheus Alertmanager，实现告警规则执行。</li><li><strong>vmagent</strong>：收集和转发监控数据，相当于 Prometheus Remote Write。</li></ul></li></ul><hr><h2 id=3-关键特性对比><strong>3. 关键特性对比</strong>
<a class=anchor href=#3-%e5%85%b3%e9%94%ae%e7%89%b9%e6%80%a7%e5%af%b9%e6%af%94>#</a></h2><table><thead><tr><th>特性</th><th><strong>Thanos</strong></th><th><strong>VictoriaMetrics</strong></th></tr></thead><tbody><tr><td><strong>高可用性</strong></td><td>依赖多个 Prometheus 实例及对象存储</td><td>原生支持 HA，不需要多个 Prometheus</td></tr><tr><td><strong>数据去重</strong></td><td>依赖 <code>--query.replica-label</code> 进行去重</td><td>内置高效去重机制</td></tr><tr><td><strong>存储方式</strong></td><td>对象存储（S3/GCS/OSS等）</td><td>本地存储 + 可选远程存储</td></tr><tr><td><strong>查询性能</strong></td><td>依赖对象存储，查询速度受限于存储系统</td><td>读取本地磁盘，查询速度更快</td></tr><tr><td><strong>集群部署</strong></td><td>需要多个组件协同工作</td><td>单机高效，支持集群模式</td></tr><tr><td><strong>资源占用</strong></td><td>需要运行多个组件，资源开销较大</td><td>低资源占用，高压缩比</td></tr><tr><td><strong>写入方式</strong></td><td>通过 Prometheus Remote Write 间接写入</td><td>直接支持 Remote Write</td></tr><tr><td><strong>数据压缩</strong></td><td>依赖 Prometheus 的存储格式</td><td>原生高压缩率</td></tr><tr><td><strong>运维复杂度</strong></td><td>组件较多，配置复杂</td><td>部署简单，单进程运行</td></tr></tbody></table><hr><h2 id=4-适用场景><strong>4. 适用场景</strong>
<a class=anchor href=#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h2><table><thead><tr><th>需求</th><th><strong>推荐使用</strong></th></tr></thead><tbody><tr><td><strong>已有 Prometheus 部署，希望扩展长期存储和查询能力</strong></td><td>✅ Thanos</td></tr><tr><td><strong>希望一个高效、独立的 TSDB 取代 Prometheus 存储</strong></td><td>✅ VictoriaMetrics</td></tr><tr><td><strong>需要对象存储（S3/OSS）存储历史数据</strong></td><td>✅ Thanos</td></tr><tr><td><strong>希望低资源占用、高性能查询</strong></td><td>✅ VictoriaMetrics</td></tr><tr><td><strong>多 Prometheus 实例统一查询</strong></td><td>✅ Thanos</td></tr><tr><td><strong>单实例高吞吐、高压缩比的存储</strong></td><td>✅ VictoriaMetrics</td></tr></tbody></table><hr><h2 id=5-总结><strong>5. 总结</strong>
<a class=anchor href=#5-%e6%80%bb%e7%bb%93>#</a></h2><ul><li><strong>Thanos 适合扩展 Prometheus</strong>，增加高可用性、长时间存储和全局查询能力，适用于 <strong>多 Prometheus 实例的企业级监控</strong>。</li><li><strong>VictoriaMetrics 适合作为独立的 TSDB</strong>，提供高性能、低资源占用的时间序列存储，适用于 <strong>大规模数据存储和高效查询</strong>。</li></ul><p><strong>如果你的 Prometheus 已经部署并希望扩展存储能力，Thanos 是更好的选择。如果你希望一个更高效、更易管理的时序数据库，VictoriaMetrics 更合适。</strong></p><h2 id=thanos-sidecar和receive区别>thanos sidecar和receive区别☆
<a class=anchor href=#thanos-sidecar%e5%92%8creceive%e5%8c%ba%e5%88%ab>#</a></h2><h3 id=thanos-sidecar-vs-thanos-receive-对比><strong>Thanos Sidecar vs Thanos Receive 对比</strong>
<a class=anchor href=#thanos-sidecar-vs-thanos-receive-%e5%af%b9%e6%af%94>#</a></h3><p>Thanos Sidecar 和 Thanos Receive 都是 Thanos 生态中的组件，但它们的用途和工作方式不同，主要区别在于 <strong>数据写入方式</strong> 和 <strong>存储目标</strong>。下面是它们的详细对比：</p><hr><h2 id=1-主要用途><strong>1. 主要用途</strong>
<a class=anchor href=#1-%e4%b8%bb%e8%a6%81%e7%94%a8%e9%80%94>#</a></h2><table><thead><tr><th>组件</th><th><strong>Thanos Sidecar</strong></th><th><strong>Thanos Receive</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>连接 Prometheus，提供对象存储上传和查询能力</td><td>直接接收 Prometheus Remote Write 数据，替代 Prometheus 存储</td></tr><tr><td><strong>使用场景</strong></td><td><strong>已有 Prometheus</strong>，想要扩展长期存储</td><td><strong>无本地 Prometheus</strong>，需要集中接收和存储数据</td></tr><tr><td><strong>存储方式</strong></td><td>依赖本地 Prometheus 存储，定期上传到对象存储</td><td>直接存储 TSDB 数据，并支持水平扩展</td></tr><tr><td><strong>查询方式</strong></td><td>通过 <code>thanos query</code> 读取对象存储的数据</td><td>通过 <code>thanos query</code> 直接查询 Receive 存储的数据</td></tr></tbody></table><hr><h2 id=2-架构对比-1><strong>2. 架构对比</strong>
<a class=anchor href=#2-%e6%9e%b6%e6%9e%84%e5%af%b9%e6%af%94-1>#</a></h2><h3 id=thanos-sidecar><strong>Thanos Sidecar</strong>
<a class=anchor href=#thanos-sidecar>#</a></h3><ul><li><p>依附于 Prometheus</p><p>，作为一个附加组件运行，负责：</p><ul><li>提供 <strong>Prometheus 运行时数据</strong> 的查询 API（类似 Prometheus Query API）。</li><li>定期将 <strong>Prometheus 的历史数据上传到对象存储</strong>（如 S3、GCS）。</li><li>使 Thanos Query 可以同时查询多个 Prometheus 实例的数据。</li></ul></li><li><p>但 <strong>不会直接接收 Remote Write</strong> 数据，仍然依赖 Prometheus 进行采集和存储。</p></li></ul><h3 id=thanos-receive><strong>Thanos Receive</strong>
<a class=anchor href=#thanos-receive>#</a></h3><ul><li><p>独立运行</p><p>，用于</p><p>直接接收 Prometheus Remote Write 数据</p><p>，主要功能：</p><ul><li>作为 <strong>Prometheus 的替代存储</strong>，不需要本地 Prometheus 。</li><li>适用于 <strong>多个 Prometheus 实例集中存储数据</strong>，提升可扩展性。</li><li><strong>多副本模式</strong>，适用于 <strong>HA 部署</strong>，通过 <code>--receive.replication-factor</code> 控制副本数。</li><li>可以直接被 <code>thanos query</code> 组件查询，无需额外 Sidecar。</li></ul></li></ul><hr><h2 id=3-详细功能对比><strong>3. 详细功能对比</strong>
<a class=anchor href=#3-%e8%af%a6%e7%bb%86%e5%8a%9f%e8%83%bd%e5%af%b9%e6%af%94>#</a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>Thanos Sidecar</strong></th><th><strong>Thanos Receive</strong></th></tr></thead><tbody><tr><td><strong>是否依赖 Prometheus</strong></td><td>✅ 是，依附 Prometheus</td><td>❌ 否，独立运行</td></tr><tr><td><strong>是否支持 Prometheus Remote Write</strong></td><td>❌ 不支持</td><td>✅ 直接支持</td></tr><tr><td><strong>数据存储方式</strong></td><td>本地 Prometheus -> 对象存储（S3/GCS/OSS）</td><td>直接存储 TSDB 数据（支持对象存储）</td></tr><tr><td><strong>查询方式</strong></td><td>通过 Thanos Query 访问 Sidecar 提供的 Prometheus API</td><td>通过 Thanos Query 直接查询</td></tr><tr><td><strong>高可用性</strong></td><td>❌ 需要多个 Prometheus 实例才能高可用</td><td>✅ 多实例+数据复制，天然支持高可用</td></tr><tr><td><strong>适用场景</strong></td><td>需要长期存储，<strong>已有 Prometheus</strong></td><td>需要集中存储，<strong>多个 Prometheus 统一 Remote Write</strong></td></tr><tr><td><strong>写入模式</strong></td><td>Prometheus 本地存储数据，Sidecar 仅提供查询和存储上传</td><td>直接作为 Remote Write 目标，存储 Prometheus 采集数据</td></tr><tr><td><strong>适用场景</strong></td><td>适用于 Prometheus <strong>本地存储扩展</strong></td><td>适用于 <strong>多集群 Remote Write</strong> 存储方案</td></tr></tbody></table><hr><h2 id=4-适用场景-1><strong>4. 适用场景</strong>
<a class=anchor href=#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-1>#</a></h2><table><thead><tr><th><strong>需求</strong></th><th><strong>推荐使用</strong></th></tr></thead><tbody><tr><td><strong>已有 Prometheus，想扩展存储能力（对象存储）</strong></td><td>✅ <strong>Thanos Sidecar</strong></td></tr><tr><td><strong>想用 Remote Write 代替 Prometheus 本地存储</strong></td><td>✅ <strong>Thanos Receive</strong></td></tr><tr><td><strong>查询多个 Prometheus 实例的数据</strong></td><td>✅ <strong>Thanos Sidecar</strong>（搭配 Thanos Query）</td></tr><tr><td><strong>跨多个 Prometheus 统一存储数据，简化架构</strong></td><td>✅ <strong>Thanos Receive</strong></td></tr><tr><td><strong>希望 Prometheus 只负责采集，不存储数据</strong></td><td>✅ <strong>Thanos Receive</strong></td></tr></tbody></table><hr><h2 id=5-选型建议><strong>5. 选型建议</strong>
<a class=anchor href=#5-%e9%80%89%e5%9e%8b%e5%bb%ba%e8%ae%ae>#</a></h2><ul><li><strong>如果你已经在用 Prometheus，并且只想增加长期存储（S3/GCS/OSS），那么 Thanos Sidecar 是更好的选择。</strong></li><li><strong>如果你的 Prometheus 采集节点非常多，希望用 Remote Write 集中存储数据，或者希望 Prometheus 只负责数据采集，而存储和查询交给一个独立系统，那么 Thanos Receive 更适合。</strong></li></ul><p><strong>最终选型取决于你的架构需求，如果是传统 Prometheus 方案扩展，Sidecar 够用；如果是大规模监控存储，Receive 更合适！</strong> 🚀</p><h2 id=thanos-rule组件和prometheus区别>thanos rule组件和prometheus区别
<a class=anchor href=#thanos-rule%e7%bb%84%e4%bb%b6%e5%92%8cprometheus%e5%8c%ba%e5%88%ab>#</a></h2><h3 id=thanos-rule-vs-prometheus区别与对比><strong>Thanos Rule vs Prometheus：区别与对比</strong>
<a class=anchor href=#thanos-rule-vs-prometheus%e5%8c%ba%e5%88%ab%e4%b8%8e%e5%af%b9%e6%af%94>#</a></h3><p>Thanos Rule 组件和 Prometheus 在规则评估（Rule Evaluation）方面有相似的功能，但它们在 <strong>存储方式</strong>、<strong>适用场景</strong> 和 <strong>查询方式</strong> 上存在较大差异。</p><hr><h2 id=1-主要用途-1><strong>1. 主要用途</strong>
<a class=anchor href=#1-%e4%b8%bb%e8%a6%81%e7%94%a8%e9%80%94-1>#</a></h2><table><thead><tr><th>组件</th><th><strong>Thanos Rule</strong></th><th><strong>Prometheus</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>远程评估规则，生成新的时间序列数据</td><td>本地评估规则，生成新的时间序列数据</td></tr><tr><td><strong>存储方式</strong></td><td><strong>Remote Write 或对象存储</strong>（TSDB）</td><td>本地存储 TSDB</td></tr><tr><td><strong>查询方式</strong></td><td>通过 Thanos Query 访问存储的规则结果</td><td>通过 PromQL 查询本地数据</td></tr><tr><td><strong>高可用性</strong></td><td>✅ 通过多个实例 + HA 部署</td><td>❌ 需要手动管理多个 Prometheus 实例</td></tr><tr><td><strong>适用场景</strong></td><td><strong>分布式监控，多集群规则评估</strong></td><td><strong>单个 Prometheus 规则评估</strong></td></tr></tbody></table><hr><h2 id=2-组件介绍><strong>2. 组件介绍</strong>
<a class=anchor href=#2-%e7%bb%84%e4%bb%b6%e4%bb%8b%e7%bb%8d>#</a></h2><h3 id=-prometheus><strong>📌 Prometheus</strong>
<a class=anchor href=#-prometheus>#</a></h3><ul><li><strong>主要职责</strong>：<ul><li>采集时序数据，并存储在本地 <strong>TSDB</strong>。</li><li><strong>Rule 规则评估</strong>，将 <strong>PromQL 计算后的结果存储在本地 TSDB</strong>。</li><li><strong>告警（Alerting）评估</strong>，并通过 Alertmanager 发送告警。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>本地存储限制</strong>，历史数据无法长期存储（除非使用远程存储）。</li><li><strong>规则评估仅限本地</strong>，无法跨多个 Prometheus 实例。</li></ul></li></ul><hr><h3 id=-thanos-rule><strong>📌 Thanos Rule</strong>
<a class=anchor href=#-thanos-rule>#</a></h3><ul><li><p>作用</p><p>：</p><ul><li>类似于 Prometheus Rules，但它是 <strong>独立的远程规则评估组件</strong>。</li><li>可以 <strong>从多个 Prometheus / Thanos Store 读取数据</strong> 进行规则评估。</li><li>评估结果可以 <strong>写入对象存储</strong> 或 <strong>Prometheus Remote Write</strong>。</li></ul></li><li><p>关键特点</p><p>：</p><ul><li><strong>规则评估脱离 Prometheus</strong>，可以<strong>跨多个 Prometheus 运行</strong>。</li><li><strong>支持 HA 部署</strong>，多个 Thanos Rule 实例可以同时运行，不会重复写入数据。</li><li><strong>避免 Prometheus 单点问题</strong>，即使 Prometheus 实例宕机，Thanos Rule 仍能继续工作。</li></ul></li></ul><hr><h2 id=3-详细功能对比-1><strong>3. 详细功能对比</strong>
<a class=anchor href=#3-%e8%af%a6%e7%bb%86%e5%8a%9f%e8%83%bd%e5%af%b9%e6%af%94-1>#</a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>Thanos Rule</strong></th><th><strong>Prometheus</strong></th></tr></thead><tbody><tr><td><strong>是否采集数据</strong></td><td>❌ 不采集数据</td><td>✅ 采集数据</td></tr><tr><td><strong>是否存储数据</strong></td><td>✅ 通过 Remote Write 或对象存储</td><td>✅ 本地 TSDB</td></tr><tr><td><strong>规则评估方式</strong></td><td>读取多个数据源，集中计算</td><td>仅能评估本地数据</td></tr><tr><td><strong>跨集群支持</strong></td><td>✅ 可以评估多个 Prometheus 数据</td><td>❌ 仅限单个 Prometheus</td></tr><tr><td><strong>HA（高可用性）</strong></td><td>✅ 多个实例可用，不影响评估</td><td>❌ 单点故障，需手动管理多个 Prometheus</td></tr><tr><td><strong>告警规则（Alerts）</strong></td><td>✅ 通过 Alertmanager 发送</td><td>✅ 通过 Alertmanager 发送</td></tr></tbody></table><hr><h2 id=4-适用场景-2><strong>4. 适用场景</strong>
<a class=anchor href=#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-2>#</a></h2><table><thead><tr><th><strong>需求</strong></th><th><strong>推荐使用</strong></th></tr></thead><tbody><tr><td><strong>只管理一个 Prometheus 实例，直接用规则计算</strong></td><td>✅ <strong>Prometheus</strong></td></tr><tr><td><strong>希望跨多个 Prometheus 进行规则评估</strong></td><td>✅ <strong>Thanos Rule</strong></td></tr><tr><td><strong>需要高可用的规则评估（HA 方案）</strong></td><td>✅ <strong>Thanos Rule</strong></td></tr><tr><td><strong>希望把计算结果写入远程存储</strong></td><td>✅ <strong>Thanos Rule</strong></td></tr><tr><td><strong>Prometheus 需要扩展长期存储</strong></td><td>✅ <strong>Thanos Rule</strong>（搭配 Thanos Store）</td></tr></tbody></table><hr><h2 id=5-总结-1><strong>5. 总结</strong>
<a class=anchor href=#5-%e6%80%bb%e7%bb%93-1>#</a></h2><ul><li><strong>Prometheus</strong> 适用于 <strong>单个实例</strong> 进行规则评估和告警，不适合分布式部署。</li><li><strong>Thanos Rule</strong> 适用于 <strong>多个 Prometheus 统一评估规则</strong>，解决 Prometheus <strong>规则计算的 HA 问题</strong>，并可将结果存储到远程存储或对象存储。</li></ul><p>👉 <strong>如果是单个 Prometheus，直接用 Prometheus Rules 即可。</strong> 👉 <strong>如果是多个 Prometheus，并且希望跨集群评估规则，建议使用 Thanos Rule！</strong> 🚀</p><h2 id=prometheus告警从触发到收到通知延迟在哪>Prometheus告警从触发到收到通知延迟在哪
<a class=anchor href=#prometheus%e5%91%8a%e8%ad%a6%e4%bb%8e%e8%a7%a6%e5%8f%91%e5%88%b0%e6%94%b6%e5%88%b0%e9%80%9a%e7%9f%a5%e5%bb%b6%e8%bf%9f%e5%9c%a8%e5%93%aa>#</a></h2><p>Prometheus 告警（Alerting）从触发到收到通知的整个流程可能会出现 <strong>延迟</strong>，主要涉及多个环节，包括 <strong>规则评估</strong>、<strong>数据存储</strong>、<strong>告警发送</strong> 等。以下是各个环节的可能延迟点和优化方案。</p><hr><h2 id=-prometheus-告警流程><strong>📌 Prometheus 告警流程</strong>
<a class=anchor href=#-prometheus-%e5%91%8a%e8%ad%a6%e6%b5%81%e7%a8%8b>#</a></h2><ol><li>数据采集（Scrape）<ul><li>Prometheus 定期从 Exporter 或应用程序端点拉取监控数据。</li></ul></li><li>规则评估（Rule Evaluation）<ul><li>Prometheus 根据 <code>alerting rules</code> 评估数据，决定是否触发告警。</li></ul></li><li>告警触发（Alert Firing）<ul><li>满足告警条件的规则被标记为 <code>firing</code>（触发）。</li></ul></li><li>Alertmanager 处理<ul><li>Prometheus 将告警推送给 Alertmanager，Alertmanager 进行分组、抑制、路由等处理。</li></ul></li><li>通知发送<ul><li>Alertmanager 通过 Webhook、邮件、Slack、钉钉等渠道发送告警。</li></ul></li></ol><hr><h2 id=-可能的延迟点><strong>📌 可能的延迟点</strong>
<a class=anchor href=#-%e5%8f%af%e8%83%bd%e7%9a%84%e5%bb%b6%e8%bf%9f%e7%82%b9>#</a></h2><table><thead><tr><th><strong>环节</strong></th><th><strong>可能的延迟来源</strong></th><th><strong>优化方案</strong></th></tr></thead><tbody><tr><td><strong>数据采集（Scrape）</strong></td><td>- Prometheus 抓取间隔 (<code>scrape_interval</code>) 过长 - 目标 Exporter 响应慢或丢失数据</td><td>- 调整 <code>scrape_interval</code>，确保足够频繁抓取数据 - 确保 Exporter 端点稳定</td></tr><tr><td><strong>规则评估（Rule Evaluation）</strong></td><td>- <code>evaluation_interval</code> 过长 - PromQL 查询过于复杂，计算时间长</td><td>- 调整 <code>evaluation_interval</code>，建议设为 15s~30s - 优化 PromQL，减少不必要的计算</td></tr><tr><td><strong>告警触发（Alert Firing）</strong></td><td>- <code>for</code> 选项（持续时间）导致延迟 - Prometheus TSDB 存储查询效率低</td><td>- 确保 <code>for</code> 时间合适，不要过长 - 增强存储性能（如 Thanos / VictoriaMetrics）</td></tr><tr><td><strong>Prometheus -> Alertmanager</strong></td><td>- Prometheus 向 Alertmanager 发送告警批量处理有延迟</td><td>- 确保 Prometheus 能够快速推送告警（查看 <code>alert_relabel_configs</code>）</td></tr><tr><td><strong>Alertmanager 处理</strong></td><td>- 告警分组 (<code>group_wait</code>) 时间过长 - 告警抑制 (<code>inhibit_rules</code>) 影响 - <code>group_interval</code> 影响后续通知</td><td>- 调整 <code>group_wait</code> (建议 10s) - 避免 <code>group_interval</code> 过长</td></tr><tr><td><strong>通知发送（Email/钉钉/Slack 等）</strong></td><td>- API 调用慢（如 Webhook 超时） - 第三方服务（如邮件、钉钉等）处理慢</td><td>- 优化通知渠道（如使用更快的 Webhook 服务器） - 确保 Alertmanager 配置的通知方式高效</td></tr></tbody></table><hr><h2 id=-如何优化-prometheus-告警延迟><strong>📌 如何优化 Prometheus 告警延迟？</strong>
<a class=anchor href=#-%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96-prometheus-%e5%91%8a%e8%ad%a6%e5%bb%b6%e8%bf%9f>#</a></h2><h3 id=1-调整><strong>1. 调整 <code>scrape_interval</code></strong>
<a class=anchor href=#1-%e8%b0%83%e6%95%b4>#</a></h3><ul><li><p>默认情况下，Prometheus 可能每 <strong>60s</strong> 抓取一次数据（<code>scrape_interval=60s</code>）。</p></li><li><p>这意味着告警可能最多延迟 <strong>1 分钟</strong>。</p></li><li><p>优化方案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#34;node_exporter&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>scrape_interval</span>: <span style=color:#ae81ff>15s </span> <span style=color:#75715e># 抓取间隔缩短，提高告警实时性</span>
</span></span></code></pre></div></li></ul><h3 id=2-调整><strong>2. 调整 <code>evaluation_interval</code></strong>
<a class=anchor href=#2-%e8%b0%83%e6%95%b4>#</a></h3><ul><li><p>Prometheus 默认每 <strong>60s</strong> 评估一次告警规则（<code>evaluation_interval=60s</code>）。</p></li><li><p>这样可能导致数据刷新慢，增加延迟。</p></li><li><p>优化方案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>evaluation_interval</span>: <span style=color:#ae81ff>15s </span> <span style=color:#75715e># 规则评估时间缩短</span>
</span></span></code></pre></div></li></ul><h3 id=3-调整><strong>3. 调整 <code>for</code> 参数</strong>
<a class=anchor href=#3-%e8%b0%83%e6%95%b4>#</a></h3><ul><li><pre tabindex=0><code>for
</code></pre><p>参数用于避免短暂波动导致的误报，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>InstanceDown</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>up == 0</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>for</span>: <span style=color:#ae81ff>2m </span> <span style=color:#75715e># 只有连续 2 分钟宕机才会触发告警</span>
</span></span></code></pre></div></li><li><p>如果 <code>for: 5m</code>，意味着即使 Prometheus 立即检测到问题，也要 <strong>等 5 分钟</strong> 才会上报告警。</p></li><li><p><strong>优化方案</strong>：如果业务不敏感，可以适当减少 <code>for</code> 时间，比如 <code>for: 30s</code>。</p></li></ul><h3 id=4-调整-alertmanager-配置><strong>4. 调整 Alertmanager 配置</strong>
<a class=anchor href=#4-%e8%b0%83%e6%95%b4-alertmanager-%e9%85%8d%e7%bd%ae>#</a></h3><ul><li><p>Alertmanager 默认有 <code>group_wait</code> 和 <code>group_interval</code> 机制，可能导致告警延迟。</p></li><li><p>优化方案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>route</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_wait</span>: <span style=color:#ae81ff>10s </span> <span style=color:#75715e># 组内首个告警延迟 10s 发送</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_interval</span>: <span style=color:#ae81ff>30s </span> <span style=color:#75715e># 组内后续告警每 30s 发送一次</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>repeat_interval</span>: <span style=color:#ae81ff>3h </span> <span style=color:#75715e># 3 小时后重新发送相同的告警</span>
</span></span></code></pre></div></li></ul><h3 id=5-优化通知方式><strong>5. 优化通知方式</strong>
<a class=anchor href=#5-%e4%bc%98%e5%8c%96%e9%80%9a%e7%9f%a5%e6%96%b9%e5%bc%8f>#</a></h3><ul><li><strong>Webhook 方式</strong> 比 <strong>邮件</strong> 和 <strong>钉钉机器人</strong> 更快。</li><li>优化方案：<ul><li>尽量使用 <strong>直接的 Webhook</strong>，避免过多代理。</li><li>避免 API 服务器超时，增加 Alertmanager 发送失败的重试机制。</li></ul></li></ul><hr><h2 id=-结论><strong>📌 结论</strong>
<a class=anchor href=#-%e7%bb%93%e8%ae%ba>#</a></h2><p>Prometheus 告警从触发到收到通知的延迟，可能发生在多个环节：</p><ol><li><strong>数据采集间隔（scrape_interval）</strong></li><li><strong>规则评估频率（evaluation_interval）</strong></li><li><strong>告警触发延迟（for 参数）</strong></li><li><strong>Alertmanager 分组/抑制机制（group_wait、group_interval）</strong></li><li><strong>通知方式的 API 延迟</strong></li></ol><h3 id=-优化建议>🚀 <strong>优化建议</strong>
<a class=anchor href=#-%e4%bc%98%e5%8c%96%e5%bb%ba%e8%ae%ae>#</a></h3><p>✅ <code>scrape_interval: 15s</code>（提高数据采集频率）
✅ <code>evaluation_interval: 15s</code>（更快评估告警规则）
✅ <code>for: 30s</code>（减少告警延迟）
✅ <code>group_wait: 10s</code> + <code>group_interval: 30s</code>（优化 Alertmanager）
✅ <strong>使用 Webhook 代替钉钉/邮件，提高告警推送速度</strong></p><hr><h3 id=-推荐优化后的示例配置><strong>🔥 推荐优化后的示例配置</strong>
<a class=anchor href=#-%e6%8e%a8%e8%8d%90%e4%bc%98%e5%8c%96%e5%90%8e%e7%9a%84%e7%a4%ba%e4%be%8b%e9%85%8d%e7%bd%ae>#</a></h3><h4 id=prometheus-配置><strong>Prometheus 配置</strong>
<a class=anchor href=#prometheus-%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>global</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>scrape_interval</span>: <span style=color:#ae81ff>15s </span> <span style=color:#75715e># 默认采集间隔</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>evaluation_interval</span>: <span style=color:#ae81ff>15s </span> <span style=color:#75715e># 规则评估间隔</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>rule_files</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;alert.rules.yml&#34;</span>
</span></span></code></pre></div><h4 id=alertmanager-配置><strong>Alertmanager 配置</strong>
<a class=anchor href=#alertmanager-%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>route</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_by</span>: [<span style=color:#e6db74>&#39;alertname&#39;</span>]
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_wait</span>: <span style=color:#ae81ff>10s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_interval</span>: <span style=color:#ae81ff>30s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>repeat_interval</span>: <span style=color:#ae81ff>1h</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>receiver</span>: <span style=color:#e6db74>&#39;webhook&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>receivers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#39;webhook&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>webhook_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>url</span>: <span style=color:#e6db74>&#34;http://webhook-server/alert&#34;</span>
</span></span></code></pre></div><p>这样可以 <strong>最大程度减少 Prometheus 告警延迟</strong> 🚀🚀🚀</p><h2 id=告警抑制怎么做>告警抑制怎么做☆
<a class=anchor href=#%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6%e6%80%8e%e4%b9%88%e5%81%9a>#</a></h2><p>在 <strong>Prometheus Alertmanager</strong> 中，告警抑制（Inhibition）用于<strong>阻止某些告警在特定情况下发送通知</strong>。通常用于减少重复告警，或者在<strong>更严重的告警发生时，屏蔽不重要的告警</strong>。</p><hr><h2 id=-告警抑制的工作原理><strong>📌 告警抑制的工作原理</strong>
<a class=anchor href=#-%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h2><ul><li><strong>抑制规则（Inhibit Rules）</strong> 允许你定义 <strong>&ldquo;A 告警存在时，B 告警就不会发送通知&rdquo;</strong>。</li><li>例如：<ul><li><strong>如果某个集群已 <code>Down</code>，就不要发送 <code>InstanceDown</code> 告警</strong>。</li><li><strong>如果主数据库已崩溃，就不再发送单个 API 失败的告警</strong>。</li></ul></li><li><strong>Alertmanager 只会对已接收到的告警进行抑制</strong>，不会影响 Prometheus 的告警触发。</li></ul><hr><h2 id=-告警抑制规则配置><strong>📌 告警抑制规则配置</strong>
<a class=anchor href=#-%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6%e8%a7%84%e5%88%99%e9%85%8d%e7%bd%ae>#</a></h2><h3 id=示例-1屏蔽><strong>示例 1：屏蔽 <code>InstanceDown</code> 告警，若 <code>ClusterDown</code> 告警已触发</strong>
<a class=anchor href=#%e7%a4%ba%e4%be%8b-1%e5%b1%8f%e8%94%bd>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>inhibit_rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>source_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;ClusterDown&#34;</span>  <span style=color:#75715e># 当 &#34;ClusterDown&#34; 告警触发时</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>target_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;InstanceDown&#34;</span>  <span style=color:#75715e># 该告警会被抑制</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>equal</span>: [<span style=color:#e6db74>&#34;cluster&#34;</span>]  <span style=color:#75715e># 必须匹配相同的 cluster 标签</span>
</span></span></code></pre></div><p>📌 <strong>解释</strong>：</p><ul><li>如果 <strong><code>ClusterDown</code></strong> 发生（整个集群宕机），则不会发送 <strong><code>InstanceDown</code></strong>（单个实例宕机）的告警，因为它们可能是相同的问题导致的。</li></ul><hr><h3 id=示例-2某个服务><strong>示例 2：某个服务 <code>APIHighLatency</code> 时，屏蔽 <code>APIErrorRate</code></strong>
<a class=anchor href=#%e7%a4%ba%e4%be%8b-2%e6%9f%90%e4%b8%aa%e6%9c%8d%e5%8a%a1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>inhibit_rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>source_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;APIHighLatency&#34;</span>  <span style=color:#75715e># API 响应慢</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>target_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;APIErrorRate&#34;</span>  <span style=color:#75715e># API 错误率升高</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>equal</span>: [<span style=color:#e6db74>&#34;service&#34;</span>]  <span style=color:#75715e># 仅在相同服务名的情况下生效</span>
</span></span></code></pre></div><p>📌 <strong>解释</strong>：</p><ul><li><strong>API 响应变慢（<code>APIHighLatency</code>）可能会导致 API 失败（<code>APIErrorRate</code>）</strong>，所以可以在延迟过高时屏蔽错误率告警。</li></ul><hr><h2 id=-配置><strong>📌 配置 <code>Alertmanager.yml</code> 规则</strong>
<a class=anchor href=#-%e9%85%8d%e7%bd%ae>#</a></h2><h3 id=完整示例><strong>完整示例</strong>
<a class=anchor href=#%e5%ae%8c%e6%95%b4%e7%a4%ba%e4%be%8b>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>route</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_by</span>: [<span style=color:#e6db74>&#39;alertname&#39;</span>]
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_wait</span>: <span style=color:#ae81ff>10s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_interval</span>: <span style=color:#ae81ff>30s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>repeat_interval</span>: <span style=color:#ae81ff>1h</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>receiver</span>: <span style=color:#e6db74>&#39;default&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>receivers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#39;default&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>webhook_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>url</span>: <span style=color:#e6db74>&#34;http://webhook-server/alert&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>inhibit_rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>source_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;ClusterDown&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>target_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;InstanceDown&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>equal</span>: [<span style=color:#e6db74>&#34;cluster&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>source_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;APIHighLatency&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>target_match</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alertname</span>: <span style=color:#e6db74>&#34;APIErrorRate&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>equal</span>: [<span style=color:#e6db74>&#34;service&#34;</span>]
</span></span></code></pre></div><hr><h2 id=-如何测试告警抑制><strong>📌 如何测试告警抑制</strong>
<a class=anchor href=#-%e5%a6%82%e4%bd%95%e6%b5%8b%e8%af%95%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6>#</a></h2><ol><li><p>触发 <code>ClusterDown</code></p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>ALERT ClusterDown</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>IF count(up == 0) &gt; 5</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>FOR 1m</span>
</span></span></code></pre></div></li><li><p>触发 <code>InstanceDown</code></p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>ALERT InstanceDown</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>IF up == 0</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>FOR 1m</span>
</span></span></code></pre></div></li><li><p>查看 Alertmanager 界面</p><ul><li><strong>若 <code>ClusterDown</code> 触发，<code>InstanceDown</code> 将被抑制（不会发通知）</strong>。</li><li>在 Alertmanager 的 <strong><code>/alerts</code> 页面</strong>，你可以看到 <code>InstanceDown</code> 状态变为 <code>Suppressed</code>（已抑制）。</li></ul></li></ol><hr><h2 id=-总结><strong>📌 总结</strong>
<a class=anchor href=#-%e6%80%bb%e7%bb%93>#</a></h2><p>✅ <strong>告警抑制的作用</strong>：</p><ul><li>减少 <strong>重复告警</strong>，避免告警风暴。</li><li>让更严重的告警优先级更高，防止被无关告警干扰。</li></ul><p>✅ <strong>关键配置</strong></p><ul><li><code>source_match</code>: 触发抑制的告警（优先级高）。</li><li><code>target_match</code>: 被抑制的告警（优先级低）。</li><li><code>equal</code>: 需要匹配的标签（如 <code>cluster</code>、<code>service</code>）。</li></ul><p>💡 <strong>最终效果</strong>：
💥<strong>如果集群崩溃（<code>ClusterDown</code>）时，所有实例宕机告警（<code>InstanceDown</code>）都会被抑制</strong>，这样不会收到重复的实例告警。 🚀</p><h3 id=prometheus-告警抑制inhibition><strong>Prometheus 告警抑制（Inhibition）</strong>
<a class=anchor href=#prometheus-%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6inhibition>#</a></h3><p>告警抑制（<strong>Inhibition</strong>）用于<strong>屏蔽</strong>某些告警，防止高优先级的告警触发时，低优先级的告警同时触发，造成信息冗余或混乱。</p><p>例如：</p><ul><li><strong>屏蔽</strong>“服务实例不可用”告警 <strong>（InstanceDown）</strong>，当整个集群不可用时 <strong>（ClusterDown）</strong> 触发。</li><li><strong>屏蔽</strong>“磁盘使用率过高”告警 <strong>（DiskUsageHigh）</strong>，当磁盘已满时 <strong>（DiskFull）</strong> 触发。</li></ul><hr><h2 id=-配置告警抑制的步骤><strong>📌 配置告警抑制的步骤</strong>
<a class=anchor href=#-%e9%85%8d%e7%bd%ae%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6%e7%9a%84%e6%ad%a5%e9%aa%a4>#</a></h2><p>告警抑制需要在 <strong>Alertmanager</strong> 中配置 <code>inhibit_rules</code>，其规则如下：</p><ul><li><strong>source_match</strong>：指定<strong>高优先级</strong>的告警（如果此告警触发，则屏蔽其他告警）。</li><li><strong>target_match</strong>：指定<strong>低优先级</strong>的告警（当 <code>source_match</code> 触发时，该告警会被屏蔽）。</li><li><strong>equal</strong>：需要匹配的标签，确保同一服务或同一实例的告警才会被抑制。</li></ul><hr><h2 id=-示例屏蔽-instancedown-告警><strong>📌 示例：屏蔽 InstanceDown 告警</strong>
<a class=anchor href=#-%e7%a4%ba%e4%be%8b%e5%b1%8f%e8%94%bd-instancedown-%e5%91%8a%e8%ad%a6>#</a></h2><p><strong>场景：</strong></p><ul><li><code>ClusterDown</code>（整个集群宕机）触发时，不再单独告警 <code>InstanceDown</code>（单个实例不可用）。</li><li><strong>目标</strong>：避免同一事件重复发送多个告警，减少噪音。</li></ul><pre tabindex=0><code>yaml


复制编辑
inhibit_rules:
  - source_match:
      alertname: &#34;ClusterDown&#34;  # 高优先级告警
    target_match:
      alertname: &#34;InstanceDown&#34;  # 低优先级告警
    equal: [&#34;cluster&#34;]  # 只抑制同一个 cluster 的告警
</code></pre><p>🔹 <strong>效果</strong>：当 <code>ClusterDown</code> 触发时，<code>InstanceDown</code> 告警不会发送。</p><hr><h2 id=-示例屏蔽磁盘使用率高告警><strong>📌 示例：屏蔽磁盘使用率高告警</strong>
<a class=anchor href=#-%e7%a4%ba%e4%be%8b%e5%b1%8f%e8%94%bd%e7%a3%81%e7%9b%98%e4%bd%bf%e7%94%a8%e7%8e%87%e9%ab%98%e5%91%8a%e8%ad%a6>#</a></h2><p><strong>场景：</strong></p><ul><li><code>DiskFull</code>（磁盘已满）触发时，不再告警 <code>DiskUsageHigh</code>（磁盘使用率高）。</li><li><strong>目标</strong>：避免相同原因导致的多条告警，减少不必要的告警流量。</li></ul><pre tabindex=0><code>yaml


复制编辑
inhibit_rules:
  - source_match:
      alertname: &#34;DiskFull&#34;  # 高级别告警
    target_match:
      alertname: &#34;DiskUsageHigh&#34;  # 低级别告警
    equal: [&#34;instance&#34;, &#34;device&#34;]  # 只抑制相同 instance 和 device 的告警
</code></pre><p>🔹 <strong>效果</strong>：磁盘已满时，不会再收到磁盘使用率高的告警。</p><hr><h2 id=-示例屏蔽><strong>📌 示例：屏蔽 <code>NodeDown</code>（节点宕机）告警</strong>
<a class=anchor href=#-%e7%a4%ba%e4%be%8b%e5%b1%8f%e8%94%bd>#</a></h2><p><strong>场景：</strong></p><ul><li><code>NetworkDown</code>（网络不可用）触发时，不再告警 <code>NodeDown</code>（节点宕机）。</li><li><strong>目标</strong>：避免误报，因为网络问题会导致所有节点的 <code>NodeDown</code> 告警。</li></ul><pre tabindex=0><code>yaml


复制编辑
inhibit_rules:
  - source_match:
      alertname: &#34;NetworkDown&#34;
    target_match:
      alertname: &#34;NodeDown&#34;
    equal: [&#34;datacenter&#34;]
</code></pre><p>🔹 <strong>效果</strong>：当 <code>NetworkDown</code> 触发时，同一数据中心的 <code>NodeDown</code> 告警会被屏蔽。</p><hr><h2 id=heading><strong>📌 <code>inhibit_rules</code> 配置完整示例</strong>
<a class=anchor href=#heading>#</a></h2><pre tabindex=0><code>yaml


复制编辑
route:
  receiver: &#34;default&#34;

inhibit_rules:
  - source_match:
      alertname: &#34;ClusterDown&#34;
    target_match:
      alertname: &#34;InstanceDown&#34;
    equal: [&#34;cluster&#34;]

  - source_match:
      alertname: &#34;DiskFull&#34;
    target_match:
      alertname: &#34;DiskUsageHigh&#34;
    equal: [&#34;instance&#34;, &#34;device&#34;]

  - source_match:
      alertname: &#34;NetworkDown&#34;
    target_match:
      alertname: &#34;NodeDown&#34;
    equal: [&#34;datacenter&#34;]
</code></pre><p>📌 <strong>解释</strong></p><ol><li><strong><code>ClusterDown</code> 触发时，不再触发 <code>InstanceDown</code></strong>。</li><li><strong><code>DiskFull</code> 触发时，不再触发 <code>DiskUsageHigh</code></strong>。</li><li><strong><code>NetworkDown</code> 触发时，不再触发 <code>NodeDown</code></strong>。</li></ol><hr><h2 id=-如何测试告警抑制-1><strong>📌 如何测试告警抑制？</strong>
<a class=anchor href=#-%e5%a6%82%e4%bd%95%e6%b5%8b%e8%af%95%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6-1>#</a></h2><h3 id=方式-1使用><strong>方式 1：使用 <code>amtool</code></strong>
<a class=anchor href=#%e6%96%b9%e5%bc%8f-1%e4%bd%bf%e7%94%a8>#</a></h3><pre tabindex=0><code>sh


复制编辑
amtool silence query  # 查看当前抑制的告警
</code></pre><h3 id=方式-2查看-alertmanager-ui><strong>方式 2：查看 Alertmanager UI</strong>
<a class=anchor href=#%e6%96%b9%e5%bc%8f-2%e6%9f%a5%e7%9c%8b-alertmanager-ui>#</a></h3><ol><li><p>访问 Alertmanager Web UI：</p><pre tabindex=0><code>cpp


复制编辑
http://&lt;alertmanager-ip&gt;:9093
</code></pre></li><li><p>进入 <strong>&ldquo;Silences&rdquo;（抑制）</strong> 页面，查看哪些告警被屏蔽。</p></li></ol><hr><h2 id=-结论-1><strong>📌 结论</strong>
<a class=anchor href=#-%e7%bb%93%e8%ae%ba-1>#</a></h2><p>✅ <strong>告警抑制（Inhibition）</strong> 可以防止低优先级的告警重复触发，提高告警的准确性。
✅ <strong><code>inhibit_rules</code></strong> 通过 <strong>source_match、target_match 和 equal</strong> 匹配规则，决定哪些告警需要被屏蔽。
✅ <strong>常见用例</strong>：</p><ul><li><strong>集群宕机时屏蔽单个实例告警</strong>。</li><li><strong>磁盘满时屏蔽磁盘使用率高的告警</strong>。</li><li><strong>网络不可用时屏蔽所有节点宕机的告警</strong>。</li></ul><p>这样可以<strong>减少告警噪音，提高运维效率</strong> 🚀🚀🚀！</p><h2 id=告警架构高可用怎么做>告警架构高可用怎么做☆
<a class=anchor href=#%e5%91%8a%e8%ad%a6%e6%9e%b6%e6%9e%84%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%8e%e4%b9%88%e5%81%9a>#</a></h2><h2 id=prometheus-告警系统高可用架构方案><strong>Prometheus 告警系统高可用架构方案</strong>
<a class=anchor href=#prometheus-%e5%91%8a%e8%ad%a6%e7%b3%bb%e7%bb%9f%e9%ab%98%e5%8f%af%e7%94%a8%e6%9e%b6%e6%9e%84%e6%96%b9%e6%a1%88>#</a></h2><p>Prometheus 的告警系统主要由 <strong>Prometheus + Alertmanager</strong> 组成，要保证其高可用（HA），需要解决以下问题：</p><ol><li><strong>Prometheus 高可用</strong>（数据采集、存储的 HA）</li><li><strong>Alertmanager 高可用</strong>（告警处理、去重的 HA）</li><li><strong>通知渠道高可用</strong>（Webhook、邮件、企业微信等）</li></ol><hr><h2 id=-1-prometheus-高可用><strong>📌 1. Prometheus 高可用</strong>
<a class=anchor href=#-1-prometheus-%e9%ab%98%e5%8f%af%e7%94%a8>#</a></h2><p>Prometheus 负责<strong>数据采集</strong>和<strong>告警规则执行</strong>，要保证它的高可用，主要考虑：</p><ul><li><strong>主备部署（热备）</strong></li><li><strong>水平扩展（联邦集群）</strong></li><li><strong>存储层高可用</strong></li></ul><h3 id=-方案-1prometheus-双实例主备><strong>🔹 方案 1：Prometheus 双实例（主备）</strong>
<a class=anchor href=#-%e6%96%b9%e6%a1%88-1prometheus-%e5%8f%8c%e5%ae%9e%e4%be%8b%e4%b8%bb%e5%a4%87>#</a></h3><ul><li><strong>架构：</strong> 部署两台独立的 Prometheus 实例，监控相同的目标。</li><li><strong>优点：</strong> 简单易实现，适用于小型环境。</li><li><strong>缺点：</strong> 需要负载均衡或手动切换，存储不共享。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>       ┌───────────┐
</span></span><span style=display:flex><span>       │  Exporter │
</span></span><span style=display:flex><span>       └────┬──────┘
</span></span><span style=display:flex><span>            │
</span></span><span style=display:flex><span>  ┌────────▼────────┐   ┌───────────┐
</span></span><span style=display:flex><span>  │ Prometheus (主)  │   │ Alertmanager │
</span></span><span style=display:flex><span>  ├────────┬────────┘   └───────────┘
</span></span><span style=display:flex><span>  │ Prometheus (备)  │
</span></span><span style=display:flex><span>  └────────┴────────┘
</span></span></code></pre></div><p>✅ <strong>如何做？</strong></p><ol><li><strong>配置两个 Prometheus 实例</strong>，让它们都拉取相同的监控数据。</li><li><strong>前端（如 Grafana）配置负载均衡</strong>，如果一个 Prometheus 宕机，使用另一个。</li></ol><hr><h3 id=-方案-2prometheus--thanos-victoriametrics><strong>🔹 方案 2：Prometheus + Thanos/ VictoriaMetrics</strong>
<a class=anchor href=#-%e6%96%b9%e6%a1%88-2prometheus--thanos-victoriametrics>#</a></h3><ul><li><strong>架构：</strong> Prometheus 采集数据，Thanos/VictoriaMetrics 负责远程存储和 HA 查询。</li><li><strong>优点：</strong> 高可用、分布式存储、支持历史数据查询。</li><li><strong>缺点：</strong> 需要额外组件（Thanos/VictoriaMetrics）。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>       ┌─────────────┐
</span></span><span style=display:flex><span>       │   Exporter  │
</span></span><span style=display:flex><span>       └─────┬───────┘
</span></span><span style=display:flex><span>             │
</span></span><span style=display:flex><span> ┌──────────▼──────────┐
</span></span><span style=display:flex><span> │    Prometheus-1     │
</span></span><span style=display:flex><span> ├──────────┬──────────┘
</span></span><span style=display:flex><span> │    Prometheus-2     │
</span></span><span style=display:flex><span> └──────────┴──────────┘
</span></span><span style=display:flex><span>            │
</span></span><span style=display:flex><span>  ┌────────▼────────┐
</span></span><span style=display:flex><span>  │ Thanos Query    │
</span></span><span style=display:flex><span>  ├─────────────────┘
</span></span><span style=display:flex><span>  │ Thanos Store    │
</span></span><span style=display:flex><span>  └─────────────────┘
</span></span></code></pre></div><p>✅ <strong>如何做？</strong></p><ol><li><strong>部署多个 Prometheus 实例</strong>，采集相同数据。</li><li><strong>使用 Thanos Query/VictoriaMetrics</strong>，让查询层能自动聚合多个 Prometheus 数据。</li></ol><hr><h2 id=-2-alertmanager-高可用><strong>📌 2. Alertmanager 高可用</strong>
<a class=anchor href=#-2-alertmanager-%e9%ab%98%e5%8f%af%e7%94%a8>#</a></h2><p>Alertmanager 负责<strong>告警的去重、分组、通知</strong>，如果单点故障，告警就可能丢失。</p><h3 id=-方案alertmanager-集群><strong>🔹 方案：Alertmanager 集群</strong>
<a class=anchor href=#-%e6%96%b9%e6%a1%88alertmanager-%e9%9b%86%e7%be%a4>#</a></h3><ul><li><strong>架构：</strong> 多个 Alertmanager 进程，通过 <code>mesh</code> 互相同步状态。</li><li><strong>优点：</strong> 互相同步，防止单点故障，告警不会丢失。</li><li><strong>缺点：</strong> 需要额外负载均衡。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>       ┌────────────────┐
</span></span><span style=display:flex><span>       │    Prometheus   │
</span></span><span style=display:flex><span>       ├────────────────┘
</span></span><span style=display:flex><span>       │  发送告警        │
</span></span><span style=display:flex><span>       └────────▲───────┘
</span></span><span style=display:flex><span>                │
</span></span><span style=display:flex><span> ┌──────────────┴──────────────┐
</span></span><span style=display:flex><span> │   Alertmanager (实例 1)      │
</span></span><span style=display:flex><span> │   Alertmanager (实例 2)      │   (集群模式)
</span></span><span style=display:flex><span> │   Alertmanager (实例 3)      │
</span></span><span style=display:flex><span> └──────────────┬──────────────┘
</span></span><span style=display:flex><span>                │
</span></span><span style=display:flex><span>        ┌──────▼──────┐
</span></span><span style=display:flex><span>        │  Webhook    │
</span></span><span style=display:flex><span>        │  邮件通知   │
</span></span><span style=display:flex><span>        │  企业微信   │
</span></span><span style=display:flex><span>        └────────────┘
</span></span></code></pre></div><p>✅ <strong>如何做？</strong></p><ol><li><strong>多个 Alertmanager 实例</strong> 通过 <code>--cluster.peer=&lt;other-instance></code> 互相同步。</li><li><strong>负载均衡（如 Nginx/LB）</strong> 让 Prometheus 以 HA 方式访问 Alertmanager。</li><li><strong>持久化存储</strong> 避免 Alertmanager 重启后丢失状态。</li></ol><hr><h2 id=-3-通知渠道高可用><strong>📌 3. 通知渠道高可用</strong>
<a class=anchor href=#-3-%e9%80%9a%e7%9f%a5%e6%b8%a0%e9%81%93%e9%ab%98%e5%8f%af%e7%94%a8>#</a></h2><p>如果通知方式不可用（例如 Webhook、邮件服务器宕机），可能导致告警丢失。</p><h3 id=-方案-1多个通知通道><strong>🔹 方案 1：多个通知通道</strong>
<a class=anchor href=#-%e6%96%b9%e6%a1%88-1%e5%a4%9a%e4%b8%aa%e9%80%9a%e7%9f%a5%e9%80%9a%e9%81%93>#</a></h3><ul><li><p>配置</p><p>多个通知通道</p><p>，例如：</p><ul><li>主要通知：<strong>邮件</strong></li><li>备用通知：<strong>企业微信</strong></li><li>紧急通知：<strong>短信</strong></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>receivers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;email&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>email_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>to</span>: <span style=color:#e6db74>&#34;admin@example.com&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;wechat&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>wechat_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>to</span>: <span style=color:#e6db74>&#34;DevOps_Group&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;sms&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>webhook_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>url</span>: <span style=color:#e6db74>&#34;http://sms-provider/api/send&#34;</span>
</span></span></code></pre></div><p>✅ <strong>如何做？</strong></p><ul><li><strong>定义多个 <code>receiver</code></strong>，并在 <code>route</code> 里配置故障转移逻辑。</li></ul><hr><h3 id=-方案-2webhook-高可用><strong>🔹 方案 2：Webhook 高可用</strong>
<a class=anchor href=#-%e6%96%b9%e6%a1%88-2webhook-%e9%ab%98%e5%8f%af%e7%94%a8>#</a></h3><ul><li>如果 Webhook 服务器崩溃，告警可能丢失。</li><li>方案：<ul><li>使用 <strong>负载均衡（Nginx、HAProxy）</strong> 代理多个 Webhook 服务器。</li><li>采用 <strong>Kafka/RabbitMQ</strong> 作为 Webhook 缓冲队列，防止瞬时流量过载。</li></ul></li></ul><hr><h2 id=-4-全局高可用架构><strong>📌 4. 全局高可用架构</strong>
<a class=anchor href=#-4-%e5%85%a8%e5%b1%80%e9%ab%98%e5%8f%af%e7%94%a8%e6%9e%b6%e6%9e%84>#</a></h2><p><strong>最终的 Prometheus 告警高可用架构如下：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>       ┌───────────────────┐
</span></span><span style=display:flex><span>       │    Exporters      │
</span></span><span style=display:flex><span>       └────────▲──────────┘
</span></span><span style=display:flex><span>                │
</span></span><span style=display:flex><span> ┌──────────────┴──────────────┐
</span></span><span style=display:flex><span> │  Prometheus (实例 1)         │
</span></span><span style=display:flex><span> │  Prometheus (实例 2)         │  (高可用)
</span></span><span style=display:flex><span> └──────────────┬──────────────┘
</span></span><span style=display:flex><span>                │
</span></span><span style=display:flex><span>       ┌───────▼───────┐
</span></span><span style=display:flex><span>       │ Thanos Query  │  (可选)
</span></span><span style=display:flex><span>       └───────┬───────┘
</span></span><span style=display:flex><span>               │
</span></span><span style=display:flex><span> ┌────────────▼────────────┐
</span></span><span style=display:flex><span> │  Alertmanager (实例 1)   │
</span></span><span style=display:flex><span> │  Alertmanager (实例 2)   │  (集群)
</span></span><span style=display:flex><span> └────────────▲────────────┘
</span></span><span style=display:flex><span>              │
</span></span><span style=display:flex><span> ┌────────────▼────────────┐
</span></span><span style=display:flex><span> │  邮件 / 微信 / Webhook  │  (多通道)
</span></span><span style=display:flex><span> └────────────────────────┘
</span></span></code></pre></div><hr><h2 id=-结论-2><strong>📌 结论</strong>
<a class=anchor href=#-%e7%bb%93%e8%ae%ba-2>#</a></h2><p>✅ <strong>Prometheus 高可用</strong></p><ul><li><strong>方案 1：双实例主备</strong></li><li><strong>方案 2：Thanos/VictoriaMetrics 分布式</strong></li></ul><p>✅ <strong>Alertmanager 高可用</strong></p><ul><li><strong>Alertmanager 集群</strong>，同步状态</li><li><strong>负载均衡（Nginx/LB）</strong></li></ul><p>✅ <strong>通知渠道高可用</strong></p><ul><li><strong>多通道（邮件、微信、短信）</strong></li><li><strong>Webhook 负载均衡 + 消息队列（Kafka）</strong></li></ul><p>🚀 <strong>这样可以确保整个告警系统的高可用，避免单点故障！</strong></p><h2 id=pod指标wss和rss区别>Pod指标WSS和RSS区别☆
<a class=anchor href=#pod%e6%8c%87%e6%a0%87wss%e5%92%8crss%e5%8c%ba%e5%88%ab>#</a></h2><p>在 Kubernetes 或 Linux 系统中，<strong>RSS（Resident Set Size）</strong> 和 <strong>WSS（Working Set Size）</strong> 是衡量 Pod 或进程内存使用的重要指标，它们有不同的含义和使用场景。</p><hr><h2 id=-rssresident-set-size><strong>📌 RSS（Resident Set Size）</strong>
<a class=anchor href=#-rssresident-set-size>#</a></h2><ul><li><strong>RSS 是进程实际占用物理内存的大小</strong>，不包括交换（swap）出去的部分。</li><li>它包括：<ul><li><strong>私有匿名页</strong>（heap、stack 等）</li><li><strong>共享库的已加载部分</strong></li></ul></li><li>不包括：<ul><li><strong>未被访问的内存页</strong></li><li><strong>Swap 到磁盘的部分</strong></li><li><strong>文件映射的未加载部分</strong></li></ul></li></ul><p>✅ <strong>适用场景</strong></p><ul><li>观察 Pod 的实际物理内存占用，避免超出节点可用内存。</li><li>用于 Kubernetes <code>memory.usage</code> 监控。</li></ul><p>📌 <strong>示例：查看 Pod RSS</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec -it &lt;pod-name&gt; -- cat /proc/1/status | grep VmRSS
</span></span></code></pre></div><p>或者：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps -o rss,vsz,pid,cmd | grep &lt;process_name&gt;
</span></span></code></pre></div><hr><h2 id=-wssworking-set-size><strong>📌 WSS（Working Set Size）</strong>
<a class=anchor href=#-wssworking-set-size>#</a></h2><ul><li><strong>WSS 是进程在一段时间内频繁访问的内存大小</strong>。</li><li>只统计<strong>活跃</strong>的内存页，未访问的部分不算 WSS。</li><li>包括：<ul><li>进程在短时间窗口内访问的页。</li><li>可能会被频繁调入物理内存的部分。</li></ul></li></ul><p>✅ <strong>适用场景</strong></p><ul><li>评估进程实际需要的内存，避免过度分配或 OOM（Out of Memory）。</li><li>用于 Kubernetes <code>memory.working_set_bytes</code> 指标。</li></ul><p>📌 <strong>示例：使用 <code>cgroup</code> 监控 WSS</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /sys/fs/cgroup/memory/kubepods/burstable/pod*/memory.working_set_bytes
</span></span></code></pre></div><hr><h2 id=-wss-vs-rss-总结><strong>📌 WSS vs. RSS 总结</strong>
<a class=anchor href=#-wss-vs-rss-%e6%80%bb%e7%bb%93>#</a></h2><table><thead><tr><th>指标</th><th>含义</th><th>计算方式</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>RSS</strong></td><td>实际占用的物理内存</td><td><code>VmRSS</code></td><td>监控内存使用，避免超配</td></tr><tr><td><strong>WSS</strong></td><td>频繁访问的内存</td><td><code>memory.working_set_bytes</code></td><td>估算应用实际需要的内存</td></tr></tbody></table><hr><h2 id=-kubernetes-相关><strong>📌 Kubernetes 相关</strong>
<a class=anchor href=#-kubernetes-%e7%9b%b8%e5%85%b3>#</a></h2><ul><li><code>memory.usage_bytes</code> ≈ RSS</li><li><code>memory.working_set_bytes</code> ≈ WSS</li><li>监控时，如果 <strong>RSS 远大于 WSS</strong>，说明有<strong>很多未使用的内存</strong>，可以优化资源分配。</li></ul><hr><p>🚀 <strong>总结</strong></p><ul><li><strong>RSS = 进程实际占用的物理内存</strong></li><li><strong>WSS = 进程活跃访问的内存</strong></li><li><strong>WSS &lt; RSS</strong>，因为 RSS 还包括未使用但驻留在物理内存中的部分。</li></ul><h2 id=监控四个黄金指标>监控四个黄金指标
<a class=anchor href=#%e7%9b%91%e6%8e%a7%e5%9b%9b%e4%b8%aa%e9%bb%84%e9%87%91%e6%8c%87%e6%a0%87>#</a></h2><p><strong>监控的四个黄金指标（Four Golden Signals）</strong> 是 Google SRE（Site Reliability Engineering）实践中提出的核心监控原则，用于衡量系统的健康状况和性能。这四个指标分别是：<strong>Latency（延迟）、Traffic（流量）、Errors（错误）、Saturation（饱和度）</strong>。</p><hr><h2 id=-1-latency延迟><strong>📌 1. Latency（延迟）</strong>
<a class=anchor href=#-1-latency%e5%bb%b6%e8%bf%9f>#</a></h2><p><strong>定义</strong>：指请求从发出到收到响应的时间，包括：</p><ul><li><strong>成功请求的延迟（成功响应时间）</strong></li><li><strong>失败请求的延迟（错误响应时间）</strong></li></ul><p><strong>监控方式</strong>：</p><ul><li>P99/P95/P50（百分位）延迟：<ul><li>P99 延迟：最慢的 1% 请求的响应时间，代表最差用户体验</li><li>P95 延迟：最慢的 5% 请求</li><li>P50 延迟（中位数）：一半请求的延迟情况</li></ul></li><li><strong>区分正常请求和失败请求的延迟</strong></li><li><strong>监控 HTTP/gRPC 响应时间</strong></li></ul><p><strong>Prometheus 监控示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[5m]))</span>
</span></span></code></pre></div><hr><h2 id=-2-traffic流量><strong>📌 2. Traffic（流量）</strong>
<a class=anchor href=#-2-traffic%e6%b5%81%e9%87%8f>#</a></h2><p><strong>定义</strong>：系统的请求速率或带宽使用情况，反映了负载。</p><p><strong>监控方式</strong>：</p><ul><li><p>HTTP/gRPC 请求数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>rate(http_requests_total[5m])</span>
</span></span></code></pre></div></li><li><p>吞吐量（TPS/QPS）：</p><ul><li>TPS（Transaction Per Second）：事务处理速率</li><li>QPS（Query Per Second）：查询速率</li></ul></li><li><p>带宽监控（流量大小）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>rate(node_network_receive_bytes_total[5m])</span>
</span></span></code></pre></div></li></ul><hr><h2 id=-3-errors错误率><strong>📌 3. Errors（错误率）</strong>
<a class=anchor href=#-3-errors%e9%94%99%e8%af%af%e7%8e%87>#</a></h2><p><strong>定义</strong>：请求失败率或错误数，衡量系统的健康状况。</p><p><strong>监控方式</strong>：</p><ul><li><p>HTTP 5xx 错误率</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>rate(http_requests_total{status=~&#34;5..&#34;}[5m]) / rate(http_requests_total[5m])</span>
</span></span></code></pre></div></li><li><p><strong>gRPC 错误码分布</strong></p></li><li><p><strong>应用级错误，如数据库查询失败</strong></p></li><li><p><strong>Kubernetes 事件、OOM（Out Of Memory）监控</strong></p></li></ul><hr><h2 id=-4-saturation饱和度><strong>📌 4. Saturation（饱和度）</strong>
<a class=anchor href=#-4-saturation%e9%a5%b1%e5%92%8c%e5%ba%a6>#</a></h2><p><strong>定义</strong>：系统资源的利用率，衡量瓶颈是否出现。</p><p><strong>监控方式</strong>：</p><ul><li><p>CPU 利用率</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>rate(node_cpu_seconds_total{mode=&#34;user&#34;}[5m]) / sum(rate(node_cpu_seconds_total[5m]))</span>
</span></span></code></pre></div></li><li><p>内存使用率</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>node_memory_Active_bytes / node_memory_MemTotal_bytes</span>
</span></span></code></pre></div></li><li><p>磁盘 I/O</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>rate(node_disk_read_bytes_total[5m])</span>
</span></span></code></pre></div></li><li><p>网络带宽</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>rate(node_network_transmit_bytes_total[5m])</span>
</span></span></code></pre></div></li></ul><hr><h2 id=-总结-1><strong>📌 总结</strong>
<a class=anchor href=#-%e6%80%bb%e7%bb%93-1>#</a></h2><table><thead><tr><th>指标</th><th>解释</th><th>监控方式</th></tr></thead><tbody><tr><td><strong>Latency（延迟）</strong></td><td>请求处理时间</td><td>HTTP 响应时间、P99 延迟</td></tr><tr><td><strong>Traffic（流量）</strong></td><td>请求量、带宽</td><td>QPS、TPS、网络流量</td></tr><tr><td><strong>Errors（错误率）</strong></td><td>失败请求占比</td><td>HTTP 5xx、gRPC 错误率</td></tr><tr><td><strong>Saturation（饱和度）</strong></td><td>资源利用率</td><td>CPU、内存、磁盘 I/O</td></tr></tbody></table><p>🚀 <strong>最佳实践</strong></p><ul><li>结合 Prometheus + Grafana 进行可视化监控</li><li>设定告警阈值，及时发现异常</li><li>使用 <strong>百分位（P99/P95）</strong> 衡量用户体验</li><li>结合 <strong>自动扩缩容（HPA/VPA）</strong> 进行优化</li></ul><p>这些指标可以帮助 SRE/DevOps 工程师快速识别系统瓶颈，提升稳定性！💪</p><h2 id=在大规模环境下如何优化prometheus性能>在大规模环境下，如何优化Prometheus性能
<a class=anchor href=#%e5%9c%a8%e5%a4%a7%e8%a7%84%e6%a8%a1%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96prometheus%e6%80%a7%e8%83%bd>#</a></h2><p>在大规模环境下，Prometheus 的性能优化非常重要，因为随着监控数据量的增加，Prometheus 可能会面临存储和查询延迟等问题。以下是一些常见的优化方法，可以帮助提升 Prometheus 的性能和可扩展性：</p><h3 id=1-分布式架构设计><strong>1. 分布式架构设计</strong>
<a class=anchor href=#1-%e5%88%86%e5%b8%83%e5%bc%8f%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1>#</a></h3><p>在大规模环境中，单个 Prometheus 实例可能无法承载庞大的监控数据量。因此，采用分布式架构进行水平扩展是非常重要的。</p><ul><li><p><strong>使用 Prometheus 高可用性架构</strong>：通过多个 Prometheus 实例来提高容错能力和扩展性。可以通过 <strong>Prometheus Federation（联邦）</strong> 或 <strong>Thanos</strong>、<strong>Cortex</strong> 等工具来实现数据的聚合和跨集群查询。</p></li><li><p><strong>Federation（联邦）</strong>：Prometheus 的联邦模式允许你在多个 Prometheus 实例间聚合数据。主 Prometheus 实例从子实例中拉取部分数据，提供全局视图。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;federation&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>scrape_interval</span>: <span style=color:#ae81ff>1m</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>honor_labels</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>static_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>targets</span>:
</span></span><span style=display:flex><span>        - <span style=color:#e6db74>&#39;prometheus-01:9090&#39;</span>
</span></span><span style=display:flex><span>        - <span style=color:#e6db74>&#39;prometheus-02:9090&#39;</span>
</span></span></code></pre></div></li><li><p><strong>Thanos 或 Cortex</strong>：它们是 Prometheus 的扩展系统，通过将数据分片和存储在外部对象存储中，提供更好的扩展性和长期存储。</p></li></ul><hr><h3 id=2-数据存储优化><strong>2. 数据存储优化</strong>
<a class=anchor href=#2-%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e4%bc%98%e5%8c%96>#</a></h3><p>存储是 Prometheus 性能瓶颈的关键因素之一。通过合理配置存储系统，可以有效提高 Prometheus 性能。</p><ul><li><p><strong>调整 Retention 时间</strong>：减少数据保留时间，特别是在不需要存储历史数据时。例如，设置较短的 <code>--storage.tsdb.retention.time</code> 来控制保留的数据时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>--<span style=color:#ae81ff>storage.tsdb.retention.time=15d</span>
</span></span></code></pre></div></li><li><p><strong>调整 Block 大小</strong>：默认情况下，Prometheus 会将数据分为多个块（blocks），每个块默认大小为 2GB。你可以根据需求调整 <code>--storage.tsdb.block-duration</code> 参数，以增加或减少每个块的大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>--<span style=color:#ae81ff>storage.tsdb.block-duration=2h</span>
</span></span></code></pre></div></li><li><p><strong>使用 SSD 存储</strong>：将 Prometheus 数据存储放在 SSD 上可以显著提高查询性能，特别是在写入和查询负载较高的情况下。</p></li><li><p><strong>适当调整 WAL（Write-Ahead Log）设置</strong>：通过配置 Prometheus 的写前日志，可以减少磁盘 IO 操作的次数，提高写入性能。</p></li></ul><hr><h3 id=3-查询优化><strong>3. 查询优化</strong>
<a class=anchor href=#3-%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96>#</a></h3><p>对于大规模的环境，Prometheus 查询的效率至关重要。通过优化查询，减少高开销查询的次数，可以大大提高性能。</p><ul><li><p><strong>避免高时间范围的查询</strong>：查询过长时间范围的数据会增加查询负载，应尽量避免一次性查询过多时间的数据。</p></li><li><p><strong>分片查询（Subqueries）</strong>：通过分割复杂查询为多个较小的查询来避免性能瓶颈，分片查询可以减轻数据库负载。</p></li><li><p><strong>预计算和聚合</strong>：使用 <strong>Recording Rules</strong> 来提前计算和存储某些常见的聚合数据，以减少查询时的计算压力。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>rule_files</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;recording_rules.yml&#34;</span>
</span></span></code></pre></div></li><li><p><strong>查询缓存</strong>：使用 <strong>Prometheus Query Caching</strong> 来缓存热点查询的结果，避免重复计算。</p></li></ul><hr><h3 id=4-调整-scrape-配置><strong>4. 调整 Scrape 配置</strong>
<a class=anchor href=#4-%e8%b0%83%e6%95%b4-scrape-%e9%85%8d%e7%bd%ae>#</a></h3><p>Prometheus 的拉取频率和数据量也会影响性能。调整采集（scrape）配置，可以有效减少负载。</p><ul><li><p><strong>减少 Scrape 频率</strong>：根据需求适当增加 <code>scrape_interval</code>，尤其是对于不需要实时更新的指标，可以设置较长的间隔时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;my_job&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>scrape_interval</span>: <span style=color:#ae81ff>60s </span> <span style=color:#75715e># 默认为 15s</span>
</span></span></code></pre></div></li><li><p><strong>使用采集过滤</strong>：通过过滤不需要的指标，减少 Prometheus 拉取的数据量。例如，可以通过 <code>metric_relabel_configs</code> 来排除不必要的指标。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>metric_relabel_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>source_labels</span>: [<span style=color:#ae81ff>__name__]</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>regex</span>: <span style=color:#e6db74>&#39;.*_unused_metric&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>action</span>: <span style=color:#ae81ff>drop</span>
</span></span></code></pre></div></li><li><p><strong>增加 Target 数量</strong>：在大规模环境下，确保 Prometheus 足够强大以处理多个 target 的数据拉取，可以通过 <code>scrape_timeout</code> 和 <code>scrape_interval</code> 配置来平衡拉取数据的速率。</p></li></ul><hr><h3 id=5-使用-external-storage><strong>5. 使用 External Storage</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8-external-storage>#</a></h3><p>对于长期存储需求较高的环境，可以将 Prometheus 数据存储迁移到外部存储系统，如 <strong>Thanos</strong>、<strong>Cortex</strong> 等，以减轻 Prometheus 的存储压力。</p><ul><li><strong>Thanos / Cortex</strong>：将 Prometheus 数据流式存储到外部对象存储（如 S3、GCS）中，并且提供查询和数据持久化功能。通过这种方式，Prometheus 仅需要处理当前的监控数据，减少存储负担。</li><li><strong>Prometheus + InfluxDB</strong>：将长期存储的指标数据迁移到 InfluxDB 或其他时间序列数据库，以便 Prometheus 专注于短期内的指标查询。</li></ul><hr><h3 id=6-优化-alerting-和-rules><strong>6. 优化 Alerting 和 Rules</strong>
<a class=anchor href=#6-%e4%bc%98%e5%8c%96-alerting-%e5%92%8c-rules>#</a></h3><p>Prometheus 中的告警规则和记录规则可能会带来性能压力。通过优化告警规则和减轻告警的计算负担，可以提高性能。</p><ul><li><p><strong>优化 Alerting 规则</strong>：避免过于复杂的告警条件，减少不必要的计算。例如，避免每个时刻都触发的告警，可以设定更高的阈值。</p></li><li><p><strong>减少告警频率</strong>：使用 <code>for</code> 参数，避免因临时波动触发过多告警。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>HighErrorRate</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>rate(http_requests_total{status=&#34;500&#34;}[5m]) &gt; 0.05</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>for</span>: <span style=color:#ae81ff>10m </span> <span style=color:#75715e># 在 10 分钟内持续触发告警才有效</span>
</span></span></code></pre></div></li></ul><hr><h3 id=7-高可用和负载均衡><strong>7. 高可用和负载均衡</strong>
<a class=anchor href=#7-%e9%ab%98%e5%8f%af%e7%94%a8%e5%92%8c%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1>#</a></h3><p>在大规模部署中，确保 Prometheus 的高可用性非常重要。可以采用以下方案：</p><ul><li><strong>使用多个 Prometheus 实例</strong>：分布式部署多个 Prometheus 实例，提高数据的采集能力。</li><li><strong>负载均衡</strong>：通过负载均衡器来分担 Prometheus 采集目标（targets）的负载。</li></ul><hr><h3 id=总结-4><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-4>#</a></h3><p>优化 Prometheus 性能时，要从存储、查询、采集配置等多个方面入手。针对大规模环境，采用分布式架构（如 Federation、Thanos 或 Cortex）、优化存储（SSD、Retain 设置）、合理配置查询和采集策略、使用外部存储等都可以有效提升性能。同时，监控系统的高可用性也是确保稳定运行的关键。</p><h2 id=如何实现告警的自动化响应>如何实现告警的自动化响应☆
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%91%8a%e8%ad%a6%e7%9a%84%e8%87%aa%e5%8a%a8%e5%8c%96%e5%93%8d%e5%ba%94>#</a></h2><p>实现告警的自动化响应是 DevOps 和 SRE（Site Reliability Engineering）实践中的一个重要组成部分，能够在问题发生时快速采取行动，减少手动干预和响应时间。以下是实现告警自动化响应的一些方法和最佳实践：</p><h3 id=1-使用-prometheus--alertmanager-配置告警自动化响应><strong>1. 使用 Prometheus + Alertmanager 配置告警自动化响应</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-prometheus--alertmanager-%e9%85%8d%e7%bd%ae%e5%91%8a%e8%ad%a6%e8%87%aa%e5%8a%a8%e5%8c%96%e5%93%8d%e5%ba%94>#</a></h3><p>Prometheus 与 Alertmanager 配合使用是最常见的告警系统。在告警触发后，Alertmanager 可以根据配置将告警发送到指定的接收器（如电子邮件、Slack、Webhook 等）。可以在告警通知中集成自动化响应流程。</p><h4 id=步骤><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4>#</a></h4><ol><li><p><strong>设置 Prometheus 告警规则</strong>：首先，设置告警规则，用于检测异常情况。比如，当 CPU 使用率超过某个阈值时触发告警。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>groups</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>HighCpuUsage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>avg(rate(cpu_usage_seconds_total[1m])) by (instance) &gt; 0.9</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>for</span>: <span style=color:#ae81ff>5m</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>critical</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>summary</span>: <span style=color:#e6db74>&#34;CPU usage is high on {{ $labels.instance }}&#34;</span>
</span></span></code></pre></div></li><li><p><strong>配置 Alertmanager</strong>：配置 Alertmanager 来处理告警并将其发送到不同的通知渠道。告警可以触发 Slack、PagerDuty 或 Webhook 等自动化响应机制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>route</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>group_by</span>: [<span style=color:#e6db74>&#39;alertname&#39;</span>]
</span></span><span style=display:flex><span>  <span style=color:#f92672>receiver</span>: <span style=color:#e6db74>&#39;slack&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>receivers</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#39;slack&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>slack_configs</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>api_url</span>: <span style=color:#e6db74>&#39;https://slack.com/api/alerts&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>channel</span>: <span style=color:#e6db74>&#39;#alerts&#39;</span>
</span></span></code></pre></div></li><li><p><strong>Webhook 集成</strong>：为了实现告警的自动化响应，可以通过配置 Alertmanager 的 Webhook 接收器来触发自定义的自动化响应脚本或外部工具。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>receivers</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#39;webhook-receiver&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>webhook_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>url</span>: <span style=color:#e6db74>&#39;http://your-service.example.com/alert&#39;</span>
</span></span></code></pre></div></li><li><p><strong>自动化响应</strong>：在告警触发时，Webhook 会通知指定的 URL。你可以编写一个 Web 服务来接收这些 Webhook 通知，并根据告警信息自动执行响应操作，例如：</p><ul><li>自动重启故障的 Pod 或服务</li><li>调整负载均衡配置</li><li>执行一组修复脚本</li></ul></li></ol><h3 id=2-集成自动化工具如-ansibleterraform进行响应><strong>2. 集成自动化工具（如 Ansible、Terraform）进行响应</strong>
<a class=anchor href=#2-%e9%9b%86%e6%88%90%e8%87%aa%e5%8a%a8%e5%8c%96%e5%b7%a5%e5%85%b7%e5%a6%82-ansibleterraform%e8%bf%9b%e8%a1%8c%e5%93%8d%e5%ba%94>#</a></h3><p>在一些情况下，可能需要执行更复杂的操作，如扩展基础设施或执行修复操作。可以使用工具如 <strong>Ansible</strong> 或 <strong>Terraform</strong> 来实现自动化响应。</p><h4 id=步骤-1><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-1>#</a></h4><ol><li><p><strong>配置告警触发 Webhook</strong>：将 Alertmanager 配置为触发 Webhook。</p></li><li><p><strong>编写自动化响应脚本</strong>：创建一个接收告警 Webhook 的 HTTP 服务，解析告警信息，并根据不同的告警类型执行相应的自动化操作。例如，使用 Ansible 运行修复脚本或扩容命令。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> json
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> subprocess
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> flask <span style=color:#f92672>import</span> Flask, request
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/alert&#39;</span>, methods<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;POST&#39;</span>])
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>alert</span>():
</span></span><span style=display:flex><span>    alert_data <span style=color:#f92672>=</span> json<span style=color:#f92672>.</span>loads(request<span style=color:#f92672>.</span>data)
</span></span><span style=display:flex><span>    <span style=color:#75715e># 根据告警类型执行不同的操作</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> alert_data[<span style=color:#e6db74>&#39;alertname&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;HighCpuUsage&#39;</span>:
</span></span><span style=display:flex><span>        subprocess<span style=color:#f92672>.</span>call([<span style=color:#e6db74>&#34;ansible-playbook&#34;</span>, <span style=color:#e6db74>&#34;fix-cpu-issue.yml&#34;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> alert_data[<span style=color:#e6db74>&#39;alertname&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;HighMemoryUsage&#39;</span>:
</span></span><span style=display:flex><span>        subprocess<span style=color:#f92672>.</span>call([<span style=color:#e6db74>&#34;ansible-playbook&#34;</span>, <span style=color:#e6db74>&#34;fix-memory-issue.yml&#34;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;OK&#39;</span>, <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>run(debug<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>5000</span>)
</span></span></code></pre></div></li><li><p><strong>通过 Ansible 执行操作</strong>：在告警触发时，自动运行 Ansible Playbook 来修复问题。例如，重新启动服务或扩展容器副本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Restart High CPU Service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>localhost</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tasks</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Restart Pod</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>kubernetes.core.k8s</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>state</span>: <span style=color:#ae81ff>restarted</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kubeconfig</span>: <span style=color:#ae81ff>/path/to/kubeconfig</span>
</span></span></code></pre></div></li><li><p><strong>自动化扩容</strong>：在告警触发时，自动扩容应用服务，以应对更高的负载。可以使用 Terraform 来扩展基础设施资源，如 EC2 实例或 Kubernetes 节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_instance&#34; &#34;web&#34;</span> {
</span></span><span style=display:flex><span>  ami <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ami-0c55b159cbfafe1f0&#34;</span>
</span></span><span style=display:flex><span>  instance_type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;t2.micro&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h3 id=3-集成-chatops-进行自动化响应><strong>3. 集成 ChatOps 进行自动化响应</strong>
<a class=anchor href=#3-%e9%9b%86%e6%88%90-chatops-%e8%bf%9b%e8%a1%8c%e8%87%aa%e5%8a%a8%e5%8c%96%e5%93%8d%e5%ba%94>#</a></h3><p>ChatOps 通过将操作自动化与聊天工具（如 Slack、Microsoft Teams）集成，使得告警响应更加迅速且可追踪。</p><h4 id=步骤-2><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-2>#</a></h4><ol><li><p><strong>集成 Slack 和 Prometheus Alertmanager</strong>：通过 Alertmanager 配置 Slack 作为告警接收器。</p></li><li><p><strong>编写 ChatOps 命令</strong>：使用 Slack 的机器人（例如 <strong>Hubot</strong> 或 <strong>Lita</strong>）来监听告警，并根据预设命令自动执行响应操作。用户可以直接在聊天中输入命令，触发自动化脚本执行修复操作。</p><p><strong>示例命令</strong>：</p><ul><li><code>/restart pod my-app</code>：重启出现问题的 Pod</li><li><code>/scale up my-app</code>：扩展应用副本数</li></ul></li><li><p><strong>执行自动化操作</strong>：通过与 ChatOps 机器人集成的自动化脚本执行基础设施操作，例如自动扩展资源、重启故障节点等。</p></li></ol><h3 id=4-使用-kubernetes-operator-进行自动化修复><strong>4. 使用 Kubernetes Operator 进行自动化修复</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-kubernetes-operator-%e8%bf%9b%e8%a1%8c%e8%87%aa%e5%8a%a8%e5%8c%96%e4%bf%ae%e5%a4%8d>#</a></h3><p>Kubernetes Operator 是一种管理 Kubernetes 资源的模式，可以自动响应应用程序的故障。</p><h4 id=步骤-3><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-3>#</a></h4><ol><li><p><strong>创建自定义 Operator</strong>：开发一个自定义的 Operator，用于监控 Prometheus 告警并自动响应。Operator 监听特定的指标或告警，当某个阈值被触发时，自动采取行动。</p></li><li><p><strong>自动修复应用</strong>：例如，在某些指标超过阈值时，Operator 可以自动重启 Pod，或者增加副本数量，进行资源调度。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-app:latest</span>
</span></span></code></pre></div></li></ol><h3 id=5-使用-pagerdutyopsgenie-等工具的自动化响应><strong>5. 使用 PagerDuty、OpsGenie 等工具的自动化响应</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8-pagerdutyopsgenie-%e7%ad%89%e5%b7%a5%e5%85%b7%e7%9a%84%e8%87%aa%e5%8a%a8%e5%8c%96%e5%93%8d%e5%ba%94>#</a></h3><p>PagerDuty 和 OpsGenie 是常用的告警响应工具，可以配置自动化响应策略，如自动重启服务、扩容等。</p><h4 id=步骤-4><strong>步骤：</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-4>#</a></h4><ol><li><strong>集成告警通知</strong>：配置 Prometheus 或其他监控工具将告警发送到 PagerDuty、OpsGenie 等工具。</li><li><strong>自动化响应配置</strong>：这些工具支持通过 API 或自动化规则触发响应。可以配置自动创建事件并根据告警类型自动执行操作，如发送确认、执行故障修复等。</li></ol><hr><h3 id=总结-5><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-5>#</a></h3><p>实现告警的自动化响应需要根据不同的需求和工具链来设计。常见的方法包括：</p><ul><li>使用 <strong>Prometheus + Alertmanager</strong> 配置告警并集成 Webhook、Ansible、Terraform 等自动化工具。</li><li>通过 <strong>ChatOps</strong> 将告警响应与聊天工具集成。</li><li>使用 <strong>Kubernetes Operator</strong> 进行自定义的自动化修复。</li><li>使用告警管理工具（如 <strong>PagerDuty</strong> 或 <strong>OpsGenie</strong>）来响应告警。</li></ul><p>自动化响应不仅能够提高运维效率，还能确保在发生故障时迅速做出反应，减少业务影响。</p><h2 id=prometheus数据压缩和持久化实现原理>Prometheus数据压缩和持久化实现原理
<a class=anchor href=#prometheus%e6%95%b0%e6%8d%ae%e5%8e%8b%e7%bc%a9%e5%92%8c%e6%8c%81%e4%b9%85%e5%8c%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86>#</a></h2><p>Prometheus 是一个开源的监控系统，能够通过时序数据的方式进行数据采集、存储和查询。在 Prometheus 中，数据压缩和持久化是两个关键的设计问题，保证了系统能够高效地存储大量的时序数据。</p><h3 id=1-prometheus-数据存储架构><strong>1. Prometheus 数据存储架构</strong>
<a class=anchor href=#1-prometheus-%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e6%9e%b6%e6%9e%84>#</a></h3><p>Prometheus 主要使用本地磁盘存储时序数据，并且在存储和压缩数据时采用了一些技术来确保其性能和可扩展性。其数据存储分为以下几个部分：</p><ul><li><strong>Time Series Database（TSDB）</strong>：Prometheus 使用时序数据库存储时序数据。每个时间序列由一个唯一的标识符（即指标名称和标签组合）和一系列时间戳与数值对组成。</li><li><strong>块（Blocks）</strong>：Prometheus 的存储采用了块（Block）的方式，将数据按时间分块存储，每个块通常保存一个时间段的数据（例如两小时的数据）。块存储是压缩存储和持久化的基础。</li></ul><h3 id=2-数据存储与持久化原理><strong>2. 数据存储与持久化原理</strong>
<a class=anchor href=#2-%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e4%b8%8e%e6%8c%81%e4%b9%85%e5%8c%96%e5%8e%9f%e7%90%86>#</a></h3><h4 id=21-数据模型><strong>2.1. 数据模型</strong>
<a class=anchor href=#21-%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b>#</a></h4><p>在 Prometheus 中，数据以时间序列（Time Series）的形式进行存储。每个时间序列由以下几个部分组成：</p><ul><li><strong>Metric Name（指标名）</strong>：唯一标识一个时间序列的名称。</li><li><strong>Labels（标签）</strong>：用于标识该时间序列的额外维度（如 <code>instance</code>、<code>job</code> 等），标签是一个键值对（Key-Value），例如 <code>job="node_exporter"</code>。</li><li><strong>Timestamp（时间戳）</strong>：时间戳指示该数据点的时间，Prometheus 中的数据精度为毫秒级。</li><li><strong>Value（值）</strong>：每个时间戳对应的度量值。</li></ul><h4 id=22-数据写入过程><strong>2.2. 数据写入过程</strong>
<a class=anchor href=#22-%e6%95%b0%e6%8d%ae%e5%86%99%e5%85%a5%e8%bf%87%e7%a8%8b>#</a></h4><p>当 Prometheus 从目标端点抓取数据时，数据会按照时间序列的形式进行存储。每个时间序列的每个数据点都会包含一个时间戳和相应的数值。这些数据会被按块进行存储。</p><p>Prometheus 采用 <strong>时间分区（Time Partitioning）</strong> 和 <strong>块文件（Block Files）</strong> 方式进行存储。数据会被分为多个 <strong>块（Block）</strong>，每个块包含一定时间范围（如两个小时或更长时间）的数据。</p><h4 id=23-块存储结构><strong>2.3. 块存储结构</strong>
<a class=anchor href=#23-%e5%9d%97%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84>#</a></h4><p>Prometheus 存储的每个块（Block）都有一个固定的时间跨度，通常为 <strong>2小时</strong>。每个块都包含以下信息：</p><ul><li><strong>索引文件</strong>：记录了时间序列的元数据，例如标签和指标信息。</li><li><strong>数据文件</strong>：存储了每个时间序列的实际数据点，数据点按时间顺序排列。</li><li><strong>压缩文件</strong>：Prometheus 会对数据进行压缩，以减小存储空间。</li></ul><p>每个块在磁盘上表现为一个目录，包含多个压缩后的数据文件（如 <code>.tsdb</code> 文件）。这些块会按时间顺序依次存储，并且在一段时间后进行合并。</p><h4 id=24-数据压缩><strong>2.4. 数据压缩</strong>
<a class=anchor href=#24-%e6%95%b0%e6%8d%ae%e5%8e%8b%e7%bc%a9>#</a></h4><p>Prometheus 通过 <strong>WAL（Write Ahead Log）</strong> 和 <strong>TSDB（Time Series Database）</strong> 数据结构来实现高效的压缩和持久化。</p><ul><li><strong>WAL（Write-Ahead Log）</strong>：在写入数据时，Prometheus 会先将数据写入 WAL 文件，确保数据不丢失。WAL 文件通常存储在磁盘上，当达到一定的大小后，会将 WAL 中的数据合并到 TSDB 的块中。</li><li><strong>TSDB 数据结构</strong>：TSDB 是 Prometheus 的核心数据存储引擎，它将时间序列数据按块（Block）存储，并使用一种基于 <strong>LZ4 压缩算法</strong> 的方法对时间序列数据进行压缩。每个数据块会按照一定的时间间隔（如 2 小时）来创建，并且每个数据块会进行压缩存储。压缩后的数据占用的磁盘空间远小于原始数据。</li></ul><p>Prometheus 使用 <strong>chunk encoding</strong>（块编码）对时间序列数据进行存储和压缩，具体方法包括：</p><ul><li><strong>Delta Encoding</strong>（增量编码）：通过记录相邻两个值之间的差异来减少存储空间。</li><li><strong>Run-Length Encoding (RLE)</strong>：对连续相同的值进行编码，以节省存储。</li><li><strong>LZ4 Compression</strong>：在块级别上使用 LZ4 压缩算法对数据进行压缩。</li></ul><h4 id=25-数据块合并><strong>2.5. 数据块合并</strong>
<a class=anchor href=#25-%e6%95%b0%e6%8d%ae%e5%9d%97%e5%90%88%e5%b9%b6>#</a></h4><p>Prometheus 会定期进行块的合并（Compaction）操作。块合并的目的是减少存储占用和提高查询效率。合并过程会把小的时间段合并成一个大的时间段，压缩率进一步提高，同时减少了存储碎片。</p><p>Prometheus 会定期清理过期数据，可以通过 <code>--storage.tsdb.retention.time</code> 参数来配置数据的保留时间。</p><h3 id=3-数据压缩与持久化的实现原理总结><strong>3. 数据压缩与持久化的实现原理总结</strong>
<a class=anchor href=#3-%e6%95%b0%e6%8d%ae%e5%8e%8b%e7%bc%a9%e4%b8%8e%e6%8c%81%e4%b9%85%e5%8c%96%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong>时间序列数据结构</strong>：Prometheus 存储时序数据时，每个时间序列有唯一的标签组合和数值。</li><li><strong>块存储机制</strong>：数据按时间切分成多个块，每个块存储一定时间段的数据，通常为 2 小时。</li><li><strong>压缩算法</strong>：使用增量编码（Delta Encoding）、游程长度编码（Run-Length Encoding）以及 LZ4 压缩算法对数据进行压缩，减少存储空间。</li><li><strong>合并与清理</strong>：定期合并小的块并清理过期数据，确保存储空间的高效利用。</li><li><strong>WAL 日志</strong>：写操作首先记录到 WAL，确保数据不会丢失，然后再写入 TSDB 块中。</li></ul><h3 id=4-持久化存储><strong>4. 持久化存储</strong>
<a class=anchor href=#4-%e6%8c%81%e4%b9%85%e5%8c%96%e5%ad%98%e5%82%a8>#</a></h3><p>Prometheus 的数据持久化是基于本地磁盘的，数据会以块的形式进行存储，并且会进行定期的压缩和合并。数据的持久化时间可以通过配置文件进行设置。通常，Prometheus 的存储引擎是有限制的，适合中小型监控集群。</p><p>对于大规模环境，可能需要使用外部存储系统（如 <strong>Thanos</strong> 或 <strong>Cortex</strong>）来实现分布式存储和长期持久化。</p><h2 id=kubectl-top输出与linux-free命令不一致原因>kubectl top输出与Linux free命令不一致原因☆
<a class=anchor href=#kubectl-top%e8%be%93%e5%87%ba%e4%b8%8elinux-free%e5%91%bd%e4%bb%a4%e4%b8%8d%e4%b8%80%e8%87%b4%e5%8e%9f%e5%9b%a0>#</a></h2><p><code>kubectl top</code> 和 Linux <code>free</code> 命令在输出上可能会有所不同，主要原因在于它们获取和显示的资源数据来源、计算方式和覆盖范围不同。具体来说：</p><h3 id=1-数据来源的差异><strong>1. 数据来源的差异</strong>
<a class=anchor href=#1-%e6%95%b0%e6%8d%ae%e6%9d%a5%e6%ba%90%e7%9a%84%e5%b7%ae%e5%bc%82>#</a></h3><ul><li><strong><code>kubectl top</code></strong>:<ul><li><code>kubectl top</code> 是 Kubernetes 的监控命令，主要通过 <strong>metrics-server</strong> 或 <strong>Prometheus</strong> 等监控工具提供集群的资源使用情况。它显示的是每个 Pod、节点、容器等在 Kubernetes 集群中的资源使用情况（如 CPU、内存等）。</li><li><strong>CPU 使用情况</strong> 是基于 Kubernetes 中的容器实际请求和分配的资源数据。</li><li><strong>内存使用情况</strong> 是基于容器在运行时的实际内存使用量（容器分配的内存可能不完全等于其实际使用的内存）。</li></ul></li><li><strong><code>free</code> 命令</strong>:<ul><li><code>free</code> 是 Linux 系统的标准命令，用于显示操作系统层面的内存使用情况。它显示的是整个操作系统级别的内存使用状态，包括系统内存（RAM）、交换内存（Swap）等。</li><li><code>free</code> 命令报告的是整个机器上的物理内存和虚拟内存的使用情况，而不考虑容器或 Kubernetes 环境中的资源隔离。</li></ul></li></ul><h3 id=2-资源的计算方式><strong>2. 资源的计算方式</strong>
<a class=anchor href=#2-%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%a1%e7%ae%97%e6%96%b9%e5%bc%8f>#</a></h3><ul><li><p><strong><code>kubectl top</code></strong>:</p><ul><li><strong>CPU</strong>：<code>kubectl top</code> 显示的是容器实际消耗的 CPU 资源，通常以 <strong>millicores</strong>（mCPU）为单位（例如 500m 表示 0.5 核）。</li><li><strong>内存</strong>：它显示的是容器实际使用的内存量，不包括系统内存中的缓存和缓冲区。容器的内存消耗可能与它所请求的内存有所不同。</li></ul></li><li><p><strong><code>free</code> 命令</strong>：</p><ul><li><p>物理内存：</p><pre tabindex=0><code>free
</code></pre><p>显示的是操作系统级别的内存使用情况，通常会报告</p><pre tabindex=0><code>used
</code></pre><p>、</p><pre tabindex=0><code>free
</code></pre><p>、</p><pre tabindex=0><code>buffers
</code></pre><p>、</p><pre tabindex=0><code>cached
</code></pre><p>等字段。</p><ul><li><code>used</code>：已使用的内存，包括系统缓存和缓冲区的内存。</li><li><code>free</code>：空闲的内存。</li><li><code>buffers/cache</code>：用于缓存文件和 I/O 操作的内存。</li></ul></li><li><p><strong>交换空间（Swap）</strong>：<code>free</code> 还显示了交换空间的使用情况，这与容器的内存使用无关。</p></li></ul></li></ul><h3 id=3-资源隔离和容器化><strong>3. 资源隔离和容器化</strong>
<a class=anchor href=#3-%e8%b5%84%e6%ba%90%e9%9a%94%e7%a6%bb%e5%92%8c%e5%ae%b9%e5%99%a8%e5%8c%96>#</a></h3><p>在 Kubernetes 环境中，容器的资源限制是与主机系统资源进行隔离的。每个容器（或 Pod）可以有自己的 CPU、内存限制和请求。<code>kubectl top</code> 是基于这些限制和容器实际消耗的资源来报告的。</p><p>而 <code>free</code> 命令显示的是整个系统级别的内存使用情况，不会区分容器之间的资源消耗。所以，<code>kubectl top</code> 中显示的内存和 CPU 使用量是基于容器内的使用情况，而 <code>free</code> 命令显示的是操作系统层面的资源使用，不区分容器之间的使用。</p><h3 id=4-汇总与显示的不同><strong>4. 汇总与显示的不同</strong>
<a class=anchor href=#4-%e6%b1%87%e6%80%bb%e4%b8%8e%e6%98%be%e7%a4%ba%e7%9a%84%e4%b8%8d%e5%90%8c>#</a></h3><ul><li><strong><code>kubectl top</code></strong>：是以 Pod、Node 或 Container 为单位显示资源使用情况。如果你查询的是 Pod 的资源使用情况，它将报告该 Pod 内所有容器的资源使用合计值，而这些容器的实际资源消耗和内存使用量是通过 Kubernetes 的监控组件（如 metrics-server）来汇报的。</li><li><strong><code>free</code> 命令</strong>：显示的是整个操作系统（包括主机、所有容器和所有进程）的内存使用情况，它的输出包括操作系统级别的内存总量和已使用、空闲、缓存等的详细情况。</li></ul><h3 id=总结-6><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-6>#</a></h3><p><code>kubectl top</code> 和 <code>free</code> 命令显示的数据来源和计算方式不同：</p><ul><li><code>kubectl top</code> 主要显示 Kubernetes 环境下的资源使用情况，依据容器的资源消耗。</li><li><code>free</code> 显示的是 Linux 系统层级的内存情况，包括操作系统的所有内存使用情况、缓存、缓冲区等。</li></ul><p>因此，<code>kubectl top</code> 和 <code>free</code> 输出不一致是因为它们的数据来源不同、计算方式不同以及所显示的资源范围不同。</p><h2 id=用到了哪些exporter功能是什么在-prometheus-监控中exporter-是一个重要的组件它用于从不同的应用或系统中收集指标并将这些指标以-prometheus-能够理解的格式暴露出来以下是一些常用的-prometheus-exporter-及其功能>用到了哪些exporter，功能是什么在 Prometheus 监控中，<strong>Exporter</strong> 是一个重要的组件，它用于从不同的应用或系统中收集指标，并将这些指标以 Prometheus 能够理解的格式暴露出来。以下是一些常用的 Prometheus Exporter 及其功能：
<a class=anchor href=#%e7%94%a8%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9bexporter%e5%8a%9f%e8%83%bd%e6%98%af%e4%bb%80%e4%b9%88%e5%9c%a8-prometheus-%e7%9b%91%e6%8e%a7%e4%b8%adexporter-%e6%98%af%e4%b8%80%e4%b8%aa%e9%87%8d%e8%a6%81%e7%9a%84%e7%bb%84%e4%bb%b6%e5%ae%83%e7%94%a8%e4%ba%8e%e4%bb%8e%e4%b8%8d%e5%90%8c%e7%9a%84%e5%ba%94%e7%94%a8%e6%88%96%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%94%b6%e9%9b%86%e6%8c%87%e6%a0%87%e5%b9%b6%e5%b0%86%e8%bf%99%e4%ba%9b%e6%8c%87%e6%a0%87%e4%bb%a5-prometheus-%e8%83%bd%e5%a4%9f%e7%90%86%e8%a7%a3%e7%9a%84%e6%a0%bc%e5%bc%8f%e6%9a%b4%e9%9c%b2%e5%87%ba%e6%9d%a5%e4%bb%a5%e4%b8%8b%e6%98%af%e4%b8%80%e4%ba%9b%e5%b8%b8%e7%94%a8%e7%9a%84-prometheus-exporter-%e5%8f%8a%e5%85%b6%e5%8a%9f%e8%83%bd>#</a></h2><h3 id=1-node-exporter>1. <strong>Node Exporter</strong>
<a class=anchor href=#1-node-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于收集操作系统级别的硬件和操作系统指标，涵盖 CPU、内存、磁盘、网络等基本资源的使用情况。</p></li><li><p>监控内容</p><p>：</p><ul><li>CPU 使用率</li><li>内存使用情况</li><li>磁盘使用情况（包括 I/O 速率、磁盘空间等）</li><li>网络流量</li><li>系统负载</li></ul></li><li><p><strong>适用场景</strong>：监控 Linux/Unix 系统的资源使用情况。</p></li></ul><h3 id=2-kube-state-metrics>2. <strong>kube-state-metrics</strong>
<a class=anchor href=#2-kube-state-metrics>#</a></h3><ul><li><p><strong>功能</strong>：用于从 Kubernetes 集群中收集关于 Kubernetes 资源的状态指标。不同于 <code>Node Exporter</code> 采集操作系统的指标，<code>kube-state-metrics</code> 采集的是 Kubernetes 资源（如 Pod、Deployment、ReplicaSet、StatefulSet、Node 等）的状态信息。</p></li><li><p>监控内容</p><p>：</p><ul><li>Pod 状态（运行、待启动、失败等）</li><li>Deployment 和 ReplicaSet 的副本数</li><li>节点状态（Ready、NotReady）</li><li>资源请求与限制</li></ul></li><li><p><strong>适用场景</strong>：监控 Kubernetes 集群的资源状态和健康状况。</p></li></ul><h3 id=3-cadvisor>3. <strong>cAdvisor</strong>
<a class=anchor href=#3-cadvisor>#</a></h3><ul><li><p><strong>功能</strong>：用于收集 Docker 容器的资源使用情况，提供 CPU、内存、磁盘 I/O、网络使用等容器级别的指标。</p></li><li><p>监控内容</p><p>：</p><ul><li>每个 Docker 容器的 CPU、内存使用情况</li><li>容器的网络流量</li><li>容器的磁盘 I/O</li><li>容器的生命周期事件（启动、停止等）</li></ul></li><li><p><strong>适用场景</strong>：监控 Docker 容器的资源消耗和性能。</p></li></ul><h3 id=4-blackbox-exporter>4. <strong>Blackbox Exporter</strong>
<a class=anchor href=#4-blackbox-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于通过黑盒方式（模拟用户行为）检查服务的可用性和响应时间。它支持 HTTP、HTTPS、DNS、TCP 等协议的健康检查。</p></li><li><p>监控内容</p><p>：</p><ul><li>HTTP/HTTPS 状态码监控</li><li>DNS 查询响应时间</li><li>TCP 端口的可达性</li></ul></li><li><p><strong>适用场景</strong>：检测外部服务的可用性，检查网站或其他网络服务的健康状态。</p></li></ul><h3 id=5-mysql-exporter>5. <strong>MySQL Exporter</strong>
<a class=anchor href=#5-mysql-exporter>#</a></h3><ul><li><p><strong>功能</strong>：专门用于收集 MySQL 数据库的指标，监控 MySQL 数据库的性能和健康状况。</p></li><li><p>监控内容</p><p>：</p><ul><li>数据库的查询性能</li><li>慢查询日志</li><li>数据库的连接数</li><li>数据库的缓存使用</li><li>磁盘 I/O 等</li></ul></li><li><p><strong>适用场景</strong>：监控 MySQL 数据库的性能，帮助诊断数据库性能瓶颈。</p></li></ul><h3 id=6-postgresql-exporter>6. <strong>PostgreSQL Exporter</strong>
<a class=anchor href=#6-postgresql-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于从 PostgreSQL 数据库中收集指标，类似于 MySQL Exporter，但专为 PostgreSQL 定制。</p></li><li><p>监控内容</p><p>：</p><ul><li>数据库的连接数</li><li>缓存和缓存命中率</li><li>活跃查询数量</li><li>数据库大小</li></ul></li><li><p><strong>适用场景</strong>：监控 PostgreSQL 数据库的性能和健康。</p></li></ul><h3 id=7-jmx-exporter>7. <strong>JMX Exporter</strong>
<a class=anchor href=#7-jmx-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于从 Java 应用中收集 JMX（Java Management Extensions）暴露的指标，适用于基于 Java 的应用，如 Kafka、Tomcat、JVM 等。</p></li><li><p>监控内容</p><p>：</p><ul><li>JVM 内存使用情况</li><li>垃圾回收统计</li><li>线程池使用情况</li><li>Kafka、Tomcat 等 Java 服务的性能指标</li></ul></li><li><p><strong>适用场景</strong>：监控 Java 应用和 JVM 的性能，尤其是在大规模生产环境中。</p></li></ul><h3 id=8-redis-exporter>8. <strong>Redis Exporter</strong>
<a class=anchor href=#8-redis-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于监控 Redis 数据库的性能和健康。</p></li><li><p>监控内容</p><p>：</p><ul><li>Redis 内存使用</li><li>命中率</li><li>锁和连接</li><li>键空间使用情况</li></ul></li><li><p><strong>适用场景</strong>：监控 Redis 数据库的性能，确保 Redis 运行健康。</p></li></ul><h3 id=9-mongodb-exporter>9. <strong>MongoDB Exporter</strong>
<a class=anchor href=#9-mongodb-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于监控 MongoDB 数据库的性能和状态。</p></li><li><p>监控内容</p><p>：</p><ul><li>数据库的连接数</li><li>查询性能</li><li>内存使用情况</li><li>复制集状态</li></ul></li><li><p><strong>适用场景</strong>：监控 MongoDB 数据库，诊断数据库性能问题。</p></li></ul><h3 id=10-elasticsearch-exporter>10. <strong>Elasticsearch Exporter</strong>
<a class=anchor href=#10-elasticsearch-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于从 Elasticsearch 集群中收集指标，监控 Elasticsearch 的健康和性能。</p></li><li><p>监控内容</p><p>：</p><ul><li>集群的健康状态</li><li>节点和索引的性能</li><li>文档数、查询性能等</li></ul></li><li><p><strong>适用场景</strong>：监控 Elasticsearch 集群，确保其高效运行。</p></li></ul><h3 id=11-nginx-exporter>11. <strong>Nginx Exporter</strong>
<a class=anchor href=#11-nginx-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于从 Nginx 服务器收集指标，帮助监控 Nginx 的性能。</p></li><li><p>监控内容</p><p>：</p><ul><li>Nginx 请求和响应数</li><li>Nginx 错误日志</li><li>Nginx 的连接数</li></ul></li><li><p><strong>适用场景</strong>：监控 Nginx 的负载和性能，诊断问题。</p></li></ul><h3 id=12-kafka-exporter>12. <strong>Kafka Exporter</strong>
<a class=anchor href=#12-kafka-exporter>#</a></h3><ul><li><p><strong>功能</strong>：用于监控 Kafka 集群的健康和性能。</p></li><li><p>监控内容</p><p>：</p><ul><li>消费者组和主题的偏移量</li><li>请求和响应延迟</li><li>磁盘和内存使用</li></ul></li><li><p><strong>适用场景</strong>：监控 Kafka 集群的健康状况，确保消息传递的高效性。</p></li></ul><h3 id=总结-7><strong>总结</strong>：
<a class=anchor href=#%e6%80%bb%e7%bb%93-7>#</a></h3><p>这些 Exporter 的共同目标是将各个系统、服务或应用的性能指标暴露给 Prometheus，以便对其进行监控和告警。通过合适的 Exporter，我们可以详细了解每个服务或系统的运行状态、资源使用情况和潜在问题，帮助运维人员做出及时响应和优化决策。</p><h2 id=是否自己开发过exporter>是否自己开发过exporter☆
<a class=anchor href=#%e6%98%af%e5%90%a6%e8%87%aa%e5%b7%b1%e5%bc%80%e5%8f%91%e8%bf%87exporter>#</a></h2><p>是的，我有开发过自定义 <strong>Exporter</strong> 的经验。在某些场景下，现有的 Prometheus Exporter 可能无法满足特定的监控需求，这时就需要开发一个自定义 Exporter 来暴露特定服务或应用的指标。</p><h3 id=自定义-exporter-开发的一般步骤>自定义 Exporter 开发的一般步骤：
<a class=anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89-exporter-%e5%bc%80%e5%8f%91%e7%9a%84%e4%b8%80%e8%88%ac%e6%ad%a5%e9%aa%a4>#</a></h3><ol><li><strong>选择语言和框架</strong>：常见的开发语言有 Go、Python、Java 等。Go 是官方推荐的语言，因为 Prometheus 本身就是用 Go 编写的，并且提供了官方的客户端库（<code>prometheus/client_golang</code>）。</li><li><strong>创建指标</strong>：<ul><li>使用 Prometheus 的客户端库来定义所需的指标（例如，计数器、直方图、摘要等）。</li><li>通过 Prometheus 提供的 <code>http.Handler</code> 向 Prometheus 暴露这些指标。</li></ul></li><li><strong>收集数据</strong>：<ul><li>通过代码收集系统或应用的特定数据（如应用的健康状态、性能指标等）。这通常涉及访问 API、日志文件或数据库等。</li></ul></li><li><strong>启动 HTTP 服务器</strong>：<ul><li>启动一个 HTTP 服务器，并监听 Prometheus 进行指标抓取的端口。</li></ul></li><li><strong>定期更新指标</strong>：<ul><li>可以通过定时任务（如 <code>time.Ticker</code>）定期更新或重新抓取需要监控的数据。</li></ul></li></ol><h3 id=示例用-go-开发一个简单的自定义-exporter>示例：用 Go 开发一个简单的自定义 Exporter
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e7%94%a8-go-%e5%bc%80%e5%8f%91%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e8%87%aa%e5%ae%9a%e4%b9%89-exporter>#</a></h3><p>这是一个简单的 Go 语言示例，创建了一个自定义的 <strong>Exporter</strong> 来监控一个假设的服务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/prometheus/client_golang/prometheus&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/prometheus/client_golang/prometheus/promhttp&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建一个自定义的指标</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>upGauge</span> = <span style=color:#a6e22e>prometheus</span>.<span style=color:#a6e22e>NewGaugeVec</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prometheus</span>.<span style=color:#a6e22e>GaugeOpts</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;my_service_up&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Help</span>: <span style=color:#e6db74>&#34;Indicates whether my service is up (1) or down (0).&#34;</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		[]<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;service_name&#34;</span>},
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 注册自定义指标</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>prometheus</span>.<span style=color:#a6e22e>MustRegister</span>(<span style=color:#a6e22e>upGauge</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>recordMetrics</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 模拟服务状态更新</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>upGauge</span>.<span style=color:#a6e22e>WithLabelValues</span>(<span style=color:#e6db74>&#34;my_service&#34;</span>).<span style=color:#a6e22e>Set</span>(<span style=color:#ae81ff>1</span>) <span style=color:#75715e>// 服务状态为 up</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>upGauge</span>.<span style=color:#a6e22e>WithLabelValues</span>(<span style=color:#e6db74>&#34;my_service&#34;</span>).<span style=color:#a6e22e>Set</span>(<span style=color:#ae81ff>0</span>) <span style=color:#75715e>// 服务状态为 down</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 启动一个 HTTP 服务，暴露 Prometheus 的指标</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/metrics&#34;</span>, <span style=color:#a6e22e>promhttp</span>.<span style=color:#a6e22e>Handler</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 开启服务状态的模拟</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>recordMetrics</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 启动 HTTP 服务器</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Starting custom exporter on :8080&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=关键点>关键点：
<a class=anchor href=#%e5%85%b3%e9%94%ae%e7%82%b9>#</a></h3><ul><li><strong>upGauge</strong> 是一个自定义的 <code>GaugeVec</code> 类型指标，用来表示服务是否可用。</li><li><code>recordMetrics</code> 函数模拟每 5 秒更新一次服务状态：服务处于 &ldquo;up&rdquo; 或 &ldquo;down&rdquo; 状态。</li><li><code>/metrics</code> 路径用于暴露 Prometheus 所需的指标。</li></ul><h3 id=开发过程中可能遇到的挑战>开发过程中可能遇到的挑战：
<a class=anchor href=#%e5%bc%80%e5%8f%91%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%8f%af%e8%83%bd%e9%81%87%e5%88%b0%e7%9a%84%e6%8c%91%e6%88%98>#</a></h3><ol><li><strong>数据源的访问问题</strong>：在自定义 Exporter 中，数据的收集源可能是数据库、API 或其他外部系统，访问这些数据源可能需要额外的权限或安全配置。</li><li><strong>性能问题</strong>：当需要频繁收集大量数据时，确保 Exporter 性能高效是非常重要的，否则可能对被监控服务造成影响。</li><li><strong>监控指标设计</strong>：设计好的指标对于后续的监控和告警非常关键，要确保指标具有可理解性、足够的细粒度，且符合 Prometheus 的最佳实践。</li></ol><p>开发自定义 Exporter 的关键是根据具体需求暴露合适的指标，并确保能够高效、稳定地运行。</p><h2 id=target-down的情况如何进行故障排除>target down的情况如何进行故障排除？
<a class=anchor href=#target-down%e7%9a%84%e6%83%85%e5%86%b5%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e6%95%85%e9%9a%9c%e6%8e%92%e9%99%a4>#</a></h2><p>当 Prometheus 报告某个 <strong>target down</strong>（目标不可达）时，意味着 Prometheus 无法从该目标抓取到数据。这种情况的故障排除可以通过以下几个步骤进行：</p><h3 id=1-检查-prometheus-日志>1. <strong>检查 Prometheus 日志</strong>
<a class=anchor href=#1-%e6%a3%80%e6%9f%a5-prometheus-%e6%97%a5%e5%bf%97>#</a></h3><ul><li>查看 Prometheus 的日志文件，以便识别是否有任何网络错误、身份验证失败或超时等信息。</li><li>日志中通常会给出详细的错误信息，例如：<ul><li>&ldquo;connection refused&rdquo;（拒绝连接）</li><li>&ldquo;timeout&rdquo;（超时）</li><li>&ldquo;authentication failure&rdquo;（认证失败）</li></ul></li></ul><h3 id=2-检查网络连接>2. <strong>检查网络连接</strong>
<a class=anchor href=#2-%e6%a3%80%e6%9f%a5%e7%bd%91%e7%bb%9c%e8%bf%9e%e6%8e%a5>#</a></h3><ul><li><p>Ping 目标服务</p><p>：首先确认 Prometheus 是否能够通过网络连接到目标机器或服务。使用</p><pre tabindex=0><code>ping
</code></pre><p>或</p><pre tabindex=0><code>telnet
</code></pre><p>测试与目标端口的连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ping &lt;target_host&gt;
</span></span><span style=display:flex><span>telnet &lt;target_host&gt; &lt;target_port&gt;
</span></span></code></pre></div></li><li><p><strong>防火墙和网络策略</strong>：确保 Prometheus 服务器与目标服务之间没有防火墙规则或网络策略阻止通信。检查防火墙设置，确保相应端口（通常是 80/443 或 Prometheus 的抓取端口）是开放的。</p></li></ul><h3 id=3-检查目标服务状态>3. <strong>检查目标服务状态</strong>
<a class=anchor href=#3-%e6%a3%80%e6%9f%a5%e7%9b%ae%e6%a0%87%e6%9c%8d%e5%8a%a1%e7%8a%b6%e6%80%81>#</a></h3><ul><li><p>如果目标服务是一个 Web 服务或应用程序，确保它正在运行并且能够正常响应请求。</p><ul><li><p>Web 服务</p><p>：可以直接在浏览器中或使用</p><pre tabindex=0><code>curl
</code></pre><p>请求目标服务的</p><pre tabindex=0><code>/metrics
</code></pre><p>端点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl http://&lt;target_host&gt;:&lt;port&gt;/metrics
</span></span></code></pre></div></li><li><p><strong>服务健康检查</strong>：如果目标服务提供健康检查 API，先检查健康状态是否正常。</p></li></ul></li></ul><h3 id=4-检查目标端点的配置>4. <strong>检查目标端点的配置</strong>
<a class=anchor href=#4-%e6%a3%80%e6%9f%a5%e7%9b%ae%e6%a0%87%e7%ab%af%e7%82%b9%e7%9a%84%e9%85%8d%e7%bd%ae>#</a></h3><ul><li>确保 Prometheus 配置文件中的抓取端点是正确的，特别是 URL 和端口。如果 URL 或端口配置错误，Prometheus 将无法抓取数据。</li><li>检查 <code>scrape_configs</code> 部分，确保目标服务的地址和端口正确，并且没有拼写错误或格式问题。</li></ul><h3 id=5-目标服务的负载问题>5. <strong>目标服务的负载问题</strong>
<a class=anchor href=#5-%e7%9b%ae%e6%a0%87%e6%9c%8d%e5%8a%a1%e7%9a%84%e8%b4%9f%e8%bd%bd%e9%97%ae%e9%a2%98>#</a></h3><ul><li>如果目标服务在高负载下，可能会导致响应时间过长，从而导致 Prometheus 无法及时抓取数据。检查目标服务的负载和性能指标（如 CPU、内存使用率等），并进行优化。</li><li><strong>资源不足</strong>：检查目标机器的资源使用情况（例如 CPU、内存、磁盘 I/O），如果负载过高，可能会导致响应超时或服务中断。</li></ul><h3 id=6-身份验证问题>6. <strong>身份验证问题</strong>
<a class=anchor href=#6-%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e9%97%ae%e9%a2%98>#</a></h3><ul><li>如果目标服务需要身份验证（如 HTTP 基本认证、OAuth 等），确保 Prometheus 配置文件中正确设置了身份验证信息。</li><li>在 Prometheus 配置文件的 <code>scrape_configs</code> 部分中，检查是否需要添加身份验证的 <code>basic_auth</code> 或 <code>bearer_token</code> 等参数。</li></ul><h3 id=7-检查-prometheus-配置文件>7. <strong>检查 Prometheus 配置文件</strong>
<a class=anchor href=#7-%e6%a3%80%e6%9f%a5-prometheus-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h3><ul><li>确保 <code>scrape_interval</code> 配置合理。如果抓取间隔太短，目标可能无法及时响应，导致抓取失败。适当增大抓取间隔，以避免过度的压力。</li><li>还要检查是否设置了 <strong>scrape_timeout</strong>，如果目标响应超时，可能会导致 <code>target down</code>。</li></ul><h3 id=8-查看-prometheus-目标状态>8. <strong>查看 Prometheus 目标状态</strong>
<a class=anchor href=#8-%e6%9f%a5%e7%9c%8b-prometheus-%e7%9b%ae%e6%a0%87%e7%8a%b6%e6%80%81>#</a></h3><ul><li>在 Prometheus 的 Web UI 中，访问 <code>Status -> Targets</code> 页面，查看目标的状态、最后一次抓取的时间和任何错误信息。</li><li>目标页面通常会显示一些详细的错误信息，帮助你进一步诊断问题。例如，是否存在 &ldquo;http_errors&rdquo; 或 &ldquo;timeouts&rdquo;。</li></ul><h3 id=9-重启-prometheus>9. <strong>重启 Prometheus</strong>
<a class=anchor href=#9-%e9%87%8d%e5%90%af-prometheus>#</a></h3><ul><li>如果所有设置看起来都正确，但 Prometheus 仍然无法连接到目标服务，可以尝试重启 Prometheus。这有时可以解决与网络连接或服务状态相关的临时问题。</li></ul><h3 id=10-目标端服务日志>10. <strong>目标端服务日志</strong>
<a class=anchor href=#10-%e7%9b%ae%e6%a0%87%e7%ab%af%e6%9c%8d%e5%8a%a1%e6%97%a5%e5%bf%97>#</a></h3><ul><li>查看目标服务的日志文件，检查是否有任何与 Prometheus 抓取相关的错误或警告信息。</li><li>如果目标服务暴露在容器或虚拟机中，确保该容器或虚拟机运行正常且没有资源瓶颈。</li></ul><h3 id=故障排除示例>故障排除示例：
<a class=anchor href=#%e6%95%85%e9%9a%9c%e6%8e%92%e9%99%a4%e7%a4%ba%e4%be%8b>#</a></h3><p>假设 Prometheus 显示一个目标为 <strong>down</strong>，你可以通过以下步骤进行排查：</p><ol><li>在 Prometheus UI 中查看目标的详细信息，发现错误信息为 <code>connection refused</code>。</li><li>使用 <code>telnet</code> 测试与目标端口的连接，发现连接不上。</li><li>检查目标服务的状态，发现目标服务未启动，尝试重启目标服务。</li><li>再次查看 Prometheus UI，发现目标状态变为 <strong>up</strong>，问题解决。</li></ol><h3 id=总结-8>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-8>#</a></h3><p>解决 <code>target down</code> 问题通常涉及以下几个方面的检查：</p><ol><li>网络连接和防火墙。</li><li>目标服务的可用性。</li><li>Prometheus 配置和抓取端点。</li><li>目标服务的负载和身份验证。</li></ol><p>通过有序的排查，你应该能够找出并解决目标服务无法抓取的根本原因。</p><h2 id=exporter-停止工作如何监控>Exporter 停止工作，如何监控？
<a class=anchor href=#exporter-%e5%81%9c%e6%ad%a2%e5%b7%a5%e4%bd%9c%e5%a6%82%e4%bd%95%e7%9b%91%e6%8e%a7>#</a></h2><p>监控 <strong>Exporter</strong> 停止工作是确保系统可靠性和健康的关键步骤。Exporter 停止工作时，Prometheus 无法抓取指标，这会影响你的监控和报警系统。因此，监控 Exporter 本身的健康状态也是至关重要的。以下是一些监控 Exporter 停止工作的方法：</p><h3 id=1-prometheus-自身的监控>1. <strong>Prometheus 自身的监控</strong>
<a class=anchor href=#1-prometheus-%e8%87%aa%e8%ba%ab%e7%9a%84%e7%9b%91%e6%8e%a7>#</a></h3><ul><li><p>Target 状态</p><p>：Prometheus 会在 Web UI 上显示抓取目标的健康状态。你可以监控</p><p>Prometheus Targets</p><p>页面的</p><pre tabindex=0><code>last scrape
</code></pre><p>时间，看看目标是否仍然处于正常抓取状态。</p><ul><li>通过 <code>Status -> Targets</code> 页面，你可以查看每个目标的最后抓取时间、抓取状态以及相关的错误信息。通过监控这些信息，可以确保 Exporter 是否正常工作。</li></ul></li><li><p>Prometheus 任务失败报警</p><p>：Prometheus 可以设置报警规则，当某个 Exporter 长时间没有抓取到数据时发出报警。例如，</p><pre tabindex=0><code>up
</code></pre><p>指标为 0 表示目标不可达，可以设置告警规则。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>groups</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>exporters</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>ExporterDown</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>up{job=&#34;your_exporter_job&#34;} == 0</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>for</span>: <span style=color:#ae81ff>5m</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>critical</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>summary</span>: <span style=color:#e6db74>&#34;Exporter is down for more than 5 minutes&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>description</span>: <span style=color:#e6db74>&#34;The exporter for {{ $labels.instance }} is not reachable for the last 5 minutes.&#34;</span>
</span></span></code></pre></div><p>这种方式可以确保在 Exporter 停止工作时及时通知你。</p></li></ul><h3 id=2-exporter-的健康检查>2. <strong>Exporter 的健康检查</strong>
<a class=anchor href=#2-exporter-%e7%9a%84%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5>#</a></h3><ul><li><p><strong>HTTP 健康检查端点</strong>：如果你的 Exporter 支持健康检查端点（如 <code>/health</code> 或 <code>/metrics</code>），你可以通过 Prometheus 或其他监控工具定期检查该端点的响应状态。</p></li><li><p>自定义 Exporter 健康指标</p><p>：许多 Exporter 提供了健康状态或内部指标，如</p><pre tabindex=0><code>up
</code></pre><p>、</p><pre tabindex=0><code>health
</code></pre><p>、</p><pre tabindex=0><code>status
</code></pre><p>等。如果没有，可以考虑自定义实现，暴露一个指标来显示 Exporter 是否正常工作。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 在你的 Exporter 中加入 /metrics 端点监控服务状态</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 例如：up{job=&#34;my_exporter&#34;} 1</span>
</span></span></code></pre></div><p>Prometheus 可以抓取并在不正常时报警。</p></li></ul><h3 id=3-exporter-进程监控>3. <strong>Exporter 进程监控</strong>
<a class=anchor href=#3-exporter-%e8%bf%9b%e7%a8%8b%e7%9b%91%e6%8e%a7>#</a></h3><ul><li><p><strong>进程监控</strong>：使用 <strong>node_exporter</strong> 或 <strong>prometheus-node-exporter</strong> 来监控 Exporter 的进程状态。你可以查看进程是否仍在运行，并监控 Exporter 的资源使用情况（CPU、内存、磁盘等）。</p></li><li><p>Linux 进程监控</p><p>：你可以使用</p><pre tabindex=0><code>ps
</code></pre><p>、</p><pre tabindex=0><code>top
</code></pre><p>或</p><pre tabindex=0><code>systemd
</code></pre><p>等工具查看 Exporter 进程是否正常运行。比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps aux | grep &lt;exporter_name&gt;
</span></span></code></pre></div><p>如果进程停止，你可以设置自动重启进程的机制（如 systemd 自动重启）。</p></li></ul><h3 id=4-外部服务监控>4. <strong>外部服务监控</strong>
<a class=anchor href=#4-%e5%a4%96%e9%83%a8%e6%9c%8d%e5%8a%a1%e7%9b%91%e6%8e%a7>#</a></h3><ul><li><p>容器化 Exporter</p><p>：如果 Exporter 运行在容器中，可以使用容器监控工具（如 Kubernetes 或 Docker）来监控容器的健康状态。</p><ul><li>在 Kubernetes 中，你可以配置健康检查（liveness 和 readiness probe）来检查 Exporter 是否可用。这样，当 Exporter 停止时，Kubernetes 会自动重启容器。</li><li>在 Docker 中，你可以设置容器的健康检查，监控容器内的服务状态。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker inspect --format <span style=color:#e6db74>&#39;{{json .State.Health}}&#39;</span> &lt;container_id&gt;
</span></span></code></pre></div></li></ul><h3 id=5-日志监控>5. <strong>日志监控</strong>
<a class=anchor href=#5-%e6%97%a5%e5%bf%97%e7%9b%91%e6%8e%a7>#</a></h3><ul><li><strong>Exporter 日志</strong>：很多 Exporter 都有日志输出，监控日志是排查问题的好方法。通过 <strong>log shipper</strong>（如 <strong>Fluentd</strong>、<strong>Logstash</strong>、<strong>Filebeat</strong> 等）将日志收集到 ELK 或其他日志管理系统中，检测是否存在错误或崩溃的日志。</li><li><strong>错误日志分析</strong>：当 Exporter 停止工作时，通常会有相关错误日志。可以通过分析日志内容来发现故障的根本原因。</li></ul><h3 id=6-自动化修复措施>6. <strong>自动化修复措施</strong>
<a class=anchor href=#6-%e8%87%aa%e5%8a%a8%e5%8c%96%e4%bf%ae%e5%a4%8d%e6%8e%aa%e6%96%bd>#</a></h3><ul><li><p>自动重启 Exporter</p><p>：如果 Exporter 停止工作，可以配置自动重启机制。通过</p><p>systemd</p><p>或</p><p>Supervisor</p><p>等工具，确保 Exporter 在停止后能够自动重启。</p><ul><li><p>在 systemd 中，你可以配置如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Exporter</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/path/to/exporter</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>always</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>RestartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div></li><li><p>通过设置 <code>Restart=always</code>，可以确保 Exporter 在任何意外停止后被自动重启。</p></li></ul></li></ul><h3 id=7-外部监控工具>7. <strong>外部监控工具</strong>
<a class=anchor href=#7-%e5%a4%96%e9%83%a8%e7%9b%91%e6%8e%a7%e5%b7%a5%e5%85%b7>#</a></h3><ul><li><strong>黑盒监控</strong>：你还可以使用外部监控工具（如 <strong>Pingdom</strong> 或 <strong>UptimeRobot</strong>）对 Exporter 的 <code>/metrics</code> 端点进行黑盒监控，确保服务是可达的。</li><li><strong>Alertmanager 集成</strong>：通过 Prometheus 的 <strong>Alertmanager</strong> 集成，可以设置复杂的报警规则，进行多渠道通知（如 Slack、邮件、短信等），确保在 Exporter 停止工作时能够及时通知运维人员。</li></ul><h3 id=8-分析指标丢失>8. <strong>分析指标丢失</strong>
<a class=anchor href=#8-%e5%88%86%e6%9e%90%e6%8c%87%e6%a0%87%e4%b8%a2%e5%a4%b1>#</a></h3><ul><li>如果 Exporter 停止工作，Prometheus 会在抓取该目标时丢失指标。通过监控 Prometheus 的 <strong>scrape_latency</strong> 和 <strong>scrape_errors</strong> 指标，可以分析抓取时的延迟和错误，发现 Exporter 是否有问题。</li></ul><h3 id=总结-9>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-9>#</a></h3><p>监控 Exporter 停止工作主要是确保其 <strong>可达性</strong>、<strong>健康状态</strong>、<strong>进程运行状态</strong>，并通过 Prometheus、外部工具以及日志监控等手段确保及时发现问题并进行自动恢复。通过配置合理的告警机制，当 Exporter 停止工作时，能够及时采取应对措施，确保监控系统的高可用性。</p><h2 id=prometheus的拉取模式与zabbix推送模式有何区别各有什么优缺点>Prometheus的拉取模式与zabbix推送模式有何区别？各有什么优缺点？
<a class=anchor href=#prometheus%e7%9a%84%e6%8b%89%e5%8f%96%e6%a8%a1%e5%bc%8f%e4%b8%8ezabbix%e6%8e%a8%e9%80%81%e6%a8%a1%e5%bc%8f%e6%9c%89%e4%bd%95%e5%8c%ba%e5%88%ab%e5%90%84%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e7%bc%ba%e7%82%b9>#</a></h2><p>Prometheus 的拉取模式（Pull Model）和 Zabbix 的推送模式（Push Model）在数据收集和监控架构上有很大的区别。以下是这两种模式的比较，包括它们的优缺点：</p><h3 id=1-prometheus-拉取模式pull-model>1. <strong>Prometheus 拉取模式（Pull Model）</strong>
<a class=anchor href=#1-prometheus-%e6%8b%89%e5%8f%96%e6%a8%a1%e5%bc%8fpull-model>#</a></h3><p><strong>原理</strong>：Prometheus 作为监控系统，定期主动从被监控的目标（如应用程序、数据库、服务器等）中拉取（scrape）指标数据。</p><p><strong>工作方式</strong>：</p><ul><li>Prometheus 配置了多个 <code>targets</code>（目标），每个目标都有一个暴露 <code>/metrics</code> 端点（通常是 HTTP）。</li><li>Prometheus 定期访问这些端点拉取数据。</li><li>拉取数据的间隔、超时等都可以在 Prometheus 配置文件中进行配置。</li></ul><p><strong>优点</strong>：</p><ul><li><strong>去中心化管理</strong>：Prometheus 主动从多个目标拉取数据，不需要在被监控的系统上安装任何推送的客户端或服务。</li><li><strong>无客户端配置</strong>：由于拉取数据是由 Prometheus 自己发起的，被监控的目标不需要知道 Prometheus 的存在，配置较为简单。</li><li><strong>灵活性高</strong>：可以方便地配置抓取间隔、拉取超时等参数，灵活应对不同目标的监控需求。</li><li><strong>支持服务发现</strong>：Prometheus 支持多种服务发现机制（如 Kubernetes、Consul、DNS），能够动态发现并监控新的目标。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>依赖目标可达性</strong>：拉取模式要求 Prometheus 能够访问所有目标，如果目标不可达，Prometheus 就无法获取数据。</li><li><strong>网络带宽消耗较大</strong>：由于 Prometheus 定期拉取数据，可能会产生大量的网络请求，尤其是在大规模部署时，对网络带宽有较大的消耗。</li><li><strong>延迟较高</strong>：拉取模式下，Prometheus 的数据采集间隔较为固定，可能会出现数据有一定延迟（例如每 15 秒或 1 分钟才抓取一次）。</li></ul><hr><h3 id=2-zabbix-推送模式push-model>2. <strong>Zabbix 推送模式（Push Model）</strong>
<a class=anchor href=#2-zabbix-%e6%8e%a8%e9%80%81%e6%a8%a1%e5%bc%8fpush-model>#</a></h3><p><strong>原理</strong>：Zabbix 通过监控代理或客户端，将监控数据主动推送到 Zabbix 服务器。</p><p><strong>工作方式</strong>：</p><ul><li>Zabbix 在被监控目标上安装了监控代理（Zabbix Agent），该代理负责收集本机的各种指标。</li><li>代理将数据推送到 Zabbix Server 或 Zabbix Proxy，Zabbix 服务器定期处理这些数据并生成报警、报告等。</li></ul><p><strong>优点</strong>：</p><ul><li><strong>即刻收集数据</strong>：数据推送到服务器后，几乎实时可以看到监控数据，延迟较低。</li><li><strong>适应动态环境</strong>：在一些目标较为动态（如容器化环境）时，推送模式可以更加灵活地处理新目标的加入。</li><li><strong>目标无须暴露端口</strong>：由于数据是从代理端推送到服务器，目标系统不需要暴露 HTTP 端口或其他服务端点，安全性相对较高。</li><li><strong>支持主动报警</strong>：Zabbix 代理可在监控指标达到预警条件时主动向服务器报告，减少了服务器端的负担。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>代理部署</strong>：需要在每个被监控的目标上部署 Zabbix 代理，这可能增加配置和维护的复杂度，尤其在大规模环境中。</li><li><strong>代理故障风险</strong>：如果 Zabbix 代理停止工作或遇到网络问题，数据就无法推送到 Zabbix 服务器，可能导致监控数据丢失。</li><li><strong>复杂的网络配置</strong>：需要处理网络访问控制、防火墙等问题，因为被监控的目标需要推送数据到 Zabbix 服务器或代理。</li><li><strong>不适合大量目标的实时监控</strong>：如果目标非常多，推送模式可能会造成代理和服务器之间的网络压力。</li></ul><hr><h3 id=3-对比总结>3. <strong>对比总结</strong>
<a class=anchor href=#3-%e5%af%b9%e6%af%94%e6%80%bb%e7%bb%93>#</a></h3><table><thead><tr><th>特性</th><th><strong>Prometheus 拉取模式</strong></th><th><strong>Zabbix 推送模式</strong></th></tr></thead><tbody><tr><td><strong>数据采集方式</strong></td><td>Prometheus 定期拉取数据</td><td>目标主动推送数据</td></tr><tr><td><strong>配置复杂度</strong></td><td>无需在目标系统上配置代理</td><td>需要在每个目标安装代理</td></tr><tr><td><strong>扩展性</strong></td><td>容易扩展（使用服务发现）</td><td>扩展时需要管理更多的代理</td></tr><tr><td><strong>延迟</strong></td><td>可能有较高延迟（取决于抓取间隔）</td><td>数据推送较为实时</td></tr><tr><td><strong>安全性</strong></td><td>需要暴露端口来拉取数据</td><td>推送数据不需要暴露端口</td></tr><tr><td><strong>可靠性</strong></td><td>如果目标不可达，会丢失数据</td><td>如果代理或网络中断，数据丢失</td></tr><tr><td><strong>网络负载</strong></td><td>定期拉取，可能产生大量请求</td><td>推送数据，如果目标不稳定则可能造成压力</td></tr><tr><td><strong>适应动态环境（如容器化）</strong></td><td>适应性较强，通过服务发现动态添加目标</td><td>需要动态更新代理配置</td></tr><tr><td><strong>报警机制</strong></td><td>报警通过 Prometheus 的查询和规则引擎触发</td><td>代理可以主动推送报警信息</td></tr></tbody></table><hr><h3 id=4-适用场景-3>4. <strong>适用场景</strong>
<a class=anchor href=#4-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-3>#</a></h3><ul><li><strong>Prometheus 拉取模式</strong>：适用于大规模、容器化环境，能够高效地处理动态变化的目标，并且通过灵活的配置和服务发现机制来支持自动化监控。</li><li><strong>Zabbix 推送模式</strong>：适用于需要实时数据且目标可以主动推送数据的环境，尤其适合传统的 IT 基础设施，并且目标系统的代理能够稳定运行。</li></ul><h3 id=总结-10>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-10>#</a></h3><ul><li><strong>Prometheus 的拉取模式</strong> 更适合大规模、容器化、云原生环境，支持自动化、灵活性高，但对网络依赖较大。</li><li><strong>Zabbix 的推送模式</strong> 更适合传统环境，支持实时监控，但需要在每个目标上部署代理，且有一定的维护成本。</li></ul><p>两者各有优缺点，根据具体的应用场景和基础设施需求来选择适合的方案。</p><h2 id=prometheus-operator怎么添加targets和告警规则>Prometheus operator怎么添加targets和告警规则
<a class=anchor href=#prometheus-operator%e6%80%8e%e4%b9%88%e6%b7%bb%e5%8a%a0targets%e5%92%8c%e5%91%8a%e8%ad%a6%e8%a7%84%e5%88%99>#</a></h2><p><strong>Prometheus Operator</strong> 是一个用来在 Kubernetes 上管理 Prometheus 部署的工具，它简化了 Prometheus 的创建、配置、管理和扩展。通过 <strong>Prometheus Operator</strong>，你可以通过 Kubernetes 资源对象来管理 Prometheus 集群的配置、告警规则和服务发现（targets）。</p><p>以下是如何通过 <strong>Prometheus Operator</strong> 来添加 <strong>targets</strong> 和 <strong>告警规则</strong> 的步骤。</p><h3 id=1-添加-targets-服务发现>1. 添加 Targets (服务发现)
<a class=anchor href=#1-%e6%b7%bb%e5%8a%a0-targets-%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0>#</a></h3><p>在 <strong>Prometheus Operator</strong> 中，目标 (targets) 是通过 <strong>ServiceMonitor</strong> 或 <strong>PodMonitor</strong> 资源来配置的。ServiceMonitor 用于监控服务，PodMonitor 用于监控单个 Pod。</p><h4 id=步骤-5>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-5>#</a></h4><ol><li><p>创建一个 <strong>ServiceMonitor</strong> 资源对象来配置 Prometheus 监控的服务。</p><p><strong>示例：创建 ServiceMonitor 配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>monitoring.coreos.com/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ServiceMonitor</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-servicemonitor</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>monitoring</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>example-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>endpoints</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>port</span>: <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>interval</span>: <span style=color:#ae81ff>30s</span>
</span></span></code></pre></div><ul><li><code>metadata.name</code>: 定义 ServiceMonitor 的名称。</li><li><code>spec.selector</code>: 用于选择匹配的 Kubernetes 服务。</li><li><code>spec.endpoints</code>: 定义 Prometheus 通过该端点进行监控的方式，通常是一个端口和拉取数据的间隔。</li></ul></li><li><p>在 Kubernetes 中应用 ServiceMonitor 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f servicemonitor.yaml
</span></span></code></pre></div></li><li><p>确保 Prometheus Operator 配置了适当的 <strong>Prometheus</strong> 实例和 <strong>ServiceMonitorSelector</strong>。在 Prometheus 配置中，您可以通过 <strong>Prometheus CRD</strong>（Custom Resource Definitions）来指定哪些 ServiceMonitor 对象需要被 Prometheus 监控。</p><p><strong>示例：Prometheus CRD 配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>monitoring.coreos.com/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Prometheus</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>prometheus</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>monitoring</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>serviceMonitorSelector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>monitoring</span>: <span style=color:#ae81ff>enabled</span>
</span></span></code></pre></div><p>这个配置使得 Prometheus 只选择带有 <code>monitoring: enabled</code> 标签的 ServiceMonitor 对象进行监控。</p></li></ol><h3 id=2-添加告警规则>2. 添加告警规则
<a class=anchor href=#2-%e6%b7%bb%e5%8a%a0%e5%91%8a%e8%ad%a6%e8%a7%84%e5%88%99>#</a></h3><p>Prometheus 的告警规则通常通过 <strong>PrometheusRule</strong> 资源来定义。告警规则定义了触发条件以及如何通知。</p><h4 id=步骤-6>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-6>#</a></h4><ol><li><p>创建一个 <strong>PrometheusRule</strong> 资源对象来定义告警规则。</p><p><strong>示例：创建 PrometheusRule 配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>monitoring.coreos.com/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PrometheusRule</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-alert-rules</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>monitoring</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>groups</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-alerts</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>HighMemoryUsage</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>container_memory_usage_bytes{container=&#34;example-container&#34;} &gt; 500000000</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>for</span>: <span style=color:#ae81ff>5m</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>critical</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>summary</span>: <span style=color:#e6db74>&#34;Memory usage is over 500MB for 5 minutes&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>description</span>: <span style=color:#e6db74>&#34;Container {{ $labels.container }} is using more than 500MB of memory.&#34;</span>
</span></span></code></pre></div><ul><li><code>alert</code>: 告警的名称。</li><li><code>expr</code>: 用 Prometheus 查询语言（PromQL）定义的告警表达式。此表达式监测容器内存使用情况，超过 500MB 触发告警。</li><li><code>for</code>: 设置告警触发的持续时间。例如，5 分钟内内存使用超过 500MB 才触发告警。</li><li><code>labels</code>: 添加一些自定义标签，可以在通知时使用。</li><li><code>annotations</code>: 提供告警的详细信息，通常包括摘要和描述。</li></ul></li><li><p>在 Kubernetes 中应用 PrometheusRule 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f prometheusrule.yaml
</span></span></code></pre></div></li><li><p>确保 Prometheus 配置了告警规则。</p><p><strong>示例：Prometheus CRD 配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>monitoring.coreos.com/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Prometheus</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>prometheus</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>monitoring</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ruleSelector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>enabled</span>
</span></span></code></pre></div><p>这个配置使得 Prometheus 只选择带有 <code>alert: enabled</code> 标签的 PrometheusRule 对象作为告警规则。</p></li></ol><h3 id=3-告警通知>3. 告警通知
<a class=anchor href=#3-%e5%91%8a%e8%ad%a6%e9%80%9a%e7%9f%a5>#</a></h3><p>一旦告警规则配置完成，Prometheus 会根据定义的规则评估和触发告警。如果你还需要告警通知（如发送邮件、Slack、PagerDuty 等），可以配置 <strong>Alertmanager</strong> 来处理告警通知。</p><p><strong>示例：Alertmanager 配置（通过 Kubernetes ConfigMap）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ConfigMap</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>alertmanager-config</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>monitoring</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>alertmanager.yml</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    global:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      resolve_timeout: 5m
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    route:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      receiver: &#39;slack-notifications&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    receivers:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      - name: &#39;slack-notifications&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        slack_configs:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          - channel: &#39;#alerts&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            send_resolved: true</span>
</span></span></code></pre></div><p><strong>应用 Alertmanager 配置</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f alertmanager-config.yaml
</span></span></code></pre></div><h3 id=总结-11>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-11>#</a></h3><ul><li><strong>添加 Targets</strong>：通过 <strong>ServiceMonitor</strong> 或 <strong>PodMonitor</strong> 来指定 Prometheus 需要监控的目标（服务或 Pod）。</li><li><strong>添加告警规则</strong>：通过 <strong>PrometheusRule</strong> 来定义 Prometheus 的告警规则。</li><li><strong>告警通知</strong>：告警会触发后，通过 <strong>Alertmanager</strong> 发送通知，您可以配置通知渠道，如 Slack、邮件等。</li></ul><p>在实际使用中，可以通过 <strong>Prometheus Operator</strong> 来自动化和简化这些配置的管理。</p><h2 id=k8s集群外exporter怎么使用prometheus监控>k8s集群外exporter怎么使用Prometheus监控
<a class=anchor href=#k8s%e9%9b%86%e7%be%a4%e5%a4%96exporter%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8prometheus%e7%9b%91%e6%8e%a7>#</a></h2><p>在 Kubernetes 集群外部使用 <strong>Prometheus</strong> 监控 <strong>Exporter</strong>，你可以通过设置 <strong>Prometheus</strong> 来直接从外部系统或服务拉取指标数据。这里的关键是配置 <strong>Prometheus</strong> 以使其能够连接到外部的 <strong>Exporter</strong> 并获取数据。</p><p>以下是实现的步骤：</p><h3 id=1-确保外部-exporter-可访问>1. 确保外部 Exporter 可访问
<a class=anchor href=#1-%e7%a1%ae%e4%bf%9d%e5%a4%96%e9%83%a8-exporter-%e5%8f%af%e8%ae%bf%e9%97%ae>#</a></h3><p>首先，确保外部 <strong>Exporter</strong> 可以被 Prometheus 访问。<strong>Exporter</strong> 可以是运行在物理机、虚拟机或云实例上的应用程序，或者是其他容器化环境中的服务。</p><ul><li>外部 <strong>Exporter</strong> 需要暴露一个 HTTP 服务接口，Prometheus 可以通过 HTTP 拉取指标。通常，<strong>Exporter</strong> 会暴露在一个特定端口（例如 9100、9182、8080 等）。</li></ul><h3 id=2-配置-prometheus-来抓取外部-exporter-数据>2. 配置 Prometheus 来抓取外部 Exporter 数据
<a class=anchor href=#2-%e9%85%8d%e7%bd%ae-prometheus-%e6%9d%a5%e6%8a%93%e5%8f%96%e5%a4%96%e9%83%a8-exporter-%e6%95%b0%e6%8d%ae>#</a></h3><p>在 Prometheus 配置中，你需要添加外部 <strong>Exporter</strong> 的目标，通常通过 <strong><code>scrape_config</code></strong> 配置 Prometheus 从外部目标（IP 地址或域名）拉取数据。</p><h4 id=步骤-7>步骤：
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-7>#</a></h4><ol><li><p><strong>编辑 Prometheus 配置文件</strong>：在 Prometheus 配置文件（通常是 <code>prometheus.yml</code>）中，添加一个新的 <code>scrape_config</code> 配置，以便 Prometheus 可以从外部的 <strong>Exporter</strong> 中抓取数据。</p><p><strong>示例：Prometheus 配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>global</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>scrape_interval</span>: <span style=color:#ae81ff>15s</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>scrape_configs</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>job_name</span>: <span style=color:#e6db74>&#39;external-exporter&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>static_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>targets</span>: [<span style=color:#e6db74>&#39;&lt;external_exporter_ip&gt;:&lt;port&gt;&#39;</span>, <span style=color:#e6db74>&#39;&lt;external_exporter_ip2&gt;:&lt;port&gt;&#39;</span>]
</span></span></code></pre></div><ul><li><code>job_name</code>：定义一个任务的名称，您可以根据需要修改这个名称。</li><li><code>targets</code>：是 <strong>Exporter</strong> 的地址列表，通常包括 IP 和端口，确保 Prometheus 可以访问这些地址。你可以列出多个目标，Prometheus 将会并行拉取数据。</li></ul></li><li><p><strong>重启 Prometheus</strong>：配置修改完成后，重启 Prometheus 服务以使新的配置生效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl restart prometheus
</span></span></code></pre></div><p>或者，如果你使用的是 Docker：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker restart &lt;prometheus_container_name&gt;
</span></span></code></pre></div></li></ol><h3 id=3-验证-prometheus-是否可以正确抓取外部-exporter-数据>3. 验证 Prometheus 是否可以正确抓取外部 Exporter 数据
<a class=anchor href=#3-%e9%aa%8c%e8%af%81-prometheus-%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e6%ad%a3%e7%a1%ae%e6%8a%93%e5%8f%96%e5%a4%96%e9%83%a8-exporter-%e6%95%b0%e6%8d%ae>#</a></h3><p>完成配置后，你可以通过 Prometheus 的 <strong>Web UI</strong> 来查看是否已经成功抓取到外部 <strong>Exporter</strong> 的数据。</p><ol><li><p>进入 Prometheus Web UI（通常是 <code>http://&lt;prometheus_ip>:9090</code>）。</p></li><li><p>进入</p><p>Targets</p><p>页面 (</p><pre tabindex=0><code>http://&lt;prometheus_ip&gt;:9090/targets
</code></pre><p>)，检查</p><pre tabindex=0><code>scrape_configs
</code></pre><p>中添加的目标是否出现，状态是否为</p><pre tabindex=0><code>up
</code></pre><p>。</p><ul><li>如果目标处于 <code>up</code> 状态，表示 Prometheus 成功抓取了指标。</li><li>如果状态为 <code>down</code>，检查是否能从 Prometheus 机器访问外部 <strong>Exporter</strong> 地址，可能是网络问题、端口没有开放或者防火墙限制等原因。</li></ul></li></ol><h3 id=4-配置告警可选>4. 配置告警（可选）
<a class=anchor href=#4-%e9%85%8d%e7%bd%ae%e5%91%8a%e8%ad%a6%e5%8f%af%e9%80%89>#</a></h3><p>你可以根据抓取到的外部指标配置 Prometheus 的告警规则。告警规则可以通过 <strong>PrometheusRule</strong> 或直接在 Prometheus 配置文件中进行设置。</p><p>例如，假设你正在抓取一个 Node Exporter 的外部指标并想设置一个告警来监控 CPU 使用率：</p><h4 id=配置告警规则>配置告警规则：
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e5%91%8a%e8%ad%a6%e8%a7%84%e5%88%99>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>groups</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>node-alerts</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>alert</span>: <span style=color:#ae81ff>HighCPUUsage</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>expr</span>: <span style=color:#ae81ff>node_cpu_seconds_total{mode=&#34;user&#34;} &gt; 80</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>for</span>: <span style=color:#ae81ff>5m</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>critical</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>summary</span>: <span style=color:#e6db74>&#34;CPU usage is over 80% for 5 minutes.&#34;</span>
</span></span></code></pre></div><h3 id=5-配置告警通知可选>5. 配置告警通知（可选）
<a class=anchor href=#5-%e9%85%8d%e7%bd%ae%e5%91%8a%e8%ad%a6%e9%80%9a%e7%9f%a5%e5%8f%af%e9%80%89>#</a></h3><p>如果需要配置告警通知（例如，发送到 Slack、Email 或其他通知渠道），你需要在 Prometheus 配置文件中设置 <strong>Alertmanager</strong> 配置。</p><p><strong>示例：Alertmanager 配置</strong>（发送 Slack 通知）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>global</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>resolve_timeout</span>: <span style=color:#ae81ff>5m</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>route</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>receiver</span>: <span style=color:#e6db74>&#39;slack-notifications&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>receivers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#39;slack-notifications&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>slack_configs</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>channel</span>: <span style=color:#e6db74>&#39;#alerts&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>send_resolved</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>然后，Prometheus 会将告警发送到 <strong>Alertmanager</strong>，由 <strong>Alertmanager</strong> 负责处理和转发通知。</p><h3 id=总结-12>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-12>#</a></h3><ol><li>确保外部 <strong>Exporter</strong> 可通过 HTTP 暴露指标，Prometheus 可以访问。</li><li>在 Prometheus 配置文件中使用 <code>scrape_configs</code> 添加外部 <strong>Exporter</strong> 的地址。</li><li>通过 Prometheus Web UI 检查目标是否被正确抓取。</li><li>配置告警规则和通知渠道（可选）。</li></ol><p>通过这些步骤，Prometheus 就可以监控外部 <strong>Exporter</strong>，并且你可以根据需要设置告警和通知。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#prometheus>Prometheus</a></li><li><a href=#prometheus的工作流程>Prometheus的工作流程</a></li><li><a href=#metric的几种类型分别是什么>Metric的几种类型？分别是什么？☆</a><ul><li><a href=#总结>总结：</a></li></ul></li><li><a href=#prometheus有哪几种服务发现>Prometheus有哪几种服务发现☆</a><ul><li><a href=#1-kubernetes-服务发现>1. <strong>Kubernetes 服务发现</strong>：</a></li><li><a href=#2-consul-服务发现>2. <strong>Consul 服务发现</strong>：</a></li><li><a href=#3-ec2-服务发现>3. <strong>EC2 服务发现</strong>：</a></li><li><a href=#4-gcegoogle-compute-engine服务发现>4. <strong>GCE（Google Compute Engine）服务发现</strong>：</a></li><li><a href=#5-azure-服务发现>5. <strong>Azure 服务发现</strong>：</a></li><li><a href=#6-dns-服务发现>6. <strong>DNS 服务发现</strong>：</a></li><li><a href=#7-file-服务发现>7. <strong>File 服务发现</strong>：</a></li><li><a href=#8-static-服务发现>8. <strong>Static 服务发现</strong>：</a></li><li><a href=#9-openstack-服务发现>9. <strong>OpenStack 服务发现</strong>：</a></li><li><a href=#总结-1>总结：</a></li></ul></li><li><a href=#prometheus常用函数>Prometheus常用函数</a><ul><li><a href=#1-聚合函数aggregation-functions>1. <strong>聚合函数（Aggregation Functions）</strong></a></li><li><a href=#2-统计函数statistical-functions>2. <strong>统计函数（Statistical Functions）</strong></a></li><li><a href=#3-时间函数time-functions>3. <strong>时间函数（Time Functions）</strong></a></li><li><a href=#4-数值处理函数mathematical-functions>4. <strong>数值处理函数（Mathematical Functions）</strong></a></li><li><a href=#5-字符串处理函数string-functions>5. <strong>字符串处理函数（String Functions）</strong></a></li><li><a href=#6-查询时间函数time-interval-functions>6. <strong>查询时间函数（Time Interval Functions）</strong></a></li><li><a href=#7-率函数rate-functions>7. <strong>率函数（Rate Functions）</strong></a></li><li><a href=#8-逻辑函数logical-functions>8. <strong>逻辑函数（Logical Functions）</strong></a></li><li><a href=#9-过滤与条件filters--conditionals>9. <strong>过滤与条件（Filters & Conditionals）</strong></a></li><li><a href=#10-百分比计算percentile-calculation>10. <strong>百分比计算（Percentile Calculation）</strong></a></li><li><a href=#总结-2>总结：</a></li></ul></li><li><a href=#thanos架构>thanos架构☆</a><ul><li><a href=#thanos-架构概述>Thanos 架构概述</a></li><li><a href=#thanos-架构图>Thanos 架构图</a></li><li><a href=#thanos-核心功能>Thanos 核心功能</a></li><li><a href=#thanos-的使用场景>Thanos 的使用场景</a></li><li><a href=#总结-3>总结</a></li></ul></li><li><a href=#thanos与victoriametrics对比>thanos与VictoriaMetrics对比</a></li><li><a href=#1-概述><strong>1. 概述</strong></a></li><li><a href=#2-架构对比><strong>2. 架构对比</strong></a><ul><li><a href=#thanos><strong>Thanos</strong></a></li><li><a href=#victoriametrics><strong>VictoriaMetrics</strong></a></li></ul></li><li><a href=#3-关键特性对比><strong>3. 关键特性对比</strong></a></li><li><a href=#4-适用场景><strong>4. 适用场景</strong></a></li><li><a href=#5-总结><strong>5. 总结</strong></a></li><li><a href=#thanos-sidecar和receive区别>thanos sidecar和receive区别☆</a><ul><li><a href=#thanos-sidecar-vs-thanos-receive-对比><strong>Thanos Sidecar vs Thanos Receive 对比</strong></a></li></ul></li><li><a href=#1-主要用途><strong>1. 主要用途</strong></a></li><li><a href=#2-架构对比-1><strong>2. 架构对比</strong></a><ul><li><a href=#thanos-sidecar><strong>Thanos Sidecar</strong></a></li><li><a href=#thanos-receive><strong>Thanos Receive</strong></a></li></ul></li><li><a href=#3-详细功能对比><strong>3. 详细功能对比</strong></a></li><li><a href=#4-适用场景-1><strong>4. 适用场景</strong></a></li><li><a href=#5-选型建议><strong>5. 选型建议</strong></a></li><li><a href=#thanos-rule组件和prometheus区别>thanos rule组件和prometheus区别</a><ul><li><a href=#thanos-rule-vs-prometheus区别与对比><strong>Thanos Rule vs Prometheus：区别与对比</strong></a></li></ul></li><li><a href=#1-主要用途-1><strong>1. 主要用途</strong></a></li><li><a href=#2-组件介绍><strong>2. 组件介绍</strong></a><ul><li><a href=#-prometheus><strong>📌 Prometheus</strong></a></li><li><a href=#-thanos-rule><strong>📌 Thanos Rule</strong></a></li></ul></li><li><a href=#3-详细功能对比-1><strong>3. 详细功能对比</strong></a></li><li><a href=#4-适用场景-2><strong>4. 适用场景</strong></a></li><li><a href=#5-总结-1><strong>5. 总结</strong></a></li><li><a href=#prometheus告警从触发到收到通知延迟在哪>Prometheus告警从触发到收到通知延迟在哪</a></li><li><a href=#-prometheus-告警流程><strong>📌 Prometheus 告警流程</strong></a></li><li><a href=#-可能的延迟点><strong>📌 可能的延迟点</strong></a></li><li><a href=#-如何优化-prometheus-告警延迟><strong>📌 如何优化 Prometheus 告警延迟？</strong></a><ul><li><a href=#1-调整><strong>1. 调整 <code>scrape_interval</code></strong></a></li><li><a href=#2-调整><strong>2. 调整 <code>evaluation_interval</code></strong></a></li><li><a href=#3-调整><strong>3. 调整 <code>for</code> 参数</strong></a></li><li><a href=#4-调整-alertmanager-配置><strong>4. 调整 Alertmanager 配置</strong></a></li><li><a href=#5-优化通知方式><strong>5. 优化通知方式</strong></a></li></ul></li><li><a href=#-结论><strong>📌 结论</strong></a><ul><li><a href=#-优化建议>🚀 <strong>优化建议</strong></a></li><li><a href=#-推荐优化后的示例配置><strong>🔥 推荐优化后的示例配置</strong></a></li></ul></li><li><a href=#告警抑制怎么做>告警抑制怎么做☆</a></li><li><a href=#-告警抑制的工作原理><strong>📌 告警抑制的工作原理</strong></a></li><li><a href=#-告警抑制规则配置><strong>📌 告警抑制规则配置</strong></a><ul><li><a href=#示例-1屏蔽><strong>示例 1：屏蔽 <code>InstanceDown</code> 告警，若 <code>ClusterDown</code> 告警已触发</strong></a></li><li><a href=#示例-2某个服务><strong>示例 2：某个服务 <code>APIHighLatency</code> 时，屏蔽 <code>APIErrorRate</code></strong></a></li></ul></li><li><a href=#-配置><strong>📌 配置 <code>Alertmanager.yml</code> 规则</strong></a><ul><li><a href=#完整示例><strong>完整示例</strong></a></li></ul></li><li><a href=#-如何测试告警抑制><strong>📌 如何测试告警抑制</strong></a></li><li><a href=#-总结><strong>📌 总结</strong></a><ul><li><a href=#prometheus-告警抑制inhibition><strong>Prometheus 告警抑制（Inhibition）</strong></a></li></ul></li><li><a href=#-配置告警抑制的步骤><strong>📌 配置告警抑制的步骤</strong></a></li><li><a href=#-示例屏蔽-instancedown-告警><strong>📌 示例：屏蔽 InstanceDown 告警</strong></a></li><li><a href=#-示例屏蔽磁盘使用率高告警><strong>📌 示例：屏蔽磁盘使用率高告警</strong></a></li><li><a href=#-示例屏蔽><strong>📌 示例：屏蔽 <code>NodeDown</code>（节点宕机）告警</strong></a></li><li><a href=#heading><strong>📌 <code>inhibit_rules</code> 配置完整示例</strong></a></li><li><a href=#-如何测试告警抑制-1><strong>📌 如何测试告警抑制？</strong></a><ul><li><a href=#方式-1使用><strong>方式 1：使用 <code>amtool</code></strong></a></li><li><a href=#方式-2查看-alertmanager-ui><strong>方式 2：查看 Alertmanager UI</strong></a></li></ul></li><li><a href=#-结论-1><strong>📌 结论</strong></a></li><li><a href=#告警架构高可用怎么做>告警架构高可用怎么做☆</a></li><li><a href=#prometheus-告警系统高可用架构方案><strong>Prometheus 告警系统高可用架构方案</strong></a></li><li><a href=#-1-prometheus-高可用><strong>📌 1. Prometheus 高可用</strong></a><ul><li><a href=#-方案-1prometheus-双实例主备><strong>🔹 方案 1：Prometheus 双实例（主备）</strong></a></li><li><a href=#-方案-2prometheus--thanos-victoriametrics><strong>🔹 方案 2：Prometheus + Thanos/ VictoriaMetrics</strong></a></li></ul></li><li><a href=#-2-alertmanager-高可用><strong>📌 2. Alertmanager 高可用</strong></a><ul><li><a href=#-方案alertmanager-集群><strong>🔹 方案：Alertmanager 集群</strong></a></li></ul></li><li><a href=#-3-通知渠道高可用><strong>📌 3. 通知渠道高可用</strong></a><ul><li><a href=#-方案-1多个通知通道><strong>🔹 方案 1：多个通知通道</strong></a></li><li><a href=#-方案-2webhook-高可用><strong>🔹 方案 2：Webhook 高可用</strong></a></li></ul></li><li><a href=#-4-全局高可用架构><strong>📌 4. 全局高可用架构</strong></a></li><li><a href=#-结论-2><strong>📌 结论</strong></a></li><li><a href=#pod指标wss和rss区别>Pod指标WSS和RSS区别☆</a></li><li><a href=#-rssresident-set-size><strong>📌 RSS（Resident Set Size）</strong></a></li><li><a href=#-wssworking-set-size><strong>📌 WSS（Working Set Size）</strong></a></li><li><a href=#-wss-vs-rss-总结><strong>📌 WSS vs. RSS 总结</strong></a></li><li><a href=#-kubernetes-相关><strong>📌 Kubernetes 相关</strong></a></li><li><a href=#监控四个黄金指标>监控四个黄金指标</a></li><li><a href=#-1-latency延迟><strong>📌 1. Latency（延迟）</strong></a></li><li><a href=#-2-traffic流量><strong>📌 2. Traffic（流量）</strong></a></li><li><a href=#-3-errors错误率><strong>📌 3. Errors（错误率）</strong></a></li><li><a href=#-4-saturation饱和度><strong>📌 4. Saturation（饱和度）</strong></a></li><li><a href=#-总结-1><strong>📌 总结</strong></a></li><li><a href=#在大规模环境下如何优化prometheus性能>在大规模环境下，如何优化Prometheus性能</a><ul><li><a href=#1-分布式架构设计><strong>1. 分布式架构设计</strong></a></li><li><a href=#2-数据存储优化><strong>2. 数据存储优化</strong></a></li><li><a href=#3-查询优化><strong>3. 查询优化</strong></a></li><li><a href=#4-调整-scrape-配置><strong>4. 调整 Scrape 配置</strong></a></li><li><a href=#5-使用-external-storage><strong>5. 使用 External Storage</strong></a></li><li><a href=#6-优化-alerting-和-rules><strong>6. 优化 Alerting 和 Rules</strong></a></li><li><a href=#7-高可用和负载均衡><strong>7. 高可用和负载均衡</strong></a></li><li><a href=#总结-4><strong>总结：</strong></a></li></ul></li><li><a href=#如何实现告警的自动化响应>如何实现告警的自动化响应☆</a><ul><li><a href=#1-使用-prometheus--alertmanager-配置告警自动化响应><strong>1. 使用 Prometheus + Alertmanager 配置告警自动化响应</strong></a></li><li><a href=#2-集成自动化工具如-ansibleterraform进行响应><strong>2. 集成自动化工具（如 Ansible、Terraform）进行响应</strong></a></li><li><a href=#3-集成-chatops-进行自动化响应><strong>3. 集成 ChatOps 进行自动化响应</strong></a></li><li><a href=#4-使用-kubernetes-operator-进行自动化修复><strong>4. 使用 Kubernetes Operator 进行自动化修复</strong></a></li><li><a href=#5-使用-pagerdutyopsgenie-等工具的自动化响应><strong>5. 使用 PagerDuty、OpsGenie 等工具的自动化响应</strong></a></li><li><a href=#总结-5><strong>总结：</strong></a></li></ul></li><li><a href=#prometheus数据压缩和持久化实现原理>Prometheus数据压缩和持久化实现原理</a><ul><li><a href=#1-prometheus-数据存储架构><strong>1. Prometheus 数据存储架构</strong></a></li><li><a href=#2-数据存储与持久化原理><strong>2. 数据存储与持久化原理</strong></a></li><li><a href=#3-数据压缩与持久化的实现原理总结><strong>3. 数据压缩与持久化的实现原理总结</strong></a></li><li><a href=#4-持久化存储><strong>4. 持久化存储</strong></a></li></ul></li><li><a href=#kubectl-top输出与linux-free命令不一致原因>kubectl top输出与Linux free命令不一致原因☆</a><ul><li><a href=#1-数据来源的差异><strong>1. 数据来源的差异</strong></a></li><li><a href=#2-资源的计算方式><strong>2. 资源的计算方式</strong></a></li><li><a href=#3-资源隔离和容器化><strong>3. 资源隔离和容器化</strong></a></li><li><a href=#4-汇总与显示的不同><strong>4. 汇总与显示的不同</strong></a></li><li><a href=#总结-6><strong>总结</strong></a></li></ul></li><li><a href=#用到了哪些exporter功能是什么在-prometheus-监控中exporter-是一个重要的组件它用于从不同的应用或系统中收集指标并将这些指标以-prometheus-能够理解的格式暴露出来以下是一些常用的-prometheus-exporter-及其功能>用到了哪些exporter，功能是什么在 Prometheus 监控中，<strong>Exporter</strong> 是一个重要的组件，它用于从不同的应用或系统中收集指标，并将这些指标以 Prometheus 能够理解的格式暴露出来。以下是一些常用的 Prometheus Exporter 及其功能：</a><ul><li><a href=#1-node-exporter>1. <strong>Node Exporter</strong></a></li><li><a href=#2-kube-state-metrics>2. <strong>kube-state-metrics</strong></a></li><li><a href=#3-cadvisor>3. <strong>cAdvisor</strong></a></li><li><a href=#4-blackbox-exporter>4. <strong>Blackbox Exporter</strong></a></li><li><a href=#5-mysql-exporter>5. <strong>MySQL Exporter</strong></a></li><li><a href=#6-postgresql-exporter>6. <strong>PostgreSQL Exporter</strong></a></li><li><a href=#7-jmx-exporter>7. <strong>JMX Exporter</strong></a></li><li><a href=#8-redis-exporter>8. <strong>Redis Exporter</strong></a></li><li><a href=#9-mongodb-exporter>9. <strong>MongoDB Exporter</strong></a></li><li><a href=#10-elasticsearch-exporter>10. <strong>Elasticsearch Exporter</strong></a></li><li><a href=#11-nginx-exporter>11. <strong>Nginx Exporter</strong></a></li><li><a href=#12-kafka-exporter>12. <strong>Kafka Exporter</strong></a></li><li><a href=#总结-7><strong>总结</strong>：</a></li></ul></li><li><a href=#是否自己开发过exporter>是否自己开发过exporter☆</a><ul><li><a href=#自定义-exporter-开发的一般步骤>自定义 Exporter 开发的一般步骤：</a></li><li><a href=#示例用-go-开发一个简单的自定义-exporter>示例：用 Go 开发一个简单的自定义 Exporter</a></li><li><a href=#关键点>关键点：</a></li><li><a href=#开发过程中可能遇到的挑战>开发过程中可能遇到的挑战：</a></li></ul></li><li><a href=#target-down的情况如何进行故障排除>target down的情况如何进行故障排除？</a><ul><li><a href=#1-检查-prometheus-日志>1. <strong>检查 Prometheus 日志</strong></a></li><li><a href=#2-检查网络连接>2. <strong>检查网络连接</strong></a></li><li><a href=#3-检查目标服务状态>3. <strong>检查目标服务状态</strong></a></li><li><a href=#4-检查目标端点的配置>4. <strong>检查目标端点的配置</strong></a></li><li><a href=#5-目标服务的负载问题>5. <strong>目标服务的负载问题</strong></a></li><li><a href=#6-身份验证问题>6. <strong>身份验证问题</strong></a></li><li><a href=#7-检查-prometheus-配置文件>7. <strong>检查 Prometheus 配置文件</strong></a></li><li><a href=#8-查看-prometheus-目标状态>8. <strong>查看 Prometheus 目标状态</strong></a></li><li><a href=#9-重启-prometheus>9. <strong>重启 Prometheus</strong></a></li><li><a href=#10-目标端服务日志>10. <strong>目标端服务日志</strong></a></li><li><a href=#故障排除示例>故障排除示例：</a></li><li><a href=#总结-8>总结</a></li></ul></li><li><a href=#exporter-停止工作如何监控>Exporter 停止工作，如何监控？</a><ul><li><a href=#1-prometheus-自身的监控>1. <strong>Prometheus 自身的监控</strong></a></li><li><a href=#2-exporter-的健康检查>2. <strong>Exporter 的健康检查</strong></a></li><li><a href=#3-exporter-进程监控>3. <strong>Exporter 进程监控</strong></a></li><li><a href=#4-外部服务监控>4. <strong>外部服务监控</strong></a></li><li><a href=#5-日志监控>5. <strong>日志监控</strong></a></li><li><a href=#6-自动化修复措施>6. <strong>自动化修复措施</strong></a></li><li><a href=#7-外部监控工具>7. <strong>外部监控工具</strong></a></li><li><a href=#8-分析指标丢失>8. <strong>分析指标丢失</strong></a></li><li><a href=#总结-9>总结</a></li></ul></li><li><a href=#prometheus的拉取模式与zabbix推送模式有何区别各有什么优缺点>Prometheus的拉取模式与zabbix推送模式有何区别？各有什么优缺点？</a><ul><li><a href=#1-prometheus-拉取模式pull-model>1. <strong>Prometheus 拉取模式（Pull Model）</strong></a></li><li><a href=#2-zabbix-推送模式push-model>2. <strong>Zabbix 推送模式（Push Model）</strong></a></li><li><a href=#3-对比总结>3. <strong>对比总结</strong></a></li><li><a href=#4-适用场景-3>4. <strong>适用场景</strong></a></li><li><a href=#总结-10>总结</a></li></ul></li><li><a href=#prometheus-operator怎么添加targets和告警规则>Prometheus operator怎么添加targets和告警规则</a><ul><li><a href=#1-添加-targets-服务发现>1. 添加 Targets (服务发现)</a></li><li><a href=#2-添加告警规则>2. 添加告警规则</a></li><li><a href=#3-告警通知>3. 告警通知</a></li><li><a href=#总结-11>总结</a></li></ul></li><li><a href=#k8s集群外exporter怎么使用prometheus监控>k8s集群外exporter怎么使用Prometheus监控</a><ul><li><a href=#1-确保外部-exporter-可访问>1. 确保外部 Exporter 可访问</a></li><li><a href=#2-配置-prometheus-来抓取外部-exporter-数据>2. 配置 Prometheus 来抓取外部 Exporter 数据</a></li><li><a href=#3-验证-prometheus-是否可以正确抓取外部-exporter-数据>3. 验证 Prometheus 是否可以正确抓取外部 Exporter 数据</a></li><li><a href=#4-配置告警可选>4. 配置告警（可选）</a></li><li><a href=#5-配置告警通知可选>5. 配置告警通知（可选）</a></li><li><a href=#总结-12>总结：</a></li></ul></li></ul></nav></div></aside></main></body></html>