<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
经过本人为期一个半月的不懈努力，累计面试了二十多家公司，共计约五十余场面试，考察的面试题超两百道，积累了许多宝贵的面试经验。现在，我将这些面试题以及我个人的应对心得精心整理成一份面试攻略分享给大家，快来一起测测自己能回答多少道面试题吧。

  面试基本信息
  #

面试岗位：运维工程师(容器与ES方向)、运维开发工程师、SRE工程师
工作经验：5年
薪资范围：年薪45万左右，base北京
面试时间：7月初-8月中旬
主要公司：

互联网公司：字节、京东、百度、网易、蚂蚁金服、小米、滴滴、去哪儿、猎豹移动、商汤、旷视、智谱华章、马蜂窝、竞技世界
国企子公司：电信、联通、建行、中石化


  面试题汇总
  #

其中☆表示多次出现过的高频面试题，已经按分类整理。

  Linux
  #


  grep sed awk cut组合使用☆
  #

grep、sed、awk 和 cut 都是 Linux 系统中常用的文本处理工具，通常可以结合使用以实现更复杂的文本处理任务。这里是一些常见的组合使用示例：

  1. 使用 grep + cut：筛选和提取字段
  #

假设你有一个文件 data.txt，其内容如下：
Name, Age, Department
Alice, 30, HR
Bob, 25, Engineering
Charlie, 35, Marketing
如果你只想提取 Name 和 Age 字段，可以使用 grep 和 cut 的组合：
grep -v &#34;Name&#34; data.txt | cut -d ',' -f 1,2
解释：

grep -v &#34;Name&#34;：去除第一行标题。
cut -d ',' -f 1,2：按照逗号分隔，提取第一列和第二列。

输出："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="高级运维面试题-linux部分"><meta property="og:description" content="经过本人为期一个半月的不懈努力，累计面试了二十多家公司，共计约五十余场面试，考察的面试题超两百道，积累了许多宝贵的面试经验。现在，我将这些面试题以及我个人的应对心得精心整理成一份面试攻略分享给大家，快来一起测测自己能回答多少道面试题吧。
面试基本信息 # 面试岗位：运维工程师(容器与ES方向)、运维开发工程师、SRE工程师 工作经验：5年 薪资范围：年薪45万左右，base北京 面试时间：7月初-8月中旬 主要公司：
互联网公司：字节、京东、百度、网易、蚂蚁金服、小米、滴滴、去哪儿、猎豹移动、商汤、旷视、智谱华章、马蜂窝、竞技世界 国企子公司：电信、联通、建行、中石化 面试题汇总 # 其中☆表示多次出现过的高频面试题，已经按分类整理。
Linux # grep sed awk cut组合使用☆ # grep、sed、awk 和 cut 都是 Linux 系统中常用的文本处理工具，通常可以结合使用以实现更复杂的文本处理任务。这里是一些常见的组合使用示例：
1. 使用 grep + cut：筛选和提取字段 # 假设你有一个文件 data.txt，其内容如下：
Name, Age, Department Alice, 30, HR Bob, 25, Engineering Charlie, 35, Marketing 如果你只想提取 Name 和 Age 字段，可以使用 grep 和 cut 的组合：
grep -v &#34;Name&#34; data.txt | cut -d ',' -f 1,2 解释：
grep -v &#34;Name&#34;：去除第一行标题。 cut -d ',' -f 1,2：按照逗号分隔，提取第一列和第二列。 输出："><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>高级运维面试题-linux部分 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.08f94944067c72307a5b42b2b0ee2b3e368ffe6c13e06a2e651ee5e8d0237c15.js integrity="sha256-CPlJRAZ8cjB6W0KysO4rPjaP/mwT4GouZR7l6NAjfBU=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>00-集群规划和基础参数设定 2023-09-28 15:19:02.214</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>01-创建证书和环境准备 2023-09-28 15:22:19.812</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>02-安装etcd集群 2023-09-28 15:23:07.363</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>0224面试</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>0226 k8s题目</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>03-安装容器运行时 2023-09-28 15:23:56.241</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>04-安装kube_master节点 2023-09-28 15:24:21.203</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>05-安装kube_node节点 2023-09-28 15:24:43.201</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>06-安装calico网络组件 2023-09-28 15:34:28.483</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>06-安装cilium网络组件 2023-09-28 15:35:23.884</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>06-安装flannel网络组件 2023-09-28 15:35:50.039</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>06-安装kube-ovn网络组件 2023-09-28 15:36:11.265</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>06-安装网络组件 2023-09-28 15:25:14.997</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>07-安装集群主要插件 2023-09-28 15:26:42.651</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>08-K8S 集群存储 2023-09-28 15:27:29.454</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>16个概念带你入门 Kubernetes 2024-04-03 15:09:21.671</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>16张硬核图解k8s网络 2024-04-03 15:12:49.601</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-2-22 k8s架构师面试大全</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-2-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-2-26 面试</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-3-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-3-4 CNI剖析演进</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-3-8 面试</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-4-17 面试总结</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 k8s面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-8-1 linux运维面试题</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 linux面试题</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2025-1-16 CSI剖析演进</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2025-1-16 k8s流量链路剖析</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-8 k8s创建pod 流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-8 k8s删除pod deployment的流程图详解</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>33款gitops与devops主流系统 2024-08-02 17:45:15.709</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>600条最强linux命令总结 2024-04-03 15:12:31.282</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>acme自动更新证书 2024-04-03 14:41:44.289</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>calico 配置 BGP Route Reflectors 2023-09-28 15:34:01.007</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>Calico网络自定义 2024-04-03 15:08:43.394</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>CICD思考 2024-04-03 15:11:24.151</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>Client-go 四种客户端 2024-04-03 14:49:34.32</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>Client-go 架构 2024-04-03 14:48:40.716</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>CNI插件选型 2024-04-03 15:01:51.29</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>Containerd 基本操作 2024-04-03 14:55:46.786</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>COREDNS之光 2024-04-03 14:54:52.059</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>dockerfile定制专属镜像 2024-08-02 17:44:00.522</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>dockerfile的copy和add的区别 2024-04-03 15:01:09.565</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>Docker重要的网络知识点 2024-04-03 15:12:10.162</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>ETCD备份 2024-04-03</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>ETCD稳定性及性能优化实践 2024-04-03 15:06:31.141</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>EX-LB 负载均衡部署 2023-09-28 15:28:51.998</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>ezctl 命令行介绍 2023-09-28 15:28:00.619</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>flanel网络 2024-04-03 15:05:04.16</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>godel-scheduler 2024-08-02 17:41:00.668</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>helm chart和repo 2024-04-03 15:00:43.125</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>istio-ingress-gateway 2024-08-02 17:51:54.75</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>istio部署 2024-08-02 17:52:40.721</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>K8S CNI剖析演进 2024-03-04 10:51:33.245</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>K8S csi openebs原理 2024-04-03 14:44:48.967</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>K8S CSI剖析演进 2024-03-04 10:52:20.507</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>K8S GPT 2024-04-03 15:02:09.127</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>K8S 开发可不止 CRUD 2024-04-03 14:50:11.765</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>K8S 探针原理 2024-04-03 14:53:29.429</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>K8S 流量链路剖析 2024-03-04 10:50:22.991</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>K8S 调度器 scheduler_one.go 源码解读 2024-04-09 11:45:28.22</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>K8S之ingress-nginx原理及配置 2024-07-05 18:02:14.243</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>k8s之kubelet源码解读 2024-03-28 15:30:39.633</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>K8S原地升级 2024-04-03 15:04:38.125</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>K8S命令指南 2024-04-03 15:14:14.207</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>K8S如何获得 IP 2024-04-16 17:09:59.658</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>k8s应用的最佳实践 2024-04-03 14:43:16.936</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>K8S控制器之 deployment_controller.go源码解读 2024-04-09 11:30:03.133</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>K8S控制器之 progress.go 进度 源码解读 2024-04-09 11:31:08.86</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>K8S控制器之 rolling.go 滚动更新 源码解读 2024-04-09 11:32:58.133</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>K8S控制器之 scheduler.go 调度器 源码解读 2024-04-09 11:44:25.171</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>K8S控制器之recreate.go 重建 源码解读 2024-04-09 11:31:49.855</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>K8S控制器之rollback.go 回滚 源码解读 2024-04-09 11:32:26.587</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>K8S控制器之stateful_pod_control.go源码解读 2024-04-10 09:42:50.078</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>K8S控制器之stateful_set_control.go源码解读 2024-04-10 09:41:30.316</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>K8S控制器之stateful_set_status_update.go源码解读 2024-04-10</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>K8S控制器之stateful_set.go源码解读 2024-04-10</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>K8S控制器之sync.go 同步 源码解读 2024-04-09 11:33:26.356</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>K8S的POD类型 2024-04-03 14:57:11.072</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>K8S的最后一块拼图 dbpaas 2024-08-02 17:48:35.899</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>k8s组件</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>k8s背后service是如何工作的 2024-08-02 17:49:44.981</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>K8S调度器 extender.go 源码解读 2024-04-09 11:45:59.666</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>K8S调试POD 2024-04-03 14:58:15.293</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>k8s运维之清理磁盘 2024-04-03 15:13:57.279</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>K8S面试大全 2024-04-03 15:10:54.493</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>K8S面试宝典 2024-04-03 15:11:09.316</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>K8S面试题 2024-08-02 17:50:50.418</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>kruise原地升级解析 2024-08-02 17:59:31.689</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>kube-router 网络组件 2023-09-28 15:33:20.658</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>kubeasz部署k8s</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>kubekey添加新节点 2024-04-03 15:36:47.646</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>Kubernetes API 2024-04-03 14:47:30.212</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>Kubernetes 源码结构 2024-04-03 14:48:05.954</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>Kubernetes 证书详解(认证) 2024-04-03 14:52:56.54</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>Kubernetes 证书详解(鉴权) 2024-04-03 14:49:04.385</a></li><li><a href=/docs/kubewharf-kubewharf/>kubewharf 2024-08-02 17:41:32.72</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>linux awk文本处理器 8个案例 2024-08-02 17:46:53.603</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>Linux 性能优化大全 2024-04-03 15:09:06.854</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>linux系统性能优化 七个实战经验 2024-08-02 17:47:26.212</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>linux运维工程师50个常见面试题 2024-08-02 17:42:12.968</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>MetalLB L2 原理 2024-04-03 14:52:24.662</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>netctl检测集群pod间连通性 2024-08-02 18:00:36.753</a></li><li><a href=/docs/network-check-network-check/>network-check 2023-09-28 15:36:33.04</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>nginx如何解决惊群效应 2024-08-02 17:45:54.531</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>OpenKruise详细解释以及原地升级及全链路灰度发布方案 2024-07-22 11:44:46.892</a></li><li><a href=/docs/pixie-pixie/>pixie 2024-08-02 17:52:17.843</a></li><li><a href=/docs/2025-2-28-prometheus/>prometheus 面试题</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>prometheus-stack 2024-08-02 17:55:22.326</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>prometheus企业级监控使用总结 2024-04-03 15:13:11.185</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>ssl证书自签发 2024-04-03</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>TEG与istio集成 2024-08-02 17:51:20.389</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>两张图全面理解K8S原理 2024-04-03 14:51:27.431</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>个性化集群参数配置 2023-09-28 15:30:56.072</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>中级运维面试题</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>二进制部署K8S加节点操作 2024-04-03 15:08:26.726</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群 2023-04-12 04:04:09.458</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>使用 OpenFunction 在任何基础设施上运行无服务器工作负载 2024-01-21 04:02:44.459</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>使用cloudflare(CF)搭建dockerhub代理 2024-06-28 14:38:34.339</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>使用kubernees leases 轻松实现leader election 2024-04-03 15:09:46.129</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>公有云上部署 kubeasz 2023-09-28 15:31:16.19</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>单master单etcd改造为3master3etcd</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>史上最牛jenkins pipeline流水线详解 2024-08-02</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>多架构支持 2023-09-28 15:29:54.111</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>大厂总结nginx高并发优化笔记 2024-08-02 17:46:19.098</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>大规模并发下如何加快 Pod 启动速度 2024-04-03</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>如何为K8S保驾护航 2024-04-16 17:09:21.962</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>如何使用tekton快速搭建CI/CD平台 2024-04-03</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>如何调试 crash 容器的网络 2024-04-03 14:50:51.378</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>容器中域名解析以及不同dnspolicy对域名解析的影响 2024-04-03 15:04:09.254</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>容器内的 1 号进程 2024-04-03 14:46:29.998</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>容器原理 2024-04-03 14:45:58.422</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>容器的文件系统 OverlayFS 原理 2024-04-03 14:45:26.893</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>容器网络原理 2024-04-03 14:51:51.962</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>常见linux运维面试题 2024-08-02 17:42:33.873</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>开始使用 cilium 2023-09-28 15:34:49.205</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>彻悟容器网络 2024-04-07 10:30:11.55</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>快速指南 2023-09-28 15:28:25.71</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>我只想做技术 走技术路线 2024-08-02 17:43:31.897</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>搞懂K8S鉴权 2024-04-03 15:11:54.885</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>搭个日志手机系统不香吗 2024-08-02 17:47:58.794</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>操作系统说明 2023-09-28 15:31:37.694</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>文学的故乡 2024-04-03 14:40:45.926</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>是技术大神还是基础架构部的祸害 2024-08-02 17:50:26.139</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>有这3个迹象，你就该离职了 2023-09-21 16:00:22.432</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>极大提高工作效率的 Linux 命令 2024-04-03 14:42:46.957</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>构建容器镜像利器buildkit 2024-08-02 17:49:14.916</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>流量何处来何处去 2024-04-03 14:56:20.089</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>清理docker镜像 2024-08-02 17:54:48.594</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>清理残留的calico网络插件 2024-04-03 15:07:38.854</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>磁盘数据恢复 2024-04-03 14:59:27.839</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>离线安装kubephere 2024-04-03 14:59:59.885</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>离线安装集群 2023-09-28 15:29:14.742</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>美国码农薪酬</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>美国码农计划</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>自动屏蔽IP攻击 2024-04-03 14:54:11.783</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>面试0212</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>面试0219</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>面试0220</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>面试0225</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>面试0308 2024-04-03 14:57:53.576</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>面试2025-02-11</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>面试2025-0218</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>面试用 Golang 手撸 LRU 2024-04-03 14:47:00.767</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>顶级devops工具大盘点 2024-08-02 17:43:03.661</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/ class=active>高级运维面试题-linux部分</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>高级运维面试题-linux部分</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#linux>Linux</a></li><li><a href=#grep-sed-awk-cut组合使用>grep sed awk cut组合使用☆</a><ul><li><a href=#1-使用-grep--cut筛选和提取字段>1. 使用 <code>grep</code> + <code>cut</code>：筛选和提取字段</a></li><li><a href=#2-使用-grep--awk筛选和处理文本>2. 使用 <code>grep</code> + <code>awk</code>：筛选和处理文本</a></li><li><a href=#3-使用-sed--awk修改并处理文本>3. 使用 <code>sed</code> + <code>awk</code>：修改并处理文本</a></li><li><a href=#4-使用-grep--sed--awk综合使用>4. 使用 <code>grep</code> + <code>sed</code> + <code>awk</code>：综合使用</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#http错误码和原因>http错误码和原因</a><ul><li><a href=#1-1xx---信息类>1. <strong>1xx - 信息类</strong></a></li><li><a href=#2-2xx---成功类>2. <strong>2xx - 成功类</strong></a></li><li><a href=#3-3xx---重定向类>3. <strong>3xx - 重定向类</strong></a></li><li><a href=#4-4xx---客户端错误类>4. <strong>4xx - 客户端错误类</strong></a></li><li><a href=#5-5xx---服务器错误类>5. <strong>5xx - 服务器错误类</strong></a></li><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#3长连接短连接websocket区别和使用场景>3.长连接、短连接、WebSocket区别和使用场景</a><ul><li><a href=#1-短连接short-connection>1. <strong>短连接（Short Connection）</strong></a></li><li><a href=#2-长连接long-connection>2. <strong>长连接（Long Connection）</strong></a></li><li><a href=#3-websocket>3. <strong>WebSocket</strong></a></li><li><a href=#总结比较><strong>总结比较</strong></a></li><li><a href=#适用场景总结>适用场景总结：</a></li></ul></li><li><a href=#nginx性能优化有哪些方式>nginx性能优化有哪些方式☆</a><ul><li><a href=#1-调整工作进程和连接数>1. <strong>调整工作进程和连接数</strong></a></li><li><a href=#2-启用>2. <strong>启用 <code>keepalive</code> 持久连接</strong></a></li><li><a href=#3-启用-gzip-压缩>3. <strong>启用 GZIP 压缩</strong></a></li><li><a href=#4-优化缓存策略>4. <strong>优化缓存策略</strong></a></li><li><a href=#5-负载均衡优化>5. <strong>负载均衡优化</strong></a></li><li><a href=#6-减少-dns-查询延迟>6. <strong>减少 DNS 查询延迟</strong></a></li><li><a href=#7-提高文件-io-性能>7. <strong>提高文件 I/O 性能</strong></a></li><li><a href=#8-调整-tcp-连接优化>8. <strong>调整 TCP 连接优化</strong></a></li><li><a href=#9-限制请求速率>9. <strong>限制请求速率</strong></a></li><li><a href=#10-禁用不必要的模块>10. <strong>禁用不必要的模块</strong></a></li><li><a href=#11-监控和日志优化>11. <strong>监控和日志优化</strong></a></li><li><a href=#总结-2>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-lvslinux-virtual-server>1. <strong>LVS（Linux Virtual Server）</strong></a></li><li><a href=#2-nginx>2. <strong>Nginx</strong></a></li><li><a href=#3-haproxy>3. <strong>HAProxy</strong></a></li><li><a href=#总结比较-1><strong>总结比较</strong></a></li><li><a href=#选择建议><strong>选择建议</strong>：</a></li></ul></li></ul><ul><li><ul><li><a href=#为什么会产生僵尸进程><strong>为什么会产生僵尸进程？</strong></a></li><li><a href=#僵尸进程的特征><strong>僵尸进程的特征</strong></a></li><li><a href=#如何查看僵尸进程><strong>如何查看僵尸进程？</strong></a></li><li><a href=#如何解决僵尸进程><strong>如何解决僵尸进程？</strong></a></li><li><a href=#总结-3><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程process>1. <strong>进程（Process）</strong></a></li><li><a href=#2-线程thread>2. <strong>线程（Thread）</strong></a></li><li><a href=#3-协程coroutine>3. <strong>协程（Coroutine）</strong></a></li><li><a href=#进程线程协程对比><strong>进程、线程、协程对比</strong></a></li><li><a href=#总结-4><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-异步asynchronous><strong>1. 异步（Asynchronous）</strong></a></li><li><a href=#2-非阻塞non-blocking><strong>2. 非阻塞（Non-blocking）</strong></a></li><li><a href=#3-事件驱动模型><strong>3. 事件驱动模型</strong></a></li><li><a href=#4-单线程处理多个请求><strong>4. 单线程处理多个请求</strong></a></li><li><a href=#5-通过工作模式管理多个连接><strong>5. 通过工作模式管理多个连接</strong></a></li><li><a href=#6-典型的异步非阻塞处理流程><strong>6. 典型的异步非阻塞处理流程</strong></a></li><li><a href=#异步非阻塞的优势><strong>异步非阻塞的优势</strong></a></li><li><a href=#总结-5><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用>1. <strong>使用 <code>ping</code> 命令测试丢包情况</strong></a></li><li><a href=#2-检查网络接口的丢包情况>2. <strong>检查网络接口的丢包情况</strong></a></li><li><a href=#3-查看系统日志>3. <strong>查看系统日志</strong></a></li><li><a href=#4-使用>4. <strong>使用 <code>netstat</code> 查看网络连接情况</strong></a></li><li><a href=#5-使用>5. <strong>使用 <code>traceroute</code> 检查网络路径</strong></a></li><li><a href=#6-查看系统资源是否不足>6. <strong>查看系统资源是否不足</strong></a></li><li><a href=#7-调整-tcp-缓冲区>7. <strong>调整 TCP 缓冲区</strong></a></li><li><a href=#8-使用>8. <strong>使用 <code>ss</code> 工具进行网络连接分析</strong></a></li><li><a href=#9-检查网卡驱动和硬件问题>9. <strong>检查网卡驱动和硬件问题</strong></a></li><li><a href=#10-网络带宽和流量限制>10. <strong>网络带宽和流量限制</strong></a></li><li><a href=#总结-6>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-top>1. <strong><code>top</code></strong></a></li><li><a href=#2-htop>2. <strong><code>htop</code></strong></a></li><li><a href=#3-vmstat>3. <strong><code>vmstat</code></strong></a></li><li><a href=#4-iostat>4. <strong><code>iostat</code></strong></a></li><li><a href=#5-netstat>5. <strong><code>netstat</code></strong></a></li><li><a href=#6-ss>6. <strong><code>ss</code></strong></a></li><li><a href=#7-sar>7. <strong><code>sar</code></strong></a></li><li><a href=#8-dstat>8. <strong><code>dstat</code></strong></a></li><li><a href=#9-strace>9. <strong><code>strace</code></strong></a></li><li><a href=#10-perf>10. <strong><code>perf</code></strong></a></li><li><a href=#11-lsof>11. <strong><code>lsof</code></strong></a></li><li><a href=#12-iotop>12. <strong><code>iotop</code></strong></a></li><li><a href=#13-mpstat>13. <strong><code>mpstat</code></strong></a></li><li><a href=#总结-7>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#进程中断的种类>进程中断的种类</a></li><li><a href=#进程中断的工作流程>进程中断的工作流程</a></li><li><a href=#中断的优先级和中断屏蔽>中断的优先级和中断屏蔽</a></li><li><a href=#进程中断的作用>进程中断的作用</a></li><li><a href=#总结-8>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-硬中断-hardware-interrupt>1. <strong>硬中断 (Hardware Interrupt)</strong></a></li><li><a href=#2-软中断-software-interrupt>2. <strong>软中断 (Software Interrupt)</strong></a></li><li><a href=#硬中断与软中断的区别><strong>硬中断与软中断的区别</strong></a></li><li><a href=#应用场景和作用><strong>应用场景和作用</strong></a></li><li><a href=#总结-9>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-不可中断进程的特点>1. <strong>不可中断进程的特点</strong></a></li><li><a href=#2-不可中断进程的常见原因>2. <strong>不可中断进程的常见原因</strong></a></li><li><a href=#3-不可中断进程的处理>3. <strong>不可中断进程的处理</strong></a></li><li><a href=#4-不可中断进程的例子>4. <strong>不可中断进程的例子</strong></a></li><li><a href=#5-如何排查不可中断进程>5. <strong>如何排查不可中断进程</strong></a></li><li><a href=#总结-10>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-栈内存-stack-memory>1. <strong>栈内存 (Stack Memory)</strong></a></li><li><a href=#2-堆内存-heap-memory>2. <strong>堆内存 (Heap Memory)</strong></a></li><li><a href=#栈内存与堆内存的区别><strong>栈内存与堆内存的区别</strong></a></li><li><a href=#栈内存与堆内存的选择><strong>栈内存与堆内存的选择</strong></a></li><li><a href=#总结-11>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#进程状态的常见字母及其含义>进程状态的常见字母及其含义：</a></li><li><a href=#top><strong><code>top</code> 命令输出中的进程状态字段示例</strong>：</a></li><li><a href=#s><strong><code>S</code>、<code>D</code> 和 <code>Z</code> 状态的具体说明</strong>：</a></li><li><a href=#进程状态总结>进程状态总结：</a></li><li><a href=#其他补充>其他补充：</a></li></ul></li></ul><ul><li><ul><li><a href=#proc-目录的主要作用><code>/proc</code> 目录的主要作用</a></li><li><a href=#proc-目录中的重要文件和子目录><code>/proc</code> 目录中的重要文件和子目录</a></li><li><a href=#使用-proc-的常见场景>使用 <code>/proc</code> 的常见场景</a></li><li><a href=#示例-6>示例</a></li><li><a href=#总结-12>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-load负载>1. <strong>Load（负载）</strong></a></li><li><a href=#2-cpu-使用率>2. <strong>CPU 使用率</strong></a></li><li><a href=#load-和-cpu-使用率的区别><strong>Load 和 CPU 使用率的区别</strong></a></li><li><a href=#如何判断系统性能问题><strong>如何判断系统性能问题</strong></a></li><li><a href=#总结-13>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#如何通过-arp-转换-mac-地址和-ip-地址><strong>如何通过 ARP 转换 MAC 地址和 IP 地址：</strong></a></li><li><a href=#arp-工作原理><strong>ARP 工作原理：</strong></a></li><li><a href=#例子><strong>例子：</strong></a></li><li><a href=#总结-14><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#常见的-raid-级别>常见的 RAID 级别</a></li><li><a href=#总结-15>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#lvm-的基本概念>LVM 的基本概念</a></li><li><a href=#lvm-的常用操作>LVM 的常用操作</a></li><li><a href=#lvm-的优缺点>LVM 的优缺点</a></li><li><a href=#总结-16>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用-1>1. <strong>使用 <code>jps</code> 命令查看 JVM 进程</strong></a></li><li><a href=#2-使用>2. <strong>使用 <code>jvm</code> 参数查看内存设置</strong></a></li><li><a href=#3-使用>3. <strong>使用 <code>jstat</code> 命令查看 JVM 内存统计</strong></a></li><li><a href=#4-使用-1>4. <strong>使用 <code>jmap</code> 命令查看堆内存信息</strong></a></li><li><a href=#5-使用-1>5. <strong>使用 <code>visualvm</code> 或 <code>jconsole</code> 图形化工具</strong></a></li><li><a href=#6-使用>6. <strong>使用 <code>-XX:+PrintGCDetails</code> 参数查看垃圾回收日志</strong></a></li><li><a href=#7-查看系统层面的内存使用>7. <strong>查看系统层面的内存使用</strong></a></li><li><a href=#8-查看-metaspace-使用情况>8. <strong>查看 Metaspace 使用情况</strong></a></li><li><a href=#总结-17>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-查看当前内核参数>1. <strong>查看当前内核参数</strong></a></li><li><a href=#2-修改内核参数>2. <strong>修改内核参数</strong></a></li><li><a href=#3-常用内核参数及其优化>3. <strong>常用内核参数及其优化</strong></a></li><li><a href=#4-监控内核参数>4. <strong>监控内核参数</strong></a></li><li><a href=#5-调整参数的策略>5. <strong>调整参数的策略</strong></a></li><li><a href=#6-注意事项>6. <strong>注意事项</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程最大数max-processes>1. <strong>进程最大数（max processes）</strong></a></li><li><a href=#2-最大线程数max-threads>2. <strong>最大线程数（max threads）</strong></a></li><li><a href=#3-进程打开的文件数open-files>3. <strong>进程打开的文件数（open files）</strong></a></li><li><a href=#总结-18>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-统计对象不同>1. <strong>统计对象不同</strong></a></li><li><a href=#2-文件系统预留空间>2. <strong>文件系统预留空间</strong></a></li><li><a href=#3-软链接和挂载点>3. <strong>软链接和挂载点</strong></a></li><li><a href=#4-文件系统缓存>4. <strong>文件系统缓存</strong></a></li><li><a href=#5-挂载点重复>5. <strong>挂载点重复</strong></a></li><li><a href=#6-延迟同步文件删除>6. <strong>延迟同步（文件删除）</strong></a></li><li><a href=#7-du>7. <strong><code>du</code> 计算的单位和 <code>df</code> 的单位不同</strong></a></li><li><a href=#8-nfs-或网络文件系统>8. <strong>NFS 或网络文件系统</strong></a></li><li><a href=#9-磁盘碎片>9. <strong>磁盘碎片</strong></a></li><li><a href=#解决办法>解决办法：</a></li><li><a href=#总结-19>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-buffers>1. <strong><code>buffers</code></strong></a></li><li><a href=#2-cached>2. <strong><code>cached</code></strong></a></li><li><a href=#3-buffers>3. <strong><code>buffers</code> 与 <code>cached</code> 的区别</strong></a></li><li><a href=#4-总结>4. <strong>总结</strong></a></li><li><a href=#5-实际影响>5. <strong>实际影响</strong></a></li><li><a href=#6-释放缓存>6. <strong>释放缓存</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-查看某个进程打开的文件>1. <strong>查看某个进程打开的文件</strong></a></li><li><a href=#2-查看某个用户打开的文件>2. <strong>查看某个用户打开的文件</strong></a></li><li><a href=#3-查看特定文件的打开情况>3. <strong>查看特定文件的打开情况</strong></a></li><li><a href=#4-查看某个端口被哪个进程占用>4. <strong>查看某个端口被哪个进程占用</strong></a></li><li><a href=#5-查看文件系统的某个挂载点>5. <strong>查看文件系统的某个挂载点</strong></a></li><li><a href=#6-查找删除的文件>6. <strong>查找删除的文件</strong></a></li><li><a href=#7-查看文件锁>7. <strong>查看文件锁</strong></a></li><li><a href=#8-查看打开的网络文件tcpudp>8. <strong>查看打开的网络文件（TCP/UDP）</strong></a></li><li><a href=#9-查找进程占用的文件描述符>9. <strong>查找进程占用的文件描述符</strong></a></li><li><a href=#10-监控进程创建的临时文件>10. <strong>监控进程创建的临时文件</strong></a></li><li><a href=#总结-20>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#常见的-linux-进程间通信方式>常见的 Linux 进程间通信方式</a></li><li><a href=#1-管道pipe>1. <strong>管道（Pipe）</strong></a></li><li><a href=#2-命名管道fifo>2. <strong>命名管道（FIFO）</strong></a></li><li><a href=#3-消息队列message-queue>3. <strong>消息队列（Message Queue）</strong></a></li><li><a href=#4-信号signal>4. <strong>信号（Signal）</strong></a></li><li><a href=#5-共享内存shared-memory>5. <strong>共享内存（Shared Memory）</strong></a></li><li><a href=#6-信号量semaphore>6. <strong>信号量（Semaphore）</strong></a></li><li><a href=#7-套接字socket>7. <strong>套接字（Socket）</strong></a></li><li><a href=#8-内存映射memory-mapping>8. <strong>内存映射（Memory Mapping）</strong></a></li><li><a href=#总结-21>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程优先级的概念>1. <strong>进程优先级的概念</strong></a></li><li><a href=#2-优先级与>2. <strong>优先级与 <code>nice</code> 值</strong></a></li><li><a href=#3-查看进程的优先级>3. <strong>查看进程的优先级</strong></a></li><li><a href=#4-修改进程的>4. <strong>修改进程的 <code>nice</code> 值</strong></a></li><li><a href=#5-进程调度策略与优先级>5. <strong>进程调度策略与优先级</strong></a></li><li><a href=#6-查看进程调度策略>6. <strong>查看进程调度策略</strong></a></li><li><a href=#7-优先级调整的使用场景>7. <strong>优先级调整的使用场景</strong></a></li><li><a href=#8-总结>8. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程优先级的概念-1>1. <strong>进程优先级的概念</strong></a></li><li><a href=#2-优先级与-1>2. <strong>优先级与 <code>nice</code> 值</strong></a></li><li><a href=#3-查看进程的优先级-1>3. <strong>查看进程的优先级</strong></a></li><li><a href=#4-修改进程的-1>4. <strong>修改进程的 <code>nice</code> 值</strong></a></li><li><a href=#5-进程调度策略与优先级-1>5. <strong>进程调度策略与优先级</strong></a></li><li><a href=#6-查看进程调度策略-1>6. <strong>查看进程调度策略</strong></a></li><li><a href=#7-优先级调整的使用场景-1>7. <strong>优先级调整的使用场景</strong></a></li><li><a href=#8-总结-1>8. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-创建自定义-systemd-服务>1. <strong>创建自定义 systemd 服务</strong></a></li><li><a href=#2-管理自定义-systemd-服务>2. <strong>管理自定义 systemd 服务</strong></a></li><li><a href=#3-高级配置>3. <strong>高级配置</strong></a></li><li><a href=#4-总结-1>4. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-内核模块的加载过程>1. <strong>内核模块的加载过程</strong></a></li><li><a href=#2-内核模块的卸载过程>2. <strong>内核模块的卸载过程</strong></a></li><li><a href=#3-内核模块管理的其他相关命令>3. <strong>内核模块管理的其他相关命令</strong></a></li><li><a href=#4-自动加载模块>4. <strong>自动加载模块</strong></a></li><li><a href=#5-总结>5. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#ansible-roles-使用场景><strong>Ansible Roles 使用场景</strong></a></li><li><a href=#ansible-roles-目录结构><strong>Ansible Roles 目录结构</strong></a></li><li><a href=#如何用-ansible-批量将多台机器加入-kubernetes-集群><strong>如何用 Ansible 批量将多台机器加入 Kubernetes 集群</strong></a></li><li><a href=#总结-22><strong>总结</strong></a></li><li><a href=#1-准备角色和任务>1. <strong>准备角色和任务</strong></a></li><li><a href=#2-systemd>2. <strong><code>systemd</code> 服务配置文件</strong></a></li><li><a href=#3-主机清单文件>3. <strong>主机清单文件</strong></a></li><li><a href=#4-playbook-配置>4. <strong>Playbook 配置</strong></a></li><li><a href=#5-执行-playbook>5. <strong>执行 Playbook</strong></a></li><li><a href=#6-总结>6. <strong>总结</strong></a></li><li><a href=#1-dockerd-docker-daemon>1. <strong><code>dockerd</code></strong> (Docker Daemon)</a></li><li><a href=#2-docker-docker-cli>2. <strong><code>docker</code></strong> (Docker CLI)</a></li><li><a href=#3-containerd-container-runtime>3. <strong><code>containerd</code></strong> (Container Runtime)</a></li><li><a href=#4-runc-low-level-container-runtime>4. <strong><code>runc</code></strong> (Low-level Container Runtime)</a></li><li><a href=#5-ctr-containerd-cli>5. <strong><code>ctr</code></strong> (Containerd CLI)</a></li><li><a href=#6-dockerd>6. <strong><code>dockerd</code> 配置文件和插件</strong></a></li><li><a href=#7-docker-compose-用于管理多容器应用>7. <strong><code>docker-compose</code></strong> (用于管理多容器应用)</a></li><li><a href=#常见安装路径><strong>常见安装路径：</strong></a></li><li><a href=#docker-依赖的其他组件><strong>Docker 依赖的其他组件：</strong></a></li><li><a href=#总结-23><strong>总结</strong></a></li><li><a href=#1-创建必要的目录><strong>1. 创建必要的目录</strong></a></li><li><a href=#2-下载二进制文件><strong>2. 下载二进制文件</strong></a></li><li><a href=#3-配置文件设置><strong>3. 配置文件设置</strong></a></li><li><a href=#4-配置-kubelet><strong>4. 配置 Kubelet</strong></a></li><li><a href=#5-配置-kube-proxy><strong>5. 配置 Kube-proxy</strong></a></li><li><a href=#6-服务启动监控与等待><strong>6. 服务启动监控与等待</strong></a></li><li><a href=#7-标签和调度控制><strong>7. 标签和调度控制</strong></a></li><li><a href=#总结-24><strong>总结</strong></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><blockquote><p>经过本人为期一个半月的不懈努力，累计面试了二十多家公司，共计约五十余场面试，考察的面试题超两百道，积累了许多宝贵的面试经验。现在，我将这些面试题以及我个人的应对心得精心整理成一份面试攻略分享给大家，快来一起测测自己能回答多少道面试题吧。</p></blockquote><h1 id=面试基本信息>面试基本信息
<a class=anchor href=#%e9%9d%a2%e8%af%95%e5%9f%ba%e6%9c%ac%e4%bf%a1%e6%81%af>#</a></h1><p>面试岗位：运维工程师(容器与ES方向)、运维开发工程师、SRE工程师
工作经验：5年
薪资范围：年薪45万左右，base北京
面试时间：7月初-8月中旬
主要公司：</p><ul><li>互联网公司：字节、京东、百度、网易、蚂蚁金服、小米、滴滴、去哪儿、猎豹移动、商汤、旷视、智谱华章、马蜂窝、竞技世界</li><li>国企子公司：电信、联通、建行、中石化</li></ul><h1 id=面试题汇总>面试题汇总
<a class=anchor href=#%e9%9d%a2%e8%af%95%e9%a2%98%e6%b1%87%e6%80%bb>#</a></h1><p>其中☆表示多次出现过的高频面试题，已经按分类整理。</p><h2 id=linux>Linux
<a class=anchor href=#linux>#</a></h2><h2 id=grep-sed-awk-cut组合使用>grep sed awk cut组合使用☆
<a class=anchor href=#grep-sed-awk-cut%e7%bb%84%e5%90%88%e4%bd%bf%e7%94%a8>#</a></h2><p><code>grep</code>、<code>sed</code>、<code>awk</code> 和 <code>cut</code> 都是 Linux 系统中常用的文本处理工具，通常可以结合使用以实现更复杂的文本处理任务。这里是一些常见的组合使用示例：</p><h3 id=1-使用-grep--cut筛选和提取字段>1. 使用 <code>grep</code> + <code>cut</code>：筛选和提取字段
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-grep--cut%e7%ad%9b%e9%80%89%e5%92%8c%e6%8f%90%e5%8f%96%e5%ad%97%e6%ae%b5>#</a></h3><p>假设你有一个文件 <code>data.txt</code>，其内容如下：</p><pre tabindex=0><code>Name, Age, Department
Alice, 30, HR
Bob, 25, Engineering
Charlie, 35, Marketing
</code></pre><p>如果你只想提取 <code>Name</code> 和 <code>Age</code> 字段，可以使用 <code>grep</code> 和 <code>cut</code> 的组合：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep -v <span style=color:#e6db74>&#34;Name&#34;</span> data.txt | cut -d <span style=color:#e6db74>&#39;,&#39;</span> -f 1,2
</span></span></code></pre></div><p>解释：</p><ul><li><code>grep -v "Name"</code>：去除第一行标题。</li><li><code>cut -d ',' -f 1,2</code>：按照逗号分隔，提取第一列和第二列。</li></ul><p>输出：</p><pre tabindex=0><code>Alice, 30
Bob, 25
Charlie, 35
</code></pre><h3 id=2-使用-grep--awk筛选和处理文本>2. 使用 <code>grep</code> + <code>awk</code>：筛选和处理文本
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-grep--awk%e7%ad%9b%e9%80%89%e5%92%8c%e5%a4%84%e7%90%86%e6%96%87%e6%9c%ac>#</a></h3><p>假设你要根据某个条件（如年龄大于 30）筛选数据，并进行一些进一步的处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep -v <span style=color:#e6db74>&#34;Name&#34;</span> data.txt | awk -F <span style=color:#e6db74>&#39;,&#39;</span> <span style=color:#e6db74>&#39;$2 &gt; 30 {print $1, $2}&#39;</span>
</span></span></code></pre></div><p>解释：</p><ul><li><code>grep -v "Name"</code>：去除标题行。</li><li><code>awk -F ',' '$2 > 30 {print $1, $2}'</code>：以逗号作为分隔符，筛选年龄大于 30 的行，并输出姓名和年龄。</li></ul><p>输出：</p><pre tabindex=0><code>Charlie 35
</code></pre><h3 id=3-使用-sed--awk修改并处理文本>3. 使用 <code>sed</code> + <code>awk</code>：修改并处理文本
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8-sed--awk%e4%bf%ae%e6%94%b9%e5%b9%b6%e5%a4%84%e7%90%86%e6%96%87%e6%9c%ac>#</a></h3><p>假设你想把所有姓名前面加上 &ldquo;Mr.&rdquo; 并筛选年龄大于 30 的人：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sed <span style=color:#e6db74>&#39;s/^/Mr. /&#39;</span> data.txt | awk -F <span style=color:#e6db74>&#39;,&#39;</span> <span style=color:#e6db74>&#39;$2 &gt; 30 {print $1, $2}&#39;</span>
</span></span></code></pre></div><p>解释：</p><ul><li><code>sed 's/^/Mr. /'</code>：在每一行的开头加上 &ldquo;Mr. &ldquo;。</li><li><code>awk -F ',' '$2 > 30 {print $1, $2}'</code>：筛选年龄大于 30 的人并输出姓名和年龄。</li></ul><p>输出：</p><pre tabindex=0><code>Mr. Charlie 35
</code></pre><h3 id=4-使用-grep--sed--awk综合使用>4. 使用 <code>grep</code> + <code>sed</code> + <code>awk</code>：综合使用
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-grep--sed--awk%e7%bb%bc%e5%90%88%e4%bd%bf%e7%94%a8>#</a></h3><p>你可以将这几种工具结合起来，进行更复杂的处理。例如，从文件中找出所有包含 &ldquo;HR&rdquo; 的行，去掉空格并提取姓名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>grep <span style=color:#e6db74>&#34;HR&#34;</span> data.txt | sed <span style=color:#e6db74>&#39;s/ //g&#39;</span> | awk -F <span style=color:#e6db74>&#39;,&#39;</span> <span style=color:#e6db74>&#39;{print $1}&#39;</span>
</span></span></code></pre></div><p>解释：</p><ul><li><code>grep "HR"</code>：查找包含 &ldquo;HR&rdquo; 的行。</li><li><code>sed 's/ //g'</code>：删除行中的所有空格。</li><li><code>awk -F ',' '{print $1}'</code>：提取第一列（姓名）。</li></ul><p>输出：</p><pre tabindex=0><code>Alice
</code></pre><h3 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong><code>grep</code></strong> 用于筛选文本。</li><li><strong><code>cut</code></strong> 用于提取特定的字段或列。</li><li><strong><code>awk</code></strong> 用于更复杂的模式匹配和处理，可以在行级别进行操作。</li><li><strong><code>sed</code></strong> 用于文本的替换、删除等操作。</li></ul><p>这些工具各有优势，可以根据需要灵活组合，完成各种文本处理任务。</p><h2 id=http错误码和原因>http错误码和原因
<a class=anchor href=#http%e9%94%99%e8%af%af%e7%a0%81%e5%92%8c%e5%8e%9f%e5%9b%a0>#</a></h2><p>HTTP 错误码用于表示 HTTP 请求的状态。它们按类别分为五个类：1xx（信息类）、2xx（成功类）、3xx（重定向类）、4xx（客户端错误类）、5xx（服务器错误类）。以下是常见的 HTTP 错误码及其含义和原因：</p><h3 id=1-1xx---信息类>1. <strong>1xx - 信息类</strong>
<a class=anchor href=#1-1xx---%e4%bf%a1%e6%81%af%e7%b1%bb>#</a></h3><p>这些状态码表示服务器已收到请求，客户端需要继续处理。</p><ul><li><strong>100 Continue</strong>：客户端应继续发送请求的剩余部分。</li><li><strong>101 Switching Protocols</strong>：服务器接受客户端的协议切换请求。</li></ul><h3 id=2-2xx---成功类>2. <strong>2xx - 成功类</strong>
<a class=anchor href=#2-2xx---%e6%88%90%e5%8a%9f%e7%b1%bb>#</a></h3><p>表示请求已经成功被服务器处理。</p><ul><li><strong>200 OK</strong>：请求成功，通常在 GET 或 POST 请求后返回。</li><li><strong>201 Created</strong>：请求成功并且服务器创建了新资源。</li><li><strong>202 Accepted</strong>：请求已接受，但未处理完成。</li><li><strong>204 No Content</strong>：请求成功，但没有返回任何内容。</li></ul><h3 id=3-3xx---重定向类>3. <strong>3xx - 重定向类</strong>
<a class=anchor href=#3-3xx---%e9%87%8d%e5%ae%9a%e5%90%91%e7%b1%bb>#</a></h3><p>这些状态码表示客户端需要采取额外的操作才能完成请求。</p><ul><li><strong>301 Moved Permanently</strong>：资源已永久移动到新位置。</li><li><strong>302 Found</strong>：资源临时移动到新位置（常用于临时重定向）。</li><li><strong>303 See Other</strong>：请求应使用 GET 方法访问另一个资源。</li><li><strong>304 Not Modified</strong>：请求的资源未修改，客户端可以使用缓存。</li><li><strong>307 Temporary Redirect</strong>：请求的资源临时移动到新位置。</li><li><strong>308 Permanent Redirect</strong>：请求的资源永久移动到新位置。</li></ul><h3 id=4-4xx---客户端错误类>4. <strong>4xx - 客户端错误类</strong>
<a class=anchor href=#4-4xx---%e5%ae%a2%e6%88%b7%e7%ab%af%e9%94%99%e8%af%af%e7%b1%bb>#</a></h3><p>这些状态码表示客户端请求有错误，通常是由于客户端的请求无效或格式不正确。</p><ul><li><strong>400 Bad Request</strong>：请求格式不正确或缺少必需的参数。</li><li><strong>401 Unauthorized</strong>：请求需要用户身份验证，通常用于未授权的 API 请求。</li><li><strong>402 Payment Required</strong>：此状态码保留供将来使用，目前大多不常见。</li><li><strong>403 Forbidden</strong>：服务器理解请求，但拒绝执行。通常是因为权限问题。</li><li><strong>404 Not Found</strong>：请求的资源未找到。</li><li><strong>405 Method Not Allowed</strong>：请求方法（如 GET、POST 等）不允许访问该资源。</li><li><strong>406 Not Acceptable</strong>：服务器无法生成符合请求头中 &ldquo;Accept&rdquo; 字段的响应。</li><li><strong>407 Proxy Authentication Required</strong>：需要代理认证。</li><li><strong>408 Request Timeout</strong>：客户端请求超时，服务器未在规定时间内接收到请求。</li><li><strong>409 Conflict</strong>：请求导致资源冲突，通常用于资源的创建或修改操作。</li><li><strong>410 Gone</strong>：请求的资源不再可用，并且不再会恢复。</li><li><strong>411 Length Required</strong>：请求缺少 &ldquo;Content-Length&rdquo; 头部。</li><li><strong>412 Precondition Failed</strong>：请求头中的某些条件未满足。</li><li><strong>413 Payload Too Large</strong>：请求体太大，服务器无法处理。</li><li><strong>414 URI Too Long</strong>：请求的 URI 太长，服务器无法处理。</li><li><strong>415 Unsupported Media Type</strong>：请求的媒体类型不受支持。</li><li><strong>416 Range Not Satisfiable</strong>：请求的范围无效，服务器无法提供部分资源。</li><li><strong>417 Expectation Failed</strong>：服务器无法满足 &ldquo;Expect&rdquo; 请求头中的期望。</li></ul><h3 id=5-5xx---服务器错误类>5. <strong>5xx - 服务器错误类</strong>
<a class=anchor href=#5-5xx---%e6%9c%8d%e5%8a%a1%e5%99%a8%e9%94%99%e8%af%af%e7%b1%bb>#</a></h3><p>这些状态码表示服务器在处理请求时发生了错误，通常是服务器问题。</p><ul><li><strong>500 Internal Server Error</strong>：服务器遇到错误，无法完成请求。</li><li><strong>501 Not Implemented</strong>：服务器不支持请求的方法或功能。</li><li><strong>502 Bad Gateway</strong>：服务器作为网关或代理时，从上游服务器收到无效响应。</li><li><strong>503 Service Unavailable</strong>：服务器当前无法处理请求，通常由于过载或维护。</li><li><strong>504 Gateway Timeout</strong>：服务器作为网关或代理时，未从上游服务器收到及时响应。</li><li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求的 HTTP 版本。</li></ul><h3 id=总结-1>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-1>#</a></h3><ul><li><strong>2xx</strong>：请求成功。</li><li><strong>3xx</strong>：请求需要重定向。</li><li><strong>4xx</strong>：客户端错误（例如请求不合法或权限问题）。</li><li><strong>5xx</strong>：服务器错误（服务器处理请求时发生了问题）。</li></ul><p>这些错误码帮助开发者理解请求失败的原因，方便进行调试或错误处理。</p><h2 id=3长连接短连接websocket区别和使用场景>3.长连接、短连接、WebSocket区别和使用场景
<a class=anchor href=#3%e9%95%bf%e8%bf%9e%e6%8e%a5%e7%9f%ad%e8%bf%9e%e6%8e%a5websocket%e5%8c%ba%e5%88%ab%e5%92%8c%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h2><p>长连接、短连接和 WebSocket 都是网络通信中的不同连接方式，它们在使用时有不同的特点和应用场景。下面我们来详细讨论它们的区别和适用场景。</p><h3 id=1-短连接short-connection>1. <strong>短连接（Short Connection）</strong>
<a class=anchor href=#1-%e7%9f%ad%e8%bf%9e%e6%8e%a5short-connection>#</a></h3><h4 id=特点>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9>#</a></h4><ul><li><strong>每次请求都建立新的连接</strong>：每次客户端发送请求时，都会和服务器建立一个新的连接，处理完请求后即关闭连接。</li><li><strong>资源消耗大</strong>：每次请求都要进行连接的建立和销毁，频繁的连接和断开会增加网络延迟和资源消耗，尤其是在高频次请求的情况下。</li><li><strong>典型协议</strong>：HTTP/1.x、SMTP（邮件）、FTP 等。</li></ul><h4 id=使用场景>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h4><ul><li><strong>简单的请求-响应模式</strong>：比如网页浏览、提交表单等，一次请求一次响应。</li><li><strong>不需要持续通信的场景</strong>：例如用户查询信息，数据更新不频繁，服务器负载较低的情况。</li></ul><h4 id=优点>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9>#</a></h4><ul><li>连接生命周期短，不会占用太多服务器资源。</li><li>适合低频请求的场景。</li></ul><h4 id=缺点>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9>#</a></h4><ul><li>每次请求都需要建立连接，较高的延迟和资源消耗。</li><li>无法实现实时通信或长时间的保持连接。</li></ul><h3 id=2-长连接long-connection>2. <strong>长连接（Long Connection）</strong>
<a class=anchor href=#2-%e9%95%bf%e8%bf%9e%e6%8e%a5long-connection>#</a></h3><h4 id=特点-1>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-1>#</a></h4><ul><li><strong>建立连接后保持长时间不关闭</strong>：客户端和服务器在建立连接后，连接会一直保持，直到客户端或服务器主动关闭连接。</li><li><strong>减少建立连接的开销</strong>：在连接存活期间，客户端可以发送多个请求，避免了频繁的连接和断开的开销。</li><li><strong>典型协议</strong>：HTTP/1.1 的持久连接（通过 <code>Connection: keep-alive</code> 头控制）、TCP 连接。</li></ul><h4 id=使用场景-1>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-1>#</a></h4><ul><li><strong>需要多次请求的场景</strong>：如在一个页面加载过程中，多个资源（图片、JS、CSS 文件等）需要多次请求服务器，这时保持一个持久的连接可以降低延迟。</li><li><strong>实时性要求不高的长时间会话</strong>：比如在线聊天室、数据推送等场景。</li></ul><h4 id=优点-1>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-1>#</a></h4><ul><li>避免了频繁的连接建立和断开，减少了延迟。</li><li>更适合多次请求的交互。</li></ul><h4 id=缺点-1>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-1>#</a></h4><ul><li>长时间占用连接资源，可能导致服务器负载增加。</li><li>如果连接不稳定，可能会导致连接中断。</li></ul><h3 id=3-websocket>3. <strong>WebSocket</strong>
<a class=anchor href=#3-websocket>#</a></h3><h4 id=特点-2>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-2>#</a></h4><ul><li><strong>全双工通信</strong>：WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，客户端和服务器可以随时发送数据到对方。</li><li><strong>低延迟、实时通信</strong>：建立 WebSocket 连接后，客户端和服务器之间可以进行实时的双向数据交换，适合高频率和低延迟的场景。</li><li><strong>持久连接</strong>：WebSocket 一旦建立连接后会持续存在，直到客户端或服务器主动关闭连接。</li><li><strong>典型协议</strong>：WebSocket 协议（<code>ws://</code> 或 <code>wss://</code>）。</li></ul><h4 id=使用场景-2>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-2>#</a></h4><ul><li><strong>实时通讯应用</strong>：如在线聊天、即时消息、股票行情、多人在线游戏、社交网络等。</li><li><strong>需要实时推送数据的场景</strong>：例如实时更新、推送通知、直播数据流、物联网设备管理等。</li></ul><h4 id=优点-2>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-2>#</a></h4><ul><li>低延迟，适合实时性要求高的应用。</li><li>通过一个连接可以发送和接收数据，减少了频繁建立连接的开销。</li><li>服务器和客户端可以主动推送消息到对方。</li></ul><h4 id=缺点-2>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-2>#</a></h4><ul><li>需要持续保持连接，可能会消耗较多的资源。</li><li>对于 WebSocket 的支持较为有限，需要服务器和客户端同时支持 WebSocket 协议。</li><li>因为 WebSocket 是持续连接，在某些网络环境下可能会遇到连接稳定性问题。</li></ul><h3 id=总结比较><strong>总结比较</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93%e6%af%94%e8%be%83>#</a></h3><table><thead><tr><th>特性/协议</th><th>短连接</th><th>长连接</th><th>WebSocket</th></tr></thead><tbody><tr><td>连接类型</td><td>每次请求建立一次连接</td><td>一次连接可多次使用</td><td>持久连接，双向通信</td></tr><tr><td>连接生命周期</td><td>短暂的连接和断开</td><td>持久连接</td><td>持久连接</td></tr><tr><td>资源消耗</td><td>高（频繁连接和断开）</td><td>低（减少连接建立的开销）</td><td>适中（长时间占用连接）</td></tr><tr><td>适用场景</td><td>简单的请求-响应，低频请求</td><td>多次请求需要保持连接，实时性要求不高</td><td>实时通信，低延迟数据交换，高频数据推送</td></tr><tr><td>通信方式</td><td>单向（客户端请求，服务器响应）</td><td>单向（客户端请求，服务器响应）</td><td>双向（客户端和服务器都能发送消息）</td></tr><tr><td>协议支持</td><td>HTTP/1.x，SMTP，FTP 等</td><td>HTTP/1.1，TCP 等</td><td>WebSocket</td></tr></tbody></table><h3 id=适用场景总结>适用场景总结：
<a class=anchor href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong>短连接</strong>：适用于简单的请求-响应场景，连接生命周期短，适合低频交互，不需要持久连接的场合。</li><li><strong>长连接</strong>：适用于需要多次请求的场景，或者是可以接受一定延迟但要求持续连接的应用。</li><li><strong>WebSocket</strong>：适用于实时通信、低延迟和高频数据交换的场景，如在线游戏、即时聊天、股票行情推送等。</li></ul><h2 id=nginx性能优化有哪些方式>nginx性能优化有哪些方式☆
<a class=anchor href=#nginx%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e5%bc%8f>#</a></h2><p>Nginx 是一个高性能的 Web 服务器和反向代理服务器，广泛用于负载均衡、反向代理、静态文件服务等场景。为了提高 Nginx 的性能，可以通过多个方面进行优化。下面列出了一些常见的 Nginx 性能优化方式：</p><h3 id=1-调整工作进程和连接数>1. <strong>调整工作进程和连接数</strong>
<a class=anchor href=#1-%e8%b0%83%e6%95%b4%e5%b7%a5%e4%bd%9c%e8%bf%9b%e7%a8%8b%e5%92%8c%e8%bf%9e%e6%8e%a5%e6%95%b0>#</a></h3><p>Nginx 的性能很大程度上取决于工作进程（worker process）和每个工作进程的连接数。合理的配置可以提高并发处理能力。</p><ul><li><p><strong>worker_processes</strong>：设置 Nginx 启动的工作进程数。通常设置为 CPU 核心数，或者根据服务器的负载情况调整。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>worker_processes</span>  <span style=color:#ae81ff>4</span>;  <span style=color:#75715e># 根据 CPU 核心数设置
</span></span></span></code></pre></div></li><li><p><strong>worker_connections</strong>：设置每个工作进程可以打开的最大连接数。此值与客户端并发连接数密切相关。调整时要考虑系统的最大文件描述符限制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>worker_connections</span> <span style=color:#ae81ff>1024</span>;  <span style=color:#75715e># 根据实际需求调整
</span></span></span></code></pre></div></li><li><p><strong>worker_rlimit_nofile</strong>：增加工作进程的文件描述符限制，防止在高并发下达到文件描述符限制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>worker_rlimit_nofile</span> <span style=color:#ae81ff>65535</span>;
</span></span></code></pre></div></li></ul><h3 id=2-启用>2. <strong>启用 <code>keepalive</code> 持久连接</strong>
<a class=anchor href=#2-%e5%90%af%e7%94%a8>#</a></h3><p><code>keepalive</code> 连接可以减少建立和关闭连接的开销。可以通过设置合适的超时时间来优化连接复用。</p><ul><li><p><strong>keepalive_timeout</strong>：设置保持连接的最大时间。在处理高并发请求时，合理的保持连接超时能减少连接建立的次数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>keepalive_timeout</span>  <span style=color:#ae81ff>65</span>;  <span style=color:#75715e># 默认是 75s，适当调小可以减少空闲连接占用
</span></span></span></code></pre></div></li><li><p><strong>keepalive_requests</strong>：限制每个连接的请求数，避免占用过多资源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>keepalive_requests</span> <span style=color:#ae81ff>10000</span>;  <span style=color:#75715e># 每个连接最多处理 10000 个请求
</span></span></span></code></pre></div></li></ul><h3 id=3-启用-gzip-压缩>3. <strong>启用 GZIP 压缩</strong>
<a class=anchor href=#3-%e5%90%af%e7%94%a8-gzip-%e5%8e%8b%e7%bc%a9>#</a></h3><p>开启 GZIP 压缩可以有效减少传输数据量，提升带宽利用率和加载速度。</p><ul><li><p><strong>gzip</strong>：开启 GZIP 压缩。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>gzip</span>  <span style=color:#66d9ef>on</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>gzip_comp_level</span> <span style=color:#ae81ff>6</span>;  <span style=color:#75715e># 设置压缩级别，1-9，数字越大压缩越强
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>gzip_min_length</span> <span style=color:#ae81ff>1000</span>;  <span style=color:#75715e># 只有内容长度大于 1000 字节的响应才会被压缩
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>gzip_proxied</span> <span style=color:#e6db74>any</span>;  <span style=color:#75715e># 启用对代理请求的压缩
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>gzip_types</span> <span style=color:#e6db74>text/plain</span> <span style=color:#e6db74>text/css</span> <span style=color:#e6db74>application/javascript</span> <span style=color:#e6db74>application/json</span> <span style=color:#e6db74>application/xml</span> <span style=color:#e6db74>text/javascript</span> <span style=color:#e6db74>application/xml+rss</span> <span style=color:#e6db74>image/svg+xml</span>;  <span style=color:#75715e># 指定需要压缩的文件类型
</span></span></span></code></pre></div></li></ul><h3 id=4-优化缓存策略>4. <strong>优化缓存策略</strong>
<a class=anchor href=#4-%e4%bc%98%e5%8c%96%e7%bc%93%e5%ad%98%e7%ad%96%e7%95%a5>#</a></h3><p>合理的缓存策略可以极大提升访问速度，减少对后端服务器的压力。</p><ul><li><p><strong>开启缓存</strong>：通过 <code>proxy_cache</code> 配置启用反向代理缓存，可以缓存静态文件和动态内容，减少对后端服务器的请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>proxy_cache_path</span> <span style=color:#e6db74>/tmp/cache</span> <span style=color:#e6db74>levels=1:2</span> <span style=color:#e6db74>keys_zone=my_cache:10m</span> <span style=color:#e6db74>inactive=60m</span> <span style=color:#e6db74>max_size=1g</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>proxy_cache_key</span> <span style=color:#e6db74>&#34;</span>$scheme$request_method$host$request_uri&#34;;
</span></span></code></pre></div></li><li><p><strong>设置缓存过期时间</strong>：使用 <code>expires</code> 设置静态资源的缓存时间，减少对后端的请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/static/</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>expires</span> <span style=color:#e6db74>30d</span>;  <span style=color:#75715e># 设置缓存 30 天
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li></ul><h3 id=5-负载均衡优化>5. <strong>负载均衡优化</strong>
<a class=anchor href=#5-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e4%bc%98%e5%8c%96>#</a></h3><p>对于 Nginx 的反向代理，合理的负载均衡配置可以提高并发性能，避免单一节点过载。</p><ul><li><p><strong>负载均衡算法</strong>：Nginx 支持多种负载均衡算法，如轮询、最少连接、IP 哈希等，可以根据实际需求选择合适的算法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>least_conn</span>;  <span style=color:#75715e># 使用最少连接负载均衡算法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>健康检查</strong>：定期检查后端服务器的健康状况，避免将流量引导到故障的服务器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>backend</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend1.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend2.example.com</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 设置失败请求重试次数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>server</span> <span style=color:#e6db74>backend3.example.com</span> <span style=color:#e6db74>max_fails=3</span> <span style=color:#e6db74>fail_timeout=30s</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=6-减少-dns-查询延迟>6. <strong>减少 DNS 查询延迟</strong>
<a class=anchor href=#6-%e5%87%8f%e5%b0%91-dns-%e6%9f%a5%e8%af%a2%e5%bb%b6%e8%bf%9f>#</a></h3><p>Nginx 可以缓存 DNS 查询结果，减少频繁的 DNS 查询带来的延迟。</p><ul><li><p><strong>resolver</strong>：设置 DNS 解析器并配置缓存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>resolver</span> <span style=color:#ae81ff>8</span><span style=color:#e6db74>.8.8.8</span> <span style=color:#ae81ff>8</span><span style=color:#e6db74>.8.4.4</span> <span style=color:#e6db74>valid=10s</span>;  <span style=color:#75715e># 设置 DNS 解析服务器及缓存时间
</span></span></span></code></pre></div></li></ul><h3 id=7-提高文件-io-性能>7. <strong>提高文件 I/O 性能</strong>
<a class=anchor href=#7-%e6%8f%90%e9%ab%98%e6%96%87%e4%bb%b6-io-%e6%80%a7%e8%83%bd>#</a></h3><p>Nginx 需要处理大量的静态文件，文件 I/O 性能直接影响整体性能。</p><ul><li><p><strong>开启 <code>sendfile</code></strong>：<code>sendfile</code> 可以直接从文件系统读取数据并通过网络发送，避免多次复制，提高性能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>sendfile</span> <span style=color:#66d9ef>on</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>tcp_nopush</span> <span style=color:#66d9ef>on</span>;  <span style=color:#75715e># 配合 sendfile 使用，减少传输时的 TCP 包数量
</span></span></span></code></pre></div></li><li><p><strong><code>aio</code> 和 <code>directio</code></strong>：对于大文件，可以开启异步 I/O，进一步提高文件传输效率。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>aio</span> <span style=color:#e6db74>threads</span>;  <span style=color:#75715e># 开启异步 I/O
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>directio</span> <span style=color:#ae81ff>4m</span>;  <span style=color:#75715e># 对大于 4MB 的文件开启直接 I/O
</span></span></span></code></pre></div></li></ul><h3 id=8-调整-tcp-连接优化>8. <strong>调整 TCP 连接优化</strong>
<a class=anchor href=#8-%e8%b0%83%e6%95%b4-tcp-%e8%bf%9e%e6%8e%a5%e4%bc%98%e5%8c%96>#</a></h3><p>Nginx 作为 Web 服务器，涉及到大量的 TCP 连接。优化 TCP 连接设置可以提高性能。</p><ul><li><p><strong>tcp_nodelay</strong>：启用 TCP_NODELAY，关闭 Nagle 算法，减少小数据包的延迟。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>tcp_nodelay</span> <span style=color:#66d9ef>on</span>;
</span></span></code></pre></div></li><li><p><strong>tcp_fin_timeout</strong>：控制服务器关闭连接时的等待时间，减小服务器的连接消耗。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>tcp_fin_timeout</span> <span style=color:#ae81ff>30</span>;
</span></span></code></pre></div></li></ul><h3 id=9-限制请求速率>9. <strong>限制请求速率</strong>
<a class=anchor href=#9-%e9%99%90%e5%88%b6%e8%af%b7%e6%b1%82%e9%80%9f%e7%8e%87>#</a></h3><p>对于高流量的应用，限制客户端的请求速率可以防止流量洪水并确保公平分配资源。</p><ul><li><p><strong>limit_req</strong>：限制每秒请求数，防止某些客户端过于频繁地请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>limit_req_zone</span> $binary_remote_addr <span style=color:#e6db74>zone=req_limit_per_ip:10m</span> <span style=color:#e6db74>rate=1r/s</span>;  <span style=color:#75715e># 每个 IP 最多 1 个请求/秒
</span></span></span></code></pre></div></li></ul><h3 id=10-禁用不必要的模块>10. <strong>禁用不必要的模块</strong>
<a class=anchor href=#10-%e7%a6%81%e7%94%a8%e4%b8%8d%e5%bf%85%e8%a6%81%e7%9a%84%e6%a8%a1%e5%9d%97>#</a></h3><p>Nginx 提供了很多模块，某些模块可能在你的应用场景中并不需要。禁用不必要的模块可以减少内存占用和提升性能。</p><ul><li><p>在编译 Nginx 时，禁用不需要的模块。例如，禁用代理模块、邮件代理模块等。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./configure --without-http_rewrite_module --without-http_gzip_module
</span></span></code></pre></div></li></ul><h3 id=11-监控和日志优化>11. <strong>监控和日志优化</strong>
<a class=anchor href=#11-%e7%9b%91%e6%8e%a7%e5%92%8c%e6%97%a5%e5%bf%97%e4%bc%98%e5%8c%96>#</a></h3><p>监控 Nginx 的性能并进行实时调整，对于高负载应用尤为重要。</p><ul><li><p><strong>日志优化</strong>：精简日志内容，避免记录不必要的请求信息，减少磁盘 I/O 和 CPU 占用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>access_log</span> <span style=color:#e6db74>/var/log/nginx/access.log</span> <span style=color:#e6db74>combined</span> <span style=color:#e6db74>buffer=32k</span> <span style=color:#e6db74>flush=5m</span>;  <span style=color:#75715e># 使用缓冲区来减少磁盘 I/O
</span></span></span></code></pre></div></li></ul><h3 id=总结-2>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-2>#</a></h3><p>Nginx 性能优化涉及多个方面，包括硬件资源（如 CPU 和内存）、网络配置、负载均衡、缓存策略、TCP 连接优化等。合理配置和调整 Nginx 的工作进程、连接数、缓存机制、负载均衡策略等，可以有效提升 Nginx 的性能，确保在高并发、高流量的场景下仍然能够稳定、高效地工作。</p><h1 id=lvsnginxhaproxy区别和使用场景>lvs、nginx、haproxy区别和使用场景☆
<a class=anchor href=#lvsnginxhaproxy%e5%8c%ba%e5%88%ab%e5%92%8c%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h1><p>LVS（Linux Virtual Server）、Nginx 和 HAProxy 都是常见的负载均衡技术，它们的功能有一些重叠，但在设计目标、性能、灵活性和使用场景上有所不同。下面将分别介绍它们的特点、优缺点及适用的使用场景。</p><h3 id=1-lvslinux-virtual-server>1. <strong>LVS（Linux Virtual Server）</strong>
<a class=anchor href=#1-lvslinux-virtual-server>#</a></h3><p>LVS 是基于 Linux 内核的负载均衡解决方案，常用于高可用性和高性能的负载均衡场景。它主要通过 IP 负载均衡来分发流量。</p><h4 id=特点-3>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-3>#</a></h4><ul><li><strong>工作在网络层（L4 层）</strong>：LVS 主要进行基于 IP 地址和端口的负载均衡，通常工作在 OSI 模型的传输层（L4 层）。</li><li><strong>高性能</strong>：LVS 作为内核级别的负载均衡器，其性能非常高，因为它直接处理数据包转发，避免了应用层的开销。</li><li><strong>透明性</strong>：LVS 通过 NAT（网络地址转换）、DR（Direct Routing）等技术实现负载均衡，客户端无法察觉负载均衡的存在。</li><li><strong>调度算法</strong>：LVS 支持多种负载均衡算法，如轮询、加权轮询、最少连接、源地址哈希等。</li></ul><h4 id=优点-3>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-3>#</a></h4><ul><li><strong>高性能</strong>：由于是内核级别的负载均衡，LVS 能提供高吞吐量，适合处理大量并发流量。</li><li><strong>透明性</strong>：客户端不需要知道负载均衡的存在，提供透明的负载均衡。</li><li><strong>高可用性</strong>：可以与 Keepalived 配合使用，实现高可用性。</li></ul><h4 id=缺点-3>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-3>#</a></h4><ul><li><strong>灵活性差</strong>：LVS 仅支持 L4 层负载均衡，无法处理基于 HTTP 头、Cookie 等内容的路由，功能上不如应用层负载均衡器灵活。</li><li><strong>配置复杂</strong>：LVS 的配置和维护相对复杂，需要一定的 Linux 网络知识。</li></ul><h4 id=使用场景-3>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-3>#</a></h4><ul><li><strong>高性能、大规模流量的负载均衡</strong>：适用于需要高吞吐量和低延迟的场景，如大规模的 Web 服务、视频流服务等。</li><li><strong>简单的 L4 层负载均衡</strong>：如果只需要基于 IP 和端口的负载均衡，而不需要 HTTP 层的复杂路由和控制，LVS 是一个优秀的选择。</li></ul><hr><h3 id=2-nginx>2. <strong>Nginx</strong>
<a class=anchor href=#2-nginx>#</a></h3><p>Nginx 是一个轻量级的 Web 服务器和反向代理服务器，除了处理 HTTP 请求外，还可以进行负载均衡。</p><h4 id=特点-4>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-4>#</a></h4><ul><li><strong>工作在应用层（L7 层）</strong>：Nginx 主要提供 HTTP、HTTPS、TCP 和 UDP 的负载均衡服务，通常工作在应用层（L7 层）。</li><li><strong>支持多种负载均衡算法</strong>：包括轮询、IP 哈希、加权轮询等。</li><li><strong>灵活的路由功能</strong>：可以基于 HTTP 请求的不同部分（如路径、头部、方法、主机等）进行路由，适合处理复杂的 Web 应用场景。</li><li><strong>反向代理功能</strong>：Nginx 同时提供反向代理功能，能够在负载均衡的同时，作为 Web 服务器或应用服务器的前端，进行内容缓存、请求处理等。</li></ul><h4 id=优点-4>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-4>#</a></h4><ul><li><strong>灵活性强</strong>：可以根据请求的内容（如 URL、HTTP 头、Cookie 等）做更精细的流量控制。</li><li><strong>简单易配置</strong>：Nginx 配置简洁，功能强大，社区活跃。</li><li><strong>支持 HTTP、HTTPS 和 TCP 负载均衡</strong>：除了支持传统的 HTTP 层负载均衡，还支持 TCP/UDP 负载均衡。</li><li><strong>高性能</strong>：尽管是应用层的负载均衡器，Nginx 依然具有较高的性能，能够处理大量并发请求。</li></ul><h4 id=缺点-4>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-4>#</a></h4><ul><li><strong>性能相对 LVS 较低</strong>：Nginx 的性能虽然很高，但相比于 LVS 的内核级负载均衡，Nginx 可能在处理非常高并发流量时稍显不足。</li><li><strong>依赖操作系统的网络栈</strong>：Nginx 是在用户态运行的，受限于操作系统的网络栈，相较于 LVS 内核级的处理能力可能稍差。</li></ul><h4 id=使用场景-4>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-4>#</a></h4><ul><li><strong>Web 服务器负载均衡</strong>：适用于 Web 服务的负载均衡，尤其是需要对 HTTP 请求进行精细路由和控制的场景。</li><li><strong>反向代理</strong>：在 Web 应用架构中，Nginx 可以作为反向代理进行负载均衡，同时提供 SSL 终端加密、缓存、限流等功能。</li><li><strong>容器化环境中的负载均衡</strong>：在 Kubernetes、Docker 等容器化环境中，Nginx 是常用的负载均衡工具。</li></ul><hr><h3 id=3-haproxy>3. <strong>HAProxy</strong>
<a class=anchor href=#3-haproxy>#</a></h3><p>HAProxy 是一个专注于高性能、高可用性的负载均衡器，广泛用于大规模的 Web 应用和高并发场景。</p><h4 id=特点-5>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-5>#</a></h4><ul><li><strong>工作在应用层（L7 层）和传输层（L4 层）</strong>：HAProxy 支持 HTTP、HTTPS、TCP 和 UDP 的负载均衡，可以根据不同层次进行流量转发。</li><li><strong>支持丰富的负载均衡算法</strong>：HAProxy 支持轮询、最少连接、加权轮询、源 IP 哈希等多种负载均衡策略。</li><li><strong>高可用性</strong>：HAProxy 支持健康检查、故障转移和高可用配置，能自动检测后端服务器的健康状况，并根据健康状态进行流量分配。</li><li><strong>非常高的性能</strong>：HAProxy 经过优化，能够处理大量的并发连接，尤其适合高吞吐量的应用。</li></ul><h4 id=优点-5>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-5>#</a></h4><ul><li><strong>高性能、高并发</strong>：HAProxy 在高负载和高并发场景下的表现优异，适合处理大量并发请求。</li><li><strong>丰富的配置选项</strong>：HAProxy 提供了灵活的配置选项，可以进行精细的负载均衡和流量管理。</li><li><strong>强大的健康检查机制</strong>：能够实时监控后端服务器的健康状态，保证高可用性。</li><li><strong>广泛的应用场景</strong>：HAProxy 可用于多种负载均衡场景，包括 Web、数据库、缓存服务等。</li></ul><h4 id=缺点-5>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-5>#</a></h4><ul><li><strong>配置相对复杂</strong>：相比 Nginx，HAProxy 的配置相对复杂，学习曲线较陡。</li><li><strong>不支持应用层的一些高级功能</strong>：虽然 HAProxy 支持 L7 层负载均衡，但其功能不如 Nginx 灵活，尤其在内容缓存、反向代理等方面，Nginx 提供了更多的高级功能。</li></ul><h4 id=使用场景-5>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-5>#</a></h4><ul><li><strong>高并发、大流量应用</strong>：适用于需要高性能和高可用性的负载均衡，如金融、社交媒体、大型电商网站等。</li><li><strong>复杂的负载均衡场景</strong>：适合需要多种负载均衡算法、健康检查以及故障转移的场景。</li><li><strong>TCP 和 HTTP 负载均衡</strong>：HAProxy 支持 HTTP 层和 TCP 层的负载均衡，适合 Web 服务和数据库、缓存等应用的负载均衡。</li></ul><hr><h3 id=总结比较-1><strong>总结比较</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93%e6%af%94%e8%be%83-1>#</a></h3><table><thead><tr><th>特性</th><th>LVS</th><th>Nginx</th><th>HAProxy</th></tr></thead><tbody><tr><td>工作层次</td><td>L4（传输层）</td><td>L7（应用层）</td><td>L7（应用层）和 L4（传输层）</td></tr><tr><td>性能</td><td>非常高（内核级负载均衡）</td><td>高，适合 Web 层负载均衡</td><td>高，专注于高并发的负载均衡</td></tr><tr><td>灵活性</td><td>低，主要支持 IP 和端口</td><td>高，支持基于 URL、HTTP 头等路由</td><td>高，支持多种负载均衡算法</td></tr><tr><td>配置复杂度</td><td>较高</td><td>较低，配置简洁</td><td>较高，配置选项丰富</td></tr><tr><td>支持的协议</td><td>TCP/UDP</td><td>HTTP、HTTPS、TCP、UDP</td><td>HTTP、HTTPS、TCP、UDP</td></tr><tr><td>高可用性</td><td>需要与 Keepalived 配合使用</td><td>支持与高可用架构集成</td><td>支持内建的健康检查和故障转移</td></tr><tr><td>使用场景</td><td>高性能的负载均衡，L4 层</td><td>Web 应用、反向代理、容器化环境</td><td>高并发、大流量的 Web 或服务负载均衡</td></tr></tbody></table><h3 id=选择建议><strong>选择建议</strong>：
<a class=anchor href=#%e9%80%89%e6%8b%a9%e5%bb%ba%e8%ae%ae>#</a></h3><ul><li><p><strong>LVS</strong>：适合大规模、高性能的 L4 层负载均衡，不需要复杂路由规则的场景。</p></li><li><p><strong>Nginx</strong>：适合需要高性能并且需要对 HTTP 流量进行细粒度控制的 Web 服务负载均衡。</p><p><strong>HAProxy</strong>：适合高并发、复杂负载均衡场景，尤其是需要灵活调度和高可用性的应用。</p></li></ul><h1 id=僵尸进程是什么>僵尸进程是什么
<a class=anchor href=#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><p><strong>僵尸进程（Zombie Process）</strong> 是指在 Linux 或 Unix 系统中，一个已经完成执行（即已经退出）的进程，但其进程描述符（PID）还没有被父进程（Parent Process）回收的进程。简单来说，僵尸进程是一个“死了但还未被清理”的进程。</p><h3 id=为什么会产生僵尸进程><strong>为什么会产生僵尸进程？</strong>
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e4%ba%a7%e7%94%9f%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b>#</a></h3><p>当一个进程结束时，它会向父进程发送一个信号（通常是 <code>SIGCHLD</code>）通知它已经结束，并向操作系统申请退出状态信息。这些信息会被存储在进程表中，等待父进程通过调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来回收。只有当父进程回收了子进程的退出状态信息（退出码）后，进程表中的条目才会被彻底清除，这时进程才会完全消失。</p><p>如果父进程没有回收这些信息（可能是因为父进程没有调用 <code>wait()</code>，或者父进程提前退出等情况），子进程就会成为“僵尸进程”。这些进程会保留在系统的进程表中，占用 PID 号和一些资源，但不再占用 CPU 和内存。</p><h3 id=僵尸进程的特征><strong>僵尸进程的特征</strong>
<a class=anchor href=#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%89%b9%e5%be%81>#</a></h3><ul><li><strong>不消耗 CPU 资源</strong>：一旦进程终止，僵尸进程就不再执行任何代码，因此不会消耗 CPU。</li><li><strong>仍然占用进程表项</strong>：尽管已结束执行，僵尸进程仍占用一个进程号（PID），但其状态为 <code>Z</code>（表示 zombie）。</li><li><strong>资源被父进程占用</strong>：父进程需要回收僵尸进程的退出状态信息。如果父进程不回收，僵尸进程会持续存在。</li></ul><h3 id=如何查看僵尸进程><strong>如何查看僵尸进程？</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b>#</a></h3><p>可以使用 <code>ps</code> 命令查看僵尸进程。通过添加 <code>-e</code> 或 <code>-aux</code> 参数查看所有进程，然后使用 <code>grep</code> 过滤出状态为 <code>Z</code> 的进程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps aux | grep <span style=color:#e6db74>&#39;Z&#39;</span>   <span style=color:#75715e># 查找所有僵尸进程</span>
</span></span></code></pre></div><p>或者：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps -e -o pid,stat,cmd | grep <span style=color:#e6db74>&#39;Z&#39;</span>  <span style=color:#75715e># 查看所有进程及其状态，过滤出状态为 Z 的进程</span>
</span></span></code></pre></div><p>在输出中，<code>STAT</code> 字段显示为 <code>Z</code>，表示该进程是一个僵尸进程。</p><h3 id=如何解决僵尸进程><strong>如何解决僵尸进程？</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b>#</a></h3><ol><li><p><strong>父进程回收子进程</strong>：</p><ul><li>通过让父进程调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来回收子进程的退出状态。如果父进程未正确回收，则僵尸进程会持续存在。</li><li>如果父进程本身已经退出，操作系统会将这些僵尸进程的父进程设置为 <code>init</code> 进程（PID 1），由 <code>init</code> 进程来回收它们。</li></ul></li><li><p><strong>结束父进程</strong>：</p><ul><li>如果父进程不回收子进程，且父进程本身也不再需要运行，可以通过终止父进程来解决。终止父进程后，系统会自动将这些僵尸进程的父进程设置为 <code>init</code> 进程（PID 1），并由 <code>init</code> 进程回收它们。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kill -9 &lt;父进程PID&gt;
</span></span></code></pre></div></li><li><p><strong>定期清理</strong>：</p><ul><li>在某些情况下，可以通过编写定时脚本，定期检查并清理僵尸进程。</li></ul></li></ol><h3 id=总结-3><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-3>#</a></h3><ul><li><strong>僵尸进程是已经退出但没有被回收的进程</strong>，其状态是 <code>Z</code>。</li><li><strong>它们不会占用系统资源（如 CPU 和内存）</strong>，但会占用 PID 和进程表项。</li><li><strong>父进程需要回收子进程的退出信息</strong>，否则就会产生僵尸进程。</li><li>通过监控和管理父进程的回收操作，可以避免僵尸进程的积累，确保系统资源得到有效利用。</li></ul><h1 id=进程线程协程区别>进程、线程、协程区别☆
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b%e5%8c%ba%e5%88%ab>#</a></h1><p><strong>进程（Process）、线程（Thread）和协程（Coroutine）</strong> 是操作系统和程序设计中的重要概念，它们之间有着不同的资源管理、执行模型和使用场景。下面是它们之间的主要区别：</p><h3 id=1-进程process>1. <strong>进程（Process）</strong>
<a class=anchor href=#1-%e8%bf%9b%e7%a8%8bprocess>#</a></h3><h4 id=定义>定义：
<a class=anchor href=#%e5%ae%9a%e4%b9%89>#</a></h4><p>进程是操作系统资源分配的基本单位，它是正在执行的程序的实例。一个进程拥有独立的内存空间、数据段、代码段、堆栈等资源，操作系统为每个进程分配资源和管理进程之间的调度。</p><h4 id=特点-6>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-6>#</a></h4><ul><li><strong>资源隔离</strong>：每个进程有自己的内存空间、文件描述符、堆栈等资源。不同进程之间是相互隔离的，一个进程不能直接访问另一个进程的内存。</li><li><strong>较重的开销</strong>：创建进程时需要大量的资源和时间开销，因为需要分配独立的内存和资源，并进行调度。</li><li><strong>上下文切换</strong>：进程切换时，操作系统需要保存当前进程的状态，并恢复下一个进程的状态，代价较大。</li></ul><h4 id=使用场景-6>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-6>#</a></h4><ul><li><strong>独立执行任务</strong>：适用于需要完全隔离的任务，例如运行不同的应用程序或服务。</li><li><strong>高隔离性需求</strong>：需要高度隔离的任务，比如多用户环境中的不同程序。</li></ul><hr><h3 id=2-线程thread>2. <strong>线程（Thread）</strong>
<a class=anchor href=#2-%e7%ba%bf%e7%a8%8bthread>#</a></h3><h4 id=定义-1>定义：
<a class=anchor href=#%e5%ae%9a%e4%b9%89-1>#</a></h4><p>线程是进程内部的执行单元，是程序执行的最小单位。多个线程可以共享进程的资源（如内存空间、文件描述符等），但每个线程有自己的栈和程序计数器（PC）。线程是操作系统调度的基本单位。</p><h4 id=特点-7>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-7>#</a></h4><ul><li><strong>共享资源</strong>：同一进程中的线程共享进程的内存和资源，可以通过共享数据进行通信（如共享内存）。</li><li><strong>轻量级</strong>：线程相比进程占用的资源少，创建和销毁的开销小，线程之间的上下文切换比进程之间的切换快。</li><li><strong>并发执行</strong>：多个线程可以并发执行，适用于多任务处理和 CPU 密集型任务。</li><li><strong>同步与竞争</strong>：线程共享内存，容易出现同步问题（如数据竞争、死锁等），需要使用锁机制来保证线程安全。</li></ul><h4 id=使用场景-7>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-7>#</a></h4><ul><li><strong>需要共享内存的并发任务</strong>：比如 Web 服务器中的多个请求处理线程。</li><li><strong>轻量级任务执行</strong>：适用于需要快速响应、资源开销较小的并发任务。</li><li><strong>多核 CPU 的并行处理</strong>：当系统拥有多核 CPU 时，线程可以在多个核上并行执行，提高效率。</li></ul><hr><h3 id=3-协程coroutine>3. <strong>协程（Coroutine）</strong>
<a class=anchor href=#3-%e5%8d%8f%e7%a8%8bcoroutine>#</a></h3><h4 id=定义-2>定义：
<a class=anchor href=#%e5%ae%9a%e4%b9%89-2>#</a></h4><p>协程是一种轻量级的线程，可以在单个线程中实现多任务的切换。协程不是由操作系统进行调度，而是由程序员手动控制执行。它的特点是<strong>非抢占式</strong>，通过显式的 <code>yield</code> 或 <code>await</code> 等语法来切换执行。</p><h4 id=特点-8>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-8>#</a></h4><ul><li><strong>轻量级</strong>：协程的创建和销毁开销极小，它们在同一个线程中运行，不需要额外的内存和上下文切换，极大减少了资源消耗。</li><li><strong>手动调度</strong>：协程由程序控制其执行顺序，协程可以在函数内保存和恢复状态，执行时切换非常快。</li><li><strong>非抢占式</strong>：与线程的抢占式调度不同，协程的切换是由程序显式控制（如通过 <code>yield</code> 或 <code>await</code> 等语法）。这意味着程序可以在任意时刻决定让协程暂停并切换到其他任务。</li><li><strong>单线程运行</strong>：协程通常在单线程中运行，因此没有线程间的同步问题。</li></ul><h4 id=使用场景-8>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-8>#</a></h4><ul><li><strong>IO 密集型任务</strong>：协程非常适合处理大量 IO 操作（如网络请求、文件读写等），因为它们可以在等待 IO 操作时切换到其他任务，充分利用 CPU。</li><li><strong>轻量级并发</strong>：当需要大量并发任务而不希望开销太大时，协程是一种理想选择。例如，Web 服务中可以使用协程来处理大量的客户端请求。</li><li><strong>无需线程上下文切换</strong>：适用于任务调度需要非常高效的场景，如一些高并发的服务器。</li></ul><hr><h3 id=进程线程协程对比><strong>进程、线程、协程对比</strong>
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b%e5%af%b9%e6%af%94>#</a></h3><table><thead><tr><th>特性</th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td><strong>创建开销</strong></td><td>较高，资源分配和上下文切换较慢</td><td>较低，线程之间共享进程的资源</td><td>非常低，仅在用户空间调度，无操作系统干预</td></tr><tr><td><strong>资源占用</strong></td><td>独立资源，如内存、文件句柄等</td><td>共享进程的资源，但每个线程有独立栈</td><td>共享线程的资源，几乎不占用额外资源</td></tr><tr><td><strong>调度方式</strong></td><td>由操作系统调度（抢占式）</td><td>由操作系统调度（抢占式）</td><td>由程序员显式控制（非抢占式）</td></tr><tr><td><strong>上下文切换</strong></td><td>代价大，需要保存和恢复大量状态</td><td>比进程切换快，但仍然需要上下文切换</td><td>极快，仅需保存少量状态</td></tr><tr><td><strong>并发性能</strong></td><td>适合独立任务的并发执行</td><td>适合 CPU 密集型并行任务</td><td>适合大量轻量级并发任务，尤其是 IO 密集型</td></tr><tr><td><strong>同步机制</strong></td><td>需要进程间通信（IPC）</td><td>需要使用线程同步机制（如锁）</td><td>无需同步，避免线程之间的数据竞争</td></tr><tr><td><strong>适用场景</strong></td><td>独立任务，要求高度隔离的环境</td><td>多任务并行，需共享内存的场景</td><td>高效处理大量并发 IO 操作，轻量级任务</td></tr></tbody></table><hr><h3 id=总结-4><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-4>#</a></h3><ul><li><strong>进程</strong>：是操作系统资源的基本分配单位，具有独立的内存空间，适用于需要完全隔离的任务，创建和切换开销较大。</li><li><strong>线程</strong>：是进程内部的执行单位，多个线程共享进程的资源，适用于需要高效并行处理的任务。线程之间的同步是一个常见问题。</li><li><strong>协程</strong>：是一种轻量级的并发单位，适用于大量 IO 密集型的并发任务，通过手动控制调度提供高效的并发处理。</li></ul><h1 id=什么是nginx的异步非阻塞>什么是nginx的异步非阻塞
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%afnginx%e7%9a%84%e5%bc%82%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e>#</a></h1><p><strong>Nginx 的异步非阻塞</strong> 是其架构设计的核心特性之一，它使得 Nginx 能够高效地处理大量并发连接，而不需要为每个连接分配独立的线程或进程。理解这一特性有助于更好地理解 Nginx 为什么在处理大量并发请求时比传统的 Web 服务器（如 Apache）更高效。</p><h3 id=1-异步asynchronous><strong>1. 异步（Asynchronous）</strong>
<a class=anchor href=#1-%e5%bc%82%e6%ad%a5asynchronous>#</a></h3><p>“异步”指的是处理请求时，Nginx 不会被单一请求的处理所阻塞。换句话说，当一个请求正在等待某些操作（比如从硬盘读取文件或等待数据库响应）时，Nginx 不会停下来等待这个操作完成，而是会去处理其他请求，直到该请求可以继续处理。</p><h4 id=示例>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b>#</a></h4><ul><li>当用户发送一个 HTTP 请求，Nginx 会将该请求交给工作进程去处理。如果这个请求需要读取磁盘上的文件，而磁盘操作是耗时的，Nginx 不会在此时停止并等待磁盘操作完成。</li><li>在等待过程中，Nginx 会处理其他到达的请求，当磁盘操作完成时，再继续处理之前请求的后续操作（比如返回文件内容给客户端）。</li></ul><h3 id=2-非阻塞non-blocking><strong>2. 非阻塞（Non-blocking）</strong>
<a class=anchor href=#2-%e9%9d%9e%e9%98%bb%e5%a1%9enon-blocking>#</a></h3><p>“非阻塞”指的是在处理请求时，Nginx 不会因为某个请求的某个阶段操作阻塞（阻止）其他请求的处理。Nginx 的事件循环机制确保了工作进程可以同时处理多个请求。</p><h4 id=示例-1>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-1>#</a></h4><ul><li>在处理一个请求的某个阶段时（比如读取文件、与数据库交互等），如果该操作需要一些时间，Nginx 不会阻止其他请求的处理。Nginx 会在等待这类操作时，转而处理其他可执行的任务或请求。</li><li>这种非阻塞的机制可以让 Nginx 充分利用 CPU 的时间片，不会因为某个慢操作停滞不前，极大地提高了并发处理能力。</li></ul><h3 id=3-事件驱动模型><strong>3. 事件驱动模型</strong>
<a class=anchor href=#3-%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%a8%a1%e5%9e%8b>#</a></h3><p>Nginx 的异步非阻塞模式是通过<strong>事件驱动模型</strong>实现的。具体来说，Nginx 通过一个事件循环来管理多个连接，每个连接对应一个事件。当某个连接上的事件准备好（如数据已经准备好可以读取、可以发送响应等），Nginx 会通知相应的工作进程来处理这个事件，而不需要为每个请求创建一个新的线程或进程。</p><h4 id=工作原理>工作原理：
<a class=anchor href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h4><ul><li><strong>事件循环</strong>：Nginx 会启动一个事件循环，循环中会监听多个事件（如文件 I/O、网络 I/O 等）。一旦某个事件可以被处理，Nginx 就会去处理它。</li><li><strong>I/O 多路复用</strong>：通过使用系统调用如 <code>epoll</code>（Linux）、<code>kqueue</code>（BSD）或 <code>select</code>，Nginx 能够高效地监听和处理多个 I/O 事件，而不需要创建多个线程或进程来等待每个请求的完成。</li></ul><h3 id=4-单线程处理多个请求><strong>4. 单线程处理多个请求</strong>
<a class=anchor href=#4-%e5%8d%95%e7%ba%bf%e7%a8%8b%e5%a4%84%e7%90%86%e5%a4%9a%e4%b8%aa%e8%af%b7%e6%b1%82>#</a></h3><p>Nginx 通常采用<strong>单线程</strong>处理多个请求，而不是每个请求一个线程。通过非阻塞 I/O 和事件驱动机制，Nginx 可以在一个线程内并发处理成千上万的请求，而不会像传统的多线程模型那样消耗大量的系统资源（如内存、CPU）。这种设计使得 Nginx 在处理高并发时非常高效。</p><h3 id=5-通过工作模式管理多个连接><strong>5. 通过工作模式管理多个连接</strong>
<a class=anchor href=#5-%e9%80%9a%e8%bf%87%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f%e7%ae%a1%e7%90%86%e5%a4%9a%e4%b8%aa%e8%bf%9e%e6%8e%a5>#</a></h3><p>Nginx 的工作模式（worker process）通常采用<strong>单线程、多进程模型</strong>：</p><ul><li><strong>Master Process</strong>：主进程负责管理配置、进程生命周期等，子进程会根据需求启动或关闭。</li><li><strong>Worker Process</strong>：每个工作进程处理客户端请求，处理过程中采用异步非阻塞方式。每个工作进程通常会有一个事件循环，处理多个连接。</li></ul><h3 id=6-典型的异步非阻塞处理流程><strong>6. 典型的异步非阻塞处理流程</strong>
<a class=anchor href=#6-%e5%85%b8%e5%9e%8b%e7%9a%84%e5%bc%82%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b>#</a></h3><p>假设有一个请求需要处理：</p><ol><li><strong>接收请求</strong>：Nginx 的 worker 进程接收到客户端的请求，解析请求信息。</li><li><strong>执行任务</strong>：如果请求需要进行磁盘 I/O（例如读取文件），Nginx 会发出 I/O 请求，然后立即返回等待其他事件发生。</li><li><strong>继续处理其他请求</strong>：在等待 I/O 完成的过程中，Nginx 可以继续处理其他请求，不会因为一个请求的 I/O 操作而阻塞。</li><li><strong>完成任务</strong>：一旦磁盘 I/O 完成，Nginx 会继续处理这个请求，并返回响应给客户端。</li></ol><h3 id=异步非阻塞的优势><strong>异步非阻塞的优势</strong>
<a class=anchor href=#%e5%bc%82%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%9a%84%e4%bc%98%e5%8a%bf>#</a></h3><ul><li><strong>高并发处理能力</strong>：能够同时处理大量并发请求，尤其是在 I/O 密集型操作中表现尤为出色。</li><li><strong>低资源消耗</strong>：不需要为每个请求创建独立的线程或进程，从而减少了系统的资源消耗（如内存和 CPU 时间片的浪费）。</li><li><strong>高效响应</strong>：可以迅速响应请求，特别适合高并发、高流量的场景。</li></ul><h3 id=总结-5><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-5>#</a></h3><ul><li><strong>异步</strong>指的是在等待某个操作（如磁盘 I/O）完成时，Nginx 不会阻塞处理其他请求。</li><li><strong>非阻塞</strong>指的是 Nginx 不会让任何一个请求阻塞其他请求的处理，能同时处理多个请求。</li><li><strong>事件驱动模型</strong>和<strong>I/O 多路复用</strong>是实现这一特性的关键技术，使得 Nginx 在高并发、高流量环境下依然能够高效稳定运行。</li></ul><p>这些特性使得 Nginx 特别适合用于 Web 服务器、反向代理以及负载均衡等需要高并发处理的场景。</p><h1 id=linux网络丢包怎么排查>linux网络丢包怎么排查☆
<a class=anchor href=#linux%e7%bd%91%e7%bb%9c%e4%b8%a2%e5%8c%85%e6%80%8e%e4%b9%88%e6%8e%92%e6%9f%a5>#</a></h1><p>在 Linux 中，网络丢包的原因可能是多种多样的，包括硬件故障、网络配置问题、带宽过载、系统资源问题等。以下是排查网络丢包的一些常见方法和工具：</p><h3 id=1-使用>1. <strong>使用 <code>ping</code> 命令测试丢包情况</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8>#</a></h3><p><code>ping</code> 是一个简单的工具，可以帮助检测是否有丢包，并能够提供丢包的百分比。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ping -c <span style=color:#ae81ff>100</span> &lt;目标IP&gt;
</span></span></code></pre></div><ul><li><code>-c 100</code> 表示发送 100 个 ICMP 请求包。</li><li>如果丢包，<code>ping</code> 会显示丢包的百分比。</li></ul><h3 id=2-检查网络接口的丢包情况>2. <strong>检查网络接口的丢包情况</strong>
<a class=anchor href=#2-%e6%a3%80%e6%9f%a5%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e7%9a%84%e4%b8%a2%e5%8c%85%e6%83%85%e5%86%b5>#</a></h3><p>通过查看网络接口的统计信息，可以了解丢包的具体情况。使用 <code>ifconfig</code> 或 <code>ip -s link</code> 命令来查看网络接口的统计数据。</p><h4 id=使用-ifconfig>使用 <code>ifconfig</code>：
<a class=anchor href=#%e4%bd%bf%e7%94%a8-ifconfig>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ifconfig &lt;网络接口&gt;
</span></span></code></pre></div><p>检查输出中的 <code>RX errors</code>（接收错误）和 <code>TX errors</code>（发送错误），这两个字段表示接收和发送时的错误数量。如果存在大量的错误，可能是网络丢包的原因。</p><h4 id=使用-ip--s-link>使用 <code>ip -s link</code>：
<a class=anchor href=#%e4%bd%bf%e7%94%a8-ip--s-link>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip -s link show &lt;网络接口&gt;
</span></span></code></pre></div><p><code>ip</code> 命令提供了更详细的统计信息，查看 <code>RX dropped</code> 和 <code>TX dropped</code> 字段，这两个字段分别表示接收和发送过程中丢失的包数。</p><h3 id=3-查看系统日志>3. <strong>查看系统日志</strong>
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e6%97%a5%e5%bf%97>#</a></h3><p>丢包可能与系统的硬件、网络驱动或其他系统问题相关。检查系统日志中是否有网络相关的错误信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dmesg | grep eth  <span style=color:#75715e># 检查与以太网相关的日志</span>
</span></span></code></pre></div><ul><li>如果发现大量的与网卡相关的错误（如“RX errors”或“TX errors”），可能是硬件问题。</li><li>也可以检查 <code>/var/log/syslog</code> 或 <code>/var/log/messages</code> 等日志文件。</li></ul><h3 id=4-使用>4. <strong>使用 <code>netstat</code> 查看网络连接情况</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8>#</a></h3><p><code>netstat</code> 命令可以帮助你查看当前网络连接的状态，并能检查是否有异常的连接导致丢包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>netstat -s
</span></span></code></pre></div><ul><li>查看是否有大量的 TCP 错误或其他协议错误，特别是 TCP 的 <code>Retransmissions</code>（重传次数）和 <code>Segs Out</code>（发出的段数）字段。</li></ul><h3 id=5-使用>5. <strong>使用 <code>traceroute</code> 检查网络路径</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8>#</a></h3><p>如果怀疑丢包发生在与外部服务器之间的网络传输过程中，可以使用 <code>traceroute</code> 工具来检查数据包经过的路由路径，以及每跳的丢包情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>traceroute &lt;目标IP&gt;
</span></span></code></pre></div><ul><li><code>traceroute</code> 可以帮助你识别哪个路由节点存在丢包。</li></ul><h3 id=6-查看系统资源是否不足>6. <strong>查看系统资源是否不足</strong>
<a class=anchor href=#6-%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90%e6%98%af%e5%90%a6%e4%b8%8d%e8%b6%b3>#</a></h3><p>网络丢包可能是因为系统的资源不足（如 CPU 或内存）导致网络处理变慢或缓慢。使用以下命令检查系统资源：</p><h4 id=cpu-使用情况>CPU 使用情况：
<a class=anchor href=#cpu-%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>top  <span style=color:#75715e># 或者 htop</span>
</span></span></code></pre></div><p>查看系统是否有高负载，特别是网络相关的进程是否占用过多 CPU。</p><h4 id=内存使用情况>内存使用情况：
<a class=anchor href=#%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>free -m
</span></span></code></pre></div><p>查看系统内存是否已经使用完，尤其是交换分区（swap）是否被过度使用。</p><h4 id=磁盘使用情况>磁盘使用情况：
<a class=anchor href=#%e7%a3%81%e7%9b%98%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iostat -x <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>查看磁盘的 I/O 性能，是否出现瓶颈，影响到网络通信。</p><h3 id=7-调整-tcp-缓冲区>7. <strong>调整 TCP 缓冲区</strong>
<a class=anchor href=#7-%e8%b0%83%e6%95%b4-tcp-%e7%bc%93%e5%86%b2%e5%8c%ba>#</a></h3><p>TCP 缓冲区的设置不当也可能导致丢包，尤其是在高带宽、低延迟的网络环境下。如果丢包发生在长时间的数据传输中，可以尝试调整 TCP 缓冲区大小。</p><p>可以通过以下命令查看和调整系统的 TCP 缓冲区：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -a | grep net.ipv4.tcp_rmem  <span style=color:#75715e># 查看接收缓冲区</span>
</span></span><span style=display:flex><span>sysctl -a | grep net.ipv4.tcp_wmem  <span style=color:#75715e># 查看发送缓冲区</span>
</span></span></code></pre></div><p>调整 TCP 接收和发送缓冲区大小：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -w net.ipv4.tcp_rmem<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;4096 87380 6291456&#34;</span>
</span></span><span style=display:flex><span>sysctl -w net.ipv4.tcp_wmem<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;4096 16384 4194304&#34;</span>
</span></span></code></pre></div><h3 id=8-使用>8. <strong>使用 <code>ss</code> 工具进行网络连接分析</strong>
<a class=anchor href=#8-%e4%bd%bf%e7%94%a8>#</a></h3><p><code>ss</code> 是一个用于查看套接字连接的命令，可以用于检查网络连接的状态和是否有大量的丢包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ss -s
</span></span></code></pre></div><ul><li>这将显示各种协议的统计信息，特别是 TCP 连接的状态。</li></ul><h3 id=9-检查网卡驱动和硬件问题>9. <strong>检查网卡驱动和硬件问题</strong>
<a class=anchor href=#9-%e6%a3%80%e6%9f%a5%e7%bd%91%e5%8d%a1%e9%a9%b1%e5%8a%a8%e5%92%8c%e7%a1%ac%e4%bb%b6%e9%97%ae%e9%a2%98>#</a></h3><p>如果发现网络丢包是由硬件故障引起的，可以通过以下方法进行排查：</p><ul><li>检查网络接口卡（NIC）是否存在硬件故障，尝试更换网卡。</li><li>查看网络驱动程序是否有更新，更新驱动程序。</li><li>检查网络设备（如交换机、路由器）是否存在故障或配置错误。</li></ul><h3 id=10-网络带宽和流量限制>10. <strong>网络带宽和流量限制</strong>
<a class=anchor href=#10-%e7%bd%91%e7%bb%9c%e5%b8%a6%e5%ae%bd%e5%92%8c%e6%b5%81%e9%87%8f%e9%99%90%e5%88%b6>#</a></h3><p>网络带宽不足、流量过载或 QoS（服务质量）策略设置不当，也可能导致丢包。通过以下方式检查带宽和流量限制：</p><ul><li>检查是否有带宽限制（如防火墙规则、流量整形等）。</li><li>使用 <code>iftop</code> 或 <code>nload</code> 等工具查看当前网络流量的实时状况。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iftop  <span style=color:#75715e># 实时流量监控</span>
</span></span><span style=display:flex><span>nload  <span style=color:#75715e># 实时网络带宽监控</span>
</span></span></code></pre></div><h3 id=总结-6>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-6>#</a></h3><ul><li><strong>基本排查方法</strong>：使用 <code>ping</code>、<code>ifconfig</code>、<code>ip -s link</code> 等工具检查丢包情况。</li><li><strong>系统资源监控</strong>：使用 <code>top</code>、<code>free</code>、<code>iostat</code> 等工具检查系统资源是否正常。</li><li><strong>网络路径分析</strong>：使用 <code>traceroute</code> 来查看是否有网络路径丢包。</li><li><strong>调整参数</strong>：调整 TCP 缓冲区等参数可能有助于减少丢包。</li></ul><p>通过这些方法，逐步排查网络丢包的原因，通常可以定位到具体问题并进行修复。</p><h1 id=常用的性能分析诊断命令>常用的性能分析诊断命令☆
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e7%9a%84%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e8%af%8a%e6%96%ad%e5%91%bd%e4%bb%a4>#</a></h1><p>在 Linux 系统中，进行性能分析和诊断时，有许多命令和工具可以帮助你查看系统资源使用情况、诊断性能瓶颈、排查问题等。以下是一些常用的性能分析和诊断命令：</p><h3 id=1-top>1. <strong><code>top</code></strong>
<a class=anchor href=#1-top>#</a></h3><p><code>top</code> 是最常用的性能分析工具，它显示实时的系统资源使用情况，包括 CPU、内存、磁盘、网络等。它适用于检查系统的整体状态，特别是资源占用较高的进程。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>top
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>显示进程的实时资源占用情况。</li><li>可以按 CPU、内存等资源占用排序。</li><li>使用 <code>P</code> 或 <code>M</code> 可以按 CPU 或内存使用量排序。</li><li>使用 <code>1</code> 显示每个 CPU 的使用情况。</li></ul></li></ul><hr><h3 id=2-htop>2. <strong><code>htop</code></strong>
<a class=anchor href=#2-htop>#</a></h3><p><code>htop</code> 是 <code>top</code> 的增强版，提供了更友好的界面和交互方式。它可以显示更多的系统信息，并允许用户通过键盘快捷键方便地进行操作。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>htop
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>显示进程树状图。</li><li>可以通过上下箭头选择进程并对其进行操作（如杀死进程）。</li><li>支持按 CPU、内存、PID 等排序。</li></ul></li></ul><hr><h3 id=3-vmstat>3. <strong><code>vmstat</code></strong>
<a class=anchor href=#3-vmstat>#</a></h3><p><code>vmstat</code>（Virtual Memory Statistics）可以用来报告关于虚拟内存、进程、CPU 活动、磁盘 I/O 等信息。它常用于查看系统性能瓶颈。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vmstat <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span>  <span style=color:#75715e># 每 1 秒输出一次，共输出 5 次</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>输出内存、交换空间、进程、CPU 使用等统计信息。</li><li>重点查看 <code>procs</code>、<code>memory</code> 和 <code>cpu</code> 部分，来判断是否存在瓶颈。</li></ul></li></ul><hr><h3 id=4-iostat>4. <strong><code>iostat</code></strong>
<a class=anchor href=#4-iostat>#</a></h3><p><code>iostat</code>（Input/Output Statistics）可以显示系统的 I/O 性能，帮助诊断磁盘或存储系统的性能问题。它显示设备的 I/O 统计信息、CPU 使用情况等。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iostat -x <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span>  <span style=color:#75715e># 每 1 秒输出一次，共输出 5 次，显示详细统计</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>查看每个磁盘设备的 I/O 活动、吞吐量、I/O 队列长度等。</li><li>监控磁盘的延迟、吞吐量等性能数据，帮助诊断存储瓶颈。</li></ul></li></ul><hr><h3 id=5-netstat>5. <strong><code>netstat</code></strong>
<a class=anchor href=#5-netstat>#</a></h3><p><code>netstat</code>（Network Statistics）用于查看网络连接、路由表、接口统计等信息。它帮助诊断网络连接、带宽使用情况等。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>netstat -tulnp  <span style=color:#75715e># 查看所有正在监听的端口及其对应的进程</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li><code>-tulnp</code>：显示 TCP、UDP、监听端口和对应的进程。</li><li><code>-s</code>：显示网络协议的统计信息，如 TCP 错误、接收/发送丢包等。</li></ul></li></ul><hr><h3 id=6-ss>6. <strong><code>ss</code></strong>
<a class=anchor href=#6-ss>#</a></h3><p><code>ss</code>（Socket Statictics）是一个比 <code>netstat</code> 更快的替代工具，用于显示网络连接、套接字统计等信息。它支持查看 TCP、UDP 等连接状态。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ss -s  <span style=color:#75715e># 显示套接字的总览信息</span>
</span></span><span style=display:flex><span>ss -tuln  <span style=color:#75715e># 查看监听的 TCP/UDP 端口</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>显示当前的网络连接、监听的端口等。</li><li>支持筛选显示特定状态的连接，如 <code>ESTAB</code>（已建立连接）或 <code>LISTEN</code>（监听连接）。</li></ul></li></ul><hr><h3 id=7-sar>7. <strong><code>sar</code></strong>
<a class=anchor href=#7-sar>#</a></h3><p><code>sar</code>（System Activity Report）是一个非常强大的性能监控工具，它通过收集系统性能数据来生成报告。它可以显示系统的 CPU 使用、内存、I/O、网络等资源的历史数据。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sar -u <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span>  <span style=color:#75715e># 每 1 秒报告一次 CPU 使用情况，共 5 次</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>显示过去的系统性能历史数据。</li><li><code>sar -u</code>：显示 CPU 使用情况。</li><li><code>sar -n DEV</code>：查看网络接口统计。</li><li><code>sar -r</code>：查看内存使用情况。</li></ul></li></ul><hr><h3 id=8-dstat>8. <strong><code>dstat</code></strong>
<a class=anchor href=#8-dstat>#</a></h3><p><code>dstat</code> 是一个功能强大的多功能监控工具，它可以同时显示 CPU、内存、磁盘、网络、IO 等多项系统资源的使用情况。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dstat -cdngy  <span style=color:#75715e># 同时查看 CPU、磁盘、网络、磁盘 I/O 等信息</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>提供全面的系统资源使用信息。</li><li>支持实时显示各种指标，适用于综合性能监控。</li></ul></li></ul><hr><h3 id=9-strace>9. <strong><code>strace</code></strong>
<a class=anchor href=#9-strace>#</a></h3><p><code>strace</code> 用于追踪系统调用，可以帮助诊断程序在执行过程中遇到的问题，如文件打开、网络请求等系统调用。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>strace -p &lt;PID&gt;  <span style=color:#75715e># 跟踪指定进程的系统调用</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>记录进程的系统调用，可以帮助诊断文件 I/O、网络连接等操作是否正常。</li><li>适用于调试程序和排查性能瓶颈。</li></ul></li></ul><hr><h3 id=10-perf>10. <strong><code>perf</code></strong>
<a class=anchor href=#10-perf>#</a></h3><p><code>perf</code> 是 Linux 提供的一个性能分析工具，用于分析系统的 CPU 性能、缓存命中率、上下文切换等低级性能指标。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>perf top  <span style=color:#75715e># 查看实时的性能瓶颈，类似于 `top`，但可以显示更多的系统信息</span>
</span></span><span style=display:flex><span>perf record -g ./my_program  <span style=color:#75715e># 记录程序的性能数据</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>通过采样来分析程序的 CPU 使用情况。</li><li>可以查看哪些函数、代码段消耗了最多的 CPU 时间，帮助找出性能瓶颈。</li></ul></li></ul><hr><h3 id=11-lsof>11. <strong><code>lsof</code></strong>
<a class=anchor href=#11-lsof>#</a></h3><p><code>lsof</code>（List Open Files）用于列出系统中所有打开的文件，包括网络连接、文件句柄等。可以用于分析文件或网络资源的使用情况。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -i :80  <span style=color:#75715e># 查看占用 80 端口的进程</span>
</span></span><span style=display:flex><span>lsof -p &lt;PID&gt;  <span style=color:#75715e># 查看指定进程打开的文件</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>显示打开的文件及其相关的进程。</li><li>查找占用特定端口的进程，诊断端口冲突问题。</li></ul></li></ul><hr><h3 id=12-iotop>12. <strong><code>iotop</code></strong>
<a class=anchor href=#12-iotop>#</a></h3><p><code>iotop</code> 是一个实时的磁盘 I/O 使用情况监控工具，它可以显示哪些进程在消耗磁盘带宽。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iotop
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>显示每个进程的磁盘 I/O 使用情况。</li><li>帮助排查磁盘 I/O 性能瓶颈。</li></ul></li></ul><hr><h3 id=13-mpstat>13. <strong><code>mpstat</code></strong>
<a class=anchor href=#13-mpstat>#</a></h3><p><code>mpstat</code> 用于显示每个 CPU 的使用情况，特别适用于多核 CPU 系统。</p><ul><li><p><strong>用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mpstat -P ALL <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>5</span>  <span style=color:#75715e># 显示每个 CPU 核心的使用情况</span>
</span></span></code></pre></div></li><li><p><strong>功能</strong>：</p><ul><li>显示各个 CPU 核心的负载情况，有助于诊断 CPU 是否存在瓶颈。</li></ul></li></ul><hr><h3 id=总结-7>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-7>#</a></h3><ul><li><strong>系统资源使用分析</strong>：<code>top</code>, <code>htop</code>, <code>vmstat</code>, <code>iostat</code>, <code>dstat</code>。</li><li><strong>网络性能分析</strong>：<code>netstat</code>, <code>ss</code>, <code>sar</code>。</li><li><strong>磁盘 I/O 分析</strong>：<code>iotop</code>, <code>iostat</code>。</li><li><strong>应用级性能分析</strong>：<code>strace</code>, <code>perf</code>。</li><li><strong>系统调用分析</strong>：<code>strace</code>, <code>perf</code>。</li><li><strong>打开文件和资源分析</strong>：<code>lsof</code>。</li></ul><p>这些命令和工具可以帮助你从不同角度进行系统性能分析和故障诊断。根据不同的需求和问题，你可以选择合适的工具来深入排查和分析系统性能。</p><h1 id=什么是进程中断>什么是进程中断
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e8%bf%9b%e7%a8%8b%e4%b8%ad%e6%96%ad>#</a></h1><p>进程中断是指在操作系统中，进程执行过程中，系统主动暂停其执行，并根据一定的规则进行某些操作（如处理中断请求），然后再恢复进程的执行。中断通常由硬件、操作系统内核或其他软件引发，它会打断当前进程的执行，优先处理某些特定的任务或事件，确保系统能够高效地响应外部或内部事件。</p><p>中断是现代操作系统中非常重要的机制，它能够实现高效的资源共享、事件响应和进程调度。</p><h3 id=进程中断的种类>进程中断的种类
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e4%b8%ad%e6%96%ad%e7%9a%84%e7%a7%8d%e7%b1%bb>#</a></h3><ol><li><strong>硬件中断</strong><ul><li>由外部硬件设备（如磁盘、键盘、鼠标、网络卡等）发起。</li><li>例如，当硬盘完成数据读取时，硬盘控制器会发出中断，通知 CPU 进行下一步操作。</li><li>设备中断通常由外部事件触发，像网络卡接收到数据包时，会触发网络中断。</li></ul></li><li><strong>软件中断</strong><ul><li>由软件程序发起，通常是为了实现系统调用或请求操作系统服务。</li><li>例如，系统调用（如 <code>read()</code>, <code>write()</code>）时，程序会发起软件中断，切换到内核模式以执行特权操作。</li><li>程序可以使用特殊的指令来发起软件中断，例如 <code>int 0x80</code> 在 Linux 中用于触发系统调用。</li></ul></li><li><strong>定时器中断</strong><ul><li>由系统定时器触发，通常用于时间片轮转、进程调度等。</li><li>定时器中断是操作系统进行进程管理和资源分配的重要手段。例如，操作系统通过定时器中断来定期检查是否需要切换进程，确保公平的 CPU 时间分配。</li></ul></li><li><strong>外部中断</strong><ul><li>外部事件引发的中断，如来自外部设备的中断请求。</li><li>例如，按下键盘时，键盘控制器会产生外部中断来通知操作系统读取键盘输入。</li></ul></li><li><strong>内部中断</strong><ul><li>由 CPU 内部状态或执行错误触发，例如除零错误、非法指令等。</li><li>例如，程序试图除以零时，CPU 会触发一个中断，处理器将跳转到错误处理程序。</li></ul></li></ol><h3 id=进程中断的工作流程>进程中断的工作流程
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e4%b8%ad%e6%96%ad%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b>#</a></h3><ol><li><strong>中断请求</strong><ul><li>中断发生时，外部设备（如硬盘、键盘、网络适配器等）或内部硬件（如计时器）会发出中断请求信号，通知 CPU 需要处理中断。</li></ul></li><li><strong>保存上下文</strong><ul><li>当中断发生时，操作系统首先会保存当前进程的执行状态（即上下文），包括程序计数器（PC）、寄存器值、堆栈指针等，以便稍后能够恢复执行。</li></ul></li><li><strong>中断处理</strong><ul><li>操作系统内核根据中断类型进行相应的处理中断程序（中断服务程序，ISR）。这可能涉及数据读取、设备驱动程序的调用或执行其他操作。</li><li>例如，硬件中断可能导致操作系统读取硬盘数据，定时器中断可能导致操作系统调度下一个进程。</li></ul></li><li><strong>恢复执行</strong><ul><li>中断处理完成后，操作系统会恢复被中断进程的上下文，继续执行该进程。中断后的程序通常会从中断发生之前的地方继续执行。</li></ul></li></ol><h3 id=中断的优先级和中断屏蔽>中断的优先级和中断屏蔽
<a class=anchor href=#%e4%b8%ad%e6%96%ad%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7%e5%92%8c%e4%b8%ad%e6%96%ad%e5%b1%8f%e8%94%bd>#</a></h3><p>在操作系统中，中断通常有优先级的概念。高优先级的中断会先处理，而低优先级的中断会在高优先级中断处理完之后才进行。</p><ul><li><strong>中断屏蔽</strong>：操作系统可以在某些时刻禁止或屏蔽某些类型的中断，以保证某些重要操作的完成。例如，操作系统在进行进程切换时可能会暂时屏蔽中断，以避免在关键时刻被打断。</li><li><strong>嵌套中断</strong>：有些情况下，高优先级的中断可以打断低优先级中断的处理过程，称为嵌套中断。操作系统通常会处理完当前高优先级中断后，再去处理低优先级的中断。</li></ul><h3 id=进程中断的作用>进程中断的作用
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e4%b8%ad%e6%96%ad%e7%9a%84%e4%bd%9c%e7%94%a8>#</a></h3><ol><li><strong>提高系统响应性</strong><ul><li>中断机制可以在任何时刻打断正在执行的进程，优先响应外部设备的请求，使得系统能够及时处理硬件设备或外部事件的变化。</li><li>例如，在实时操作系统中，中断机制确保能够快速响应外部事件（如传感器数据、用户输入等）。</li></ul></li><li><strong>实现多任务并行</strong><ul><li>中断使得操作系统能够迅速切换不同进程的执行状态，配合进程调度算法实现 CPU 时间的公平分配。</li><li>例如，当一个进程处于 I/O 阻塞时，操作系统通过中断机制能够迅速调度其他进程，最大化系统资源的利用率。</li></ul></li><li><strong>设备驱动与外设管理</strong><ul><li>通过中断，操作系统可以有效地与外设进行交互。当设备完成某项任务时，它会触发中断请求，操作系统可以响应并执行相应操作（如读取数据、发送数据等）。</li><li>例如，磁盘 I/O 中断会通知操作系统磁盘读取操作已完成，网络中断通知操作系统收到网络数据包。</li></ul></li><li><strong>优化系统性能</strong><ul><li>通过中断，系统可以减少空闲等待的时间，进程不需要轮询硬件状态，而是等到硬件完成任务后再被中断处理。</li><li>例如，在网络通信中，进程可以等待中断信号，以避免频繁轮询网络接口。</li></ul></li></ol><h3 id=总结-8>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-8>#</a></h3><ul><li><strong>进程中断</strong> 是操作系统中一种重要的机制，它能够在进程执行过程中打断当前的执行流，优先处理一些外部或内部的事件，并在中断处理完毕后恢复进程的执行。</li><li>中断分为硬件中断、软件中断、定时器中断等多种类型。</li><li>通过中断，操作系统可以实现高效的设备管理、进程调度和系统响应，从而提高系统的性能和响应速度。</li></ul><p>进程中断是操作系统多任务处理的核心部分，极大地增强了系统的灵活性和响应能力。</p><h1 id=什么是软中断硬中断>什么是软中断、硬中断
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e8%bd%af%e4%b8%ad%e6%96%ad%e7%a1%ac%e4%b8%ad%e6%96%ad>#</a></h1><p>在计算机系统中，<strong>中断</strong> 是一种机制，它允许外部或内部事件打断正在运行的程序，以便系统可以处理中断请求。在操作系统中，中断可以分为 <strong>软中断</strong> 和 <strong>硬中断</strong>，它们的触发来源和作用有所不同。以下是两者的详细解释：</p><h3 id=1-硬中断-hardware-interrupt>1. <strong>硬中断 (Hardware Interrupt)</strong>
<a class=anchor href=#1-%e7%a1%ac%e4%b8%ad%e6%96%ad-hardware-interrupt>#</a></h3><p><strong>硬中断</strong> 是由硬件设备触发的中断信号，通常是外部设备（如磁盘、网络适配器、键盘、鼠标等）发出的信号，用于通知 CPU 需要处理某个事件。硬中断的目的是让操作系统能够实时响应外部设备的变化或事件，例如数据准备完成、输入信号等。</p><h4 id=特点-9>特点
<a class=anchor href=#%e7%89%b9%e7%82%b9-9>#</a></h4><ul><li><strong>触发来源</strong>：硬中断是由外部硬件设备（如外设、控制器等）触发的。</li><li><strong>高优先级</strong>：硬中断的优先级较高，当硬件设备发出中断信号时，CPU 会停止当前的任务，立即响应中断。</li><li><strong>硬件中断号</strong>：硬件中断通常有固定的中断号，例如中断控制器会分配不同的中断号来标识不同的设备。</li><li><strong>中断处理程序</strong>：硬中断会跳转到中断服务例程（ISR，Interrupt Service Routine），在该例程中，操作系统会处理硬件请求（如数据读取、状态更新等）。</li></ul><h4 id=示例-2>示例
<a class=anchor href=#%e7%a4%ba%e4%be%8b-2>#</a></h4><ul><li><strong>磁盘 I/O 完成</strong>：硬盘在完成数据读写后发出中断，通知操作系统该操作已完成，操作系统会读取数据并继续处理。</li><li><strong>键盘输入</strong>：键盘输入一个按键时，键盘会发出中断，通知 CPU 处理按键输入事件。</li><li><strong>定时器中断</strong>：系统定时器发出中断，操作系统会进行进程调度，切换当前进程。</li></ul><h4 id=处理流程>处理流程
<a class=anchor href=#%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b>#</a></h4><ol><li>硬件设备通过中断控制器向 CPU 发送中断信号。</li><li>CPU 停止当前进程，保存当前进程的状态。</li><li>CPU 跳转到硬中断的中断服务例程（ISR）来处理该硬件设备的请求。</li><li>处理完成后，CPU 恢复原进程的执行。</li></ol><hr><h3 id=2-软中断-software-interrupt>2. <strong>软中断 (Software Interrupt)</strong>
<a class=anchor href=#2-%e8%bd%af%e4%b8%ad%e6%96%ad-software-interrupt>#</a></h3><p><strong>软中断</strong> 是由程序或操作系统通过软件指令触发的中断，通常用于系统调用或操作系统内核执行一些特权操作。软中断的主要目的是提供一种程序在用户态与内核态之间切换的机制，使得用户程序能够请求操作系统提供的服务。</p><h4 id=特点-10>特点
<a class=anchor href=#%e7%89%b9%e7%82%b9-10>#</a></h4><ul><li><strong>触发来源</strong>：软中断由程序发起，通常通过特定的指令（如 <code>int</code> 指令）触发。</li><li><strong>低优先级</strong>：软中断的优先级较低，一般是在程序主动请求系统服务时触发。</li><li><strong>中断号</strong>：软中断使用一个软件中断号，通常由操作系统定义，用于区分不同类型的软中断。</li><li><strong>系统调用</strong>：软中断是系统调用的一部分，用户程序通过触发软中断进入内核态，向操作系统请求服务。</li></ul><h4 id=示例-3>示例
<a class=anchor href=#%e7%a4%ba%e4%be%8b-3>#</a></h4><ul><li><strong>系统调用</strong>：用户程序调用 <code>read()</code>、<code>write()</code> 等系统调用时，操作系统通过软中断进入内核态执行相应的操作。</li><li><strong>错误处理</strong>：程序发生错误时，操作系统可能通过软中断处理异常，例如除零错误或非法操作。</li></ul><h4 id=处理流程-1>处理流程
<a class=anchor href=#%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b-1>#</a></h4><ol><li>用户程序通过 <code>int</code> 指令或类似机制发出软中断请求。</li><li>CPU 暂停当前程序，保存进程的状态。</li><li>CPU 跳转到软中断的中断服务例程（通常是操作系统的内核代码）。</li><li>操作系统根据中断号执行相应的系统调用或内核操作。</li><li>处理完成后，操作系统返回用户程序并恢复执行。</li></ol><hr><h3 id=硬中断与软中断的区别><strong>硬中断与软中断的区别</strong>
<a class=anchor href=#%e7%a1%ac%e4%b8%ad%e6%96%ad%e4%b8%8e%e8%bd%af%e4%b8%ad%e6%96%ad%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>硬中断 (Hardware Interrupt)</strong></th><th><strong>软中断 (Software Interrupt)</strong></th></tr></thead><tbody><tr><td><strong>触发方式</strong></td><td>外部硬件设备触发</td><td>程序通过特定指令触发</td></tr><tr><td><strong>优先级</strong></td><td>高优先级</td><td>低优先级</td></tr><tr><td><strong>常见触发源</strong></td><td>硬件设备（如磁盘、网络卡、定时器等）</td><td>用户程序或操作系统内部</td></tr><tr><td><strong>目的</strong></td><td>响应外部事件或设备请求</td><td>进入内核态执行系统调用或处理错误</td></tr><tr><td><strong>例子</strong></td><td>磁盘 I/O 完成、定时器中断、键盘输入</td><td>系统调用（如 <code>read()</code>、<code>write()</code>）</td></tr></tbody></table><hr><h3 id=应用场景和作用><strong>应用场景和作用</strong>
<a class=anchor href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e5%92%8c%e4%bd%9c%e7%94%a8>#</a></h3><ul><li><strong>硬中断</strong>：硬中断主要用于处理外部设备事件，确保操作系统能够及时响应硬件变化，如 I/O 完成、外设信号等。这使得操作系统能够高效地进行多任务处理和设备管理。</li><li><strong>软中断</strong>：软中断用于程序与操作系统内核之间的交互，提供了用户态和内核态的切换机制。通过软中断，程序能够请求操作系统提供的服务（如文件操作、内存分配等），并且能够处理程序错误或异常。</li></ul><h3 id=总结-9>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-9>#</a></h3><ul><li><strong>硬中断</strong> 由硬件设备触发，用于及时响应外部事件，优先级较高，通常需要立即处理中断请求。</li><li><strong>软中断</strong> 由程序通过指令触发，用于用户程序与操作系统之间的交互，主要用于系统调用和错误处理。</li></ul><p>这两者共同作用，确保了操作系统能够高效地管理硬件资源、响应外部事件，并且提供用户程序与内核之间的协作机制。</p><h1 id=什么是不可中断进程>什么是不可中断进程
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e8%bf%9b%e7%a8%8b>#</a></h1><p><strong>不可中断进程</strong>（也称为 <strong>D状态进程</strong> 或 <strong>不可打断进程</strong>）是指在运行过程中无法被操作系统的调度程序中断或打断的进程。通常，这种进程在执行某些特定操作时，系统不允许其他进程或信号中断其执行，确保其完成当前的任务。</p><p>在 Linux 和类 Unix 系统中，进程的状态通常会在 <code>/proc</code> 目录下的进程状态文件中查看，其中有一个字段表示进程的状态。不可中断进程的状态通常是 <code>D</code>，即 <strong>不可中断睡眠</strong>（Uninterruptible Sleep），表示进程正在等待某些资源（如 I/O 操作、磁盘读取、网络请求等），并且在完成这些操作之前，不能被任何信号打断。</p><h3 id=1-不可中断进程的特点>1. <strong>不可中断进程的特点</strong>
<a class=anchor href=#1-%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%89%b9%e7%82%b9>#</a></h3><ul><li><p><strong>无法响应信号</strong>：当一个进程处于不可中断状态时，操作系统不会响应它的信号（比如 <code>SIGKILL</code> 或 <code>SIGTERM</code> 等）。这意味着即使你尝试通过命令（如 <code>kill</code>）终止这个进程，它也无法被中断或杀死，直到进程的当前操作完成。</p></li><li><p><strong>等待 I/O 操作</strong>：不可中断进程通常出现在等待某些硬件 I/O 操作完成时，如硬盘读写、网络通信等。进程处于此状态时，CPU 无法调度它，直到 I/O 操作结束，进程才会恢复执行。</p></li><li><p><strong>系统资源占用</strong>：由于进程在等待 I/O 操作或资源，它会占用一定的系统资源，直到操作完成。</p></li><li><p><strong>进程状态</strong>：通过 <code>ps</code> 或 <code>top</code> 等命令查看进程时，进程会显示为 <strong>D</strong> 状态。这是不可中断进程的标志。例如：</p><pre tabindex=0><code>ps aux | grep &lt;pid&gt;
</code></pre><p>在输出中，进程的状态会显示为 <code>D</code>，表示该进程正在不可中断的等待中。</p></li></ul><h3 id=2-不可中断进程的常见原因>2. <strong>不可中断进程的常见原因</strong>
<a class=anchor href=#2-%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%b8%b8%e8%a7%81%e5%8e%9f%e5%9b%a0>#</a></h3><p>不可中断进程通常是由于以下几种原因导致的：</p><h4 id=1-io-操作>1. <strong>I/O 操作</strong>
<a class=anchor href=#1-io-%e6%93%8d%e4%bd%9c>#</a></h4><ul><li>当进程在进行硬件 I/O 操作时，比如磁盘读取、网络通信或等待从设备获取数据时，它会进入不可中断状态。</li><li>例如，进程请求读取硬盘上的数据时，如果磁盘正在忙碌或者出现延迟，进程可能会进入不可中断状态，直到磁盘操作完成。</li></ul><h4 id=2-文件系统操作>2. <strong>文件系统操作</strong>
<a class=anchor href=#2-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%93%8d%e4%bd%9c>#</a></h4><ul><li>如果进程正在访问一个挂载的文件系统（如读取文件），且该文件系统出现问题（如磁盘故障、挂载点不可访问等），进程可能会长时间处于不可中断状态。</li></ul><h4 id=3-设备驱动程序问题>3. <strong>设备驱动程序问题</strong>
<a class=anchor href=#3-%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f%e9%97%ae%e9%a2%98>#</a></h4><ul><li>如果操作系统或内核中的设备驱动程序存在问题（例如死锁或资源争用），可能导致进程进入不可中断状态，无法完成操作。</li></ul><h4 id=4-网络通信>4. <strong>网络通信</strong>
<a class=anchor href=#4-%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1>#</a></h4><ul><li>网络相关的操作，如等待网络数据包，尤其是在高延迟或网络中断的情况下，进程可能会长时间处于不可中断状态，直到网络通信恢复。</li></ul><h3 id=3-不可中断进程的处理>3. <strong>不可中断进程的处理</strong>
<a class=anchor href=#3-%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%a4%84%e7%90%86>#</a></h3><ul><li><strong>进程卡死</strong>：不可中断进程通常会表现为“卡死”，因为它们无法被杀死或中断，无法响应信号。在这种情况下，如果不可中断进程长时间不恢复，系统管理员需要调查进程为何无法中断，通常需要查看系统日志、硬件状况或相关驱动程序问题。</li><li><strong>解决方法</strong>：<ul><li><strong>检查硬件或设备问题</strong>：如果进程处于不可中断状态且是由硬件问题（如磁盘故障、网络中断等）引起的，解决问题通常需要恢复硬件功能或修复设备问题。</li><li><strong>查看内核日志</strong>：内核日志文件（如 <code>/var/log/messages</code> 或 <code>dmesg</code>）可能包含导致进程无法中断的错误信息。例如，如果是因为硬件故障或驱动问题，内核日志中可能有相关错误提示。</li><li><strong>重启系统</strong>：在某些情况下，无法通过普通手段终止不可中断进程。如果进程导致系统资源耗尽或卡死，可能需要重启计算机来清理这些进程。</li></ul></li></ul><h3 id=4-不可中断进程的例子>4. <strong>不可中断进程的例子</strong>
<a class=anchor href=#4-%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%be%8b%e5%ad%90>#</a></h3><p>以下是一些常见的导致进程进入不可中断状态的情景：</p><ul><li><strong>硬盘故障</strong>：例如，进程正在读取磁盘数据，而磁盘出现故障或延迟时，进程可能会卡在等待磁盘响应的状态。</li><li><strong>网络阻塞</strong>：如果进程正在进行网络请求，且网络连接出现问题（例如目标服务器不可达，或者网络拥塞），进程可能进入不可中断状态，直到网络恢复。</li><li><strong>驱动程序错误</strong>：某些设备驱动程序存在 bug 或设计缺陷时，可能导致进程无法继续执行，直到该驱动的操作完成。</li></ul><h3 id=5-如何排查不可中断进程>5. <strong>如何排查不可中断进程</strong>
<a class=anchor href=#5-%e5%a6%82%e4%bd%95%e6%8e%92%e6%9f%a5%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e8%bf%9b%e7%a8%8b>#</a></h3><ul><li><p><strong>使用 <code>ps</code> 命令查看进程状态</strong>： 你可以使用 <code>ps</code> 或 <code>top</code> 命令查看进程的状态，确认是否有进程处于 <code>D</code> 状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps aux | grep D
</span></span></code></pre></div><p>或使用 <code>top</code> 命令查看所有进程的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>top
</span></span></code></pre></div><p>如果进程处于 <code>D</code> 状态，表示它处于不可中断状态。</p></li><li><p><strong>查看系统日志</strong>： 系统日志中可能有有关进程卡死的原因。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dmesg | tail -n <span style=color:#ae81ff>100</span>
</span></span></code></pre></div></li><li><p><strong>检查硬件设备</strong>： 确保没有硬件故障，尤其是磁盘、网络等关键硬件。</p></li><li><p><strong>重新启动进程</strong>： 如果无法终止不可中断进程，可以尝试重新启动相关进程或重启系统来恢复正常运行。</p></li></ul><h3 id=总结-10>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-10>#</a></h3><p>不可中断进程是由于进程正在等待某些资源（如 I/O 操作、硬件设备响应等）而不能被中断的进程。它们通常处于 <code>D</code> 状态，且无法响应信号。通常，硬件问题、驱动程序问题或资源争用可能导致进程进入这种状态。在这种情况下，管理员需要调查硬件、驱动或网络等相关问题，必要时重启系统来恢复正常。</p><h1 id=什么是栈内存和堆内存>什么是栈内存和堆内存
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%a0%88%e5%86%85%e5%ad%98%e5%92%8c%e5%a0%86%e5%86%85%e5%ad%98>#</a></h1><p><strong>栈内存</strong>（Stack Memory）和<strong>堆内存</strong>（Heap Memory）是程序运行过程中用于存储数据的两种不同类型的内存区域，它们有各自不同的管理方式和使用场景。</p><h3 id=1-栈内存-stack-memory>1. <strong>栈内存 (Stack Memory)</strong>
<a class=anchor href=#1-%e6%a0%88%e5%86%85%e5%ad%98-stack-memory>#</a></h3><p>栈内存是一种存储临时数据的内存区域，通常由操作系统自动管理。当一个程序调用一个函数时，系统会为该函数在栈上分配内存，用于存储局部变量和函数调用的返回地址。栈内存是 <strong>LIFO（后进先出）</strong> 的结构，也就是说，后入栈的数据会先被弹出。</p><h4 id=特点-11>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-11>#</a></h4><ul><li><strong>自动管理</strong>：栈内存的分配和释放是自动的。当一个函数调用时，局部变量和函数参数会被压入栈中，函数返回时，这些局部变量和参数会自动被弹出栈，内存空间会被释放。</li><li><strong>快速分配与释放</strong>：栈内存的分配和释放速度非常快，因为它是基于栈顶的操作，分配内存只需要简单地向栈顶“压栈”，释放内存则是“弹栈”。</li><li><strong>大小有限</strong>：栈内存的大小通常是有限的，一般由操作系统决定。如果栈空间用尽（例如递归调用过深），就会发生 <strong>栈溢出</strong>（Stack Overflow）错误。</li><li><strong>存储数据</strong>：栈内存用于存储局部变量、函数参数和函数调用的返回地址等。</li></ul><h4 id=适用场景>适用场景：
<a class=anchor href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h4><ul><li><strong>局部变量</strong>：函数内部的局部变量会存储在栈内存中。它们的生命周期仅限于函数执行期间，函数执行完毕后，栈中的数据会自动销毁。</li><li><strong>函数调用</strong>：每次函数调用时，栈会为该函数分配内存空间，保存该函数的局部变量、返回地址等信息。</li></ul><h4 id=示例-4>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-4>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;  <span style=color:#75715e>// 局部变量 x 存储在栈中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;  <span style=color:#75715e>// 局部变量 y 存储在栈中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>在这个例子中，<code>x</code> 和 <code>y</code> 都是局部变量，存储在栈内存中，函数 <code>foo</code> 调用时，它们被压入栈中，函数执行完毕后，它们的内存会被自动释放。</p><hr><h3 id=2-堆内存-heap-memory>2. <strong>堆内存 (Heap Memory)</strong>
<a class=anchor href=#2-%e5%a0%86%e5%86%85%e5%ad%98-heap-memory>#</a></h3><p>堆内存是一块由程序员控制的内存区域，用于动态分配内存。堆内存的大小在程序运行时可以根据需要动态扩展，适用于存储那些需要在多个函数或不同地方之间共享的较大的数据结构。</p><h4 id=特点-12>特点：
<a class=anchor href=#%e7%89%b9%e7%82%b9-12>#</a></h4><ul><li><strong>手动管理</strong>：与栈内存不同，堆内存的分配和释放是由程序员手动管理的。在 C/C++ 中，程序员使用 <code>malloc</code>、<code>free</code> 或 <code>new</code>、<code>delete</code> 等操作来分配和释放堆内存。如果程序员忘记释放堆内存，就会发生 <strong>内存泄漏</strong>（Memory Leak），导致程序占用越来越多的内存。</li><li><strong>较慢的分配与释放</strong>：堆内存的分配和释放速度比栈内存慢，因为它需要通过更复杂的算法来管理内存（例如，查找空闲空间、合并已释放内存等）。</li><li><strong>较大的内存空间</strong>：堆内存的大小通常仅受系统内存大小的限制，相对于栈内存，堆内存更大，因此适合存储大规模数据。</li><li><strong>动态内存</strong>：堆内存的大小可以在程序运行时动态决定，适合存储那些大小无法在编译时确定的数据。</li></ul><h4 id=适用场景-1>适用场景：
<a class=anchor href=#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af-1>#</a></h4><ul><li><strong>动态分配的数据结构</strong>：例如，链表、树、图等动态数据结构，它们的大小在程序运行时才能确定，因此需要使用堆内存。</li><li><strong>对象</strong>：在面向对象编程中，通常使用堆内存来动态创建对象，以便在多个函数之间共享或延长对象的生命周期。</li></ul><h4 id=示例-5>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)<span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));  <span style=color:#75715e>// 在堆上分配内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;  <span style=color:#75715e>// 访问堆上的内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>free</span>(ptr);  <span style=color:#75715e>// 手动释放堆内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>在这个例子中，<code>ptr</code> 是一个指向堆内存的指针，程序使用 <code>malloc</code> 分配了一块内存，并在堆中存储一个整数 <code>10</code>。在使用完堆内存后，程序需要手动调用 <code>free</code> 来释放这块内存。</p><hr><h3 id=栈内存与堆内存的区别><strong>栈内存与堆内存的区别</strong>
<a class=anchor href=#%e6%a0%88%e5%86%85%e5%ad%98%e4%b8%8e%e5%a0%86%e5%86%85%e5%ad%98%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>栈内存</strong></th><th><strong>堆内存</strong></th></tr></thead><tbody><tr><td><strong>分配方式</strong></td><td>自动分配，随函数调用和返回自动管理</td><td>程序员手动分配和释放</td></tr><tr><td><strong>内存大小</strong></td><td>相对较小，有限，通常几 MB 到几十 MB</td><td>大且灵活，仅受系统内存限制</td></tr><tr><td><strong>生命周期</strong></td><td>函数调用时分配，函数结束时自动销毁</td><td>持续到程序员显式释放（<code>free</code> 或 <code>delete</code>）</td></tr><tr><td><strong>分配与释放速度</strong></td><td>快速</td><td>相对较慢</td></tr><tr><td><strong>访问速度</strong></td><td>较快，CPU 缓存优化</td><td>较慢，堆内存的管理较复杂</td></tr><tr><td><strong>适用场景</strong></td><td>局部变量、函数调用、递归</td><td>动态分配内存、对象、动态数据结构等</td></tr><tr><td><strong>内存管理问题</strong></td><td>栈溢出（如递归过深）</td><td>内存泄漏（未释放堆内存）</td></tr></tbody></table><h3 id=栈内存与堆内存的选择><strong>栈内存与堆内存的选择</strong>
<a class=anchor href=#%e6%a0%88%e5%86%85%e5%ad%98%e4%b8%8e%e5%a0%86%e5%86%85%e5%ad%98%e7%9a%84%e9%80%89%e6%8b%a9>#</a></h3><ul><li><strong>栈内存</strong>：适合用于存储生命周期短、大小固定的局部数据。栈内存是自动管理的，且访问速度非常快，但它的大小是有限的，不适合存储大量的数据或需要在多个函数之间共享的数据。</li><li><strong>堆内存</strong>：适合用于存储动态分配的、生命周期较长或大小不确定的数据。堆内存的管理较为复杂，程序员需要手动分配和释放内存，且可能会遇到内存泄漏的问题。</li></ul><h3 id=总结-11>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-11>#</a></h3><ul><li><strong>栈内存</strong> 用于存储局部变量和函数调用等临时数据，由系统自动管理，速度快但大小有限。</li><li><strong>堆内存</strong> 用于存储动态分配的较大数据，程序员需要手动管理，适用于存储动态数据结构和对象。</li></ul><h1 id=top-命令里面可以看到进程哪些状态>top 命令里面可以看到进程哪些状态☆
<a class=anchor href=#top-%e5%91%bd%e4%bb%a4%e9%87%8c%e9%9d%a2%e5%8f%af%e4%bb%a5%e7%9c%8b%e5%88%b0%e8%bf%9b%e7%a8%8b%e5%93%aa%e4%ba%9b%e7%8a%b6%e6%80%81>#</a></h1><p>在 Linux 系统中，使用 <code>top</code> 命令可以实时查看系统资源的使用情况，包括 CPU、内存、进程等信息。在 <code>top</code> 命令的输出中，进程的状态通常显示在 <strong>STAT</strong>（状态）这一列中。每个进程有一个对应的状态字母，表示该进程的当前状态。不同的字母代表不同的进程状态。</p><h3 id=进程状态的常见字母及其含义>进程状态的常见字母及其含义：
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e7%9a%84%e5%b8%b8%e8%a7%81%e5%ad%97%e6%af%8d%e5%8f%8a%e5%85%b6%e5%90%ab%e4%b9%89>#</a></h3><ol><li><strong>R (Running)</strong> — 运行中<ul><li>该进程正在运行或在就绪队列中等待运行。通常，进程正在执行或准备执行。</li></ul></li><li><strong>S (Sleeping)</strong> — 睡眠中<ul><li>该进程处于休眠状态，等待某些事件或条件（如 I/O 完成）。这通常是大部分进程的状态，它们在等待资源时会进入此状态。</li></ul></li><li><strong>D (Uninterruptible Sleep)</strong> — 不可中断睡眠<ul><li>该进程处于不可中断睡眠状态，通常是因为它正在等待 I/O 操作完成，如磁盘读取或网络请求。进程无法被任何信号打断，只有当操作完成时，进程才会继续执行。如果进程长时间处于该状态，可能表示 I/O 阻塞或设备故障。</li></ul></li><li><strong>T (Stopped)</strong> — 停止<ul><li>该进程已经停止运行。可能是因为它接收了 <code>SIGSTOP</code> 信号，或者正在调试过程中。你可以使用 <code>kill</code> 命令发送 <code>SIGCONT</code> 信号恢复该进程。</li></ul></li><li><strong>Z (Zombie)</strong> — 僵尸<ul><li>该进程已经完成执行，但它的父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 来读取它的退出状态。僵尸进程占用进程表项，但不占用 CPU 时间。</li></ul></li><li><strong>I (Idle)</strong> — 空闲<ul><li>在某些系统中，<code>I</code> 状态表示进程处于空闲状态，CPU 处于空闲模式。但一般来说，<code>top</code> 中没有明确的 <code>I</code> 状态，通常会看到 <code>R</code> 或 <code>S</code>。</li></ul></li><li><strong>X (Dead)</strong> — 死亡<ul><li>该进程已经死亡并且不再存在，通常系统将其从进程表中移除。<code>X</code> 状态是比较少见的，通常表示系统中某些资源的异常状态。</li></ul></li><li><strong>W (Paging)</strong> — 页面调度<ul><li>进程正在被操作系统调度来进行页面交换（Paging），即进程内存正在被交换到磁盘或从磁盘加载。</li></ul></li></ol><h3 id=top><strong><code>top</code> 命令输出中的进程状态字段示例</strong>：
<a class=anchor href=#top>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PID  USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
</span></span><span style=display:flex><span><span style=color:#ae81ff>1234</span> user1     <span style=color:#ae81ff>20</span>   <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>10000</span>  <span style=color:#ae81ff>4000</span>  <span style=color:#ae81ff>3000</span> S  1.0  0.1   0:05.67 myapp
</span></span><span style=display:flex><span><span style=color:#ae81ff>5678</span> user2     <span style=color:#ae81ff>20</span>   <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>20000</span>  <span style=color:#ae81ff>8000</span>  <span style=color:#ae81ff>6000</span> D  0.5  0.2   0:02.14 anotherapp
</span></span><span style=display:flex><span><span style=color:#ae81ff>9012</span> user3     <span style=color:#ae81ff>20</span>   <span style=color:#ae81ff>0</span>  <span style=color:#ae81ff>15000</span>  <span style=color:#ae81ff>6000</span>  <span style=color:#ae81ff>5000</span> Z  0.0  0.0   0:00.01 myzombie
</span></span></code></pre></div><h3 id=s><strong><code>S</code>、<code>D</code> 和 <code>Z</code> 状态的具体说明</strong>：
<a class=anchor href=#s>#</a></h3><ul><li><strong>S（睡眠中）</strong>：这通常是一个进程在等待某个事件（如等待 I/O）发生时的状态。它可能会在等待磁盘、网络、文件描述符等资源时处于这种状态。大多数进程在没有执行任务时都处于睡眠状态。</li><li><strong>D（不可中断睡眠）</strong>：这是进程在执行某些 I/O 操作时，无法被外部信号打断的状态。例如，等待磁盘操作或网络数据传输的完成。进程一旦完成这些操作，它就会变为 <code>S</code> 或其他状态。如果进程长时间处于 <code>D</code> 状态，可能意味着系统的硬件资源（如磁盘、网络等）出现了瓶颈或故障。</li><li><strong>Z（僵尸进程）</strong>：僵尸进程是已经结束的进程，但它的父进程没有收集它的退出状态，仍然保留在进程表中。它占用系统资源（进程 ID），但是不占用 CPU 和内存，通常会在父进程调用 <code>wait()</code> 或 <code>waitpid()</code> 时清理掉。</li></ul><h3 id=进程状态总结>进程状态总结：
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e6%80%bb%e7%bb%93>#</a></h3><table><thead><tr><th>状态字母</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>R</td><td>Running（运行中）</td><td>进程正在执行或准备执行。</td></tr><tr><td>S</td><td>Sleeping（睡眠中）</td><td>进程处于等待状态（如 I/O）。</td></tr><tr><td>D</td><td>Uninterruptible Sleep（不可中断睡眠）</td><td>进程在等待 I/O 操作，不能被打断。</td></tr><tr><td>T</td><td>Stopped（停止）</td><td>进程已停止，可以通过 <code>SIGCONT</code> 恢复。</td></tr><tr><td>Z</td><td>Zombie（僵尸进程）</td><td>进程已终止，但父进程未回收退出状态。</td></tr><tr><td>I</td><td>Idle（空闲）</td><td>进程处于空闲状态。</td></tr><tr><td>X</td><td>Dead（死去）</td><td>进程已死亡，通常系统清理后会消失。</td></tr><tr><td>W</td><td>Paging（页面调度）</td><td>进程处于页面交换操作中。</td></tr></tbody></table><h3 id=其他补充>其他补充：
<a class=anchor href=#%e5%85%b6%e4%bb%96%e8%a1%a5%e5%85%85>#</a></h3><ul><li><strong><code>top</code> 命令中的进程状态可以通过按下 <code>Shift + P</code> 来查看，也可以通过 <code>Shift + M</code> 查看内存使用情况。</strong></li><li><strong>不同的 Linux 发行版和版本的 <code>top</code> 命令可能会有所不同，状态字母可能有细微差异，但大体相同。</strong></li></ul><p>理解进程的不同状态可以帮助你诊断系统中的问题，如发现进程长时间处于 <code>D</code> 或 <code>Z</code> 状态，可能需要进一步调查资源瓶颈或系统配置问题。</p><h1 id=linux-系统中proc是做什么的>Linux 系统中/proc是做什么的
<a class=anchor href=#linux-%e7%b3%bb%e7%bb%9f%e4%b8%adproc%e6%98%af%e5%81%9a%e4%bb%80%e4%b9%88%e7%9a%84>#</a></h1><p>在 Linux 系统中，<code>/proc</code> 目录是一个虚拟文件系统（virtual filesystem），它提供了内核与系统信息的访问接口。通过 <code>/proc</code>，你可以查看操作系统内核、进程、硬件、内存等的实时信息。实际上，<code>/proc</code> 并不存储真正的文件，而是由内核动态生成的虚拟文件，这些文件的内容反映了当前系统的状态。</p><h3 id=proc-目录的主要作用><code>/proc</code> 目录的主要作用
<a class=anchor href=#proc-%e7%9b%ae%e5%bd%95%e7%9a%84%e4%b8%bb%e8%a6%81%e4%bd%9c%e7%94%a8>#</a></h3><ol><li><strong>提供系统和进程信息</strong>
<code>/proc</code> 包含了大量的虚拟文件和目录，用户可以通过查看这些文件来获得系统运行时的各种信息，比如进程信息、内存状态、硬件配置等。</li><li><strong>系统监控和调试</strong>
<code>/proc</code> 中的许多文件允许系统管理员和程序员获取系统运行时的状态。这些文件对于性能监控、故障排除以及系统调试非常有用。</li><li><strong>与内核交互</strong>
<code>/proc</code> 目录是与内核交互的一个重要接口，可以通过它修改一些内核参数或动态调整系统设置。</li></ol><h3 id=proc-目录中的重要文件和子目录><code>/proc</code> 目录中的重要文件和子目录
<a class=anchor href=#proc-%e7%9b%ae%e5%bd%95%e4%b8%ad%e7%9a%84%e9%87%8d%e8%a6%81%e6%96%87%e4%bb%b6%e5%92%8c%e5%ad%90%e7%9b%ae%e5%bd%95>#</a></h3><ol><li><p><strong>/proc/[pid]</strong>
这是进程信息目录，其中 <code>[pid]</code> 是一个数字，表示进程的 ID。每个进程都有一个对应的目录，在该目录下有许多文件，可以获取到进程的详细信息，例如：</p><ul><li><code>/proc/[pid]/cmdline</code>：进程的命令行</li><li><code>/proc/[pid]/status</code>：进程的状态、内存、IO等信息</li><li><code>/proc/[pid]/stat</code>：进程的统计信息，包括 CPU 时间、内存使用等</li><li><code>/proc/[pid]/fd/</code>：该进程打开的文件描述符列表</li></ul></li><li><p><strong>/proc/cpuinfo</strong>
包含了有关 CPU 的详细信息，如型号、核数、频率等。查看该文件可以获取当前系统 CPU 的配置信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/cpuinfo
</span></span></code></pre></div></li><li><p><strong>/proc/meminfo</strong>
提供有关内存的详细信息，包括总内存、已用内存、空闲内存、缓存、交换空间等。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/meminfo
</span></span></code></pre></div></li><li><p><strong>/proc/uptime</strong>
显示系统启动以来的运行时间，以及空闲时间（单位：秒）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/uptime
</span></span></code></pre></div></li><li><p><strong>/proc/partitions</strong>
显示磁盘分区信息，包括设备、分区大小等。可以查看系统上的磁盘设备和分区情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/partitions
</span></span></code></pre></div></li><li><p><strong>/proc/loads</strong>
显示系统的负载平均值。包括过去 1 分钟、5 分钟和 15 分钟的平均负载。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/loadavg
</span></span></code></pre></div></li><li><p><strong>/proc/filesystems</strong>
列出系统支持的文件系统类型，例如 <code>ext4</code>、<code>btrfs</code> 等。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/filesystems
</span></span></code></pre></div></li><li><p><strong>/proc/net/</strong>
该目录下包含了与网络相关的虚拟文件，提供网络配置、连接信息等。例如：</p><ul><li><code>/proc/net/tcp</code>：TCP 连接信息</li><li><code>/proc/net/udp</code>：UDP 连接信息</li><li><code>/proc/net/dev</code>：网络接口统计信息</li></ul></li><li><p><strong>/proc/sys/</strong>
包含了可用于调整内核参数的虚拟文件，用户可以在运行时通过修改这些文件来调整系统行为。例如：</p><ul><li><code>/proc/sys/net/ipv4/ip_forward</code>：控制 IP 转发</li><li><code>/proc/sys/vm/swappiness</code>：控制交换空间的使用策略</li><li><code>/proc/sys/kernel/hostname</code>：查看或修改系统主机名</li></ul><p>例如，查看和设置虚拟内存交换策略：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/sys/vm/swappiness
</span></span><span style=display:flex><span>echo <span style=color:#ae81ff>10</span> &gt; /proc/sys/vm/swappiness
</span></span></code></pre></div></li><li><p><strong>/proc/version</strong>
显示当前操作系统内核的版本信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/version
</span></span></code></pre></div></li></ol><h3 id=使用-proc-的常见场景>使用 <code>/proc</code> 的常见场景
<a class=anchor href=#%e4%bd%bf%e7%94%a8-proc-%e7%9a%84%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af>#</a></h3><ul><li><strong>查看系统资源使用情况</strong>：可以通过查看 <code>/proc/meminfo</code>、<code>/proc/cpuinfo</code>、<code>/proc/uptime</code> 等文件，了解系统的内存、CPU 使用情况以及系统的运行时间。</li><li><strong>监控进程信息</strong>：每个进程都有对应的 <code>/proc/[pid]</code> 目录，你可以用来实时监控进程的状态、CPU 使用情况、内存使用情况等。</li><li><strong>动态调整系统参数</strong>：可以通过 <code>/proc/sys/</code> 下的文件动态修改内核参数或配置，比如改变网络配置、调整虚拟内存管理等。</li><li><strong>排查故障和调试</strong>：系统管理员可以通过分析 <code>/proc</code> 中的数据来诊断系统问题或监控异常行为，例如检查进程状态、文件系统、网络连接等。</li></ul><h3 id=示例-6>示例
<a class=anchor href=#%e7%a4%ba%e4%be%8b-6>#</a></h3><ol><li><p><strong>查看 CPU 信息</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/cpuinfo
</span></span></code></pre></div></li><li><p><strong>查看内存使用情况</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/meminfo
</span></span></code></pre></div></li><li><p><strong>查看当前系统的负载情况</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/loadavg
</span></span></code></pre></div></li><li><p><strong>查看当前系统运行时间</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/uptime
</span></span></code></pre></div></li><li><p><strong>查看系统支持的文件系统类型</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/filesystems
</span></span></code></pre></div></li></ol><h3 id=总结-12>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-12>#</a></h3><ul><li><code>/proc</code> 目录是 Linux 系统中的一个虚拟文件系统，它提供了对系统运行时信息的访问接口。</li><li>通过 <code>/proc</code> 中的各种文件，用户和管理员可以获取 CPU、内存、硬盘、进程、网络等方面的实时信息。</li><li><code>/proc</code> 目录中的文件通常是内核动态生成的，反映了系统的当前状态。</li><li><code>/proc</code> 不仅用于查询信息，也可以用于修改内核参数，实时调整系统的行为。</li></ul><h1 id=load和cpu使用率区别>load和cpu使用率区别
<a class=anchor href=#load%e5%92%8ccpu%e4%bd%bf%e7%94%a8%e7%8e%87%e5%8c%ba%e5%88%ab>#</a></h1><p>在 Linux 系统中，<strong>load（负载）**和**CPU 使用率</strong>是两个常见的性能指标，它们都涉及到系统的资源使用情况，但它们的含义和作用有所不同。</p><h3 id=1-load负载>1. <strong>Load（负载）</strong>
<a class=anchor href=#1-load%e8%b4%9f%e8%bd%bd>#</a></h3><p><strong>负载</strong>表示系统在某一时间段内，处于运行或等待执行的进程数量。它反映了系统的工作负荷，可以用来评估系统的“忙碌”程度。负载值不仅仅与 CPU 使用情况有关，还包括 I/O 操作（如磁盘、网络等）和等待队列的进程数量。</p><h4 id=负载的关键点>负载的关键点：
<a class=anchor href=#%e8%b4%9f%e8%bd%bd%e7%9a%84%e5%85%b3%e9%94%ae%e7%82%b9>#</a></h4><ul><li><p><strong>负载的计算方式</strong>：系统负载通常用一个三元组表示，分别为过去 1 分钟、5 分钟、15 分钟的平均负载。这些值显示了系统负载的趋势。你可以通过 <code>cat /proc/loadavg</code> 来查看当前系统的负载。</p></li><li><p>负载的含义</p><p>：</p><ul><li>如果负载值小于或等于 CPU 核心数，则表明系统的资源还没有被完全占满，能够处理当前的任务。</li><li>如果负载值大于 CPU 核心数，则表明系统可能正在过载，可能会有很多进程在等待 CPU 时间片。</li></ul><p>例如：如果你有 4 核 CPU，负载值为 4 表示系统刚好忙碌（每个核心都有任务）。如果负载为 8，表示系统的负载已经超过了 CPU 核心数，可能会有等待的进程。</p></li></ul><h4 id=负载的查看>负载的查看：
<a class=anchor href=#%e8%b4%9f%e8%bd%bd%e7%9a%84%e6%9f%a5%e7%9c%8b>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/loadavg
</span></span></code></pre></div><p>输出示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>0.85 1.12 1.14 2/310 <span style=color:#ae81ff>15432</span>
</span></span></code></pre></div><p>其中：</p><ul><li><code>0.85</code>：过去 1 分钟的平均负载</li><li><code>1.12</code>：过去 5 分钟的平均负载</li><li><code>1.14</code>：过去 15 分钟的平均负载</li><li><code>2/310</code>：表示当前正在运行的进程数（2），以及系统中所有进程的总数（310）</li></ul><h4 id=负载值的含义>负载值的含义：
<a class=anchor href=#%e8%b4%9f%e8%bd%bd%e5%80%bc%e7%9a%84%e5%90%ab%e4%b9%89>#</a></h4><ul><li><strong>1.00（或 1）</strong>：系统的负载等于 CPU 核心数，表明系统刚好忙碌。</li><li><strong>> 1.00（或 CPU 核心数）</strong>：系统负载高，可能导致任务排队和延迟。</li><li><strong>&lt; 1.00</strong>：系统负载较低，通常表明 CPU 的处理能力有富余。</li></ul><hr><h3 id=2-cpu-使用率>2. <strong>CPU 使用率</strong>
<a class=anchor href=#2-cpu-%e4%bd%bf%e7%94%a8%e7%8e%87>#</a></h3><p><strong>CPU 使用率</strong>指的是 CPU 在某段时间内实际工作的比例，它反映了 CPU 资源的使用情况。CPU 使用率通常包括以下几个方面：</p><ul><li><strong>用户空间的 CPU 使用率（user）</strong>：表示 CPU 在用户程序中执行任务的时间比例。</li><li><strong>系统空间的 CPU 使用率（system）</strong>：表示 CPU 在内核空间中执行任务的时间比例。</li><li><strong>空闲 CPU 时间（idle）</strong>：表示 CPU 没有工作、处于空闲状态的时间比例。</li><li><strong>等待 I/O 操作的 CPU 时间（iowait）</strong>：表示 CPU 在等待 I/O 操作完成时的时间比例。</li></ul><p>CPU 使用率的关键点：</p><ul><li><strong>实时性</strong>：CPU 使用率是一个动态的、实时更新的指标，反映了 CPU 当前的负载状况。</li><li><strong>计算方式</strong>：CPU 使用率通常通过周期性测量 CPU 的空闲时间和工作时间来计算，表示为一个百分比值。</li></ul><h4 id=cpu-使用率的查看>CPU 使用率的查看：
<a class=anchor href=#cpu-%e4%bd%bf%e7%94%a8%e7%8e%87%e7%9a%84%e6%9f%a5%e7%9c%8b>#</a></h4><p>可以通过 <code>top</code> 命令来查看 CPU 使用率：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>top
</span></span></code></pre></div><p>在 <code>top</code> 输出的第一行中，你可以看到 CPU 使用率的各项指标：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>%Cpu<span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>:  1.3 us,  0.3 sy,  0.0 ni, 98.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</span></span></code></pre></div><ul><li><code>us</code>（user）：用户空间（程序运行）占用的 CPU 时间比例。</li><li><code>sy</code>（system）：内核空间（系统调用、内核任务）占用的 CPU 时间比例。</li><li><code>ni</code>（nice）：用户进程的优先级调整部分占用的 CPU 时间比例。</li><li><code>id</code>（idle）：CPU 空闲的时间比例。</li><li><code>wa</code>（iowait）：CPU 等待 I/O 操作的时间比例。</li><li><code>hi</code>（hardware interrupt）：硬件中断占用的 CPU 时间比例。</li><li><code>si</code>（software interrupt）：软件中断占用的 CPU 时间比例。</li><li><code>st</code>（steal）：虚拟化环境中，虚拟 CPU 被其他虚拟机抢占的时间比例。</li></ul><hr><h3 id=load-和-cpu-使用率的区别><strong>Load 和 CPU 使用率的区别</strong>
<a class=anchor href=#load-%e5%92%8c-cpu-%e4%bd%bf%e7%94%a8%e7%8e%87%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><table><thead><tr><th><strong>指标</strong></th><th><strong>Load（负载）</strong></th><th><strong>CPU 使用率</strong></th></tr></thead><tbody><tr><td><strong>含义</strong></td><td>表示系统当前有多少进程在运行或等待运行</td><td>表示 CPU 实际工作的百分比</td></tr><tr><td><strong>单位</strong></td><td>平均负载值，通常是 1 分钟、5 分钟、15 分钟的平均值</td><td>百分比（%）</td></tr><tr><td><strong>计算依据</strong></td><td>与 CPU 核心数、进程排队和 I/O 等等待时间有关</td><td>与 CPU 的使用情况（用户空间、系统空间、空闲等）有关</td></tr><tr><td><strong>查看方式</strong></td><td><code>cat /proc/loadavg</code> 或 <code>uptime</code></td><td><code>top</code> 命令中的 CPU 使用情况</td></tr><tr><td><strong>反映的内容</strong></td><td>反映系统负载和任务队列的长度</td><td>反映 CPU 的工作量和空闲情况</td></tr><tr><td><strong>影响因素</strong></td><td>与进程数量、I/O 等相关，负载过高可能导致系统过载</td><td>与程序运行、系统调用等相关，CPU 使用率过高可能影响系统响应</td></tr><tr><td><strong>系统过载情况</strong></td><td>当负载值 > CPU 核心数时，系统可能过载</td><td>当 CPU 使用率接近 100% 时，系统可能被过度占用</td></tr><tr><td><strong>示例</strong></td><td><code>loadavg</code> 值为 2，表示系统有 2 个进程在排队等待 CPU</td><td><code>top</code> 中 CPU 使用率显示 90%，表示 CPU 的 90% 被占用</td></tr></tbody></table><hr><h3 id=如何判断系统性能问题><strong>如何判断系统性能问题</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e7%b3%bb%e7%bb%9f%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98>#</a></h3><ul><li><strong>高负载：</strong> 如果 <code>loadavg</code> 值远高于 CPU 核心数，说明系统的负载很重，可能有很多进程在等待 CPU 时间。如果负载持续很高，可以考虑优化程序或增加硬件资源（如 CPU 核心数）。</li><li><strong>高 CPU 使用率：</strong> 如果 CPU 使用率接近 100%，且空闲时间很少（<code>id</code> 值低），说明系统的 CPU 资源已被大量占用，可能需要优化 CPU 密集型程序，或者检查是否有不正常的进程。</li><li><strong>I/O 等待：</strong> 如果 CPU 使用率较低，但负载较高，并且 <code>iowait</code> 比例较大，可能是系统存在 I/O 阻塞，导致进程等待磁盘或网络资源。</li></ul><h3 id=总结-13>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-13>#</a></h3><ul><li><strong>Load（负载）</strong> 主要反映系统整体的工作负载情况，关注的是有多少进程在等待资源（不仅仅是 CPU），以及这些进程是否被有效调度。</li><li><strong>CPU 使用率</strong> 主要关注 CPU 的实际使用情况，反映了 CPU 资源的忙碌程度，关注的是 CPU 被多大比例占用。</li></ul><p>通过结合查看负载和 CPU 使用率，可以更全面地了解系统的性能状况，帮助你判断是否存在瓶颈或资源不足的情况。</p><h1 id=mac地址ip地址如何转换>MAC地址IP地址如何转换
<a class=anchor href=#mac%e5%9c%b0%e5%9d%80ip%e5%9c%b0%e5%9d%80%e5%a6%82%e4%bd%95%e8%bd%ac%e6%8d%a2>#</a></h1><p><strong>MAC 地址和 IP 地址是两种不同层次的地址</strong>，分别工作在不同的网络模型层：</p><ul><li><strong>MAC 地址</strong>（媒体访问控制地址）是数据链路层（OSI 模型的第 2 层）的地址，用于唯一标识网络设备。每个网络接口卡（NIC）都有一个唯一的 MAC 地址，通常由硬件厂商分配。</li><li><strong>IP 地址</strong>是网络层（OSI 模型的第 3 层）的地址，用于标识设备在网络中的位置，允许设备之间进行通信。</li></ul><p><strong>MAC 地址和 IP 地址的转换</strong>并不是直接相互转换的过程，但它们之间存在联系，尤其在局域网内，MAC 地址通过 <strong>ARP（地址解析协议）</strong> 可以与 IP 地址进行映射。</p><h3 id=如何通过-arp-转换-mac-地址和-ip-地址><strong>如何通过 ARP 转换 MAC 地址和 IP 地址：</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87-arp-%e8%bd%ac%e6%8d%a2-mac-%e5%9c%b0%e5%9d%80%e5%92%8c-ip-%e5%9c%b0%e5%9d%80>#</a></h3><ol><li><p><strong>从 IP 地址获取 MAC 地址</strong></p><ul><li>当设备知道目标设备的 <strong>IP 地址</strong> 时，设备会通过 <strong>ARP 请求</strong>来寻找目标设备的 <strong>MAC 地址</strong>。</li><li>该过程通常如下：<ol><li>设备广播一个 ARP 请求，询问“IP 地址为 X.X.X.X 的设备的 MAC 地址是什么？”</li><li>如果该 IP 地址对应的设备在同一局域网内，则目标设备会响应一个 ARP 响应，包含它的 MAC 地址。</li><li>发送方设备收到响应后，将 IP 地址与 MAC 地址进行映射，并将其存储在 ARP 缓存中，以供将来使用。</li></ol></li></ul><p><strong>命令行示例</strong>（Linux）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>arp -n 192.168.1.10
</span></span></code></pre></div><p>这将显示 IP 地址 <code>192.168.1.10</code> 的 MAC 地址。</p></li><li><p><strong>从 MAC 地址获取 IP 地址</strong></p><ul><li>如果你知道设备的 <strong>MAC 地址</strong>，并想找出其对应的 <strong>IP 地址</strong>，通常可以通过 ARP 缓存来查看。</li><li>在本地设备上，你可以查看 ARP 缓存表，其中会列出本地网络中设备的 IP 地址与 MAC 地址的映射。</li></ul><p><strong>命令行示例</strong>（Linux）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>arp -a
</span></span></code></pre></div><p>这将列出所有已知设备的 IP 地址和它们对应的 MAC 地址。</p></li></ol><h3 id=arp-工作原理><strong>ARP 工作原理：</strong>
<a class=anchor href=#arp-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h3><p>ARP（地址解析协议）是一个在局域网内将 IP 地址映射到 MAC 地址的协议。ARP 协议用于查找设备的 MAC 地址，基于其已知的 IP 地址。该协议只在 <strong>局域网（LAN）中工作</strong>，因为它是基于广播的。</p><ul><li>当一个设备发送数据包到网络中的另一个设备时，它首先检查目标设备的 IP 地址。如果目标设备与源设备在同一个子网中，源设备会通过 ARP 查找目标设备的 MAC 地址，并将数据包发送给该设备的 MAC 地址。</li><li>如果目标设备的 MAC 地址已经缓存（通过先前的 ARP 请求获得），则直接使用该 MAC 地址发送数据包。</li><li>如果缓存没有目标设备的 MAC 地址，设备会通过广播 ARP 请求来查找该设备的 MAC 地址。</li></ul><h3 id=例子><strong>例子：</strong>
<a class=anchor href=#%e4%be%8b%e5%ad%90>#</a></h3><p>假设设备 A 想向设备 B 发送数据：</p><ol><li>设备 A 知道设备 B 的 IP 地址，但不知道它的 MAC 地址。</li><li>设备 A 向网络广播 ARP 请求，询问“IP 地址为 192.168.1.10 的设备的 MAC 地址是什么？”</li><li>设备 B 收到 ARP 请求后，发送 ARP 响应，告知设备 A 它的 MAC 地址（例如：00:1A:2B:3C:4D:5E）。</li><li>设备 A 获取到 MAC 地址后，就可以直接向设备 B 的 MAC 地址发送数据包。</li></ol><h3 id=总结-14><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-14>#</a></h3><ul><li><strong>MAC 地址</strong> 和 <strong>IP 地址</strong> 是不同层次的地址，不能直接相互转换。</li><li><strong>ARP 协议</strong>在局域网内用于根据 IP 地址查找设备的 MAC 地址，或根据 MAC 地址查找设备的 IP 地址。</li><li>每个设备会通过 ARP 协议自动进行这些转换，通常不需要人工干预。</li></ul><h1 id=常见的raid有哪些使用场景是什么>常见的raid有哪些，使用场景是什么
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84raid%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e6%98%af%e4%bb%80%e4%b9%88>#</a></h1><p>RAID（冗余磁盘阵列）是将多个物理硬盘驱动器（HDD）或固态硬盘（SSD）组合在一起，以提高存储性能、容量和可靠性。RAID 有不同的级别，每种级别都有不同的性能、冗余和成本权衡。以下是常见的 RAID 级别及其使用场景。</p><h3 id=常见的-raid-级别>常见的 RAID 级别
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84-raid-%e7%ba%a7%e5%88%ab>#</a></h3><h4 id=1-raid-0条带化>1. <strong>RAID 0（条带化）</strong>
<a class=anchor href=#1-raid-0%e6%9d%a1%e5%b8%a6%e5%8c%96>#</a></h4><ul><li><strong>特点</strong>：<ul><li>数据被分割成多个条带，分别写入不同的磁盘中，所有磁盘共同工作，提供更高的读写性能。</li><li>没有冗余机制。如果其中一个硬盘发生故障，所有数据都将丢失。</li><li>磁盘的容量等于所有硬盘容量的总和。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于需要高性能、高吞吐量的场景，例如视频编辑、图像处理等，尤其是对数据冗余没有要求的情况下。</li><li>不适合存储重要数据，因为没有冗余保护。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：性能非常高，适合读写密集型工作负载。</li><li><strong>缺点</strong>：没有冗余，单一硬盘故障会导致数据丢失。</li></ul></li></ul><h4 id=2-raid-1镜像>2. <strong>RAID 1（镜像）</strong>
<a class=anchor href=#2-raid-1%e9%95%9c%e5%83%8f>#</a></h4><ul><li><strong>特点</strong>：<ul><li>数据被复制到两个或多个硬盘中，提供冗余。每个硬盘保存完全相同的数据副本。</li><li>具有高度的容错能力，如果其中一个硬盘故障，数据依然可以从另一个硬盘中恢复。</li><li>磁盘的总容量是最小硬盘的容量（即，两个 1TB 硬盘组成的 RAID 1 阵列总容量为 1TB）。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于需要高数据可靠性和可用性的环境，例如小型办公室、文件存储服务器、数据库和关键应用。</li><li>适合不希望丢失数据的场景，例如个人数据备份、财务信息存储等。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：数据冗余高，硬盘故障不会导致数据丢失。</li><li><strong>缺点</strong>：存储效率低，只有一半的磁盘空间可用，性能提升不明显。</li></ul></li></ul><h4 id=3-raid-5带奇偶校验的条带化>3. <strong>RAID 5（带奇偶校验的条带化）</strong>
<a class=anchor href=#3-raid-5%e5%b8%a6%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c%e7%9a%84%e6%9d%a1%e5%b8%a6%e5%8c%96>#</a></h4><ul><li><strong>特点</strong>：<ul><li>数据和奇偶校验信息分布在所有硬盘上。奇偶校验是数据冗余的一种方式，能够在一个硬盘发生故障时，使用剩余硬盘和奇偶校验数据恢复丢失的数据。</li><li>至少需要 3 个硬盘。</li><li>存储效率相对较高，比 RAID 1 提供更多的存储空间。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于要求数据冗余和性能平衡的场景，例如中型企业的文件服务器、数据库服务器、Web 服务器等。</li><li>适合大多数企业环境，可以容忍一个硬盘故障而不丢失数据。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：性能和冗余之间有较好平衡，存储效率较高，能够容忍单个硬盘故障。</li><li><strong>缺点</strong>：写入性能较差，因为需要计算奇偶校验。</li></ul></li></ul><h4 id=4-raid-6带双重奇偶校验的条带化>4. <strong>RAID 6（带双重奇偶校验的条带化）</strong>
<a class=anchor href=#4-raid-6%e5%b8%a6%e5%8f%8c%e9%87%8d%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c%e7%9a%84%e6%9d%a1%e5%b8%a6%e5%8c%96>#</a></h4><ul><li><strong>特点</strong>：<ul><li>数据和双重奇偶校验信息分布在所有硬盘上，能够在两个硬盘同时发生故障时，依然能够恢复数据。</li><li>至少需要 4 个硬盘。</li><li>提供比 RAID 5 更高的容错能力，但存储效率较低。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于极其重视数据可靠性和容错的环境，例如企业级存储、数据中心、云存储服务等。</li><li>适合要求高可用性和容错性的关键应用和数据存储。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：提供比 RAID 5 更强的冗余能力，能够容忍两个硬盘同时故障。</li><li><strong>缺点</strong>：存储效率较低，写入性能较差，硬件要求较高。</li></ul></li></ul><h4 id=5-raid-10raid-1raid-0镜像条带化>5. <strong>RAID 10（RAID 1+RAID 0，镜像+条带化）</strong>
<a class=anchor href=#5-raid-10raid-1raid-0%e9%95%9c%e5%83%8f%e6%9d%a1%e5%b8%a6%e5%8c%96>#</a></h4><ul><li><strong>特点</strong>：<ul><li>结合了 RAID 1 和 RAID 0 的优点。首先将硬盘镜像（RAID 1），然后将镜像盘进行条带化（RAID 0）。</li><li>提供了高性能和高冗余，但需要至少 4 个硬盘。</li><li>数据被镜像并条带化，使其在提高性能的同时保留了冗余。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于需要高性能和高数据可靠性的环境，例如数据库服务器、高流量的 Web 服务器等。</li><li>适合需要快速读写和容忍故障的关键任务应用。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：提供非常高的性能和数据冗余，能够容忍单个硬盘故障。</li><li><strong>缺点</strong>：存储效率低，需要更多的硬盘，成本较高。</li></ul></li></ul><h4 id=6-raid-50raid-5--raid-0带奇偶校验的条带化>6. <strong>RAID 50（RAID 5 + RAID 0，带奇偶校验的条带化）</strong>
<a class=anchor href=#6-raid-50raid-5--raid-0%e5%b8%a6%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c%e7%9a%84%e6%9d%a1%e5%b8%a6%e5%8c%96>#</a></h4><ul><li><strong>特点</strong>：<ul><li>将多个 RAID 5 阵列组合成一个 RAID 0 阵列，以获得更好的性能。提供 RAID 5 的冗余和 RAID 0 的性能。</li><li>至少需要 6 个硬盘。</li><li>提供比单独的 RAID 5 更高的性能，尤其在读写密集型应用中。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于对性能和冗余都有较高要求的环境，如大规模数据存储、数据库存储等。</li><li>适合需要大存储容量并且需要在 RAID 5 性能基础上进行进一步优化的场景。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：提供较高的性能和冗余，适合需要更高吞吐量的场景。</li><li><strong>缺点</strong>：需要更多的硬盘，复杂度和成本较高。</li></ul></li></ul><h4 id=7-raid-60raid-6--raid-0带双重奇偶校验的条带化>7. <strong>RAID 60（RAID 6 + RAID 0，带双重奇偶校验的条带化）</strong>
<a class=anchor href=#7-raid-60raid-6--raid-0%e5%b8%a6%e5%8f%8c%e9%87%8d%e5%a5%87%e5%81%b6%e6%a0%a1%e9%aa%8c%e7%9a%84%e6%9d%a1%e5%b8%a6%e5%8c%96>#</a></h4><ul><li><strong>特点</strong>：<ul><li>将多个 RAID 6 阵列组合成一个 RAID 0 阵列，提供更高的性能和容错能力。能够容忍两个硬盘同时发生故障。</li><li>至少需要 8 个硬盘。</li><li>提供比 RAID 6 更高的性能，尤其在读写密集型场景下。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于对冗余性和性能要求极高的环境，如大规模企业级存储、数据中心、高可用性应用等。</li></ul></li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：提供非常高的容错能力和性能，能够容忍两个硬盘同时故障。</li><li><strong>缺点</strong>：需要大量硬盘，存储效率较低，成本较高。</li></ul></li></ul><hr><h3 id=总结-15>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-15>#</a></h3><ul><li><strong>RAID 0</strong>：适用于需要高性能、低成本，但不要求数据冗余的场景。</li><li><strong>RAID 1</strong>：适用于需要高数据可靠性，但对性能要求不高的环境。</li><li><strong>RAID 5</strong>：适用于大多数企业级存储，提供良好的性能与冗余平衡，适合存储大量数据。</li><li><strong>RAID 6</strong>：适用于要求非常高冗余的环境，能够容忍两个硬盘故障。</li><li><strong>RAID 10</strong>：适用于需要高性能和高冗余的环境，特别是数据库和高流量应用。</li><li><strong>RAID 50/60</strong>：适用于对性能和冗余要求较高的企业级存储，适合大规模的数据存储需求。</li></ul><p>根据不同的应用场景，选择合适的 RAID 级别可以有效提升系统性能和数据保护能力。</p><h1 id=lvm怎么划分>lvm怎么划分
<a class=anchor href=#lvm%e6%80%8e%e4%b9%88%e5%88%92%e5%88%86>#</a></h1><p>LVM（逻辑卷管理，Logical Volume Manager）是 Linux 中的一种逻辑存储管理方式，可以通过将物理卷（Physical Volumes, PV）组合成卷组（Volume Groups, VG），然后再从卷组中划分逻辑卷（Logical Volumes, LV），以实现更加灵活和动态的磁盘管理。</p><h3 id=lvm-的基本概念>LVM 的基本概念
<a class=anchor href=#lvm-%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h3><ol><li><strong>物理卷（PV）</strong>： 物理卷是实际的存储设备或存储介质，例如硬盘分区、硬盘或 RAID 阵列。一个物理卷可以是一个完整的硬盘、一个分区或其他支持的存储设备。</li><li><strong>卷组（VG）</strong>： 卷组是由一个或多个物理卷组成的存储池，提供了一组可用的空间来创建逻辑卷。卷组将多个物理卷的存储空间合并在一起，使得可以像一个大的磁盘一样来管理存储。</li><li><strong>逻辑卷（LV）</strong>： 逻辑卷是从卷组中划分出来的虚拟磁盘，可以在逻辑卷中存储数据。逻辑卷可以动态调整大小，扩展或缩小，支持灵活的磁盘分区管理。</li><li><strong>物理块（PE）</strong>： 物理卷上的数据是以固定大小的块（Physical Extents, PE）来划分的。一个物理卷上的 PE 数量决定了卷组中的可用空间。</li><li><strong>逻辑块（LE）</strong>： 逻辑卷中的数据同样是以固定大小的块（Logical Extents, LE）来划分的。每个逻辑卷上的 LE 是与卷组中的 PE 对应的。</li></ol><h3 id=lvm-的常用操作>LVM 的常用操作
<a class=anchor href=#lvm-%e7%9a%84%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c>#</a></h3><h4 id=1-创建物理卷pv>1. <strong>创建物理卷（PV）</strong>
<a class=anchor href=#1-%e5%88%9b%e5%bb%ba%e7%89%a9%e7%90%86%e5%8d%b7pv>#</a></h4><p>物理卷是物理存储设备上的一个分区或整个磁盘，可以通过 <code>pvcreate</code> 命令来创建。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo pvcreate /dev/sdb
</span></span></code></pre></div><p>这将 <code>/dev/sdb</code> 设备初始化为物理卷。</p><h4 id=2-创建卷组vg>2. <strong>创建卷组（VG）</strong>
<a class=anchor href=#2-%e5%88%9b%e5%bb%ba%e5%8d%b7%e7%bb%84vg>#</a></h4><p>卷组是由多个物理卷组成的，可以通过 <code>vgcreate</code> 命令来创建。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo vgcreate my_vg /dev/sdb
</span></span></code></pre></div><p>这将创建一个名为 <code>my_vg</code> 的卷组，并将 <code>/dev/sdb</code> 添加到该卷组中。</p><h4 id=3-创建逻辑卷lv>3. <strong>创建逻辑卷（LV）</strong>
<a class=anchor href=#3-%e5%88%9b%e5%bb%ba%e9%80%bb%e8%be%91%e5%8d%b7lv>#</a></h4><p>逻辑卷是在卷组中创建的，类似于传统的分区，可以通过 <code>lvcreate</code> 命令来创建。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo lvcreate -L 10G -n my_lv my_vg
</span></span></code></pre></div><p>这将创建一个大小为 10GB 的逻辑卷 <code>my_lv</code>，并将其放置在 <code>my_vg</code> 卷组中。</p><h4 id=4-查看-lvm-配置>4. <strong>查看 LVM 配置</strong>
<a class=anchor href=#4-%e6%9f%a5%e7%9c%8b-lvm-%e9%85%8d%e7%bd%ae>#</a></h4><p>可以通过 <code>vgs</code>、<code>lvs</code> 和 <code>pvs</code> 命令查看卷组、逻辑卷和物理卷的详细信息。</p><ul><li><p>查看卷组：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo vgs
</span></span></code></pre></div></li><li><p>查看逻辑卷：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo lvs
</span></span></code></pre></div></li><li><p>查看物理卷：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo pvs
</span></span></code></pre></div></li></ul><h4 id=5-扩展逻辑卷lv>5. <strong>扩展逻辑卷（LV）</strong>
<a class=anchor href=#5-%e6%89%a9%e5%b1%95%e9%80%bb%e8%be%91%e5%8d%b7lv>#</a></h4><p>如果逻辑卷空间不足，可以扩展逻辑卷的大小。可以通过 <code>lvextend</code> 命令增加逻辑卷的大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo lvextend -L +5G /dev/my_vg/my_lv
</span></span></code></pre></div><p>这将 <code>my_lv</code> 逻辑卷的大小增加 5GB。</p><p>扩展后，还需要扩展文件系统，使用 <code>resize2fs</code>（对于 ext 文件系统）或 <code>xfs_growfs</code>（对于 XFS 文件系统）来调整文件系统的大小：</p><ul><li><p>对于 ext 文件系统：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo resize2fs /dev/my_vg/my_lv
</span></span></code></pre></div></li><li><p>对于 XFS 文件系统：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo xfs_growfs /dev/my_vg/my_lv
</span></span></code></pre></div></li></ul><h4 id=6-缩小逻辑卷lv>6. <strong>缩小逻辑卷（LV）</strong>
<a class=anchor href=#6-%e7%bc%a9%e5%b0%8f%e9%80%bb%e8%be%91%e5%8d%b7lv>#</a></h4><p>如果需要减少逻辑卷的大小，首先需要先收缩文件系统，然后再缩小逻辑卷。</p><p><strong>步骤</strong>：</p><ol><li><p>收缩文件系统。</p><ul><li><p>对于 ext 文件系统：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo resize2fs /dev/my_vg/my_lv 5G
</span></span></code></pre></div></li><li><p>对于 XFS 文件系统： XFS 不支持直接缩小大小，因此如果要缩小 XFS 文件系统，必须先备份数据，删除逻辑卷，然后再重新创建较小的逻辑卷。</p></li></ul></li><li><p>缩小逻辑卷：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo lvreduce -L 5G /dev/my_vg/my_lv
</span></span></code></pre></div></li></ol><h4 id=7-删除逻辑卷lv>7. <strong>删除逻辑卷（LV）</strong>
<a class=anchor href=#7-%e5%88%a0%e9%99%a4%e9%80%bb%e8%be%91%e5%8d%b7lv>#</a></h4><p>当逻辑卷不再需要时，可以通过 <code>lvremove</code> 命令删除逻辑卷。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo lvremove /dev/my_vg/my_lv
</span></span></code></pre></div><h4 id=8-删除卷组vg>8. <strong>删除卷组（VG）</strong>
<a class=anchor href=#8-%e5%88%a0%e9%99%a4%e5%8d%b7%e7%bb%84vg>#</a></h4><p>在删除卷组之前，所有逻辑卷必须先被删除。然后可以使用 <code>vgremove</code> 命令删除卷组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo vgremove my_vg
</span></span></code></pre></div><h4 id=9-删除物理卷pv>9. <strong>删除物理卷（PV）</strong>
<a class=anchor href=#9-%e5%88%a0%e9%99%a4%e7%89%a9%e7%90%86%e5%8d%b7pv>#</a></h4><p>在删除物理卷之前，需要先将其从卷组中移除。然后可以使用 <code>pvremove</code> 命令删除物理卷。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo pvremove /dev/sdb
</span></span></code></pre></div><h3 id=lvm-的优缺点>LVM 的优缺点
<a class=anchor href=#lvm-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9>#</a></h3><p><strong>优点</strong>：</p><ul><li><strong>灵活性高</strong>：LVM 支持动态调整磁盘分区大小，可以在系统运行时扩展或缩小逻辑卷。</li><li><strong>易于管理</strong>：卷组和逻辑卷的管理比传统的分区方式更加方便，支持合并多个硬盘空间。</li><li><strong>冗余支持</strong>：LVM 支持创建镜像（RAID1）或条带化（RAID0）卷，以实现数据冗余和性能优化。</li><li><strong>支持快照</strong>：LVM 提供了快照功能，方便备份和恢复数据。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>复杂性</strong>：LVM 管理较为复杂，初学者可能不太容易理解和配置。</li><li><strong>性能开销</strong>：由于 LVM 进行逻辑层的抽象，可能会带来一定的性能开销，尤其是在较低规格的硬件上。</li></ul><h3 id=总结-16>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-16>#</a></h3><p>LVM 是一种非常灵活的磁盘管理方案，适用于动态存储需求的环境。通过物理卷、卷组和逻辑卷的组合，LVM 提供了比传统磁盘分区更高的灵活性和可扩展性。适合用于大规模存储、虚拟化环境或需要频繁调整存储容量的应用场景。</p><h1 id=jvm内存如何查看>jvm内存如何查看
<a class=anchor href=#jvm%e5%86%85%e5%ad%98%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b>#</a></h1><p>在 Java 程序运行时，JVM（Java Virtual Machine）会分配不同的内存区域来存储代码、数据、堆、栈等信息。了解 JVM 内存的使用情况有助于进行性能优化、内存调优以及排查内存泄漏等问题。</p><p>要查看 JVM 内存的使用情况，可以使用多种工具和方法。下面列出了几种常用的查看 JVM 内存的方法。</p><h3 id=1-使用-1>1. <strong>使用 <code>jps</code> 命令查看 JVM 进程</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-1>#</a></h3><p><code>jps</code>（Java Process Status）是一个简单的命令行工具，用于列出当前系统上运行的所有 Java 进程及其进程号（PID）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>jps
</span></span></code></pre></div><p>这将输出所有正在运行的 Java 进程的 ID 和名称。</p><h3 id=2-使用>2. <strong>使用 <code>jvm</code> 参数查看内存设置</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8>#</a></h3><p>JVM 启动时，您可以使用一些启动参数来设置和查看内存配置：</p><ul><li><code>-Xms</code>：设置 JVM 初始堆内存大小（单位：字节、KB、MB、GB）。</li><li><code>-Xmx</code>：设置 JVM 最大堆内存大小（单位：字节、KB、MB、GB）。</li><li><code>-Xmn</code>：设置新生代的大小（单位：字节、KB、MB、GB）。</li><li><code>-XX:MetaspaceSize</code>：设置 Metaspace 初始大小。</li><li><code>-XX:MaxMetaspaceSize</code>：设置 Metaspace 最大大小。</li></ul><p>例如，要查看 JVM 的堆内存设置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>java -Xms512m -Xmx2g -XX:MaxMetaspaceSize<span style=color:#f92672>=</span>256m -jar your-application.jar
</span></span></code></pre></div><p>这些参数在程序启动时传递，以便您可以根据需要进行调整。</p><h3 id=3-使用>3. <strong>使用 <code>jstat</code> 命令查看 JVM 内存统计</strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8>#</a></h3><p><code>jstat</code> 是 Java 提供的一个监控工具，用于查看 JVM 运行时的各种统计信息，包括内存使用情况。最常见的命令是 <code>jstat -gc</code>，可以查看垃圾收集相关的内存信息。</p><p>查看 JVM 的垃圾收集和内存使用情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>jstat -gc &lt;pid&gt; <span style=color:#ae81ff>1000</span>
</span></span></code></pre></div><p>解释：</p><ul><li><code>&lt;pid></code>：JVM 进程的进程 ID。</li><li><code>1000</code>：表示每隔 1000 毫秒（即 1 秒）输出一次统计信息。</li></ul><p><code>jstat -gc</code> 输出的字段包括：</p><ul><li><strong>S0C</strong>：第一个 Survivor 区的内存大小。</li><li><strong>S1C</strong>：第二个 Survivor 区的内存大小。</li><li><strong>EC</strong>：Eden 区的内存大小。</li><li><strong>OC</strong>：老年代的内存大小。</li><li><strong>MC</strong>：Metaspace 区的内存大小。</li><li><strong>YGC</strong>：垃圾回收发生的次数（Young GC）。</li><li><strong>YGCT</strong>：Young GC 的总耗时。</li><li><strong>FGC</strong>：垃圾回收发生的次数（Full GC）。</li><li><strong>FGCT</strong>：Full GC 的总耗时。</li></ul><h3 id=4-使用-1>4. <strong>使用 <code>jmap</code> 命令查看堆内存信息</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-1>#</a></h3><p><code>jmap</code> 是另一个用于查看 JVM 内存的工具，主要用于生成堆内存的快照。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>jmap -heap &lt;pid&gt;
</span></span></code></pre></div><p>这将显示堆内存的使用情况，包括堆的初始大小、最大大小、当前大小、各个区域的使用情况（如 Eden 区、老年代、Survivor 区等）以及垃圾回收的相关统计信息。</p><p>例如：</p><pre tabindex=0><code>Heap Configuration:
   MinHeapFreeRatio           = 40
   MaxHeapFreeRatio           = 70
   MaxHeapSize                = 2147483648 (2048.0MB)
   NewSize                    = 268435456 (256.0MB)
   MaxNewSize                 = 268435456 (256.0MB)
   OldSize                    = 0 (0.0MB)
   NewRatio                   = 2
   SurvivorRatio              = 8
   MetaspaceSize              = 16777216 (16.0MB)
   MaxMetaspaceSize           = 1073741824 (1024.0MB)

Heap Usage:
PS Young Generation:
Eden Space:
   capacity = 33554432 (32.0MB)
   used     = 33123456 (31.6MB)
   free     = 431280 (0.4MB)
   98.8% used
From Space:
   capacity = 8388608 (8.0MB)
   used     = 0 (0.0MB)
   free     = 8388608 (8.0MB)
   0.0% used
To Space:
   capacity = 8388608 (8.0MB)
   used     = 0 (0.0MB)
   free     = 8388608 (8.0MB)
   0.0% used
PS Old Generation:
   capacity = 4294967296 (4096.0MB)
   used     = 500000000 (476.8MB)
   free     = 3794967296 (3600.2MB)
   11.6% used
</code></pre><h3 id=5-使用-1>5. <strong>使用 <code>visualvm</code> 或 <code>jconsole</code> 图形化工具</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8-1>#</a></h3><p>如果您更倾向于图形化界面，可以使用 <strong>VisualVM</strong> 或 <strong>JConsole</strong> 工具来查看 JVM 内存和垃圾回收等相关信息。</p><ul><li><strong>VisualVM</strong>：是一个功能强大的监控工具，提供了内存、线程、垃圾收集、CPU 等的可视化图表。可以通过 <code>jvisualvm</code> 启动。</li><li><strong>JConsole</strong>：是一个基于 Java 的监控工具，提供了 CPU、内存、线程和类加载等方面的信息。可以通过 <code>jconsole</code> 启动。</li></ul><p>这些工具允许实时监控 JVM 的状态，查看堆内存的使用情况，以及生成堆转储（heap dump）文件用于分析内存泄漏等问题。</p><h3 id=6-使用>6. <strong>使用 <code>-XX:+PrintGCDetails</code> 参数查看垃圾回收日志</strong>
<a class=anchor href=#6-%e4%bd%bf%e7%94%a8>#</a></h3><p>为了监控 JVM 垃圾回收的详细信息，您可以通过 JVM 启动参数启用垃圾回收日志。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:&lt;path-to-log-file&gt; -jar your-application.jar
</span></span></code></pre></div><p>这将打印出每次垃圾回收的详细信息，包括内存的使用情况、GC 类型、回收前后的内存量等。</p><h3 id=7-查看系统层面的内存使用>7. <strong>查看系统层面的内存使用</strong>
<a class=anchor href=#7-%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e5%b1%82%e9%9d%a2%e7%9a%84%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8>#</a></h3><p>除了 Java 自身的工具，还可以查看系统层面的内存使用情况。通过 <code>top</code>、<code>htop</code> 或 <code>free</code> 等工具可以查看系统上所有进程的内存使用情况，其中包括 JVM 占用的内存。</p><ul><li><code>top</code>：显示系统的内存使用情况和每个进程的内存占用。</li><li><code>htop</code>：是 <code>top</code> 的增强版，提供更友好的交互界面。</li><li><code>free</code>：显示系统内存的总量、已用、空闲和交换空间（swap）的情况。</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>top -p &lt;pid&gt;
</span></span></code></pre></div><p>这将只显示指定进程的内存使用情况。</p><h3 id=8-查看-metaspace-使用情况>8. <strong>查看 Metaspace 使用情况</strong>
<a class=anchor href=#8-%e6%9f%a5%e7%9c%8b-metaspace-%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5>#</a></h3><p>JVM 在 Java 8 及更高版本使用 Metaspace 来代替永久代（PermGen）。可以通过 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 来配置 Metaspace 的大小。</p><p>使用 <code>jstat -gc</code> 命令查看 Metaspace 的使用情况，或者在 JVM 启动时使用参数 <code>-XX:+PrintGCDetails</code> 来查看 Metaspace 的 GC 日志。</p><h3 id=总结-17>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-17>#</a></h3><p>查看 JVM 内存使用情况有多种方法，包括使用命令行工具（如 <code>jps</code>、<code>jstat</code>、<code>jmap</code>）、图形化工具（如 <code>VisualVM</code>、<code>JConsole</code>）以及通过 JVM 启动参数来获取详细的内存、GC 日志信息。通过这些工具，您可以实时监控 JVM 的内存使用，进行性能调优，定位内存泄漏等问题。</p><h1 id=如何管理和优化内核参数>如何管理和优化内核参数
<a class=anchor href=#%e5%a6%82%e4%bd%95%e7%ae%a1%e7%90%86%e5%92%8c%e4%bc%98%e5%8c%96%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0>#</a></h1><p>管理和优化 Linux 内核参数是确保系统性能、稳定性和安全性的关键操作，尤其是在高负载或特殊场景下（例如大规模并发、网络优化、大数据处理等）。Linux 内核的各项参数影响着系统的行为，包括内存管理、进程调度、文件系统、网络等方面。</p><h3 id=1-查看当前内核参数>1. <strong>查看当前内核参数</strong>
<a class=anchor href=#1-%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0>#</a></h3><p>内核参数通常存储在 <code>/proc/sys/</code> 目录中，或者通过 <code>sysctl</code> 命令进行管理。可以使用以下命令查看当前的内核参数：</p><ul><li><p>查看当前内核参数值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -a
</span></span></code></pre></div><p>这将列出所有当前的内核参数及其值。</p></li><li><p>查看单个内核参数的值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl &lt;parameter&gt;
</span></span></code></pre></div><p>例如，要查看最大文件描述符数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl fs.file-max
</span></span></code></pre></div></li><li><p>直接查看 <code>/proc/sys/</code> 下的内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/sys/net/core/rmem_max
</span></span></code></pre></div></li></ul><h3 id=2-修改内核参数>2. <strong>修改内核参数</strong>
<a class=anchor href=#2-%e4%bf%ae%e6%94%b9%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0>#</a></h3><p>可以通过两种方式来修改内核参数：临时修改和永久修改。</p><h4 id=临时修改内核参数>临时修改内核参数
<a class=anchor href=#%e4%b8%b4%e6%97%b6%e4%bf%ae%e6%94%b9%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0>#</a></h4><p>临时修改内核参数会在系统重启后失效。可以通过 <code>sysctl</code> 命令直接修改内核参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo sysctl -w &lt;parameter&gt;<span style=color:#f92672>=</span>&lt;value&gt;
</span></span></code></pre></div><p>例如，修改最大文件描述符数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo sysctl -w fs.file-max<span style=color:#f92672>=</span><span style=color:#ae81ff>2097152</span>
</span></span></code></pre></div><h4 id=永久修改内核参数>永久修改内核参数
<a class=anchor href=#%e6%b0%b8%e4%b9%85%e4%bf%ae%e6%94%b9%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0>#</a></h4><p>要永久修改内核参数，需要将其添加到 <code>/etc/sysctl.conf</code> 文件中。每次系统启动时，<code>sysctl</code> 会自动读取该文件中的设置并应用。</p><ol><li><p>编辑 <code>/etc/sysctl.conf</code> 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo vi /etc/sysctl.conf
</span></span></code></pre></div></li><li><p>添加或修改需要的内核参数。例如，增加文件描述符的最大值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>fs.file-max <span style=color:#f92672>=</span> <span style=color:#ae81ff>2097152</span>
</span></span></code></pre></div></li><li><p>使更改生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo sysctl -p
</span></span></code></pre></div></li></ol><p>你也可以通过直接修改 <code>/etc/sysctl.d/</code> 目录下的配置文件来管理内核参数。</p><h3 id=3-常用内核参数及其优化>3. <strong>常用内核参数及其优化</strong>
<a class=anchor href=#3-%e5%b8%b8%e7%94%a8%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0%e5%8f%8a%e5%85%b6%e4%bc%98%e5%8c%96>#</a></h3><h4 id=a-内存管理>a. <strong>内存管理</strong>
<a class=anchor href=#a-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>#</a></h4><ul><li><p><strong>vm.swappiness</strong>：控制内存交换行为，0-100 范围内，值越小，系统越倾向于使用物理内存而不是交换分区。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl vm.swappiness<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>
</span></span></code></pre></div><p>对于数据库、内存密集型应用，设置较低的值可以避免过早进行交换。</p></li><li><p><strong>vm.overcommit_memory</strong>：控制内核如何处理内存超分配。值为 0 表示内核允许超额分配，值为 1 表示总是允许超额分配，值为 2 表示不允许超额分配。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl vm.overcommit_memory<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>
</span></span></code></pre></div></li><li><p><strong>vm.dirty_ratio</strong> 和 <strong>vm.dirty_background_ratio</strong>：控制在写回磁盘之前，内存中可以保持的脏页（未同步到磁盘的页面）比例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl vm.dirty_ratio<span style=color:#f92672>=</span><span style=color:#ae81ff>60</span>
</span></span><span style=display:flex><span>sysctl vm.dirty_background_ratio<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>
</span></span></code></pre></div></li></ul><h4 id=b-进程调度>b. <strong>进程调度</strong>
<a class=anchor href=#b-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6>#</a></h4><ul><li><p><strong>kernel.pid_max</strong>：设置系统允许的最大进程号，默认 32768。对高并发系统可进行适当调整。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl kernel.pid_max<span style=color:#f92672>=</span><span style=color:#ae81ff>65535</span>
</span></span></code></pre></div></li><li><p><strong>kernel.threads-max</strong>：设置系统允许的最大线程数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl kernel.threads-max<span style=color:#f92672>=</span><span style=color:#ae81ff>1000000</span>
</span></span></code></pre></div></li></ul><h4 id=c-网络优化>c. <strong>网络优化</strong>
<a class=anchor href=#c-%e7%bd%91%e7%bb%9c%e4%bc%98%e5%8c%96>#</a></h4><ul><li><p><strong>net.core.somaxconn</strong>：控制系统每个网络接口的最大连接队列长度。可以增加该值来提高处理高并发连接的能力。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl net.core.somaxconn<span style=color:#f92672>=</span><span style=color:#ae81ff>65535</span>
</span></span></code></pre></div></li><li><p><strong>net.ipv4.tcp_fin_timeout</strong>：控制 TCP 连接关闭的等待时间，减少连接的长时间保持状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl net.ipv4.tcp_fin_timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>30</span>
</span></span></code></pre></div></li><li><p><strong>net.ipv4.tcp_rmem</strong> 和 <strong>net.ipv4.tcp_wmem</strong>：控制 TCP 接收和发送缓冲区大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl net.ipv4.tcp_rmem<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;4096 87380 6291456&#34;</span>
</span></span><span style=display:flex><span>sysctl net.ipv4.tcp_wmem<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;4096 65536 6291456&#34;</span>
</span></span></code></pre></div></li><li><p><strong>net.ipv4.ip_local_port_range</strong>：设置可用的本地端口范围，对于高并发服务，应该扩大端口范围。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl net.ipv4.ip_local_port_range<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1024 65535&#34;</span>
</span></span></code></pre></div></li></ul><h4 id=d-文件系统>d. <strong>文件系统</strong>
<a class=anchor href=#d-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h4><ul><li><p><strong>fs.file-max</strong>：控制整个系统允许的最大文件句柄数。可以通过增加该值来提高支持大并发文件操作的能力。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl fs.file-max<span style=color:#f92672>=</span><span style=color:#ae81ff>2097152</span>
</span></span></code></pre></div></li><li><p><strong>fs.inotify.max_user_watches</strong>：调整可以同时监视的文件数量，适用于需要大量监控文件变化的应用（如文件监控系统）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl fs.inotify.max_user_watches<span style=color:#f92672>=</span><span style=color:#ae81ff>524288</span>
</span></span></code></pre></div></li></ul><h4 id=e-安全性设置>e. <strong>安全性设置</strong>
<a class=anchor href=#e-%e5%ae%89%e5%85%a8%e6%80%a7%e8%ae%be%e7%bd%ae>#</a></h4><ul><li><p><strong>kernel.randomize_va_space</strong>：启用或禁用地址空间布局随机化（ASLR），增强系统的安全性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl kernel.randomize_va_space<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>
</span></span></code></pre></div></li><li><p><strong>net.ipv4.icmp_echo_ignore_all</strong>：如果你想要忽略 ICMP 回显请求（ping 请求），可以禁用 ICMP 响应。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl net.ipv4.icmp_echo_ignore_all<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div></li></ul><h3 id=4-监控内核参数>4. <strong>监控内核参数</strong>
<a class=anchor href=#4-%e7%9b%91%e6%8e%a7%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0>#</a></h3><ul><li><strong><code>sysctl -a</code></strong>：查看所有内核参数及其值。</li><li><strong><code>vmstat</code></strong>：查看系统的内存、进程、IO 等相关统计信息。</li><li><strong><code>iostat</code></strong>：查看系统的 CPU 使用情况和磁盘 I/O 性能。</li><li><strong><code>netstat</code></strong>：查看网络连接状态、路由表等信息。</li><li><strong><code>top</code> / <code>htop</code></strong>：实时查看系统资源使用情况，包括内存、CPU、负载等。</li><li><strong><code>sar</code></strong>：收集、报告和保存系统活动信息，适合做长期性能监控。</li></ul><h3 id=5-调整参数的策略>5. <strong>调整参数的策略</strong>
<a class=anchor href=#5-%e8%b0%83%e6%95%b4%e5%8f%82%e6%95%b0%e7%9a%84%e7%ad%96%e7%95%a5>#</a></h3><ul><li><strong>负载高的应用</strong>：如果有高并发的 web 服务器，调整网络相关的参数（如 <code>somaxconn</code>、<code>tcp_fin_timeout</code>、<code>tcp_rmem</code> 等）和文件句柄限制（<code>file-max</code>）。</li><li><strong>内存密集型应用</strong>：可以调整 <code>swappiness</code>、<code>vm.dirty_ratio</code>、<code>overcommit_memory</code> 等内存管理参数。</li><li><strong>系统启动优化</strong>：一些内核参数（如 <code>pid_max</code>）可以影响系统的最大进程数和线程数，适当调整可以提升系统的并发能力。</li><li><strong>监控与调优</strong>：定期使用 <code>sysctl</code>、<code>top</code>、<code>vmstat</code> 等工具监控内核参数，根据实际负载调整参数。</li></ul><h3 id=6-注意事项>6. <strong>注意事项</strong>
<a class=anchor href=#6-%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h3><ul><li><strong>内核参数调整需要小心</strong>：有些内核参数可能对系统的稳定性和安全性产生影响，修改前最好了解其具体作用。</li><li><strong>合理使用内存和 CPU 资源</strong>：某些参数（如 <code>swappiness</code>）可以提高系统的响应速度，但可能会增加 I/O 操作的负担，因此需要根据实际应用负载来调整。</li><li><strong>定期监控与调整</strong>：系统负载和性能需求可能会随时间变化，因此定期评估和调整内核参数非常重要。</li></ul><p>通过合理地管理和优化内核参数，能够有效提高系统性能、稳定性并满足特定应用场景的需求。</p><h1 id=什么是进程最大数最大线程数进程打开的文件数怎么调整>什么是进程最大数、最大线程数、进程打开的文件数，怎么调整☆
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e8%bf%9b%e7%a8%8b%e6%9c%80%e5%a4%a7%e6%95%b0%e6%9c%80%e5%a4%a7%e7%ba%bf%e7%a8%8b%e6%95%b0%e8%bf%9b%e7%a8%8b%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6%e6%95%b0%e6%80%8e%e4%b9%88%e8%b0%83%e6%95%b4>#</a></h1><p>在 Linux 系统中，<strong>进程最大数</strong>、<strong>最大线程数</strong>和<strong>进程打开的文件数</strong>是与系统资源和性能密切相关的重要参数。理解这些参数并适时调整它们有助于提高系统的处理能力，尤其是在高负载或高并发的场景下。</p><h3 id=1-进程最大数max-processes>1. <strong>进程最大数（max processes）</strong>
<a class=anchor href=#1-%e8%bf%9b%e7%a8%8b%e6%9c%80%e5%a4%a7%e6%95%b0max-processes>#</a></h3><p><strong>进程最大数</strong>是指系统中允许的最大进程数。在 Linux 系统中，进程数受两个因素的限制：</p><ul><li><strong>系统级别限制</strong>：即整个系统最多能够启动多少个进程。</li><li><strong>用户级别限制</strong>：即单个用户最多能够启动多少个进程。</li></ul><h4 id=查看进程最大数>查看进程最大数：
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e6%9c%80%e5%a4%a7%e6%95%b0>#</a></h4><ul><li><p><strong>系统级别</strong>： 可以查看 <code>/proc/sys/kernel/pid_max</code> 来查看当前系统允许的最大进程号（即最大进程数）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/sys/kernel/pid_max
</span></span></code></pre></div></li><li><p><strong>用户级别</strong>： 使用 <code>ulimit</code> 命令查看当前用户的进程限制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ulimit -u
</span></span></code></pre></div></li></ul><h4 id=调整进程最大数>调整进程最大数：
<a class=anchor href=#%e8%b0%83%e6%95%b4%e8%bf%9b%e7%a8%8b%e6%9c%80%e5%a4%a7%e6%95%b0>#</a></h4><ul><li><p><strong>临时调整</strong>：可以通过 <code>sysctl</code> 命令来调整系统级别的最大进程数。例如，修改最大进程号：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo sysctl -w kernel.pid_max<span style=color:#f92672>=</span><span style=color:#ae81ff>65535</span>
</span></span></code></pre></div></li><li><p><strong>永久调整</strong>：修改 <code>/etc/sysctl.conf</code> 文件，添加或修改如下行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kernel.pid_max <span style=color:#f92672>=</span> <span style=color:#ae81ff>65535</span>
</span></span></code></pre></div><p>然后使用以下命令使其生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo sysctl -p
</span></span></code></pre></div></li><li><p><strong>用户级别调整</strong>：通过修改 <code>/etc/security/limits.conf</code> 文件，可以设置每个用户的最大进程数。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>username soft nproc <span style=color:#ae81ff>4096</span>
</span></span><span style=display:flex><span>username hard nproc <span style=color:#ae81ff>8192</span>
</span></span></code></pre></div><p>其中：</p><ul><li><code>soft</code> 是软限制，表示普通的进程数限制。</li><li><code>hard</code> 是硬限制，表示无法再增加的进程数限制。</li></ul><p>另外，修改 <code>/etc/pam.d/common-session</code> 文件，确保 <code>pam_limits.so</code> 被启用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>session required pam_limits.so
</span></span></code></pre></div></li></ul><h3 id=2-最大线程数max-threads>2. <strong>最大线程数（max threads）</strong>
<a class=anchor href=#2-%e6%9c%80%e5%a4%a7%e7%ba%bf%e7%a8%8b%e6%95%b0max-threads>#</a></h3><p>线程是进程内的一个执行单元。一个进程可以拥有多个线程，这些线程共享进程的内存空间和资源。在 Linux 系统中，线程数通常与进程数一起受到限制。</p><h4 id=查看最大线程数>查看最大线程数：
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e6%9c%80%e5%a4%a7%e7%ba%bf%e7%a8%8b%e6%95%b0>#</a></h4><ul><li><p>系统级别限制</p><p>：在 Linux 系统中，线程数的最大限制与进程数相同，因为每个线程也会被当作进程来管理。使用</p><pre tabindex=0><code>ulimit -a
</code></pre><p>命令查看当前的线程数限制：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ulimit -a
</span></span></code></pre></div><p>其中</p><pre tabindex=0><code>max user processes
</code></pre><p>就是当前用户可创建的最大线程数。</p></li></ul><h4 id=调整最大线程数>调整最大线程数：
<a class=anchor href=#%e8%b0%83%e6%95%b4%e6%9c%80%e5%a4%a7%e7%ba%bf%e7%a8%8b%e6%95%b0>#</a></h4><ul><li><p><strong>用户级别调整</strong>：同样通过修改 <code>/etc/security/limits.conf</code> 文件来调整线程数的限制。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>username soft nproc <span style=color:#ae81ff>4096</span>
</span></span><span style=display:flex><span>username hard nproc <span style=color:#ae81ff>8192</span>
</span></span></code></pre></div></li><li><p><strong>系统级别调整</strong>：如果需要允许系统创建更多的线程，可以增加 <code>kernel.pid_max</code> 参数的值，因为系统会为每个线程分配一个进程号（PID）。请参考前面的 &ldquo;进程最大数&rdquo; 部分来调整。</p></li></ul><h3 id=3-进程打开的文件数open-files>3. <strong>进程打开的文件数（open files）</strong>
<a class=anchor href=#3-%e8%bf%9b%e7%a8%8b%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6%e6%95%b0open-files>#</a></h3><p>每个进程在运行时会打开多个文件，包括普通文件、套接字、管道等。操作系统为每个进程设置了一个 <strong>最大打开文件数</strong> 限制，防止某个进程占用过多的文件描述符资源。</p><h4 id=查看进程最大文件数>查看进程最大文件数：
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e6%9c%80%e5%a4%a7%e6%96%87%e4%bb%b6%e6%95%b0>#</a></h4><ul><li><p><strong>当前进程的最大文件数限制</strong>： 使用 <code>ulimit -n</code> 命令查看当前用户可以打开的最大文件数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ulimit -n
</span></span></code></pre></div></li><li><p><strong>系统级别限制</strong>： 系统有一个全局的最大打开文件数，可以通过查看 <code>/proc/sys/fs/file-max</code> 来查询：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /proc/sys/fs/file-max
</span></span></code></pre></div></li></ul><h4 id=调整进程打开的文件数>调整进程打开的文件数：
<a class=anchor href=#%e8%b0%83%e6%95%b4%e8%bf%9b%e7%a8%8b%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6%e6%95%b0>#</a></h4><ul><li><p><strong>临时调整</strong>：使用 <code>ulimit</code> 命令临时增加最大文件数。例如，将最大文件数设置为 65535：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ulimit -n <span style=color:#ae81ff>65535</span>
</span></span></code></pre></div></li><li><p><strong>永久调整</strong>：</p><ol><li><p>修改 <code>/etc/security/limits.conf</code> 文件，设置最大文件数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>username soft nofile <span style=color:#ae81ff>65535</span>
</span></span><span style=display:flex><span>username hard nofile <span style=color:#ae81ff>65535</span>
</span></span></code></pre></div><ul><li><code>soft</code> 是软限制，表示当前会话可以达到的最大文件数。</li><li><code>hard</code> 是硬限制，表示最大允许的文件数限制。</li></ul></li><li><p>修改 <code>/etc/sysctl.conf</code> 文件，设置系统全局的最大文件数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>fs.file-max <span style=color:#f92672>=</span> <span style=color:#ae81ff>2097152</span>
</span></span></code></pre></div><p>然后使其生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo sysctl -p
</span></span></code></pre></div></li><li><p>修改 <code>/etc/pam.d/common-session</code> 文件，确保 <code>pam_limits.so</code> 被启用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>session required pam_limits.so
</span></span></code></pre></div></li></ol></li></ul><h3 id=总结-18>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-18>#</a></h3><ul><li><strong>进程最大数</strong>：限制系统允许的进程总数，可以通过修改 <code>/proc/sys/kernel/pid_max</code> 来调整。用户级别的限制可以通过 <code>ulimit -u</code> 和 <code>/etc/security/limits.conf</code> 来调整。</li><li><strong>最大线程数</strong>：线程数受进程最大数的影响，因此也可以通过调整 <code>ulimit -u</code> 或 <code>/etc/security/limits.conf</code> 来管理。需要根据系统资源合理设置。</li><li><strong>进程打开的文件数</strong>：每个进程可以打开的文件数量是有限制的，可以通过 <code>ulimit -n</code> 和 <code>/etc/security/limits.conf</code> 来调整。系统级别的限制可以通过修改 <code>/proc/sys/fs/file-max</code> 来管理。</li></ul><p>合理调整这些限制能够确保系统在高并发、高负载下的稳定性和性能，避免资源耗尽或过度竞争。</p><h1 id=du和df统计不一致原因>du和df统计不一致原因☆
<a class=anchor href=#du%e5%92%8cdf%e7%bb%9f%e8%ae%a1%e4%b8%8d%e4%b8%80%e8%87%b4%e5%8e%9f%e5%9b%a0>#</a></h1><p><code>du</code>（Disk Usage）和 <code>df</code>（Disk Free）是常用的磁盘空间使用情况统计工具，二者的统计结果可能存在差异，主要原因如下：</p><h3 id=1-统计对象不同>1. <strong>统计对象不同</strong>
<a class=anchor href=#1-%e7%bb%9f%e8%ae%a1%e5%af%b9%e8%b1%a1%e4%b8%8d%e5%90%8c>#</a></h3><ul><li><p><strong><code>df</code></strong>：<code>df</code> 命令显示的是整个文件系统的磁盘使用情况。它基于文件系统的元数据（如文件系统的块大小）来统计磁盘的使用情况，显示的是文件系统的总容量、已用空间和可用空间。</p><p><code>df</code> 统计的是 <strong>文件系统层级的空间使用情况</strong>，并且它关注的是每个挂载点的总空间，包括系统预留空间（如 <code>root</code> 用户保留的空间）。</p></li><li><p><strong><code>du</code></strong>：<code>du</code> 命令显示的是 <strong>目录或文件的磁盘空间使用情况</strong>，它是通过遍历目录中的文件和子目录来计算空间的。<code>du</code> 统计的是文件和目录实际占用的磁盘空间，包括文件的实际内容，但不会计算文件系统级别的元数据（如目录的大小、inode 信息等）。</p></li></ul><h3 id=2-文件系统预留空间>2. <strong>文件系统预留空间</strong>
<a class=anchor href=#2-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e9%a2%84%e7%95%99%e7%a9%ba%e9%97%b4>#</a></h3><ul><li><strong><code>df</code> 命令</strong> 会考虑文件系统的预留空间（reserved blocks），通常是 <strong>root 用户</strong> 用于防止文件系统完全填满，保持系统的稳定性。例如，Ext4 文件系统默认会保留 5% 的磁盘空间供 root 用户使用。<code>df</code> 会显示文件系统总容量、已用空间和可用空间，其中的可用空间是考虑了预留空间之后的剩余空间。</li><li><strong><code>du</code> 命令</strong> 计算的是实际占用的空间，不会考虑文件系统的保留空间。因此，<code>du</code> 显示的磁盘使用情况可能会比 <code>df</code> 显示的实际占用空间稍低，因为它不包括文件系统中为 root 保留的空间。</li></ul><h3 id=3-软链接和挂载点>3. <strong>软链接和挂载点</strong>
<a class=anchor href=#3-%e8%bd%af%e9%93%be%e6%8e%a5%e5%92%8c%e6%8c%82%e8%bd%bd%e7%82%b9>#</a></h3><ul><li><strong><code>du</code></strong> 会统计 <strong>软链接</strong>（symbolic links）指向的目标文件和目录的实际使用情况。它默认会将软链接指向的目标文件计入空间占用。这可能会导致 <code>du</code> 显示的空间比 <code>df</code> 更大，因为软链接会被重复计算。</li><li><strong><code>df</code></strong> 只计算挂载点的空间，不会考虑挂载点内的其他文件系统。如果你有多个文件系统或挂载点（如挂载了 <code>/home</code>、<code>/data</code> 等），<code>df</code> 会分别显示它们的空间占用，而 <code>du</code> 只会显示当前目录下的空间使用情况，不会考虑其他挂载点。</li></ul><h3 id=4-文件系统缓存>4. <strong>文件系统缓存</strong>
<a class=anchor href=#4-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%bc%93%e5%ad%98>#</a></h3><ul><li><strong><code>df</code></strong> 统计的是磁盘的实际使用情况，不会受到文件系统缓存的影响。即使文件刚刚被删除，但其空间尚未被回收，<code>df</code> 可能会显示该文件仍占用空间。</li><li><strong><code>du</code></strong> 只会统计已实际写入磁盘的数据，不会考虑缓存中的数据。如果有大量的数据被删除但文件系统没有立即回收空间，<code>du</code> 可能会显示文件占用的空间较少，而 <code>df</code> 显示的可用空间较少。</li></ul><h3 id=5-挂载点重复>5. <strong>挂载点重复</strong>
<a class=anchor href=#5-%e6%8c%82%e8%bd%bd%e7%82%b9%e9%87%8d%e5%a4%8d>#</a></h3><p>如果文件系统有多个挂载点，例如 <code>/dev</code>, <code>/proc</code>, <code>/sys</code> 等虚拟文件系统，这些文件系统通常并不占用实际磁盘空间。<code>du</code> 会忽略这些挂载点，而 <code>df</code> 可能会显示这些挂载点所占用的空间。</p><h3 id=6-延迟同步文件删除>6. <strong>延迟同步（文件删除）</strong>
<a class=anchor href=#6-%e5%bb%b6%e8%bf%9f%e5%90%8c%e6%ad%a5%e6%96%87%e4%bb%b6%e5%88%a0%e9%99%a4>#</a></h3><p>当你删除文件时，<code>df</code> 显示的空间释放情况是基于文件系统的实际状态，但文件内容可能仍然保留在缓存中，直到真正写入磁盘（例如，缓存被刷新）。因此，<code>du</code> 可能会显示某些文件仍然存在，直到缓存清理，才会在 <code>df</code> 上反映出更准确的空闲空间。</p><h3 id=7-du>7. <strong><code>du</code> 计算的单位和 <code>df</code> 的单位不同</strong>
<a class=anchor href=#7-du>#</a></h3><p>有时候，<code>du</code> 和 <code>df</code> 的输出单位可能不同，导致看起来的空间占用差异。例如，<code>df</code> 默认显示的是 <strong>块（block）单位</strong>，而 <code>du</code> 默认显示的是 <strong>字节（byte）</strong> 或 <strong>千字节（KB）</strong>。如果不统一单位，可能会觉得统计不一致。</p><h3 id=8-nfs-或网络文件系统>8. <strong>NFS 或网络文件系统</strong>
<a class=anchor href=#8-nfs-%e6%88%96%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h3><p>如果系统中有挂载了 <strong>NFS</strong> 或其他网络文件系统，<code>du</code> 和 <code>df</code> 也可能会出现差异，特别是在高延迟或不稳定的网络环境下。<code>df</code> 可能会显示一个较为准确的空间统计，而 <code>du</code> 在网络文件系统中可能由于延迟或未更新的文件系统缓存，导致显示的空间使用不一致。</p><h3 id=9-磁盘碎片>9. <strong>磁盘碎片</strong>
<a class=anchor href=#9-%e7%a3%81%e7%9b%98%e7%a2%8e%e7%89%87>#</a></h3><p>虽然现代文件系统通常能较好地处理碎片问题，但磁盘碎片还是可能会影响 <code>df</code> 和 <code>du</code> 的统计差异。<code>df</code> 显示的是逻辑块的使用情况，而 <code>du</code> 显示的是文件实际占用的空间。如果文件系统存在碎片，实际磁盘占用空间和文件的逻辑占用空间可能不一致。</p><h3 id=解决办法>解决办法：
<a class=anchor href=#%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95>#</a></h3><ul><li>确保使用相同的单位进行比较，例如，使用 <code>df -h</code> 和 <code>du -h</code> 显示为可读的格式（MB、GB）。</li><li>检查文件系统是否有保留空间（通过 <code>df</code> 命令查看）。</li><li>检查文件系统挂载点、软链接以及挂载点是否被重复计算。</li><li>使用 <code>lsof</code> 检查文件是否已被删除但仍由进程占用。</li></ul><h3 id=总结-19>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-19>#</a></h3><p><code>du</code> 和 <code>df</code> 显示的磁盘使用情况不一致，通常是因为它们统计的方式不同、关注的对象不同，以及文件系统的特性（如缓存、预留空间、软链接等）。通过理解这些差异，可以更好地理解和利用这两个命令。</p><h1 id=buffers与cached的区别>buffers与cached的区别☆
<a class=anchor href=#buffers%e4%b8%8ecached%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h1><p>在 Linux 系统中，<code>buffers</code> 和 <code>cached</code> 都与内存的使用相关，它们表示不同类型的缓存，它们的作用和统计方式有所区别。理解这两者的区别有助于更好地理解系统内存的使用情况。</p><h3 id=1-buffers>1. <strong><code>buffers</code></strong>
<a class=anchor href=#1-buffers>#</a></h3><ul><li><strong><code>buffers</code></strong> 是指 <strong>块设备缓存</strong>，即为磁盘（硬盘、SSD、USB 等）块设备上的数据分配的内存。它主要用于缓存 <strong>原始块设备的数据</strong>，例如用于存放磁盘块的元数据（如文件系统的结构、磁盘块的索引等）。</li><li><strong>作用</strong>：<ul><li><code>buffers</code> 主要用于优化磁盘 I/O 性能，尤其是文件系统和磁盘之间的数据传输。</li><li>它帮助减少对磁盘的直接访问，避免频繁的磁盘操作，从而提高文件系统的访问速度。</li></ul></li><li><strong>举例</strong>：<ul><li>当你访问文件时，文件系统需要读取文件的磁盘块，如果这些块已经存在于 <code>buffers</code> 中，系统就可以直接从内存中获取，而不需要重新从磁盘读取。</li></ul></li></ul><h3 id=2-cached>2. <strong><code>cached</code></strong>
<a class=anchor href=#2-cached>#</a></h3><ul><li><strong><code>cached</code></strong> 是指 <strong>页面缓存</strong>，即文件内容缓存。<code>cached</code> 主要用于存储 <strong>文件内容</strong>，即文件系统中实际存储的文件数据。当系统读取文件内容时，操作系统会将这些数据存储在内存中，供后续访问使用，从而提高文件读取的性能。</li><li><strong>作用</strong>：<ul><li><code>cached</code> 主要缓存的是文件数据的内容，而不仅仅是文件系统元数据（如目录结构）。</li><li>它有助于加速后续对文件的读取操作。例如，当你多次读取同一个文件时，如果文件数据已经被缓存，那么系统可以直接从内存中读取，而不需要再次访问磁盘。</li></ul></li><li><strong>举例</strong>：<ul><li>如果你打开一个文件，系统会将该文件的数据存储到 <code>cached</code> 中，下次访问该文件时，系统可以直接从内存中读取，而不需要重新访问磁盘。</li></ul></li></ul><h3 id=3-buffers>3. <strong><code>buffers</code> 与 <code>cached</code> 的区别</strong>
<a class=anchor href=#3-buffers>#</a></h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th><th><strong>缓存对象</strong></th><th><strong>内存区域</strong></th></tr></thead><tbody><tr><td><strong>buffers</strong></td><td>块设备缓存</td><td>文件系统的元数据（如索引、目录结构）</td><td>磁盘块级别的数据缓存</td></tr><tr><td><strong>cached</strong></td><td>页面缓存</td><td>文件数据（文件的内容）</td><td>文件内容的内存缓存</td></tr></tbody></table><h3 id=4-总结>4. <strong>总结</strong>
<a class=anchor href=#4-%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong><code>buffers</code></strong>：缓存的是磁盘的 <strong>元数据</strong>（如文件系统结构），优化文件系统的读写性能。</li><li><strong><code>cached</code></strong>：缓存的是 <strong>文件内容</strong>（即文件的实际数据），加速对文件内容的重复读取。</li></ul><h3 id=5-实际影响>5. <strong>实际影响</strong>
<a class=anchor href=#5-%e5%ae%9e%e9%99%85%e5%bd%b1%e5%93%8d>#</a></h3><ul><li>在 <code>free</code> 命令或 <code>top</code> 命令的输出中，<code>buffers</code> 和 <code>cached</code> 都算作 <strong>“使用中的内存”</strong>，但它们并不会占用实际的磁盘空间，而是优化系统性能的一部分。</li><li><strong><code>cached</code></strong> 的内存通常是最易释放的，当系统需要更多内存时，操作系统可以将 <code>cached</code> 中的数据释放并清空，重新分配内存给其他进程。</li><li><strong><code>buffers</code></strong> 通常占用的内存也可以被释放，但它更多的是处理块设备层级的数据传输，涉及更底层的文件系统结构。</li></ul><h3 id=6-释放缓存>6. <strong>释放缓存</strong>
<a class=anchor href=#6-%e9%87%8a%e6%94%be%e7%bc%93%e5%ad%98>#</a></h3><p>如果系统内存非常紧张，你可以通过以下命令来释放缓存：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 清空 pagecache</span>
</span></span><span style=display:flex><span>sudo sync; sudo echo <span style=color:#ae81ff>1</span> &gt; /proc/sys/vm/drop_caches
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 清空 dentries 和 inodes 缓存</span>
</span></span><span style=display:flex><span>sudo echo <span style=color:#ae81ff>2</span> &gt; /proc/sys/vm/drop_caches
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 清空 pagecache, dentries 和 inodes 缓存</span>
</span></span><span style=display:flex><span>sudo echo <span style=color:#ae81ff>3</span> &gt; /proc/sys/vm/drop_caches
</span></span></code></pre></div><p>这些命令会释放缓存的内存，但会导致性能下降，因为系统将需要重新读取缓存中的数据。</p><h1 id=lsof命令使用场景>lsof命令使用场景
<a class=anchor href=#lsof%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h1><p><code>lsof</code>（List Open Files）是一个非常强大的工具，用于列出当前系统中所有打开的文件和正在使用它们的进程。由于 Linux 中的设备、文件、目录、网络连接等都被当作文件处理，<code>lsof</code> 可以用于排查多种问题。以下是 <code>lsof</code> 常见的使用场景：</p><h3 id=1-查看某个进程打开的文件>1. <strong>查看某个进程打开的文件</strong>
<a class=anchor href=#1-%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%aa%e8%bf%9b%e7%a8%8b%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6>#</a></h3><p>如果你想查看某个进程打开了哪些文件，可以使用 <code>lsof</code> 配合进程ID（PID）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -p &lt;pid&gt;
</span></span></code></pre></div><h4 id=使用场景-9>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-9>#</a></h4><ul><li>排查某个进程是否打开了特定的文件。</li><li>查看进程是否存在文件句柄泄漏的现象。</li></ul><h3 id=2-查看某个用户打开的文件>2. <strong>查看某个用户打开的文件</strong>
<a class=anchor href=#2-%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%aa%e7%94%a8%e6%88%b7%e6%89%93%e5%bc%80%e7%9a%84%e6%96%87%e4%bb%b6>#</a></h3><p>可以使用 <code>lsof</code> 查看某个用户打开的所有文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -u &lt;username&gt;
</span></span></code></pre></div><h4 id=使用场景-10>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-10>#</a></h4><ul><li>监控某个用户的文件使用情况。</li><li>在需要查找某个用户正在访问的文件时，尤其是多用户系统中，帮助管理员跟踪活动。</li></ul><h3 id=3-查看特定文件的打开情况>3. <strong>查看特定文件的打开情况</strong>
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e7%89%b9%e5%ae%9a%e6%96%87%e4%bb%b6%e7%9a%84%e6%89%93%e5%bc%80%e6%83%85%e5%86%b5>#</a></h3><p>如果你想查看某个文件是否正在被进程占用，可以直接使用文件名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof &lt;file_path&gt;
</span></span></code></pre></div><h4 id=使用场景-11>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-11>#</a></h4><ul><li>查找某个文件是否被其他进程占用，尤其在需要删除或修改文件时。例如，在删除日志文件之前，可能需要检查文件是否仍然被进程打开。</li><li>查找某个特定文件是否被锁定，是否有其他进程在访问它。</li></ul><h3 id=4-查看某个端口被哪个进程占用>4. <strong>查看某个端口被哪个进程占用</strong>
<a class=anchor href=#4-%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%aa%e7%ab%af%e5%8f%a3%e8%a2%ab%e5%93%aa%e4%b8%aa%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8>#</a></h3><p><code>lsof</code> 也可以列出当前系统中所有的网络连接，并显示是哪个进程在监听特定端口。你可以使用 <code>-i</code> 参数指定特定端口或协议。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -i :&lt;port_number&gt;
</span></span></code></pre></div><p>例如，查看哪个进程占用了 80 端口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -i :80
</span></span></code></pre></div><p>或者查看所有 TCP 连接：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -i tcp
</span></span></code></pre></div><h4 id=使用场景-12>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-12>#</a></h4><ul><li>追踪网络端口的使用情况。</li><li>查找哪个进程占用了系统的某个端口，尤其在端口冲突的情况下非常有用。</li><li>检查服务是否正常监听对应的端口。</li></ul><h3 id=5-查看文件系统的某个挂载点>5. <strong>查看文件系统的某个挂载点</strong>
<a class=anchor href=#5-%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%9f%90%e4%b8%aa%e6%8c%82%e8%bd%bd%e7%82%b9>#</a></h3><p><code>lsof</code> 可以查看系统中某个挂载点的所有打开文件。例如，查看 <code>/mnt/data</code> 目录下的所有打开文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof +D /mnt/data
</span></span></code></pre></div><h4 id=使用场景-13>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-13>#</a></h4><ul><li>检查特定挂载点上的文件是否有进程正在访问，尤其在磁盘挂载、卸载前需要确保没有进程正在使用该目录。</li><li>调查文件系统挂载点的访问情况，避免数据丢失。</li></ul><h3 id=6-查找删除的文件>6. <strong>查找删除的文件</strong>
<a class=anchor href=#6-%e6%9f%a5%e6%89%be%e5%88%a0%e9%99%a4%e7%9a%84%e6%96%87%e4%bb%b6>#</a></h3><p>在 Linux 系统中，如果文件被删除，但进程仍然打开着它，<code>lsof</code> 可以列出这些文件，即使文件已经从文件系统中删除，它仍然存在于进程的文件描述符中，直到进程关闭该文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof | grep deleted
</span></span></code></pre></div><h4 id=使用场景-14>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-14>#</a></h4><ul><li>调查删除文件后仍然占用磁盘空间的情况。某些进程可能持有已删除文件的文件描述符，导致磁盘空间无法释放。</li><li>检查进程是否仍然占用被删除的日志文件，防止磁盘空间被大量占用。</li></ul><h3 id=7-查看文件锁>7. <strong>查看文件锁</strong>
<a class=anchor href=#7-%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e9%94%81>#</a></h3><p><code>lsof</code> 可以显示由进程持有的文件锁。如果你怀疑某个文件或资源被锁定，可以通过以下命令查看：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -i | grep LOCK
</span></span></code></pre></div><h4 id=使用场景-15>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-15>#</a></h4><ul><li>排查文件锁定问题，特别是在需要访问文件但遇到“文件已被锁定”错误时。</li><li>监控进程对文件的锁定操作，避免死锁或锁竞争问题。</li></ul><h3 id=8-查看打开的网络文件tcpudp>8. <strong>查看打开的网络文件（TCP/UDP）</strong>
<a class=anchor href=#8-%e6%9f%a5%e7%9c%8b%e6%89%93%e5%bc%80%e7%9a%84%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6tcpudp>#</a></h3><p><code>lsof</code> 可以列出当前系统中所有活动的网络连接，包括 TCP 和 UDP 连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -i
</span></span></code></pre></div><h4 id=使用场景-16>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-16>#</a></h4><ul><li>诊断网络问题，查看哪些进程正在通过网络进行通信。</li><li>检查系统的开放网络端口和连接状态。</li><li>追踪进程是否在访问外部资源。</li></ul><h3 id=9-查找进程占用的文件描述符>9. <strong>查找进程占用的文件描述符</strong>
<a class=anchor href=#9-%e6%9f%a5%e6%89%be%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8%e7%9a%84%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6>#</a></h3><p>每个进程都有一个文件描述符的限制，使用 <code>lsof</code> 可以查看进程打开了多少个文件描述符：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof -p &lt;pid&gt; | wc -l
</span></span></code></pre></div><h4 id=使用场景-17>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-17>#</a></h4><ul><li>诊断文件描述符耗尽问题。Linux 系统中每个进程都有打开文件数的限制，如果达到最大文件描述符数限制，进程可能无法打开新的文件或套接字。</li><li>排查进程是否存在文件描述符泄漏。</li></ul><h3 id=10-监控进程创建的临时文件>10. <strong>监控进程创建的临时文件</strong>
<a class=anchor href=#10-%e7%9b%91%e6%8e%a7%e8%bf%9b%e7%a8%8b%e5%88%9b%e5%bb%ba%e7%9a%84%e4%b8%b4%e6%97%b6%e6%96%87%e4%bb%b6>#</a></h3><p><code>lsof</code> 可以帮助监控进程创建的临时文件，尤其在高并发系统中，进程可能会大量创建临时文件，但没有及时关闭，导致磁盘空间被占满。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsof +L1
</span></span></code></pre></div><h4 id=使用场景-18>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-18>#</a></h4><ul><li>检查进程是否创建了大量临时文件，并没有及时清理，导致磁盘空间被占满。</li></ul><hr><h3 id=总结-20>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-20>#</a></h3><p><code>lsof</code> 是一个非常强大的工具，能够提供系统中文件和进程的详细信息，常见的使用场景包括：</p><ul><li>查找文件是否被占用。</li><li>排查文件锁、端口占用等问题。</li><li>调查被删除但未释放的文件。</li><li>监控进程的资源使用情况。</li></ul><p>在系统运维、故障排查和性能优化过程中，<code>lsof</code> 是一个非常实用的工具，能帮助管理员了解系统文件和网络连接的详细使用情况。</p><h1 id=linux中的进程间通信的方式及其使用场景>Linux中的进程间通信的方式及其使用场景
<a class=anchor href=#linux%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1%e7%9a%84%e6%96%b9%e5%bc%8f%e5%8f%8a%e5%85%b6%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h1><p>在 Linux 中，进程间通信（IPC，Inter-Process Communication）是指在不同的进程之间传递信息或同步操作的机制。进程间通信非常重要，尤其是在多进程并发执行的环境下，确保数据的传递与协调。Linux 提供了多种进程间通信方式，每种方式适用于不同的场景。</p><h3 id=常见的-linux-进程间通信方式>常见的 Linux 进程间通信方式
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84-linux-%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1%e6%96%b9%e5%bc%8f>#</a></h3><ol><li><strong>管道（Pipe）</strong></li><li><strong>命名管道（Named Pipe 或 FIFO）</strong></li><li><strong>消息队列（Message Queue）</strong></li><li><strong>信号（Signal）</strong></li><li><strong>共享内存（Shared Memory）</strong></li><li><strong>信号量（Semaphore）</strong></li><li><strong>套接字（Socket）</strong></li><li><strong>内存映射（Memory Mapping）</strong></li></ol><h3 id=1-管道pipe>1. <strong>管道（Pipe）</strong>
<a class=anchor href=#1-%e7%ae%a1%e9%81%93pipe>#</a></h3><p>管道是最基本的进程间通信方式之一，它允许一个进程将数据写入管道，另一个进程从管道中读取数据。管道通常是匿名的，且只能在父子进程或兄弟进程之间使用。</p><h4 id=使用场景-19>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-19>#</a></h4><ul><li>父进程和子进程之间的数据传输。</li><li>命令行工具之间的组合使用（例如，<code>ls | grep</code>）。</li></ul><h4 id=优点-6>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-6>#</a></h4><ul><li>实现简单，通信速度较快。</li></ul><h4 id=缺点-6>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-6>#</a></h4><ul><li>只能用于同一机器上的进程间通信。</li><li>不能在无关进程间通信。</li></ul><h3 id=2-命名管道fifo>2. <strong>命名管道（FIFO）</strong>
<a class=anchor href=#2-%e5%91%bd%e5%90%8d%e7%ae%a1%e9%81%93fifo>#</a></h3><p>命名管道是管道的一种改进形式，允许具有不同 PID 的进程通过一个指定的文件来进行通信。不同于匿名管道，命名管道在文件系统中有一个名字，进程可以通过这个名字访问管道。</p><h4 id=使用场景-20>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-20>#</a></h4><ul><li>不同的进程之间，通过文件系统进行通信。</li><li>需要多个进程共享数据时使用。</li></ul><h4 id=优点-7>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-7>#</a></h4><ul><li>可以在无父子关系的进程之间通信。</li></ul><h4 id=缺点-7>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-7>#</a></h4><ul><li>需要显式创建和管理文件，存在一定的复杂性。</li></ul><h3 id=3-消息队列message-queue>3. <strong>消息队列（Message Queue）</strong>
<a class=anchor href=#3-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97message-queue>#</a></h3><p>消息队列是一种先进先出（FIFO）的消息传递机制，允许进程以消息的形式交换数据。消息队列中的消息有一个优先级，可以支持不同进程间异步通信。</p><h4 id=使用场景-21>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-21>#</a></h4><ul><li>多个进程之间的异步通信，尤其是需要保证消息顺序的场合。</li><li>任务调度、事件通知系统等。</li></ul><h4 id=优点-8>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-8>#</a></h4><ul><li>提供了进程间的异步通信机制。</li><li>支持消息优先级，消息传递不会丢失。</li></ul><h4 id=缺点-8>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-8>#</a></h4><ul><li>较复杂，管理和维护消息队列需要额外的开销。</li></ul><h3 id=4-信号signal>4. <strong>信号（Signal）</strong>
<a class=anchor href=#4-%e4%bf%a1%e5%8f%b7signal>#</a></h3><p>信号是一种通知进程发生事件的机制，进程通过发送信号来通知另一个进程。信号通常用于处理异步事件或进程控制（如中断、终止等）。</p><h4 id=使用场景-22>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-22>#</a></h4><ul><li>进程之间的状态变化通知，例如 <code>SIGTERM</code> 用于优雅终止进程，<code>SIGINT</code> 用于中断进程。</li><li>异常事件的处理，比如处理定时器到期的信号。</li></ul><h4 id=优点-9>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-9>#</a></h4><ul><li>实现简单，常用于进程控制。</li></ul><h4 id=缺点-9>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-9>#</a></h4><ul><li>不能传输大量数据，只适合用于通知事件。</li><li>信号的处理非常依赖操作系统。</li></ul><h3 id=5-共享内存shared-memory>5. <strong>共享内存（Shared Memory）</strong>
<a class=anchor href=#5-%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98shared-memory>#</a></h3><p>共享内存是一种高效的进程间通信方式，多个进程可以访问同一块内存区域，从而共享数据。共享内存的大小可以很大，因此适合传输大量数据。</p><h4 id=使用场景-23>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-23>#</a></h4><ul><li>大量数据的高速传输。</li><li>多个进程之间的协作操作，例如数据库缓存、图形处理等。</li></ul><h4 id=优点-10>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-10>#</a></h4><ul><li>性能高，数据传输速度快。</li><li>可以共享大量数据。</li></ul><h4 id=缺点-10>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-10>#</a></h4><ul><li>需要进程之间协调访问（如使用信号量来进行同步）。</li><li>需要更复杂的内存管理。</li></ul><h3 id=6-信号量semaphore>6. <strong>信号量（Semaphore）</strong>
<a class=anchor href=#6-%e4%bf%a1%e5%8f%b7%e9%87%8fsemaphore>#</a></h3><p>信号量是一种用于控制对共享资源的访问的机制。信号量通常与共享内存一起使用，用于同步进程的执行，防止多个进程同时访问共享资源。</p><h4 id=使用场景-24>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-24>#</a></h4><ul><li>需要对共享资源进行互斥访问时使用，例如避免多个进程同时写入共享文件。</li><li>实现生产者-消费者模型等。</li></ul><h4 id=优点-11>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-11>#</a></h4><ul><li>用于进程同步和互斥，能有效避免竞态条件。</li></ul><h4 id=缺点-11>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-11>#</a></h4><ul><li>需要额外的同步机制，管理上较为复杂。</li></ul><h3 id=7-套接字socket>7. <strong>套接字（Socket）</strong>
<a class=anchor href=#7-%e5%a5%97%e6%8e%a5%e5%ad%97socket>#</a></h3><p>套接字提供了一种跨进程、跨主机的通信机制，广泛用于网络通信。套接字可以在同一台机器上的进程之间，也可以在不同机器之间进行通信。</p><h4 id=使用场景-25>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-25>#</a></h4><ul><li>网络通信：客户端与服务器之间的数据传输。</li><li>分布式系统、微服务之间的通信。</li></ul><h4 id=优点-12>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-12>#</a></h4><ul><li>支持跨主机、跨网络的通信。</li><li>支持面向连接（TCP）和无连接（UDP）的通信方式。</li></ul><h4 id=缺点-12>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-12>#</a></h4><ul><li>需要复杂的协议栈支持，可能导致一定的性能开销。</li></ul><h3 id=8-内存映射memory-mapping>8. <strong>内存映射（Memory Mapping）</strong>
<a class=anchor href=#8-%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84memory-mapping>#</a></h3><p>内存映射是一种通过将文件或设备的内容映射到进程的虚拟内存空间中的方式，使得进程能够直接操作内存中的数据，通常通过 <code>mmap</code> 系统调用实现。</p><h4 id=使用场景-26>使用场景：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-26>#</a></h4><ul><li>共享数据、文件的映射访问。</li><li>需要快速访问大文件或多个进程共享的数据时。</li></ul><h4 id=优点-13>优点：
<a class=anchor href=#%e4%bc%98%e7%82%b9-13>#</a></h4><ul><li>高效，支持大规模数据共享。</li><li>减少了文件 I/O 操作的开销。</li></ul><h4 id=缺点-13>缺点：
<a class=anchor href=#%e7%bc%ba%e7%82%b9-13>#</a></h4><ul><li>对内存管理有较高要求，可能导致内存泄漏。</li><li>映射文件的修改需要同步处理。</li></ul><hr><h3 id=总结-21>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-21>#</a></h3><table><thead><tr><th><strong>通信方式</strong></th><th><strong>适用场景</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>管道（Pipe）</strong></td><td>父子进程间的数据传输，命令行工具组合使用</td><td>简单、快速，但仅限父子进程和临时通信</td></tr><tr><td><strong>命名管道（FIFO）</strong></td><td>不同进程之间的数据传输</td><td>支持无亲缘关系进程通信，但需要显式创建和管理文件</td></tr><tr><td><strong>消息队列（Message Queue）</strong></td><td>多进程间的异步通信，需要传递带优先级的消息</td><td>支持优先级，消息不丢失，但管理较复杂</td></tr><tr><td><strong>信号（Signal）</strong></td><td>异步通知进程事件，如进程控制、异常事件</td><td>仅限通知，不适合大数据传输，处理依赖操作系统</td></tr><tr><td><strong>共享内存（Shared Memory）</strong></td><td>大量数据高速传输，进程间协作操作（如数据库缓存）</td><td>性能高，但需要同步机制，复杂的内存管理</td></tr><tr><td><strong>信号量（Semaphore）</strong></td><td>共享资源的同步与互斥访问，避免竞态条件</td><td>用于同步和互斥，管理复杂</td></tr><tr><td><strong>套接字（Socket）</strong></td><td>网络通信，跨进程、跨主机的数据传输</td><td>支持远程通信，但需要复杂的协议栈支持</td></tr><tr><td><strong>内存映射（Memory Mapping）</strong></td><td>大文件的高效访问，进程间共享数据</td><td>高效，减少 I/O 操作，但需要额外的内存管理</td></tr></tbody></table><p>不同的进程间通信方式有不同的优势和适用场景，开发人员应根据实际需求选择合适的方式。</p><h1 id=linux中的进程优先级与设置方法>Linux中的进程优先级与设置方法
<a class=anchor href=#linux%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7%e4%b8%8e%e8%ae%be%e7%bd%ae%e6%96%b9%e6%b3%95>#</a></h1><p>在 Linux 中，进程的优先级决定了操作系统调度进程的顺序和分配 CPU 时间的方式。理解进程优先级的设置方法对于优化系统性能和调度效率至关重要。Linux 中有多种方式来设置和调整进程的优先级。</p><h3 id=1-进程优先级的概念>1. <strong>进程优先级的概念</strong>
<a class=anchor href=#1-%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7%e7%9a%84%e6%a6%82%e5%bf%b5>#</a></h3><p>Linux 中的进程优先级由两个值来表示：</p><ul><li><strong>静态优先级（Static Priority）</strong>：也叫 &ldquo;nice&rdquo; 值，表示进程的调度优先级，范围是 <code>-20</code> 到 <code>19</code>，其中 <code>-20</code> 表示最高优先级，<code>19</code> 表示最低优先级。默认情况下，进程的 <code>nice</code> 值为 0。</li><li><strong>动态优先级（Dynamic Priority）</strong>：操作系统调度器使用的实际优先级，决定了哪个进程将获得 CPU 资源。动态优先级不仅依赖于静态优先级，还会受到进程的 CPU 时间消耗、调度策略等因素的影响。</li></ul><h3 id=2-优先级与>2. <strong>优先级与 <code>nice</code> 值</strong>
<a class=anchor href=#2-%e4%bc%98%e5%85%88%e7%ba%a7%e4%b8%8e>#</a></h3><p>Linux 中的 <code>nice</code> 值影响进程的优先级。<strong>更高的 <code>nice</code> 值意味着更低的优先级</strong>，反之，<strong>更低的 <code>nice</code> 值（甚至是负值）表示更高的优先级</strong>。</p><h4 id=nice-值的范围><code>nice</code> 值的范围：
<a class=anchor href=#nice-%e5%80%bc%e7%9a%84%e8%8c%83%e5%9b%b4>#</a></h4><ul><li><code>nice</code> 值的范围是 <code>-20</code> 到 <code>19</code>，其中 <code>-20</code> 为最高优先级，<code>19</code> 为最低优先级。</li><li>默认情况下，进程的 <code>nice</code> 值为 0。</li></ul><h3 id=3-查看进程的优先级>3. <strong>查看进程的优先级</strong>
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7>#</a></h3><p>使用 <code>ps</code> 命令可以查看进程的 <code>nice</code> 值及其优先级（PID 和静态优先级）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps -eo pid,pri,ni,comm
</span></span></code></pre></div><ul><li><code>pid</code>：进程 ID</li><li><code>pri</code>：动态优先级</li><li><code>ni</code>：nice 值</li><li><code>comm</code>：进程名</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps -eo pid,pri,ni,comm
</span></span></code></pre></div><p>输出可能类似：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  PID  PRI  NI  COMMAND
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1234</span>  <span style=color:#ae81ff>20</span>   <span style=color:#ae81ff>0</span>  myprocess
</span></span></code></pre></div><h3 id=4-修改进程的>4. <strong>修改进程的 <code>nice</code> 值</strong>
<a class=anchor href=#4-%e4%bf%ae%e6%94%b9%e8%bf%9b%e7%a8%8b%e7%9a%84>#</a></h3><p>使用 <code>nice</code> 或 <code>renice</code> 命令来修改进程的 <code>nice</code> 值，从而调整其优先级。</p><h4 id=1-使用-nice-启动新进程>(1) 使用 <code>nice</code> 启动新进程
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-nice-%e5%90%af%e5%8a%a8%e6%96%b0%e8%bf%9b%e7%a8%8b>#</a></h4><p>可以使用 <code>nice</code> 命令启动一个新进程，并设置其 <code>nice</code> 值。<code>nice</code> 命令的语法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nice -n &lt;nice_value&gt; &lt;command&gt;
</span></span></code></pre></div><p>例如，要启动一个进程并将其 <code>nice</code> 值设置为 <code>10</code>（较低的优先级）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nice -n <span style=color:#ae81ff>10</span> myprocess
</span></span></code></pre></div><h4 id=2-使用-renice-调整已运行进程的-nice-值>(2) 使用 <code>renice</code> 调整已运行进程的 <code>nice</code> 值
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-renice-%e8%b0%83%e6%95%b4%e5%b7%b2%e8%bf%90%e8%a1%8c%e8%bf%9b%e7%a8%8b%e7%9a%84-nice-%e5%80%bc>#</a></h4><p><code>renice</code> 命令用于修改已经在运行中的进程的 <code>nice</code> 值。语法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>renice -n &lt;nice_value&gt; -p &lt;pid&gt;
</span></span></code></pre></div><p>例如，要将 PID 为 1234 的进程的 <code>nice</code> 值调整为 <code>-5</code>（提高优先级）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>renice -n -5 -p <span style=color:#ae81ff>1234</span>
</span></span></code></pre></div><p><strong>注意：</strong></p><ul><li>只有超级用户（root）可以将 <code>nice</code> 值设置为负数（即提高优先级）。</li><li>普通用户只能将 <code>nice</code> 值设置为正值（即降低优先级）。</li></ul><h3 id=5-进程调度策略与优先级>5. <strong>进程调度策略与优先级</strong>
<a class=anchor href=#5-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5%e4%b8%8e%e4%bc%98%e5%85%88%e7%ba%a7>#</a></h3><p>除了 <code>nice</code> 值，Linux 还使用不同的调度策略来管理进程调度，进程的实际优先级（动态优先级）会受到调度策略的影响。Linux 支持几种调度策略，常见的有：</p><h4 id=1-实时调度策略>(1) <strong>实时调度策略</strong>
<a class=anchor href=#1-%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5>#</a></h4><ul><li><strong>SCHED_FIFO</strong>：先进先出（First In First Out），是最简单的实时调度策略，进程按照它们的到达顺序执行。</li><li><strong>SCHED_RR</strong>：轮转调度（Round Robin），进程按时间片轮流执行，每个进程有固定的时间片。</li></ul><h4 id=2-普通调度策略>(2) <strong>普通调度策略</strong>
<a class=anchor href=#2-%e6%99%ae%e9%80%9a%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5>#</a></h4><ul><li><strong>SCHED_OTHER</strong>：常规调度策略，使用的是 Linux 默认的调度策略（CFS 调度器），一般用于非实时进程。</li></ul><h3 id=6-查看进程调度策略>6. <strong>查看进程调度策略</strong>
<a class=anchor href=#6-%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5>#</a></h3><p>可以使用 <code>chrt</code> 命令来查看和设置进程的调度策略及优先级。<code>chrt</code> 命令可以查看实时进程的调度策略和优先级，并允许设置。</p><h4 id=1-查看进程调度策略>(1) 查看进程调度策略
<a class=anchor href=#1-%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chrt -p &lt;pid&gt;
</span></span></code></pre></div><h4 id=2-设置进程的调度策略>(2) 设置进程的调度策略
<a class=anchor href=#2-%e8%ae%be%e7%bd%ae%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5>#</a></h4><p>可以使用 <code>chrt</code> 命令设置实时进程的调度策略和优先级：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chrt -f &lt;priority&gt; &lt;pid&gt;    <span style=color:#75715e># 设置为 FIFO 策略</span>
</span></span><span style=display:flex><span>chrt -r &lt;priority&gt; &lt;pid&gt;    <span style=color:#75715e># 设置为 RR 策略</span>
</span></span></code></pre></div><p>其中，<code>&lt;priority></code> 是优先级数值，通常在 1 到 99 之间（优先级越小越高）。实时调度策略的优先级是独立的，普通调度策略的优先级由 <code>nice</code> 值决定。</p><h3 id=7-优先级调整的使用场景>7. <strong>优先级调整的使用场景</strong>
<a class=anchor href=#7-%e4%bc%98%e5%85%88%e7%ba%a7%e8%b0%83%e6%95%b4%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><ul><li><strong>实时任务</strong>：如需要对某些任务（例如硬件控制、音频处理等）进行实时调度时，使用 <code>SCHED_FIFO</code> 或 <code>SCHED_RR</code> 策略和较高的优先级。</li><li><strong>后台进程</strong>：对于不需要占用大量 CPU 时间的后台任务，可以设置较高的 <code>nice</code> 值，降低它们的优先级，避免影响系统响应。</li><li><strong>计算密集型任务</strong>：对于高优先级的计算密集型任务，可以使用较低的 <code>nice</code> 值，确保它们获得更多的 CPU 时间。</li></ul><h3 id=8-总结>8. <strong>总结</strong>
<a class=anchor href=#8-%e6%80%bb%e7%bb%93>#</a></h3><p>在 Linux 系统中，进程的优先级由静态优先级（nice 值）和动态优先级（实际调度优先级）决定。我们可以通过以下方式调整进程优先级：</p><ul><li><strong>使用 <code>nice</code> 启动新进程</strong>。</li><li><strong>使用 <code>renice</code> 调整正在运行的进程的 <code>nice</code> 值</strong>。</li><li><strong>通过调度策略</strong>（如 <code>SCHED_FIFO</code>、<code>SCHED_RR</code>）来调整实时进程的优先级。</li></ul><p>通过合理设置进程的优先级，可以优化系统性能，确保重要任务得到足够的资源，同时避免不必要的资源竞争。</p><h1 id=什么是内存分页和分段>什么是内存分页和分段
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e5%88%86%e9%a1%b5%e5%92%8c%e5%88%86%e6%ae%b5>#</a></h1><p>在 Linux 中，进程的优先级决定了操作系统调度进程的顺序和分配 CPU 时间的方式。理解进程优先级的设置方法对于优化系统性能和调度效率至关重要。Linux 中有多种方式来设置和调整进程的优先级。</p><h3 id=1-进程优先级的概念-1>1. <strong>进程优先级的概念</strong>
<a class=anchor href=#1-%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7%e7%9a%84%e6%a6%82%e5%bf%b5-1>#</a></h3><p>Linux 中的进程优先级由两个值来表示：</p><ul><li><strong>静态优先级（Static Priority）</strong>：也叫 &ldquo;nice&rdquo; 值，表示进程的调度优先级，范围是 <code>-20</code> 到 <code>19</code>，其中 <code>-20</code> 表示最高优先级，<code>19</code> 表示最低优先级。默认情况下，进程的 <code>nice</code> 值为 0。</li><li><strong>动态优先级（Dynamic Priority）</strong>：操作系统调度器使用的实际优先级，决定了哪个进程将获得 CPU 资源。动态优先级不仅依赖于静态优先级，还会受到进程的 CPU 时间消耗、调度策略等因素的影响。</li></ul><h3 id=2-优先级与-1>2. <strong>优先级与 <code>nice</code> 值</strong>
<a class=anchor href=#2-%e4%bc%98%e5%85%88%e7%ba%a7%e4%b8%8e-1>#</a></h3><p>Linux 中的 <code>nice</code> 值影响进程的优先级。<strong>更高的 <code>nice</code> 值意味着更低的优先级</strong>，反之，<strong>更低的 <code>nice</code> 值（甚至是负值）表示更高的优先级</strong>。</p><h4 id=nice-值的范围-1><code>nice</code> 值的范围：
<a class=anchor href=#nice-%e5%80%bc%e7%9a%84%e8%8c%83%e5%9b%b4-1>#</a></h4><ul><li><code>nice</code> 值的范围是 <code>-20</code> 到 <code>19</code>，其中 <code>-20</code> 为最高优先级，<code>19</code> 为最低优先级。</li><li>默认情况下，进程的 <code>nice</code> 值为 0。</li></ul><h3 id=3-查看进程的优先级-1>3. <strong>查看进程的优先级</strong>
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7-1>#</a></h3><p>使用 <code>ps</code> 命令可以查看进程的 <code>nice</code> 值及其优先级（PID 和静态优先级）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps -eo pid,pri,ni,comm
</span></span></code></pre></div><ul><li><code>pid</code>：进程 ID</li><li><code>pri</code>：动态优先级</li><li><code>ni</code>：nice 值</li><li><code>comm</code>：进程名</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps -eo pid,pri,ni,comm
</span></span></code></pre></div><p>输出可能类似：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  PID  PRI  NI  COMMAND
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1234</span>  <span style=color:#ae81ff>20</span>   <span style=color:#ae81ff>0</span>  myprocess
</span></span></code></pre></div><h3 id=4-修改进程的-1>4. <strong>修改进程的 <code>nice</code> 值</strong>
<a class=anchor href=#4-%e4%bf%ae%e6%94%b9%e8%bf%9b%e7%a8%8b%e7%9a%84-1>#</a></h3><p>使用 <code>nice</code> 或 <code>renice</code> 命令来修改进程的 <code>nice</code> 值，从而调整其优先级。</p><h4 id=1-使用-nice-启动新进程-1>(1) 使用 <code>nice</code> 启动新进程
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-nice-%e5%90%af%e5%8a%a8%e6%96%b0%e8%bf%9b%e7%a8%8b-1>#</a></h4><p>可以使用 <code>nice</code> 命令启动一个新进程，并设置其 <code>nice</code> 值。<code>nice</code> 命令的语法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nice -n &lt;nice_value&gt; &lt;command&gt;
</span></span></code></pre></div><p>例如，要启动一个进程并将其 <code>nice</code> 值设置为 <code>10</code>（较低的优先级）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nice -n <span style=color:#ae81ff>10</span> myprocess
</span></span></code></pre></div><h4 id=2-使用-renice-调整已运行进程的-nice-值-1>(2) 使用 <code>renice</code> 调整已运行进程的 <code>nice</code> 值
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-renice-%e8%b0%83%e6%95%b4%e5%b7%b2%e8%bf%90%e8%a1%8c%e8%bf%9b%e7%a8%8b%e7%9a%84-nice-%e5%80%bc-1>#</a></h4><p><code>renice</code> 命令用于修改已经在运行中的进程的 <code>nice</code> 值。语法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>renice -n &lt;nice_value&gt; -p &lt;pid&gt;
</span></span></code></pre></div><p>例如，要将 PID 为 1234 的进程的 <code>nice</code> 值调整为 <code>-5</code>（提高优先级）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>renice -n -5 -p <span style=color:#ae81ff>1234</span>
</span></span></code></pre></div><p><strong>注意：</strong></p><ul><li>只有超级用户（root）可以将 <code>nice</code> 值设置为负数（即提高优先级）。</li><li>普通用户只能将 <code>nice</code> 值设置为正值（即降低优先级）。</li></ul><h3 id=5-进程调度策略与优先级-1>5. <strong>进程调度策略与优先级</strong>
<a class=anchor href=#5-%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5%e4%b8%8e%e4%bc%98%e5%85%88%e7%ba%a7-1>#</a></h3><p>除了 <code>nice</code> 值，Linux 还使用不同的调度策略来管理进程调度，进程的实际优先级（动态优先级）会受到调度策略的影响。Linux 支持几种调度策略，常见的有：</p><h4 id=1-实时调度策略-1>(1) <strong>实时调度策略</strong>
<a class=anchor href=#1-%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5-1>#</a></h4><ul><li><strong>SCHED_FIFO</strong>：先进先出（First In First Out），是最简单的实时调度策略，进程按照它们的到达顺序执行。</li><li><strong>SCHED_RR</strong>：轮转调度（Round Robin），进程按时间片轮流执行，每个进程有固定的时间片。</li></ul><h4 id=2-普通调度策略-1>(2) <strong>普通调度策略</strong>
<a class=anchor href=#2-%e6%99%ae%e9%80%9a%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5-1>#</a></h4><ul><li><strong>SCHED_OTHER</strong>：常规调度策略，使用的是 Linux 默认的调度策略（CFS 调度器），一般用于非实时进程。</li></ul><h3 id=6-查看进程调度策略-1>6. <strong>查看进程调度策略</strong>
<a class=anchor href=#6-%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5-1>#</a></h3><p>可以使用 <code>chrt</code> 命令来查看和设置进程的调度策略及优先级。<code>chrt</code> 命令可以查看实时进程的调度策略和优先级，并允许设置。</p><h4 id=1-查看进程调度策略-1>(1) 查看进程调度策略
<a class=anchor href=#1-%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chrt -p &lt;pid&gt;
</span></span></code></pre></div><h4 id=2-设置进程的调度策略-1>(2) 设置进程的调度策略
<a class=anchor href=#2-%e8%ae%be%e7%bd%ae%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5-1>#</a></h4><p>可以使用 <code>chrt</code> 命令设置实时进程的调度策略和优先级：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chrt -f &lt;priority&gt; &lt;pid&gt;    <span style=color:#75715e># 设置为 FIFO 策略</span>
</span></span><span style=display:flex><span>chrt -r &lt;priority&gt; &lt;pid&gt;    <span style=color:#75715e># 设置为 RR 策略</span>
</span></span></code></pre></div><p>其中，<code>&lt;priority></code> 是优先级数值，通常在 1 到 99 之间（优先级越小越高）。实时调度策略的优先级是独立的，普通调度策略的优先级由 <code>nice</code> 值决定。</p><h3 id=7-优先级调整的使用场景-1>7. <strong>优先级调整的使用场景</strong>
<a class=anchor href=#7-%e4%bc%98%e5%85%88%e7%ba%a7%e8%b0%83%e6%95%b4%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af-1>#</a></h3><ul><li><strong>实时任务</strong>：如需要对某些任务（例如硬件控制、音频处理等）进行实时调度时，使用 <code>SCHED_FIFO</code> 或 <code>SCHED_RR</code> 策略和较高的优先级。</li><li><strong>后台进程</strong>：对于不需要占用大量 CPU 时间的后台任务，可以设置较高的 <code>nice</code> 值，降低它们的优先级，避免影响系统响应。</li><li><strong>计算密集型任务</strong>：对于高优先级的计算密集型任务，可以使用较低的 <code>nice</code> 值，确保它们获得更多的 CPU 时间。</li></ul><h3 id=8-总结-1>8. <strong>总结</strong>
<a class=anchor href=#8-%e6%80%bb%e7%bb%93-1>#</a></h3><p>在 Linux 系统中，进程的优先级由静态优先级（nice 值）和动态优先级（实际调度优先级）决定。我们可以通过以下方式调整进程优先级：</p><ul><li><strong>使用 <code>nice</code> 启动新进程</strong>。</li><li><strong>使用 <code>renice</code> 调整正在运行的进程的 <code>nice</code> 值</strong>。</li><li><strong>通过调度策略</strong>（如 <code>SCHED_FIFO</code>、<code>SCHED_RR</code>）来调整实时进程的优先级。</li></ul><p>通过合理设置进程的优先级，可以优化系统性能，确保重要任务得到足够的资源，同时避免不必要的资源竞争。</p><h1 id=如何创建和管理自定义systemd服务>如何创建和管理自定义systemd服务
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e5%92%8c%e7%ae%a1%e7%90%86%e8%87%aa%e5%ae%9a%e4%b9%89systemd%e6%9c%8d%e5%8a%a1>#</a></h1><p>在 Linux 系统中，<strong>systemd</strong> 是现代 Linux 系统的初始化系统和服务管理器，广泛用于启动、停止和管理服务。通过创建和管理自定义 <code>systemd</code> 服务，可以让你以统一的方式控制和监控应用程序或脚本的执行。</p><h3 id=1-创建自定义-systemd-服务>1. <strong>创建自定义 systemd 服务</strong>
<a class=anchor href=#1-%e5%88%9b%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89-systemd-%e6%9c%8d%e5%8a%a1>#</a></h3><h4 id=1-创建服务单元文件>(1) 创建服务单元文件
<a class=anchor href=#1-%e5%88%9b%e5%bb%ba%e6%9c%8d%e5%8a%a1%e5%8d%95%e5%85%83%e6%96%87%e4%bb%b6>#</a></h4><p>一个 <code>systemd</code> 服务是通过创建一个服务单元文件来定义的。服务单元文件通常位于 <code>/etc/systemd/system/</code> 目录下，文件名以 <code>.service</code> 结尾。</p><p>例如，假设我们需要创建一个名为 <code>my-service</code> 的服务，我们需要创建一个名为 <code>my-service.service</code> 的文件。</p><p><strong>步骤：</strong></p><ol><li><p>使用文本编辑器创建服务文件。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nano /etc/systemd/system/my-service.service
</span></span></code></pre></div></li><li><p>定义服务单元文件内容。一个基本的 <code>.service</code> 文件可以包含以下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>My Custom Service</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/path/to/your/command_or_script</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>on-failure</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>User</span><span style=color:#f92672>=</span><span style=color:#e6db74>myuser</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Group</span><span style=color:#f92672>=</span><span style=color:#e6db74>mygroup</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Environment</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ENV_VAR=value&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><p>解释：</p><ul><li><code>[Unit]</code> 部分：定义了服务的描述和依赖关系。<code>After=network.target</code> 表示该服务会在网络服务启动之后执行。</li><li><code>[Service]</code> 部分：指定服务启动的命令。<code>ExecStart</code> 定义了启动服务时执行的命令或脚本路径。<code>Restart=on-failure</code> 表示服务失败时会自动重启。<code>User</code> 和 <code>Group</code> 指定了运行服务的用户和组。<code>Environment</code> 设置了环境变量。</li><li><code>[Install]</code> 部分：定义了服务安装时的目标（即在哪个 runlevel 启动）。<code>multi-user.target</code> 通常表示多用户模式，是大多数服务器的默认目标。</li></ul></li></ol><h4 id=2-保存并退出编辑器>(2) 保存并退出编辑器
<a class=anchor href=#2-%e4%bf%9d%e5%ad%98%e5%b9%b6%e9%80%80%e5%87%ba%e7%bc%96%e8%be%91%e5%99%a8>#</a></h4><p>完成文件编辑后，保存并关闭编辑器（在 nano 中按 <code>Ctrl + X</code>，然后按 <code>Y</code> 和 <code>Enter</code>）。</p><h4 id=3-重新加载-systemd-配置>(3) 重新加载 systemd 配置
<a class=anchor href=#3-%e9%87%8d%e6%96%b0%e5%8a%a0%e8%bd%bd-systemd-%e9%85%8d%e7%bd%ae>#</a></h4><p>在创建服务单元文件之后，需要重新加载 <code>systemd</code> 配置，以使其识别新的服务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl daemon-reload
</span></span></code></pre></div><h4 id=4-启动并启用服务>(4) 启动并启用服务
<a class=anchor href=#4-%e5%90%af%e5%8a%a8%e5%b9%b6%e5%90%af%e7%94%a8%e6%9c%8d%e5%8a%a1>#</a></h4><p>启动服务并让其开机自动启动：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl start my-service.service   <span style=color:#75715e># 启动服务</span>
</span></span><span style=display:flex><span>sudo systemctl enable my-service.service  <span style=color:#75715e># 设置为开机自动启动</span>
</span></span></code></pre></div><h4 id=5-检查服务状态>(5) 检查服务状态
<a class=anchor href=#5-%e6%a3%80%e6%9f%a5%e6%9c%8d%e5%8a%a1%e7%8a%b6%e6%80%81>#</a></h4><p>可以使用 <code>systemctl</code> 命令检查服务的状态、日志等信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl status my-service.service  <span style=color:#75715e># 查看服务状态</span>
</span></span></code></pre></div><h3 id=2-管理自定义-systemd-服务>2. <strong>管理自定义 systemd 服务</strong>
<a class=anchor href=#2-%e7%ae%a1%e7%90%86%e8%87%aa%e5%ae%9a%e4%b9%89-systemd-%e6%9c%8d%e5%8a%a1>#</a></h3><h4 id=1-启动和停止服务>(1) 启动和停止服务
<a class=anchor href=#1-%e5%90%af%e5%8a%a8%e5%92%8c%e5%81%9c%e6%ad%a2%e6%9c%8d%e5%8a%a1>#</a></h4><ul><li><p>启动服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl start my-service.service
</span></span></code></pre></div></li><li><p>停止服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl stop my-service.service
</span></span></code></pre></div></li><li><p>重启服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl restart my-service.service
</span></span></code></pre></div></li></ul><h4 id=2-查看服务状态>(2) 查看服务状态
<a class=anchor href=#2-%e6%9f%a5%e7%9c%8b%e6%9c%8d%e5%8a%a1%e7%8a%b6%e6%80%81>#</a></h4><p>查看服务的当前状态（是否正在运行、是否存在错误等）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl status my-service.service
</span></span></code></pre></div><p>输出示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>● my-service.service - My Custom Service
</span></span><span style=display:flex><span>   Loaded: loaded <span style=color:#f92672>(</span>/etc/systemd/system/my-service.service; enabled; vendor preset: enabled<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   Active: active <span style=color:#f92672>(</span>running<span style=color:#f92672>)</span> since Fri 2025-02-25 12:34:56 UTC; 1h 30min ago
</span></span><span style=display:flex><span> Main PID: <span style=color:#ae81ff>1234</span> <span style=color:#f92672>(</span>your_process<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Tasks: <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>limit: 4915<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   Memory: 1.0M
</span></span><span style=display:flex><span>   CGroup: /system.slice/my-service.service
</span></span><span style=display:flex><span>           └─1234 /path/to/your/command_or_script
</span></span></code></pre></div><h4 id=3-查看服务日志>(3) 查看服务日志
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e6%9c%8d%e5%8a%a1%e6%97%a5%e5%bf%97>#</a></h4><p><code>systemd</code> 使用 <code>journal</code> 来记录日志。查看服务的日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo journalctl -u my-service.service
</span></span></code></pre></div><p>如果需要实时查看日志输出，可以加上 <code>-f</code> 选项：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo journalctl -u my-service.service -f
</span></span></code></pre></div><h4 id=4-禁用和删除服务>(4) 禁用和删除服务
<a class=anchor href=#4-%e7%a6%81%e7%94%a8%e5%92%8c%e5%88%a0%e9%99%a4%e6%9c%8d%e5%8a%a1>#</a></h4><ul><li><p>禁用服务（不再开机启动）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl disable my-service.service
</span></span></code></pre></div></li><li><p>删除服务单元文件：</p><p>如果你不再需要此服务，可以删除其单元文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo rm /etc/systemd/system/my-service.service
</span></span></code></pre></div><p>删除后，也需要重新加载 <code>systemd</code> 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl daemon-reload
</span></span></code></pre></div></li></ul><h4 id=5-修改服务>(5) 修改服务
<a class=anchor href=#5-%e4%bf%ae%e6%94%b9%e6%9c%8d%e5%8a%a1>#</a></h4><p>如果需要修改服务的配置，只需要编辑相应的 <code>.service</code> 文件，修改完成后，重新加载 <code>systemd</code> 配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl daemon-reload
</span></span></code></pre></div><p>然后重新启动服务使其生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl restart my-service.service
</span></span></code></pre></div><h3 id=3-高级配置>3. <strong>高级配置</strong>
<a class=anchor href=#3-%e9%ab%98%e7%ba%a7%e9%85%8d%e7%bd%ae>#</a></h3><h4 id=1-设置服务的资源限制>(1) 设置服务的资源限制
<a class=anchor href=#1-%e8%ae%be%e7%bd%ae%e6%9c%8d%e5%8a%a1%e7%9a%84%e8%b5%84%e6%ba%90%e9%99%90%e5%88%b6>#</a></h4><p>在 <code>[Service]</code> 部分，你可以设置服务的资源限制，例如 CPU、内存、文件句柄等：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>LimitCPU</span><span style=color:#f92672>=</span><span style=color:#e6db74>50000     # 限制 CPU 使用，单位：毫秒</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>LimitMEMLOCK</span><span style=color:#f92672>=</span><span style=color:#e6db74>10000 # 限制内存锁定大小</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>LimitNOFILE</span><span style=color:#f92672>=</span><span style=color:#e6db74>65536  # 限制打开文件数量</span>
</span></span></code></pre></div><h4 id=2-设置服务的定时重启>(2) 设置服务的定时重启
<a class=anchor href=#2-%e8%ae%be%e7%bd%ae%e6%9c%8d%e5%8a%a1%e7%9a%84%e5%ae%9a%e6%97%b6%e9%87%8d%e5%90%af>#</a></h4><p>你可以设置服务在某些条件下自动重启：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>always     # 总是重启</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>RestartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>10      # 重启间隔 10 秒</span>
</span></span></code></pre></div><h4 id=3-使用-execstop-指定停止命令>(3) 使用 <code>ExecStop</code> 指定停止命令
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8-execstop-%e6%8c%87%e5%ae%9a%e5%81%9c%e6%ad%a2%e5%91%bd%e4%bb%a4>#</a></h4><p>你可以指定停止服务时要执行的命令。例如，如果是脚本或程序，可能需要指定停止命令来清理资源：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStop</span><span style=color:#f92672>=</span><span style=color:#e6db74>/path/to/stop_script.sh</span>
</span></span></code></pre></div><h4 id=4-使用-after-和-before-控制服务的启动顺序>(4) 使用 <code>After</code> 和 <code>Before</code> 控制服务的启动顺序
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-after-%e5%92%8c-before-%e6%8e%a7%e5%88%b6%e6%9c%8d%e5%8a%a1%e7%9a%84%e5%90%af%e5%8a%a8%e9%a1%ba%e5%ba%8f>#</a></h4><p>你可以通过 <code>After</code> 和 <code>Before</code> 配置项控制服务的启动顺序。例如，如果你的服务依赖于网络，你可以在 <code>[Unit]</code> 部分添加：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span></code></pre></div><h3 id=4-总结-1>4. <strong>总结</strong>
<a class=anchor href=#4-%e6%80%bb%e7%bb%93-1>#</a></h3><ul><li>创建自定义 systemd 服务时，首先需要定义 <code>.service</code> 文件，指定服务的启动命令、资源限制等信息。</li><li>使用 <code>systemctl</code> 命令来启动、停止、重启和查看服务状态。</li><li>可以使用 <code>journalctl</code> 查看服务日志。</li><li>服务单元文件可以按需进行修改，修改后使用 <code>systemctl daemon-reload</code> 更新 systemd 配置。</li></ul><p><code>systemd</code> 服务为你的应用提供了一种简洁而强大的管理方式，不仅适用于常见的后台服务，也可以用于定时任务、脚本执行等场景。</p><h1 id=linux内核模块的加载与卸载过程>Linux内核模块的加载与卸载过程
<a class=anchor href=#linux%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%9a%84%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%8d%b8%e8%bd%bd%e8%bf%87%e7%a8%8b>#</a></h1><p>在 Linux 系统中，内核模块（Kernel Module）是一个能够在运行时被加载和卸载的二进制文件，它们提供了内核的扩展功能，比如硬件驱动、文件系统支持等。通过加载和卸载内核模块，可以动态地修改内核的功能，而不需要重新启动系统。下面是内核模块的加载和卸载过程的详细介绍：</p><h3 id=1-内核模块的加载过程>1. <strong>内核模块的加载过程</strong>
<a class=anchor href=#1-%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%9a%84%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b>#</a></h3><h4 id=1-加载内核模块的命令>(1) <strong>加载内核模块的命令</strong>
<a class=anchor href=#1-%e5%8a%a0%e8%bd%bd%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%9a%84%e5%91%bd%e4%bb%a4>#</a></h4><ul><li><p><code>insmod</code>：用于加载内核模块。此命令直接加载模块，模块文件必须指定完整路径，且不会自动处理依赖。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo insmod /path/to/module.ko
</span></span></code></pre></div></li><li><p><code>modprobe</code>：用于加载内核模块。相比 <code>insmod</code>，<code>modprobe</code> 会自动处理模块依赖关系，推荐使用这个命令来加载模块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo modprobe module_name
</span></span></code></pre></div><p><code>module_name</code> 是模块的名字，不需要包含 <code>.ko</code> 扩展名，<code>modprobe</code> 会自动查找模块文件。</p></li><li><p><code>lsmod</code>：用于查看当前已加载的所有内核模块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsmod
</span></span></code></pre></div></li></ul><h4 id=2-加载内核模块的过程>(2) <strong>加载内核模块的过程</strong>
<a class=anchor href=#2-%e5%8a%a0%e8%bd%bd%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%9a%84%e8%bf%87%e7%a8%8b>#</a></h4><ol><li><p><strong>检查依赖关系</strong>：</p><ul><li>当执行 <code>modprobe</code> 命令加载一个模块时，系统会首先检查模块的依赖关系。例如，某些模块可能依赖于其他模块。</li><li><code>modprobe</code> 会自动加载所需的依赖模块。如果是通过 <code>insmod</code> 命令手动加载模块，则需要手动加载所有的依赖模块。</li></ul></li><li><p><strong>模块文件路径</strong>：</p><ul><li><code>modprobe</code> 会在 <code>/lib/modules/$(uname -r)/</code> 目录下查找内核模块文件，<code>uname -r</code> 获取当前系统的内核版本。模块文件的后缀通常是 <code>.ko</code>。</li></ul></li><li><p><strong>加载模块到内核空间</strong>：</p><ul><li>内核模块通过 <code>insmod</code> 或 <code>modprobe</code> 命令被加载到内核中。内核会解析模块文件的 ELF 格式，进行符号解析，初始化模块的入口函数。</li><li>如果模块初始化成功，它将注册自己的功能到内核，例如注册硬件驱动、文件系统类型、系统调用等。</li></ul></li><li><p><strong>模块加载的检查</strong>：</p><ul><li>可以使用 <code>dmesg</code> 命令查看加载模块时产生的内核日志，检查模块加载的详细信息。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dmesg | tail
</span></span></code></pre></div></li><li><p><strong>模块文件的缓存</strong>：</p><ul><li>模块一旦加载到内核中，它们将驻留在内存中，并通过 <code>lsmod</code> 命令显示为已加载的模块。系统会保持模块的状态，直到卸载或系统重启。</li></ul></li></ol><h4 id=3-查看加载的模块>(3) <strong>查看加载的模块</strong>
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e5%8a%a0%e8%bd%bd%e7%9a%84%e6%a8%a1%e5%9d%97>#</a></h4><ul><li><p>使用 <code>lsmod</code> 查看已加载的内核模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>lsmod
</span></span></code></pre></div><p>该命令会列出所有当前已加载的模块、模块大小以及模块使用情况等信息。</p></li></ul><h4 id=4-动态加载模块>(4) <strong>动态加载模块</strong>
<a class=anchor href=#4-%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd%e6%a8%a1%e5%9d%97>#</a></h4><p>某些模块可以配置为在特定的事件发生时自动加载。例如，设备插入时自动加载相应的驱动模块，这通过 <code>udev</code> 机制实现。你可以使用 <code>/etc/modules</code> 或 <code>/etc/modprobe.d/</code> 下的配置文件，指定模块的自动加载。</p><h3 id=2-内核模块的卸载过程>2. <strong>内核模块的卸载过程</strong>
<a class=anchor href=#2-%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%9a%84%e5%8d%b8%e8%bd%bd%e8%bf%87%e7%a8%8b>#</a></h3><h4 id=1-卸载内核模块的命令>(1) <strong>卸载内核模块的命令</strong>
<a class=anchor href=#1-%e5%8d%b8%e8%bd%bd%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%9a%84%e5%91%bd%e4%bb%a4>#</a></h4><ul><li><p><code>rmmod</code>：用于卸载已加载的内核模块，卸载时会检查该模块是否存在其他依赖模块。如果该模块是被其他模块所依赖，则无法卸载。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo rmmod module_name
</span></span></code></pre></div></li><li><p><code>modprobe -r</code>：用于卸载内核模块，<code>modprobe -r</code> 会自动处理依赖关系，卸载时会自动卸载依赖该模块的其他模块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo modprobe -r module_name
</span></span></code></pre></div></li></ul><h4 id=2-卸载内核模块的过程>(2) <strong>卸载内核模块的过程</strong>
<a class=anchor href=#2-%e5%8d%b8%e8%bd%bd%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%9a%84%e8%bf%87%e7%a8%8b>#</a></h4><ol><li><p><strong>检查模块是否被使用</strong>：</p><ul><li>如果模块正在被使用（例如硬件设备驱动正在驱动设备），则无法直接卸载。此时需要先停止相关的服务或卸载相关依赖模块。</li></ul></li><li><p><strong>卸载模块</strong>：</p><ul><li>执行 <code>rmmod</code> 或 <code>modprobe -r</code> 命令卸载模块。卸载模块时，内核会释放该模块占用的资源，并注销它的功能。</li></ul></li><li><p><strong>依赖关系处理</strong>：</p><ul><li>如果有其他模块依赖于该模块，<code>modprobe -r</code> 会先卸载依赖模块，再卸载目标模块。而 <code>rmmod</code> 会检查是否有其他模块依赖于目标模块，如果有依赖，则无法卸载。</li></ul></li><li><p><strong>检查内核日志</strong>：</p><ul><li>卸载模块的过程会在内核日志中生成相应的记录，可以通过 <code>dmesg</code> 查看卸载过程中的日志信息。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dmesg | tail
</span></span></code></pre></div></li><li><p><strong>模块缓存</strong>：</p><ul><li>模块卸载后，它会从内核中释放，内核空间中的相应资源将被回收。如果该模块有注册的功能（如设备驱动），这些功能将不再可用。</li></ul></li></ol><h4 id=3-查看当前加载的模块>(3) <strong>查看当前加载的模块</strong>
<a class=anchor href=#3-%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e5%8a%a0%e8%bd%bd%e7%9a%84%e6%a8%a1%e5%9d%97>#</a></h4><p>使用 <code>lsmod</code> 查看当前加载的所有模块，确认模块是否已成功卸载。</p><h3 id=3-内核模块管理的其他相关命令>3. <strong>内核模块管理的其他相关命令</strong>
<a class=anchor href=#3-%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e7%ae%a1%e7%90%86%e7%9a%84%e5%85%b6%e4%bb%96%e7%9b%b8%e5%85%b3%e5%91%bd%e4%bb%a4>#</a></h3><ul><li><p><strong>查看模块的详细信息</strong>：</p><p>使用 <code>modinfo</code> 命令查看某个模块的详细信息，如版本、依赖关系等。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>modinfo module_name
</span></span></code></pre></div><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>modinfo e1000
</span></span></code></pre></div></li><li><p><strong>查找模块文件位置</strong>：</p><p>使用 <code>modprobe</code> 的 <code>-n</code> 选项来显示模块的加载路径，但不实际加载模块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>modprobe -n -v module_name
</span></span></code></pre></div></li><li><p><strong>查看模块的依赖关系</strong>：</p><p>使用 <code>lsmod</code> 和 <code>modinfo</code> 可以查看模块的依赖关系。</p></li></ul><h3 id=4-自动加载模块>4. <strong>自动加载模块</strong>
<a class=anchor href=#4-%e8%87%aa%e5%8a%a8%e5%8a%a0%e8%bd%bd%e6%a8%a1%e5%9d%97>#</a></h3><p>内核模块可以配置为在系统启动时或设备连接时自动加载。这通常通过配置 <code>/etc/modules</code> 或在 <code>/etc/modprobe.d/</code> 目录下创建配置文件来完成。你也可以在 <code>initramfs</code> 配置中设置内核模块的加载。</p><h3 id=5-总结>5. <strong>总结</strong>
<a class=anchor href=#5-%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong>加载模块</strong>：使用 <code>insmod</code> 或 <code>modprobe</code> 命令加载内核模块，<code>modprobe</code> 自动处理依赖关系。</li><li><strong>卸载模块</strong>：使用 <code>rmmod</code> 或 <code>modprobe -r</code> 卸载模块，<code>modprobe -r</code> 会自动处理依赖关系。</li><li><strong>查看已加载模块</strong>：使用 <code>lsmod</code> 查看当前已加载的模块，使用 <code>dmesg</code> 查看内核日志。</li><li><strong>内核模块管理</strong>：通过 <code>modinfo</code> 查看模块信息，<code>modprobe -n</code> 查看模块路径等。</li></ul><p>内核模块的动态加载和卸载为 Linux 系统提供了极大的灵活性，允许你在不重启系统的情况下为系统添加或移除功能。</p><h1 id=ansible-roles使用场景现在有多台机器需要批量加入k8s集群怎么实现>ansible roles使用场景，现在有多台机器需要批量加入k8s集群，怎么实现☆
<a class=anchor href=#ansible-roles%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e7%8e%b0%e5%9c%a8%e6%9c%89%e5%a4%9a%e5%8f%b0%e6%9c%ba%e5%99%a8%e9%9c%80%e8%a6%81%e6%89%b9%e9%87%8f%e5%8a%a0%e5%85%a5k8s%e9%9b%86%e7%be%a4%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0>#</a></h1><p>Ansible <strong>Roles</strong> 是一种将配置文件、任务、变量等分组的方式，使得管理更为模块化和可重用。在大规模部署和配置环境时，使用 Ansible Roles 可以提高代码的可维护性和复用性。</p><h3 id=ansible-roles-使用场景><strong>Ansible Roles 使用场景</strong>
<a class=anchor href=#ansible-roles-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><ul><li><strong>模块化管理</strong>：当你的任务比较复杂时，可以将其拆分成多个独立的角色，每个角色管理一个特定的功能或模块。例如，管理数据库、Web 服务器、Kubernetes 集群等。</li><li><strong>提高重用性</strong>：角色的代码结构独立，便于重用。例如，一个 Kubernetes 角色可以在不同环境中重复使用，只需要传入不同的变量。</li><li><strong>简化配置和管理</strong>：通过角色结构，你可以避免重复配置，并且可以专注于某个模块的功能。</li></ul><h3 id=ansible-roles-目录结构><strong>Ansible Roles 目录结构</strong>
<a class=anchor href=#ansible-roles-%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84>#</a></h3><p>假设你要创建一个名为 <code>k8s-cluster</code> 的角色，安装并配置 Kubernetes，角色的目录结构可能如下：</p><pre tabindex=0><code>k8s-cluster/
├── defaults/
│   └── main.yml      # 默认变量
├── files/
│   └── ...           # 需要拷贝的文件
├── handlers/
│   └── main.yml      # 处理器，例如服务重启
├── meta/
│   └── main.yml      # 角色的元数据
├── tasks/
│   └── main.yml      # 任务定义
├── templates/
│   └── ...           # Jinja2 模板文件
├── vars/
│   └── main.yml      # 变量文件
</code></pre><h3 id=如何用-ansible-批量将多台机器加入-kubernetes-集群><strong>如何用 Ansible 批量将多台机器加入 Kubernetes 集群</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e7%94%a8-ansible-%e6%89%b9%e9%87%8f%e5%b0%86%e5%a4%9a%e5%8f%b0%e6%9c%ba%e5%99%a8%e5%8a%a0%e5%85%a5-kubernetes-%e9%9b%86%e7%be%a4>#</a></h3><p>假设有多台机器，你可以使用 Ansible 批量将这些机器加入 Kubernetes 集群。以下是使用 Ansible Roles 来实现这一目标的基本步骤：</p><h4 id=1-创建-kubernetes-角色>1. <strong>创建 Kubernetes 角色</strong>
<a class=anchor href=#1-%e5%88%9b%e5%bb%ba-kubernetes-%e8%a7%92%e8%89%b2>#</a></h4><p>在 <code>k8s-cluster/</code> 目录下，编写以下内容：</p><ul><li><p><strong>defaults/main.yml</strong>（定义默认变量）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># k8s-cluster/defaults/main.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kube_version</span>: <span style=color:#e6db74>&#34;1.24.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>api_server</span>: <span style=color:#e6db74>&#34;https://your-k8s-master-ip:6443&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kubeconfig_path</span>: <span style=color:#e6db74>&#34;/etc/kubernetes/kubelet.conf&#34;</span>
</span></span></code></pre></div></li><li><p><strong>tasks/main.yml</strong>（执行任务）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># k8s-cluster/tasks/main.yml</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Install Docker</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>package</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>docker</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>present</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Add Kubernetes repositories</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    echo &#34;deb https://apt.kubernetes.io/ kubernetes-xenial main&#34; &gt; /etc/apt/sources.list.d/kubernetes.list</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Install kubelet, kubeadm, and kubectl</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>apt</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;{{ item }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>present</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>update_cache</span>: <span style=color:#66d9ef>yes</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>loop</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>kubelet={{ kube_version }}</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>kubeadm={{ kube_version }}</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>kubectl={{ kube_version }}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Initialize Kubernetes Cluster (for master node)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>command</span>: <span style=color:#ae81ff>kubeadm init --apiserver-advertise-address={{ ansible_host }} --pod-network-cidr=192.168.0.0/16</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>inventory_hostname == groups[&#39;master&#39;][0]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Join Kubernetes Cluster (for worker nodes)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>command</span>: <span style=color:#ae81ff>kubeadm join {{ api_server }} --token {{ join_token }} --discovery-token-ca-cert-hash {{ discovery_token_hash }}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>inventory_hostname != groups[&#39;master&#39;][0]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Configure kubectl for non-root user</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;/etc/kubernetes/admin.conf&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;{{ kubeconfig_path }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;0644&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>inventory_hostname == groups[&#39;master&#39;][0]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Install Calico network plugin</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>kubectl apply -f https://docs.projectcalico.org/v3.19/manifests/calico.yaml</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>inventory_hostname == groups[&#39;master&#39;][0]</span>
</span></span></code></pre></div></li></ul><h4 id=2-主机清单inventory文件>2. <strong>主机清单（Inventory）文件</strong>
<a class=anchor href=#2-%e4%b8%bb%e6%9c%ba%e6%b8%85%e5%8d%95inventory%e6%96%87%e4%bb%b6>#</a></h4><p>创建一个 Ansible 主机清单文件 <code>hosts.ini</code>，列出所有的 Kubernetes Master 和 Worker 节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[master]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>master1 ansible_host</span><span style=color:#f92672>=</span><span style=color:#e6db74>master1_ip</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[worker]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>worker1 ansible_host</span><span style=color:#f92672>=</span><span style=color:#e6db74>worker1_ip</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>worker2 ansible_host</span><span style=color:#f92672>=</span><span style=color:#e6db74>worker2_ip</span>
</span></span></code></pre></div><h4 id=3-创建-playbook>3. <strong>创建 Playbook</strong>
<a class=anchor href=#3-%e5%88%9b%e5%bb%ba-playbook>#</a></h4><p>编写一个 Playbook 来使用 <code>k8s-cluster</code> 角色来配置节点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Configure Kubernetes Cluster</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>become</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>k8s-cluster</span>
</span></span></code></pre></div><h4 id=4-运行-playbook>4. <strong>运行 Playbook</strong>
<a class=anchor href=#4-%e8%bf%90%e8%a1%8c-playbook>#</a></h4><p>使用 Ansible 执行 Playbook 来将多台机器加入到 Kubernetes 集群中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ansible-playbook -i hosts.ini k8s-cluster-setup.yml
</span></span></code></pre></div><p>这个命令会根据 <code>hosts.ini</code> 中定义的主机信息，批量配置每个节点，并按照定义的角色来安装 Kubernetes 和网络插件。</p><h3 id=总结-22><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-22>#</a></h3><ol><li><strong>Ansible Roles</strong> 使得管理大规模集群和复杂配置变得更简单，可以将不同的配置和功能模块化，便于管理。</li><li><strong>批量加入 Kubernetes 集群</strong>：通过使用 Ansible，你可以在多个节点上执行 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令来批量初始化或加入 Kubernetes 集群。</li><li><strong>自动化运维</strong>：使用 Ansible Playbooks 和 Roles 来实现 Kubernetes 集群的自动化管理，降低手动配置的复杂度，提升运维效率。</li></ol><p>这样，你就可以使用 Ansible 角色来高效地管理 Kubernetes 集群的节点，批量配置并将机器加入集群。</p><p>了解了！如果你需要包括 Docker 和 <code>kube-proxy</code> 的分发步骤，并且要将它们配置成 <code>systemd</code> 服务来管理，下面是一个完整的解决方案。</p><h3 id=1-准备角色和任务>1. <strong>准备角色和任务</strong>
<a class=anchor href=#1-%e5%87%86%e5%a4%87%e8%a7%92%e8%89%b2%e5%92%8c%e4%bb%bb%e5%8a%a1>#</a></h3><h4 id=1-角色目录结构>(1) <strong>角色目录结构</strong>
<a class=anchor href=#1-%e8%a7%92%e8%89%b2%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84>#</a></h4><pre tabindex=0><code>k8s-deploy/
├── defaults/
│   └── main.yml          # 默认变量文件
├── files/
│   ├── kubelet           # 二进制文件
│   ├── kubectl           # 二进制文件
│   ├── kubeconfig        # kubeconfig 文件（包含集群的配置信息）
│   ├── kubelet.crt       # kubelet 证书
│   ├── kubelet.key       # kubelet 私钥
│   ├── kube-proxy        # kube-proxy 二进制文件
│   ├── docker-ce         # Docker 二进制文件（如果使用的是自定义 Docker 版本）
│   ├── etc...            # 其他配置文件
├── tasks/
│   └── main.yml          # 安装和分发文件的任务
├── handlers/
│   └── main.yml          # 处理器（如重启服务等）
└── vars/
    └── main.yml          # 变量文件（如文件路径、Kubernetes 版本等）
</code></pre><h4 id=2-默认变量文件defaultsmainyml>(2) <strong>默认变量文件（defaults/main.yml）</strong>
<a class=anchor href=#2-%e9%bb%98%e8%ae%a4%e5%8f%98%e9%87%8f%e6%96%87%e4%bb%b6defaultsmainyml>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># k8s-deploy/defaults/main.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>k8s_bin_dir</span>: <span style=color:#e6db74>&#34;/usr/local/bin&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>docker_version</span>: <span style=color:#e6db74>&#34;20.10.8&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>docker_package</span>: <span style=color:#e6db74>&#34;docker.io&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>docker_service</span>: <span style=color:#e6db74>&#34;docker&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kubeconfig_path</span>: <span style=color:#e6db74>&#34;/etc/kubernetes/kubelet.conf&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kube_proxy_bin</span>: <span style=color:#e6db74>&#34;/usr/local/bin/kube-proxy&#34;</span>
</span></span></code></pre></div><h4 id=3-任务文件tasksmainyml>(3) <strong>任务文件（tasks/main.yml）</strong>
<a class=anchor href=#3-%e4%bb%bb%e5%8a%a1%e6%96%87%e4%bb%b6tasksmainyml>#</a></h4><p>这部分包括 Docker、<code>kube-proxy</code>、<code>kubelet</code> 的安装和配置，及其作为 <code>systemd</code> 服务进行管理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># k8s-deploy/tasks/main.yml</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 安装 Docker</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Install Docker</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>package</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;{{ docker_package }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>present</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Start and enable Docker service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>systemd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;{{ docker_service }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>started</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 分发 Kubernetes 二进制文件</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Distribute kubelet binary</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;files/kubelet&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;{{ k8s_bin_dir }}/kubelet&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#39;0755&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Distribute kubectl binary</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;files/kubectl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;{{ k8s_bin_dir }}/kubectl&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#39;0755&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Distribute kube-proxy binary</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;files/kube-proxy&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;{{ k8s_bin_dir }}/kube-proxy&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#39;0755&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 分发证书和配置文件</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Distribute kubelet certificate</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;files/kubelet.crt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;/etc/kubernetes/kubelet.crt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#39;0644&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Distribute kubelet private key</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;files/kubelet.key&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;/etc/kubernetes/kubelet.key&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#39;0600&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Distribute kubeconfig file</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;files/kubeconfig&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;{{ kubeconfig_path }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#39;0644&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 分发 Docker 配置文件（如果有自定义配置）</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Distribute Docker configuration file (if needed)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;files/docker_config.json&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;/etc/docker/daemon.json&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#39;0644&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>docker_config is defined</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. 配置并启动 kubelet 服务</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Enable and start kubelet service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>systemd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kubelet</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>started</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>daemon_reload</span>: <span style=color:#66d9ef>yes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 6. 配置并启动 kube-proxy 服务</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Enable and start kube-proxy service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>systemd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kube-proxy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>started</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>daemon_reload</span>: <span style=color:#66d9ef>yes</span>
</span></span></code></pre></div><h4 id=4-处理器handlersmainyml>(4) <strong>处理器（handlers/main.yml）</strong>
<a class=anchor href=#4-%e5%a4%84%e7%90%86%e5%99%a8handlersmainyml>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># k8s-deploy/handlers/main.yml</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Restart kubelet</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>systemd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kubelet</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>restarted</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>daemon_reload</span>: <span style=color:#66d9ef>yes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Restart kube-proxy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>systemd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kube-proxy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>restarted</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>daemon_reload</span>: <span style=color:#66d9ef>yes</span>
</span></span></code></pre></div><h3 id=2-systemd>2. <strong><code>systemd</code> 服务配置文件</strong>
<a class=anchor href=#2-systemd>#</a></h3><p>为了确保 <code>kubelet</code> 和 <code>kube-proxy</code> 可以作为 <code>systemd</code> 服务管理，你需要为它们创建 <code>systemd</code> 服务文件。这些服务文件将被复制到 <code>/etc/systemd/system/</code> 目录，并在必要时启动。</p><h4 id=1-kubeletservice>(1) <strong><code>kubelet.service</code> 配置</strong>
<a class=anchor href=#1-kubeletservice>#</a></h4><p>创建 <code>kubelet.service</code> 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># /etc/systemd/system/kubelet.service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>kubelet: The Kubernetes Node Agent</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Documentation</span><span style=color:#f92672>=</span><span style=color:#e6db74>https://kubernetes.io/docs/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/local/bin/kubelet --kubeconfig=/etc/kubernetes/kubelet.conf --config=/etc/kubernetes/kubelet.config.yaml</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>always</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>RestartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>10</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>LimitNOFILE</span><span style=color:#f92672>=</span><span style=color:#e6db74>65536</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TimeoutStartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><h4 id=2-kube-proxyservice>(2) <strong><code>kube-proxy.service</code> 配置</strong>
<a class=anchor href=#2-kube-proxyservice>#</a></h4><p>创建 <code>kube-proxy.service</code> 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># /etc/systemd/system/kube-proxy.service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>kube-proxy: The Kubernetes Network Proxy</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Documentation</span><span style=color:#f92672>=</span><span style=color:#e6db74>https://kubernetes.io/docs/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/local/bin/kube-proxy --kubeconfig=/etc/kubernetes/kubelet.conf</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>always</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>RestartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>10</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>LimitNOFILE</span><span style=color:#f92672>=</span><span style=color:#e6db74>65536</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TimeoutStartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><h3 id=3-主机清单文件>3. <strong>主机清单文件</strong>
<a class=anchor href=#3-%e4%b8%bb%e6%9c%ba%e6%b8%85%e5%8d%95%e6%96%87%e4%bb%b6>#</a></h3><p>确保在 <code>hosts.ini</code> 文件中列出 Master 和 Worker 节点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[master]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>master1 ansible_host</span><span style=color:#f92672>=</span><span style=color:#e6db74>master1_ip</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[worker]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>worker1 ansible_host</span><span style=color:#f92672>=</span><span style=color:#e6db74>worker1_ip</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>worker2 ansible_host</span><span style=color:#f92672>=</span><span style=color:#e6db74>worker2_ip</span>
</span></span></code></pre></div><h3 id=4-playbook-配置>4. <strong>Playbook 配置</strong>
<a class=anchor href=#4-playbook-%e9%85%8d%e7%bd%ae>#</a></h3><p>编写 Playbook 来使用 <code>k8s-deploy</code> 角色来安装和配置 Kubernetes。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Install and Configure Kubernetes on all nodes</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>become</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>k8s-deploy</span>
</span></span></code></pre></div><h3 id=5-执行-playbook>5. <strong>执行 Playbook</strong>
<a class=anchor href=#5-%e6%89%a7%e8%a1%8c-playbook>#</a></h3><p>执行 Playbook 将 Kubernetes 配置文件、证书以及二进制文件分发到所有节点，并启动 <code>kubelet</code> 和 <code>kube-proxy</code> 服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ansible-playbook -i hosts.ini k8s-deploy.yml
</span></span></code></pre></div><h3 id=6-总结>6. <strong>总结</strong>
<a class=anchor href=#6-%e6%80%bb%e7%bb%93>#</a></h3><ul><li><strong>分发二进制文件</strong>：通过 <code>copy</code> 模块将 <code>kubelet</code>、<code>kubectl</code> 和 <code>kube-proxy</code> 等二进制文件分发到每台机器。</li><li><strong>分发证书和配置文件</strong>：将 <code>kubelet</code> 证书、<code>kubeconfig</code> 配置文件等分发到目标节点，确保它们能够通过 <code>kubeconfig</code> 自动连接到集群。</li><li><strong>安装和配置 Docker</strong>：通过 <code>package</code> 模块安装 Docker，并根据需要配置 Docker。</li><li><strong><code>systemd</code> 服务管理</strong>：为 <code>kubelet</code> 和 <code>kube-proxy</code> 创建 <code>systemd</code> 服务文件，并通过 <code>systemd</code> 来管理它们的启动、停止、重启等。</li><li><strong>启动服务</strong>：通过 <code>systemd</code> 启动 <code>kubelet</code> 和 <code>kube-proxy</code> 服务，使它们自动连接到 Kubernetes 集群。</li></ul><p>通过这种方式，你可以确保所有的 Kubernetes 组件（如 <code>kubelet</code>, <code>kube-proxy</code>）以及 Docker 服务都能通过 <code>systemd</code> 来进行管理，提供高效的自动化部署过程。</p><p>Docker 二进制文件主要包括以下几个核心组件，它们一起协作完成 Docker 容器的管理和运行：</p><h3 id=1-dockerd-docker-daemon>1. <strong><code>dockerd</code></strong> (Docker Daemon)
<a class=anchor href=#1-dockerd-docker-daemon>#</a></h3><ul><li><strong>作用</strong>：<code>dockerd</code> 是 Docker 守护进程，它负责管理 Docker 容器的生命周期，监听 Docker API 请求，创建、启动、停止容器等操作。</li><li><strong>路径</strong>：通常安装在 <code>/usr/local/bin/dockerd</code> 或 <code>/usr/bin/dockerd</code>。</li></ul><h3 id=2-docker-docker-cli>2. <strong><code>docker</code></strong> (Docker CLI)
<a class=anchor href=#2-docker-docker-cli>#</a></h3><ul><li><strong>作用</strong>：<code>docker</code> 是 Docker 客户端命令行工具，用户通过该命令行工具与 Docker 守护进程进行交互。它提供了常见的 Docker 命令，如 <code>docker run</code>、<code>docker ps</code>、<code>docker build</code> 等。</li><li><strong>路径</strong>：通常安装在 <code>/usr/local/bin/docker</code> 或 <code>/usr/bin/docker</code>。</li></ul><h3 id=3-containerd-container-runtime>3. <strong><code>containerd</code></strong> (Container Runtime)
<a class=anchor href=#3-containerd-container-runtime>#</a></h3><ul><li><strong>作用</strong>：<code>containerd</code> 是容器运行时，Docker 使用它来执行容器的创建、调度、运行和监控。它是 Docker 核心的一个组件，负责容器的生命周期管理。</li><li><strong>路径</strong>：通常安装在 <code>/usr/local/bin/containerd</code> 或 <code>/usr/bin/containerd</code>。</li></ul><h3 id=4-runc-low-level-container-runtime>4. <strong><code>runc</code></strong> (Low-level Container Runtime)
<a class=anchor href=#4-runc-low-level-container-runtime>#</a></h3><ul><li><strong>作用</strong>：<code>runc</code> 是一个低级别的容器运行时，负责容器的创建、启动、停止等操作。它由 Docker 使用，并且也是 Kubernetes 采用的容器运行时之一（通过 containerd 或直接使用）。</li><li><strong>路径</strong>：通常安装在 <code>/usr/local/bin/runc</code> 或 <code>/usr/bin/runc</code>。</li></ul><h3 id=5-ctr-containerd-cli>5. <strong><code>ctr</code></strong> (Containerd CLI)
<a class=anchor href=#5-ctr-containerd-cli>#</a></h3><ul><li><strong>作用</strong>：<code>ctr</code> 是 containerd 的命令行工具，主要用于与 <code>containerd</code> 交互，执行容器的调试、管理等操作。它比 Docker 命令行工具更底层，通常用于调试和测试。</li><li><strong>路径</strong>：通常安装在 <code>/usr/local/bin/ctr</code>。</li></ul><h3 id=6-dockerd>6. <strong><code>dockerd</code> 配置文件和插件</strong>
<a class=anchor href=#6-dockerd>#</a></h3><ul><li><strong>插件</strong>：Docker 的功能通过插件机制进行扩展，插件包括网络插件、存储插件、日志插件等。它们通常位于 <code>/usr/lib/docker/</code> 或 <code>/etc/docker/</code> 目录下。</li><li><strong>配置文件</strong>：Docker 的配置文件通常位于 <code>/etc/docker/daemon.json</code>，用于配置 Docker 守护进程的行为（例如，指定镜像仓库、日志驱动、存储驱动等）。</li></ul><h3 id=7-docker-compose-用于管理多容器应用>7. <strong><code>docker-compose</code></strong> (用于管理多容器应用)
<a class=anchor href=#7-docker-compose-%e7%94%a8%e4%ba%8e%e7%ae%a1%e7%90%86%e5%a4%9a%e5%ae%b9%e5%99%a8%e5%ba%94%e7%94%a8>#</a></h3><ul><li><strong>作用</strong>：<code>docker-compose</code> 是一个独立的命令行工具，用于定义和管理 Docker 容器的多容器应用（例如，定义应用的服务、网络、卷等）。它通过一个 YAML 文件 <code>docker-compose.yml</code> 来进行容器的编排和管理。</li><li><strong>路径</strong>：通常安装在 <code>/usr/local/bin/docker-compose</code> 或 <code>/usr/bin/docker-compose</code>。</li></ul><hr><h3 id=常见安装路径><strong>常见安装路径：</strong>
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e5%ae%89%e8%a3%85%e8%b7%af%e5%be%84>#</a></h3><ul><li><p><strong><code>dockerd</code>、<code>docker</code>、<code>containerd</code>、<code>runc</code></strong> 等二进制文件通常位于 <code>/usr/local/bin/</code> 或 <code>/usr/bin/</code>。</p></li><li><p>你可以通过</p><pre tabindex=0><code>which
</code></pre><p>命令查看这些二进制文件的安装路径：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>which dockerd
</span></span><span style=display:flex><span>which docker
</span></span><span style=display:flex><span>which containerd
</span></span><span style=display:flex><span>which runc
</span></span></code></pre></div></li></ul><h3 id=docker-依赖的其他组件><strong>Docker 依赖的其他组件：</strong>
<a class=anchor href=#docker-%e4%be%9d%e8%b5%96%e7%9a%84%e5%85%b6%e4%bb%96%e7%bb%84%e4%bb%b6>#</a></h3><ul><li><strong><code>libcontainer</code></strong>：用于实现容器的基本功能。</li><li><strong><code>aufs</code>、<code>btrfs</code>、<code>overlay</code>、<code>zfs</code></strong> 等存储驱动：Docker 支持多种存储驱动，每种驱动有不同的性能和特性。</li><li><strong><code>network plugins</code></strong>：Docker 网络插件，用于为容器提供网络支持。</li></ul><h3 id=总结-23><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-23>#</a></h3><p>Docker 的核心二进制文件主要包括 <code>dockerd</code>（守护进程）、<code>docker</code>（命令行客户端）、<code>containerd</code>（容器运行时）和 <code>runc</code>（底层容器运行时）。如果使用二进制方式安装 Docker，通常需要将这些二进制文件放置在合适的路径，并配置相应的 <code>systemd</code> 服务文件来启动和管理它们。</p><pre tabindex=0><code>- name: 创建kube_node 相关目录
  file: name={{ item }} state=directory
  with_items:
  - /var/lib/kubelet
  - /var/lib/kube-proxy
  - /etc/cni/net.d
  - /opt/cni/bin

- name: 下载 kubelet,kube-proxy 二进制
  copy: src={{ base_dir }}/bin/{{ item }} dest={{ bin_dir }}/{{ item }} mode=0755
  with_items:
  - kubectl
  - kubelet
  - kube-proxy
  tags: upgrade_k8s

- name: 下载 cni plugins 二进制文件
  copy: src={{ item }} dest=/opt/cni/bin/ mode=0755
  with_fileglob:
  - &#34;{{ base_dir }}/bin/cni-bin/*&#34;

- name: 添加 kubectl 自动补全
  lineinfile:
    dest: ~/.bashrc
    state: present
    regexp: &#39;kubectl completion&#39;
    line: &#39;source &lt;(kubectl completion bash) # generated by kubeasz&#39;

##----------kubelet 配置部分--------------
# 创建 kubelet 相关证书及 kubelet.kubeconfig
- import_tasks: create-kubelet-kubeconfig.yml
  tags: force_change_certs

- name: 准备 cni配置文件
  template: src=cni-default.conf.j2 dest=/etc/cni/net.d/10-default.conf

- name: 创建kubelet的配置文件
  template: src=kubelet-config.yaml.j2 dest=/var/lib/kubelet/config.yaml
  tags: upgrade_k8s, restart_node

- name: 检查文件/run/systemd/resolve/resolv.conf
  stat: path=&#34;/run/systemd/resolve/resolv.conf&#34;
  register: resolv
  tags: upgrade_k8s, restart_node

- name: 替换resolvConf 配置
  lineinfile:
    dest: /var/lib/kubelet/config.yaml
    state: present
    regexp: &#39;resolvConf&#39;
    line: &#39;resolvConf: /run/systemd/resolve/resolv.conf&#39;
  when: &#34;resolv.stat.isreg is defined&#34;
  tags: upgrade_k8s, restart_node

- name: 创建kubelet的systemd unit文件
  template: src=kubelet.service.j2 dest=/etc/systemd/system/kubelet.service
  tags: upgrade_k8s, restart_node

- name: 开机启用kubelet 服务
  shell: systemctl enable kubelet
  ignore_errors: true

- name: 开启kubelet 服务
  shell: systemctl daemon-reload &amp;&amp; systemctl restart kubelet
  tags: upgrade_k8s, restart_node, force_change_certs

##-------kube-proxy部分----------------
- name: 分发 kube-proxy.kubeconfig配置文件
  copy: src={{ cluster_dir }}/kube-proxy.kubeconfig dest=/etc/kubernetes/kube-proxy.kubeconfig
  tags: force_change_certs

- name: 替换 kube-proxy.kubeconfig 的 apiserver 地址
  lineinfile:
    dest: /etc/kubernetes/kube-proxy.kubeconfig
    regexp: &#34;^    server&#34;
    line: &#34;    server: {{ KUBE_APISERVER }}&#34;
  tags: force_change_certs

- name: 创建kube-proxy 配置
  template: src=kube-proxy-config.yaml.j2 dest=/var/lib/kube-proxy/kube-proxy-config.yaml
  tags: reload-kube-proxy, restart_node, upgrade_k8s

- name: 创建kube-proxy 服务文件
  template: src=kube-proxy.service.j2 dest=/etc/systemd/system/kube-proxy.service
  tags: reload-kube-proxy, restart_node, upgrade_k8s

- name: 开机启用kube-proxy 服务
  shell: systemctl enable kube-proxy
  ignore_errors: true

- name: 开启kube-proxy 服务
  shell: systemctl daemon-reload &amp;&amp; systemctl restart kube-proxy
  tags: reload-kube-proxy, upgrade_k8s, restart_node, force_change_certs

# 轮询等待kube-proxy启动完成
- name: 轮询等待kube-proxy启动
  shell: &#34;systemctl is-active kube-proxy.service&#34;
  register: kubeproxy_status
  until: &#39;&#34;active&#34; in kubeproxy_status.stdout&#39;
  retries: 4
  delay: 2
  tags: reload-kube-proxy, upgrade_k8s, restart_node, force_change_certs

# 轮询等待kubelet启动完成
- name: 轮询等待kubelet启动
  shell: &#34;systemctl is-active kubelet.service&#34;
  register: kubelet_status
  until: &#39;&#34;active&#34; in kubelet_status.stdout&#39;
  retries: 4
  delay: 2
  tags: reload-kube-proxy, upgrade_k8s, restart_node, force_change_certs

- name: 轮询等待node达到Ready状态
  shell: &#34;{{ base_dir }}/bin/kubectl get node {{ K8S_NODENAME }}|awk &#39;NR&gt;1{print $2}&#39;&#34;
  register: node_status
  until: node_status.stdout == &#34;Ready&#34; or node_status.stdout == &#34;Ready,SchedulingDisabled&#34;
  retries: 8 
  delay: 8
  tags: upgrade_k8s, restart_node, force_change_certs
  connection: local

- block:
  - name: Setting worker role name
    shell: &#34;{{ base_dir }}/bin/kubectl label node {{ K8S_NODENAME }} kubernetes.io/role=node --overwrite&#34;

  - name: Setting master role name
    shell: &#34;{{ base_dir }}/bin/kubectl label node {{ K8S_NODENAME }} kubernetes.io/role=master --overwrite&#34;
    when: &#34;inventory_hostname in groups[&#39;kube_master&#39;]&#34;

  - name: Making master nodes SchedulingDisabled
    shell: &#34;{{ base_dir }}/bin/kubectl cordon {{ K8S_NODENAME }} &#34;
    when: &#34;inventory_hostname not in groups[&#39;kube_node&#39;]&#34;
  ignore_errors: true
  connection: local
</code></pre><p>这个 Ansible Playbook 是用于将一个新节点加入 Kubernetes 集群的过程，涵盖了以下几个步骤：</p><h3 id=1-创建必要的目录><strong>1. 创建必要的目录</strong>
<a class=anchor href=#1-%e5%88%9b%e5%bb%ba%e5%bf%85%e8%a6%81%e7%9a%84%e7%9b%ae%e5%bd%95>#</a></h3><ul><li><p>创建节点相关目录</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建kube_node 相关目录</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>file</span>: <span style=color:#ae81ff>name={{ item }} state=directory</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with_items</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>/var/lib/kubelet</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>/var/lib/kube-proxy</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>/etc/cni/net.d</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>/opt/cni/bin</span>
</span></span></code></pre></div><p>这些目录是 Kubernetes 组件（如</p><pre tabindex=0><code>kubelet
</code></pre><p>和</p><pre tabindex=0><code>kube-proxy
</code></pre><p>）运行所必需的，确保新节点有这些目录。</p></li></ul><h3 id=2-下载二进制文件><strong>2. 下载二进制文件</strong>
<a class=anchor href=#2-%e4%b8%8b%e8%bd%bd%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6>#</a></h3><ul><li><p><strong>下载 <code>kubelet</code>, <code>kube-proxy</code>, <code>kubectl</code></strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>下载 kubelet,kube-proxy 二进制</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>: <span style=color:#ae81ff>src={{ base_dir }}/bin/{{ item }} dest={{ bin_dir }}/{{ item }} mode=0755</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with_items</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>kubectl</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>kubelet</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>kube-proxy</span>
</span></span></code></pre></div><p>将 <code>kubelet</code>, <code>kube-proxy</code>, <code>kubectl</code> 等二进制文件分发到目标节点，确保节点能够与 Kubernetes 集群进行通信和管理。</p></li><li><p><strong>下载 CNI 插件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>下载 cni plugins 二进制文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>: <span style=color:#ae81ff>src={{ item }} dest=/opt/cni/bin/ mode=0755</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with_fileglob</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;{{ base_dir }}/bin/cni-bin/*&#34;</span>
</span></span></code></pre></div><p>CNI 插件用于管理容器网络。</p></li></ul><h3 id=3-配置文件设置><strong>3. 配置文件设置</strong>
<a class=anchor href=#3-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e8%ae%be%e7%bd%ae>#</a></h3><ul><li><p>添加 kubectl 自动补全</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>添加 kubectl 自动补全</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>lineinfile</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#ae81ff>~/.bashrc</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>present</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>regexp</span>: <span style=color:#e6db74>&#39;kubectl completion&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>line</span>: <span style=color:#e6db74>&#39;source &lt;(kubectl completion bash) # generated by kubeasz&#39;</span>
</span></span></code></pre></div><p>为</p><pre tabindex=0><code>kubectl
</code></pre><p>设置自动补全功能，方便后续操作。</p></li></ul><h3 id=4-配置-kubelet><strong>4. 配置 Kubelet</strong>
<a class=anchor href=#4-%e9%85%8d%e7%bd%ae-kubelet>#</a></h3><ul><li><p><strong>创建 Kubelet 配置文件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建kubelet的配置文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>: <span style=color:#ae81ff>src=kubelet-config.yaml.j2 dest=/var/lib/kubelet/config.yaml</span>
</span></span></code></pre></div><p>创建 <code>kubelet</code> 的配置文件，配置节点如何加入 Kubernetes 集群。</p></li><li><p><strong>配置 DNS 设置</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>替换resolvConf 配置</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>lineinfile</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#ae81ff>/var/lib/kubelet/config.yaml</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>present</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>regexp</span>: <span style=color:#e6db74>&#39;resolvConf&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>line: &#39;resolvConf</span>: <span style=color:#ae81ff>/run/systemd/resolve/resolv.conf&#39;</span>
</span></span></code></pre></div><p>修改 <code>kubelet</code> 配置文件，确保 DNS 配置正确。</p></li><li><p><strong>创建 <code>kubelet</code> 的 <code>systemd</code> 服务文件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建kubelet的systemd unit文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>: <span style=color:#ae81ff>src=kubelet.service.j2 dest=/etc/systemd/system/kubelet.service</span>
</span></span></code></pre></div><p>创建 <code>kubelet</code> 的 <code>systemd</code> 服务文件，以便通过 <code>systemd</code> 管理服务的启动和停止。</p></li><li><p><strong>启用并启动 <code>kubelet</code> 服务</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>开机启用kubelet 服务</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>systemctl enable kubelet</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ignore_errors</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>开启kubelet 服务</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>systemctl daemon-reload &amp;&amp; systemctl restart kubelet</span>
</span></span></code></pre></div></li></ul><h3 id=5-配置-kube-proxy><strong>5. 配置 Kube-proxy</strong>
<a class=anchor href=#5-%e9%85%8d%e7%bd%ae-kube-proxy>#</a></h3><ul><li><p><strong>下载并配置 <code>kube-proxy.kubeconfig</code></strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>分发 kube-proxy.kubeconfig配置文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>: <span style=color:#ae81ff>src={{ cluster_dir }}/kube-proxy.kubeconfig dest=/etc/kubernetes/kube-proxy.kubeconfig</span>
</span></span></code></pre></div><p>配置 <code>kube-proxy</code> 的 <code>kubeconfig</code>，使其能够与 Kubernetes 集群进行通信。</p></li><li><p><strong>创建 <code>kube-proxy</code> 配置文件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建kube-proxy 配置</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>: <span style=color:#ae81ff>src=kube-proxy-config.yaml.j2 dest=/var/lib/kube-proxy/kube-proxy-config.yaml</span>
</span></span></code></pre></div></li><li><p><strong>创建 <code>kube-proxy</code> 服务文件</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建kube-proxy 服务文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>: <span style=color:#ae81ff>src=kube-proxy.service.j2 dest=/etc/systemd/system/kube-proxy.service</span>
</span></span></code></pre></div></li><li><p><strong>启用并启动 <code>kube-proxy</code> 服务</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>开机启用kube-proxy 服务</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>systemctl enable kube-proxy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ignore_errors</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>开启kube-proxy 服务</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>systemctl daemon-reload &amp;&amp; systemctl restart kube-proxy</span>
</span></span></code></pre></div></li></ul><h3 id=6-服务启动监控与等待><strong>6. 服务启动监控与等待</strong>
<a class=anchor href=#6-%e6%9c%8d%e5%8a%a1%e5%90%af%e5%8a%a8%e7%9b%91%e6%8e%a7%e4%b8%8e%e7%ad%89%e5%be%85>#</a></h3><ul><li><p><strong>轮询等待 <code>kube-proxy</code> 启动完成</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>轮询等待kube-proxy启动</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#e6db74>&#34;systemctl is-active kube-proxy.service&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>register</span>: <span style=color:#ae81ff>kubeproxy_status</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>until</span>: <span style=color:#e6db74>&#39;&#34;active&#34; in kubeproxy_status.stdout&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>retries</span>: <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>delay</span>: <span style=color:#ae81ff>2</span>
</span></span></code></pre></div></li><li><p><strong>轮询等待 <code>kubelet</code> 启动完成</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>轮询等待kubelet启动</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#e6db74>&#34;systemctl is-active kubelet.service&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>register</span>: <span style=color:#ae81ff>kubelet_status</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>until</span>: <span style=color:#e6db74>&#39;&#34;active&#34; in kubelet_status.stdout&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>retries</span>: <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>delay</span>: <span style=color:#ae81ff>2</span>
</span></span></code></pre></div></li><li><p><strong>轮询等待节点状态变为 <code>Ready</code></strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>轮询等待node达到Ready状态</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#e6db74>&#34;{{ base_dir }}/bin/kubectl get node {{ K8S_NODENAME }}|awk &#39;NR&gt;1{print $2}&#39;&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>register</span>: <span style=color:#ae81ff>node_status</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>until</span>: <span style=color:#ae81ff>node_status.stdout == &#34;Ready&#34; or node_status.stdout == &#34;Ready,SchedulingDisabled&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>retries</span>: <span style=color:#ae81ff>8</span> 
</span></span><span style=display:flex><span>  <span style=color:#f92672>delay</span>: <span style=color:#ae81ff>8</span>
</span></span></code></pre></div></li></ul><h3 id=7-标签和调度控制><strong>7. 标签和调度控制</strong>
<a class=anchor href=#7-%e6%a0%87%e7%ad%be%e5%92%8c%e8%b0%83%e5%ba%a6%e6%8e%a7%e5%88%b6>#</a></h3><ul><li><p><strong>设置节点角色标签</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Setting worker role name</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#e6db74>&#34;{{ base_dir }}/bin/kubectl label node {{ K8S_NODENAME }} kubernetes.io/role=node --overwrite&#34;</span>
</span></span></code></pre></div></li><li><p><strong>为主节点设置调度禁用</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Making master nodes SchedulingDisabled</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#e6db74>&#34;{{ base_dir }}/bin/kubectl cordon {{ K8S_NODENAME }} &#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#e6db74>&#34;inventory_hostname not in groups[&#39;kube_node&#39;]&#34;</span>
</span></span></code></pre></div></li></ul><h3 id=总结-24><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-24>#</a></h3><p>这个 Playbook 的步骤主要是：</p><ol><li>创建 Kubernetes 节点所需的目录和配置。</li><li>下载并配置所需的二进制文件（<code>kubelet</code>、<code>kube-proxy</code>、<code>kubectl</code> 和 CNI 插件）。</li><li>配置并启用 <code>kubelet</code> 和 <code>kube-proxy</code> 服务，确保它们在系统启动时自动启动。</li><li>检查并等待 <code>kubelet</code> 和 <code>kube-proxy</code> 启动成功，并确保节点的状态变为 <code>Ready</code>。</li><li>设置节点角色标签，并在必要时对主节点执行调度禁用（<code>cordon</code>）操作。</li></ol><p>总体来看，它是一个自动化的 Kubernetes 节点加入过程，配置并启动了节点所需的所有服务，使节点能够顺利加入 Kubernetes 集群。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#linux>Linux</a></li><li><a href=#grep-sed-awk-cut组合使用>grep sed awk cut组合使用☆</a><ul><li><a href=#1-使用-grep--cut筛选和提取字段>1. 使用 <code>grep</code> + <code>cut</code>：筛选和提取字段</a></li><li><a href=#2-使用-grep--awk筛选和处理文本>2. 使用 <code>grep</code> + <code>awk</code>：筛选和处理文本</a></li><li><a href=#3-使用-sed--awk修改并处理文本>3. 使用 <code>sed</code> + <code>awk</code>：修改并处理文本</a></li><li><a href=#4-使用-grep--sed--awk综合使用>4. 使用 <code>grep</code> + <code>sed</code> + <code>awk</code>：综合使用</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#http错误码和原因>http错误码和原因</a><ul><li><a href=#1-1xx---信息类>1. <strong>1xx - 信息类</strong></a></li><li><a href=#2-2xx---成功类>2. <strong>2xx - 成功类</strong></a></li><li><a href=#3-3xx---重定向类>3. <strong>3xx - 重定向类</strong></a></li><li><a href=#4-4xx---客户端错误类>4. <strong>4xx - 客户端错误类</strong></a></li><li><a href=#5-5xx---服务器错误类>5. <strong>5xx - 服务器错误类</strong></a></li><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#3长连接短连接websocket区别和使用场景>3.长连接、短连接、WebSocket区别和使用场景</a><ul><li><a href=#1-短连接short-connection>1. <strong>短连接（Short Connection）</strong></a></li><li><a href=#2-长连接long-connection>2. <strong>长连接（Long Connection）</strong></a></li><li><a href=#3-websocket>3. <strong>WebSocket</strong></a></li><li><a href=#总结比较><strong>总结比较</strong></a></li><li><a href=#适用场景总结>适用场景总结：</a></li></ul></li><li><a href=#nginx性能优化有哪些方式>nginx性能优化有哪些方式☆</a><ul><li><a href=#1-调整工作进程和连接数>1. <strong>调整工作进程和连接数</strong></a></li><li><a href=#2-启用>2. <strong>启用 <code>keepalive</code> 持久连接</strong></a></li><li><a href=#3-启用-gzip-压缩>3. <strong>启用 GZIP 压缩</strong></a></li><li><a href=#4-优化缓存策略>4. <strong>优化缓存策略</strong></a></li><li><a href=#5-负载均衡优化>5. <strong>负载均衡优化</strong></a></li><li><a href=#6-减少-dns-查询延迟>6. <strong>减少 DNS 查询延迟</strong></a></li><li><a href=#7-提高文件-io-性能>7. <strong>提高文件 I/O 性能</strong></a></li><li><a href=#8-调整-tcp-连接优化>8. <strong>调整 TCP 连接优化</strong></a></li><li><a href=#9-限制请求速率>9. <strong>限制请求速率</strong></a></li><li><a href=#10-禁用不必要的模块>10. <strong>禁用不必要的模块</strong></a></li><li><a href=#11-监控和日志优化>11. <strong>监控和日志优化</strong></a></li><li><a href=#总结-2>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-lvslinux-virtual-server>1. <strong>LVS（Linux Virtual Server）</strong></a></li><li><a href=#2-nginx>2. <strong>Nginx</strong></a></li><li><a href=#3-haproxy>3. <strong>HAProxy</strong></a></li><li><a href=#总结比较-1><strong>总结比较</strong></a></li><li><a href=#选择建议><strong>选择建议</strong>：</a></li></ul></li></ul><ul><li><ul><li><a href=#为什么会产生僵尸进程><strong>为什么会产生僵尸进程？</strong></a></li><li><a href=#僵尸进程的特征><strong>僵尸进程的特征</strong></a></li><li><a href=#如何查看僵尸进程><strong>如何查看僵尸进程？</strong></a></li><li><a href=#如何解决僵尸进程><strong>如何解决僵尸进程？</strong></a></li><li><a href=#总结-3><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程process>1. <strong>进程（Process）</strong></a></li><li><a href=#2-线程thread>2. <strong>线程（Thread）</strong></a></li><li><a href=#3-协程coroutine>3. <strong>协程（Coroutine）</strong></a></li><li><a href=#进程线程协程对比><strong>进程、线程、协程对比</strong></a></li><li><a href=#总结-4><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-异步asynchronous><strong>1. 异步（Asynchronous）</strong></a></li><li><a href=#2-非阻塞non-blocking><strong>2. 非阻塞（Non-blocking）</strong></a></li><li><a href=#3-事件驱动模型><strong>3. 事件驱动模型</strong></a></li><li><a href=#4-单线程处理多个请求><strong>4. 单线程处理多个请求</strong></a></li><li><a href=#5-通过工作模式管理多个连接><strong>5. 通过工作模式管理多个连接</strong></a></li><li><a href=#6-典型的异步非阻塞处理流程><strong>6. 典型的异步非阻塞处理流程</strong></a></li><li><a href=#异步非阻塞的优势><strong>异步非阻塞的优势</strong></a></li><li><a href=#总结-5><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用>1. <strong>使用 <code>ping</code> 命令测试丢包情况</strong></a></li><li><a href=#2-检查网络接口的丢包情况>2. <strong>检查网络接口的丢包情况</strong></a></li><li><a href=#3-查看系统日志>3. <strong>查看系统日志</strong></a></li><li><a href=#4-使用>4. <strong>使用 <code>netstat</code> 查看网络连接情况</strong></a></li><li><a href=#5-使用>5. <strong>使用 <code>traceroute</code> 检查网络路径</strong></a></li><li><a href=#6-查看系统资源是否不足>6. <strong>查看系统资源是否不足</strong></a></li><li><a href=#7-调整-tcp-缓冲区>7. <strong>调整 TCP 缓冲区</strong></a></li><li><a href=#8-使用>8. <strong>使用 <code>ss</code> 工具进行网络连接分析</strong></a></li><li><a href=#9-检查网卡驱动和硬件问题>9. <strong>检查网卡驱动和硬件问题</strong></a></li><li><a href=#10-网络带宽和流量限制>10. <strong>网络带宽和流量限制</strong></a></li><li><a href=#总结-6>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-top>1. <strong><code>top</code></strong></a></li><li><a href=#2-htop>2. <strong><code>htop</code></strong></a></li><li><a href=#3-vmstat>3. <strong><code>vmstat</code></strong></a></li><li><a href=#4-iostat>4. <strong><code>iostat</code></strong></a></li><li><a href=#5-netstat>5. <strong><code>netstat</code></strong></a></li><li><a href=#6-ss>6. <strong><code>ss</code></strong></a></li><li><a href=#7-sar>7. <strong><code>sar</code></strong></a></li><li><a href=#8-dstat>8. <strong><code>dstat</code></strong></a></li><li><a href=#9-strace>9. <strong><code>strace</code></strong></a></li><li><a href=#10-perf>10. <strong><code>perf</code></strong></a></li><li><a href=#11-lsof>11. <strong><code>lsof</code></strong></a></li><li><a href=#12-iotop>12. <strong><code>iotop</code></strong></a></li><li><a href=#13-mpstat>13. <strong><code>mpstat</code></strong></a></li><li><a href=#总结-7>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#进程中断的种类>进程中断的种类</a></li><li><a href=#进程中断的工作流程>进程中断的工作流程</a></li><li><a href=#中断的优先级和中断屏蔽>中断的优先级和中断屏蔽</a></li><li><a href=#进程中断的作用>进程中断的作用</a></li><li><a href=#总结-8>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-硬中断-hardware-interrupt>1. <strong>硬中断 (Hardware Interrupt)</strong></a></li><li><a href=#2-软中断-software-interrupt>2. <strong>软中断 (Software Interrupt)</strong></a></li><li><a href=#硬中断与软中断的区别><strong>硬中断与软中断的区别</strong></a></li><li><a href=#应用场景和作用><strong>应用场景和作用</strong></a></li><li><a href=#总结-9>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-不可中断进程的特点>1. <strong>不可中断进程的特点</strong></a></li><li><a href=#2-不可中断进程的常见原因>2. <strong>不可中断进程的常见原因</strong></a></li><li><a href=#3-不可中断进程的处理>3. <strong>不可中断进程的处理</strong></a></li><li><a href=#4-不可中断进程的例子>4. <strong>不可中断进程的例子</strong></a></li><li><a href=#5-如何排查不可中断进程>5. <strong>如何排查不可中断进程</strong></a></li><li><a href=#总结-10>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-栈内存-stack-memory>1. <strong>栈内存 (Stack Memory)</strong></a></li><li><a href=#2-堆内存-heap-memory>2. <strong>堆内存 (Heap Memory)</strong></a></li><li><a href=#栈内存与堆内存的区别><strong>栈内存与堆内存的区别</strong></a></li><li><a href=#栈内存与堆内存的选择><strong>栈内存与堆内存的选择</strong></a></li><li><a href=#总结-11>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#进程状态的常见字母及其含义>进程状态的常见字母及其含义：</a></li><li><a href=#top><strong><code>top</code> 命令输出中的进程状态字段示例</strong>：</a></li><li><a href=#s><strong><code>S</code>、<code>D</code> 和 <code>Z</code> 状态的具体说明</strong>：</a></li><li><a href=#进程状态总结>进程状态总结：</a></li><li><a href=#其他补充>其他补充：</a></li></ul></li></ul><ul><li><ul><li><a href=#proc-目录的主要作用><code>/proc</code> 目录的主要作用</a></li><li><a href=#proc-目录中的重要文件和子目录><code>/proc</code> 目录中的重要文件和子目录</a></li><li><a href=#使用-proc-的常见场景>使用 <code>/proc</code> 的常见场景</a></li><li><a href=#示例-6>示例</a></li><li><a href=#总结-12>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-load负载>1. <strong>Load（负载）</strong></a></li><li><a href=#2-cpu-使用率>2. <strong>CPU 使用率</strong></a></li><li><a href=#load-和-cpu-使用率的区别><strong>Load 和 CPU 使用率的区别</strong></a></li><li><a href=#如何判断系统性能问题><strong>如何判断系统性能问题</strong></a></li><li><a href=#总结-13>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#如何通过-arp-转换-mac-地址和-ip-地址><strong>如何通过 ARP 转换 MAC 地址和 IP 地址：</strong></a></li><li><a href=#arp-工作原理><strong>ARP 工作原理：</strong></a></li><li><a href=#例子><strong>例子：</strong></a></li><li><a href=#总结-14><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#常见的-raid-级别>常见的 RAID 级别</a></li><li><a href=#总结-15>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#lvm-的基本概念>LVM 的基本概念</a></li><li><a href=#lvm-的常用操作>LVM 的常用操作</a></li><li><a href=#lvm-的优缺点>LVM 的优缺点</a></li><li><a href=#总结-16>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-使用-1>1. <strong>使用 <code>jps</code> 命令查看 JVM 进程</strong></a></li><li><a href=#2-使用>2. <strong>使用 <code>jvm</code> 参数查看内存设置</strong></a></li><li><a href=#3-使用>3. <strong>使用 <code>jstat</code> 命令查看 JVM 内存统计</strong></a></li><li><a href=#4-使用-1>4. <strong>使用 <code>jmap</code> 命令查看堆内存信息</strong></a></li><li><a href=#5-使用-1>5. <strong>使用 <code>visualvm</code> 或 <code>jconsole</code> 图形化工具</strong></a></li><li><a href=#6-使用>6. <strong>使用 <code>-XX:+PrintGCDetails</code> 参数查看垃圾回收日志</strong></a></li><li><a href=#7-查看系统层面的内存使用>7. <strong>查看系统层面的内存使用</strong></a></li><li><a href=#8-查看-metaspace-使用情况>8. <strong>查看 Metaspace 使用情况</strong></a></li><li><a href=#总结-17>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-查看当前内核参数>1. <strong>查看当前内核参数</strong></a></li><li><a href=#2-修改内核参数>2. <strong>修改内核参数</strong></a></li><li><a href=#3-常用内核参数及其优化>3. <strong>常用内核参数及其优化</strong></a></li><li><a href=#4-监控内核参数>4. <strong>监控内核参数</strong></a></li><li><a href=#5-调整参数的策略>5. <strong>调整参数的策略</strong></a></li><li><a href=#6-注意事项>6. <strong>注意事项</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程最大数max-processes>1. <strong>进程最大数（max processes）</strong></a></li><li><a href=#2-最大线程数max-threads>2. <strong>最大线程数（max threads）</strong></a></li><li><a href=#3-进程打开的文件数open-files>3. <strong>进程打开的文件数（open files）</strong></a></li><li><a href=#总结-18>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#1-统计对象不同>1. <strong>统计对象不同</strong></a></li><li><a href=#2-文件系统预留空间>2. <strong>文件系统预留空间</strong></a></li><li><a href=#3-软链接和挂载点>3. <strong>软链接和挂载点</strong></a></li><li><a href=#4-文件系统缓存>4. <strong>文件系统缓存</strong></a></li><li><a href=#5-挂载点重复>5. <strong>挂载点重复</strong></a></li><li><a href=#6-延迟同步文件删除>6. <strong>延迟同步（文件删除）</strong></a></li><li><a href=#7-du>7. <strong><code>du</code> 计算的单位和 <code>df</code> 的单位不同</strong></a></li><li><a href=#8-nfs-或网络文件系统>8. <strong>NFS 或网络文件系统</strong></a></li><li><a href=#9-磁盘碎片>9. <strong>磁盘碎片</strong></a></li><li><a href=#解决办法>解决办法：</a></li><li><a href=#总结-19>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-buffers>1. <strong><code>buffers</code></strong></a></li><li><a href=#2-cached>2. <strong><code>cached</code></strong></a></li><li><a href=#3-buffers>3. <strong><code>buffers</code> 与 <code>cached</code> 的区别</strong></a></li><li><a href=#4-总结>4. <strong>总结</strong></a></li><li><a href=#5-实际影响>5. <strong>实际影响</strong></a></li><li><a href=#6-释放缓存>6. <strong>释放缓存</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-查看某个进程打开的文件>1. <strong>查看某个进程打开的文件</strong></a></li><li><a href=#2-查看某个用户打开的文件>2. <strong>查看某个用户打开的文件</strong></a></li><li><a href=#3-查看特定文件的打开情况>3. <strong>查看特定文件的打开情况</strong></a></li><li><a href=#4-查看某个端口被哪个进程占用>4. <strong>查看某个端口被哪个进程占用</strong></a></li><li><a href=#5-查看文件系统的某个挂载点>5. <strong>查看文件系统的某个挂载点</strong></a></li><li><a href=#6-查找删除的文件>6. <strong>查找删除的文件</strong></a></li><li><a href=#7-查看文件锁>7. <strong>查看文件锁</strong></a></li><li><a href=#8-查看打开的网络文件tcpudp>8. <strong>查看打开的网络文件（TCP/UDP）</strong></a></li><li><a href=#9-查找进程占用的文件描述符>9. <strong>查找进程占用的文件描述符</strong></a></li><li><a href=#10-监控进程创建的临时文件>10. <strong>监控进程创建的临时文件</strong></a></li><li><a href=#总结-20>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#常见的-linux-进程间通信方式>常见的 Linux 进程间通信方式</a></li><li><a href=#1-管道pipe>1. <strong>管道（Pipe）</strong></a></li><li><a href=#2-命名管道fifo>2. <strong>命名管道（FIFO）</strong></a></li><li><a href=#3-消息队列message-queue>3. <strong>消息队列（Message Queue）</strong></a></li><li><a href=#4-信号signal>4. <strong>信号（Signal）</strong></a></li><li><a href=#5-共享内存shared-memory>5. <strong>共享内存（Shared Memory）</strong></a></li><li><a href=#6-信号量semaphore>6. <strong>信号量（Semaphore）</strong></a></li><li><a href=#7-套接字socket>7. <strong>套接字（Socket）</strong></a></li><li><a href=#8-内存映射memory-mapping>8. <strong>内存映射（Memory Mapping）</strong></a></li><li><a href=#总结-21>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程优先级的概念>1. <strong>进程优先级的概念</strong></a></li><li><a href=#2-优先级与>2. <strong>优先级与 <code>nice</code> 值</strong></a></li><li><a href=#3-查看进程的优先级>3. <strong>查看进程的优先级</strong></a></li><li><a href=#4-修改进程的>4. <strong>修改进程的 <code>nice</code> 值</strong></a></li><li><a href=#5-进程调度策略与优先级>5. <strong>进程调度策略与优先级</strong></a></li><li><a href=#6-查看进程调度策略>6. <strong>查看进程调度策略</strong></a></li><li><a href=#7-优先级调整的使用场景>7. <strong>优先级调整的使用场景</strong></a></li><li><a href=#8-总结>8. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-进程优先级的概念-1>1. <strong>进程优先级的概念</strong></a></li><li><a href=#2-优先级与-1>2. <strong>优先级与 <code>nice</code> 值</strong></a></li><li><a href=#3-查看进程的优先级-1>3. <strong>查看进程的优先级</strong></a></li><li><a href=#4-修改进程的-1>4. <strong>修改进程的 <code>nice</code> 值</strong></a></li><li><a href=#5-进程调度策略与优先级-1>5. <strong>进程调度策略与优先级</strong></a></li><li><a href=#6-查看进程调度策略-1>6. <strong>查看进程调度策略</strong></a></li><li><a href=#7-优先级调整的使用场景-1>7. <strong>优先级调整的使用场景</strong></a></li><li><a href=#8-总结-1>8. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-创建自定义-systemd-服务>1. <strong>创建自定义 systemd 服务</strong></a></li><li><a href=#2-管理自定义-systemd-服务>2. <strong>管理自定义 systemd 服务</strong></a></li><li><a href=#3-高级配置>3. <strong>高级配置</strong></a></li><li><a href=#4-总结-1>4. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-内核模块的加载过程>1. <strong>内核模块的加载过程</strong></a></li><li><a href=#2-内核模块的卸载过程>2. <strong>内核模块的卸载过程</strong></a></li><li><a href=#3-内核模块管理的其他相关命令>3. <strong>内核模块管理的其他相关命令</strong></a></li><li><a href=#4-自动加载模块>4. <strong>自动加载模块</strong></a></li><li><a href=#5-总结>5. <strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#ansible-roles-使用场景><strong>Ansible Roles 使用场景</strong></a></li><li><a href=#ansible-roles-目录结构><strong>Ansible Roles 目录结构</strong></a></li><li><a href=#如何用-ansible-批量将多台机器加入-kubernetes-集群><strong>如何用 Ansible 批量将多台机器加入 Kubernetes 集群</strong></a></li><li><a href=#总结-22><strong>总结</strong></a></li><li><a href=#1-准备角色和任务>1. <strong>准备角色和任务</strong></a></li><li><a href=#2-systemd>2. <strong><code>systemd</code> 服务配置文件</strong></a></li><li><a href=#3-主机清单文件>3. <strong>主机清单文件</strong></a></li><li><a href=#4-playbook-配置>4. <strong>Playbook 配置</strong></a></li><li><a href=#5-执行-playbook>5. <strong>执行 Playbook</strong></a></li><li><a href=#6-总结>6. <strong>总结</strong></a></li><li><a href=#1-dockerd-docker-daemon>1. <strong><code>dockerd</code></strong> (Docker Daemon)</a></li><li><a href=#2-docker-docker-cli>2. <strong><code>docker</code></strong> (Docker CLI)</a></li><li><a href=#3-containerd-container-runtime>3. <strong><code>containerd</code></strong> (Container Runtime)</a></li><li><a href=#4-runc-low-level-container-runtime>4. <strong><code>runc</code></strong> (Low-level Container Runtime)</a></li><li><a href=#5-ctr-containerd-cli>5. <strong><code>ctr</code></strong> (Containerd CLI)</a></li><li><a href=#6-dockerd>6. <strong><code>dockerd</code> 配置文件和插件</strong></a></li><li><a href=#7-docker-compose-用于管理多容器应用>7. <strong><code>docker-compose</code></strong> (用于管理多容器应用)</a></li><li><a href=#常见安装路径><strong>常见安装路径：</strong></a></li><li><a href=#docker-依赖的其他组件><strong>Docker 依赖的其他组件：</strong></a></li><li><a href=#总结-23><strong>总结</strong></a></li><li><a href=#1-创建必要的目录><strong>1. 创建必要的目录</strong></a></li><li><a href=#2-下载二进制文件><strong>2. 下载二进制文件</strong></a></li><li><a href=#3-配置文件设置><strong>3. 配置文件设置</strong></a></li><li><a href=#4-配置-kubelet><strong>4. 配置 Kubelet</strong></a></li><li><a href=#5-配置-kube-proxy><strong>5. 配置 Kube-proxy</strong></a></li><li><a href=#6-服务启动监控与等待><strong>6. 服务启动监控与等待</strong></a></li><li><a href=#7-标签和调度控制><strong>7. 标签和调度控制</strong></a></li><li><a href=#总结-24><strong>总结</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>