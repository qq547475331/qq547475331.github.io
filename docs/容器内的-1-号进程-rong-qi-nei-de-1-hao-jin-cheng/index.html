<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  简介
  #


  在 Linux 系统中，系统启动的时候先是执行内核态的代码，然后在内核中调用 1 号进程的代码，从内核态切换到用户态。内核执行的第一个用户态程序就是 1 号进程。
  #


  目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程。
  #


  同样在容器中也有 1 号进程的概念，一旦容器建立了自己的 **Pid Namespace（进程命名空间)，**这个 Namespace 里的进程号也是从 1 开始标记的。
  #


  1 号进程是第一个用户态的进程，由它直接或者间接创建了容器中的其他进程。
  #


  为什么杀不掉容器中 1号进程
  #


  通过几个实际的示例来说明
  #


  下面示例统一用如下 Dockerfile，启动一个休闲 600s 的容器。
  #

FROM ubuntu
ENTRYPOINT ["sleep", "600"]

  现象
  #

示例一

  在容器中使用 kill -9，kill -15 杀死 1 号进程
  #

$ docker run --name test -d test-init:v1
$ docker exec -it test bash
[root@4db3c6f1766b /]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 01:38 ?        00:00:00 sleep 600
root          6      0  2 01:39 pts/0    00:00:00 bash
root         13      6  0 01:39 pts/0    00:00:00 ps -ef

[root@5cc69036b7b2 /]# kill 1
[root@5cc69036b7b2 /]# kill -9 1
[root@5cc69036b7b2 /]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 01:38 ?        00:00:00 sleep 600
root          6      0  2 01:39 pts/0    00:00:00 bash
root         13      6  0 01:39 pts/0    00:00:00 ps -ef

  当我们完成前面的操作，就会发现无论运行 kill 1 (对应 Linux 中的 SIGTERM 信号) 还是 kill -9 1(对应 Linux 中的 SIGKILL 信号)，都无法让进程终止。那么问题来了，这两个常常用来终止进程的信号，都对容器中的 1号进程不起作用。
  #

示例二'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2024-04-03 容器内的 1 号进程"><meta property="og:description" content='简介 # 在 Linux 系统中，系统启动的时候先是执行内核态的代码，然后在内核中调用 1 号进程的代码，从内核态切换到用户态。内核执行的第一个用户态程序就是 1 号进程。 # 目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程。 # 同样在容器中也有 1 号进程的概念，一旦容器建立了自己的 **Pid Namespace（进程命名空间)，**这个 Namespace 里的进程号也是从 1 开始标记的。 # 1 号进程是第一个用户态的进程，由它直接或者间接创建了容器中的其他进程。 # 为什么杀不掉容器中 1号进程 # 通过几个实际的示例来说明 # 下面示例统一用如下 Dockerfile，启动一个休闲 600s 的容器。 # FROM ubuntu ENTRYPOINT ["sleep", "600"] 现象 # 示例一
在容器中使用 kill -9，kill -15 杀死 1 号进程 # $ docker run --name test -d test-init:v1 $ docker exec -it test bash [root@4db3c6f1766b /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 01:38 ? 00:00:00 sleep 600 root 6 0 2 01:39 pts/0 00:00:00 bash root 13 6 0 01:39 pts/0 00:00:00 ps -ef [root@5cc69036b7b2 /]# kill 1 [root@5cc69036b7b2 /]# kill -9 1 [root@5cc69036b7b2 /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 01:38 ? 00:00:00 sleep 600 root 6 0 2 01:39 pts/0 00:00:00 bash root 13 6 0 01:39 pts/0 00:00:00 ps -ef 当我们完成前面的操作，就会发现无论运行 kill 1 (对应 Linux 中的 SIGTERM 信号) 还是 kill -9 1(对应 Linux 中的 SIGKILL 信号)，都无法让进程终止。那么问题来了，这两个常常用来终止进程的信号，都对容器中的 1号进程不起作用。 # 示例二'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2024-04-03 容器内的 1 号进程 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.88a659fb8847c246a711980994cf17ddf51e31d05dde9d037cacf40daae9145c.js integrity="sha256-iKZZ+4hHwkanEZgJlM8X3fUeMdBd3p0DfKz0DarpFFw=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-5-7-%E6%8E%A5%E5%8D%95app/>2025-5-7 接单app设计</a></li><li><a href=/docs/2025-5-7-%E5%A5%BD%E5%BF%83%E6%80%81-app/>2025-5-7 好心态 app</a></li><li><a href=/docs/2025-4-28-cursor-agent-%E6%8F%90%E7%A4%BA%E5%99%A8/>2025-4-28 cursor agent 提示器</a></li><li><a href=/docs/2025-4-16-%E8%87%AA%E7%A0%94k8s%E5%B9%B3%E5%8F%B0/>2025-4-16 自研k8s平台</a></li><li><a href=/docs/2025-4-16-sleep%E7%9D%A1%E7%9C%A0%E5%BA%94%E7%94%A8/>2025-4-16 sleep睡眠应用</a></li><li><a href=/docs/2025-4-16-paas%E8%AE%BE%E8%AE%A1/>2025-4-16 paas开发记录</a></li><li><a href=/docs/2025-4-16-cursoe-free-vip/>2025-4-16 Cursor Free VIP</a></li><li><a href=/docs/2025-4-16-boss%E7%9B%B4%E8%81%98%E8%87%AA%E5%8A%A8%E6%8A%95%E9%80%92/>2025-4-16 BOSS直聘自动投递</a></li><li><a href=/docs/2025-4-14-github%E6%8E%A8%E9%80%81/>2025-4-14 github推送</a></li><li><a href=/docs/2025-3-30-metallb/>2025-3-30 metallb</a></li><li><a href=/docs/2025-3-24-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/>2025-3-24 自我介绍</a></li><li><a href=/docs/2025-3-20-victoriametrics-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics高可用架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 thanos高可用架构</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-08-01 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 k8s面试题</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-05-01 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-04-17 面试总结</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/ class=active>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-03-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-03-08 面试</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2024-03-04 k8s流量链路剖析</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2024-03-04 CSI剖析演进</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-03-04 CNI剖析演进</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-02-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-02-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-02-22 k8s架构师面试大全</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/2025-4-20-%E6%80%A7%E5%90%8C%E6%84%8Fapp/>2025 4 20 性同意app</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2024-04-03 容器内的 1 号进程</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li></li></ul></li><li><a href=#为什么杀不掉容器中-1号进程>为什么杀不掉容器中 1号进程</a><ul><li></li><li><a href=#现象>现象</a></li><li><a href=#linux-信号>Linux 信号</a></li><li><a href=#linux-信号处理原理>Linux 信号处理原理</a></li></ul></li><li><a href=#1-号进程与-init-进程>1 号进程与 init 进程</a><ul><li></li><li><a href=#1-号进程><strong>1 号进程</strong></a></li><li><a href=#init-进程><strong>init 进程</strong></a></li></ul></li><li><a href=#容器中的-init-进程>容器中的 init 进程</a><ul><li></li><li><a href=#shell-模式>shell 模式</a></li><li><a href=#exec-模式>exec 模式</a></li><li><a href=#使用-exec-命令>使用 exec 命令</a></li><li><a href=#使用-tini>使用 tini</a></li><li><a href=#使用场景>使用场景</a></li></ul></li><li><a href=#总结>总结</a><ul><li></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=简介>简介
<a class=anchor href=#%e7%ae%80%e4%bb%8b>#</a></h2><h5 id=在-linux-系统中系统启动的时候先是执行内核态的代码然后在内核中调用-1-号进程的代码从内核态切换到用户态内核执行的第一个用户态程序就是-1-号进程>在 Linux 系统中，系统启动的时候先是执行内核态的代码，然后在内核中调用 <strong>1 号进程</strong>的代码，从内核态切换到用户态。内核执行的第一个用户态程序就是 <strong>1 号进程。</strong>
<a class=anchor href=#%e5%9c%a8-linux-%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%b3%bb%e7%bb%9f%e5%90%af%e5%8a%a8%e7%9a%84%e6%97%b6%e5%80%99%e5%85%88%e6%98%af%e6%89%a7%e8%a1%8c%e5%86%85%e6%a0%b8%e6%80%81%e7%9a%84%e4%bb%a3%e7%a0%81%e7%84%b6%e5%90%8e%e5%9c%a8%e5%86%85%e6%a0%b8%e4%b8%ad%e8%b0%83%e7%94%a8-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%bb%a3%e7%a0%81%e4%bb%8e%e5%86%85%e6%a0%b8%e6%80%81%e5%88%87%e6%8d%a2%e5%88%b0%e7%94%a8%e6%88%b7%e6%80%81%e5%86%85%e6%a0%b8%e6%89%a7%e8%a1%8c%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%94%a8%e6%88%b7%e6%80%81%e7%a8%8b%e5%ba%8f%e5%b0%b1%e6%98%af-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=目前主流的-linux-发行版无论是-redhat-系的还是-debian-系的都会把-sbininit-作为符号链接指向-systemdsystemd-是目前最流行的-linux-init-进程在它之前还有-sysvinitupstart-等-linux-init-进程>目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程。
<a class=anchor href=#%e7%9b%ae%e5%89%8d%e4%b8%bb%e6%b5%81%e7%9a%84-linux-%e5%8f%91%e8%a1%8c%e7%89%88%e6%97%a0%e8%ae%ba%e6%98%af-redhat-%e7%b3%bb%e7%9a%84%e8%bf%98%e6%98%af-debian-%e7%b3%bb%e7%9a%84%e9%83%bd%e4%bc%9a%e6%8a%8a-sbininit-%e4%bd%9c%e4%b8%ba%e7%ac%a6%e5%8f%b7%e9%93%be%e6%8e%a5%e6%8c%87%e5%90%91-systemdsystemd-%e6%98%af%e7%9b%ae%e5%89%8d%e6%9c%80%e6%b5%81%e8%a1%8c%e7%9a%84-linux-init-%e8%bf%9b%e7%a8%8b%e5%9c%a8%e5%ae%83%e4%b9%8b%e5%89%8d%e8%bf%98%e6%9c%89-sysvinitupstart-%e7%ad%89-linux-init-%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=同样在容器中也有-1-号进程的概念一旦容器建立了自己的-pid-namespace进程命名空间这个-namespace-里的进程号也是从-1-开始标记的>同样在<strong>容器中</strong>也有 1 号进程的概念，一旦容器建立了自己的 **Pid Namespace（进程命名空间)，**这个 Namespace 里的进程号也是从 1 开始标记的。
<a class=anchor href=#%e5%90%8c%e6%a0%b7%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e4%b9%9f%e6%9c%89-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%a6%82%e5%bf%b5%e4%b8%80%e6%97%a6%e5%ae%b9%e5%99%a8%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%87%aa%e5%b7%b1%e7%9a%84-pid-namespace%e8%bf%9b%e7%a8%8b%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e8%bf%99%e4%b8%aa-namespace-%e9%87%8c%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%8f%b7%e4%b9%9f%e6%98%af%e4%bb%8e-1-%e5%bc%80%e5%a7%8b%e6%a0%87%e8%ae%b0%e7%9a%84>#</a></h5><h5 id=1-号进程是第一个用户态的进程由它直接或者间接创建了容器中的其他进程>1 号进程是第一个用户态的进程，由它直接或者间接创建了容器中的其他进程。
<a class=anchor href=#1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e6%98%af%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%94%a8%e6%88%b7%e6%80%81%e7%9a%84%e8%bf%9b%e7%a8%8b%e7%94%b1%e5%ae%83%e7%9b%b4%e6%8e%a5%e6%88%96%e8%80%85%e9%97%b4%e6%8e%a5%e5%88%9b%e5%bb%ba%e4%ba%86%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84%e5%85%b6%e4%bb%96%e8%bf%9b%e7%a8%8b>#</a></h5><h2 id=为什么杀不掉容器中-1号进程>为什么杀不掉容器中 1号进程
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9d%80%e4%b8%8d%e6%8e%89%e5%ae%b9%e5%99%a8%e4%b8%ad-1%e5%8f%b7%e8%bf%9b%e7%a8%8b>#</a></h2><h5 id=通过几个实际的示例来说明>通过几个实际的示例来说明
<a class=anchor href=#%e9%80%9a%e8%bf%87%e5%87%a0%e4%b8%aa%e5%ae%9e%e9%99%85%e7%9a%84%e7%a4%ba%e4%be%8b%e6%9d%a5%e8%af%b4%e6%98%8e>#</a></h5><h5 id=下面示例统一用如下-dockerfile启动一个休闲-600s-的容器>下面示例统一用如下 Dockerfile，启动一个休闲 <code>600s</code> 的容器。
<a class=anchor href=#%e4%b8%8b%e9%9d%a2%e7%a4%ba%e4%be%8b%e7%bb%9f%e4%b8%80%e7%94%a8%e5%a6%82%e4%b8%8b-dockerfile%e5%90%af%e5%8a%a8%e4%b8%80%e4%b8%aa%e4%bc%91%e9%97%b2-600s-%e7%9a%84%e5%ae%b9%e5%99%a8>#</a></h5><pre tabindex=0><code>FROM ubuntu
ENTRYPOINT [&#34;sleep&#34;, &#34;600&#34;]
</code></pre><h3 id=现象>现象
<a class=anchor href=#%e7%8e%b0%e8%b1%a1>#</a></h3><p><strong>示例一</strong></p><h5 id=在容器中使用-kill--9kill--15-杀死-1-号进程>在容器中使用 <code>kill -9，kill -15</code> 杀死 1 号进程
<a class=anchor href=#%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e4%bd%bf%e7%94%a8-kill--9kill--15-%e6%9d%80%e6%ad%bb-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b>#</a></h5><pre tabindex=0><code>$ docker run --name test -d test-init:v1
$ docker exec -it test bash
[root@4db3c6f1766b /]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 01:38 ?        00:00:00 sleep 600
root          6      0  2 01:39 pts/0    00:00:00 bash
root         13      6  0 01:39 pts/0    00:00:00 ps -ef

[root@5cc69036b7b2 /]# kill 1
[root@5cc69036b7b2 /]# kill -9 1
[root@5cc69036b7b2 /]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 01:38 ?        00:00:00 sleep 600
root          6      0  2 01:39 pts/0    00:00:00 bash
root         13      6  0 01:39 pts/0    00:00:00 ps -ef
</code></pre><h5 id=当我们完成前面的操作就会发现无论运行-kill-1-对应-linux-中的-sigterm-信号-还是-kill--9-1对应-linux-中的-sigkill-信号都无法让进程终止那么问题来了这两个常常用来终止进程的信号都对容器中的-1号进程不起作用>当我们完成前面的操作，就会发现无论运行 <code>kill 1</code> (对应 Linux 中的 <code>SIGTERM</code> 信号) 还是 <code>kill -9 1</code>(对应 Linux 中的 <code>SIGKILL</code> 信号)，都无法让进程终止。那么问题来了，这两个常常用来终止进程的信号，都对容器中的 1号进程不起作用。
<a class=anchor href=#%e5%bd%93%e6%88%91%e4%bb%ac%e5%ae%8c%e6%88%90%e5%89%8d%e9%9d%a2%e7%9a%84%e6%93%8d%e4%bd%9c%e5%b0%b1%e4%bc%9a%e5%8f%91%e7%8e%b0%e6%97%a0%e8%ae%ba%e8%bf%90%e8%a1%8c-kill-1-%e5%af%b9%e5%ba%94-linux-%e4%b8%ad%e7%9a%84-sigterm-%e4%bf%a1%e5%8f%b7-%e8%bf%98%e6%98%af-kill--9-1%e5%af%b9%e5%ba%94-linux-%e4%b8%ad%e7%9a%84-sigkill-%e4%bf%a1%e5%8f%b7%e9%83%bd%e6%97%a0%e6%b3%95%e8%ae%a9%e8%bf%9b%e7%a8%8b%e7%bb%88%e6%ad%a2%e9%82%a3%e4%b9%88%e9%97%ae%e9%a2%98%e6%9d%a5%e4%ba%86%e8%bf%99%e4%b8%a4%e4%b8%aa%e5%b8%b8%e5%b8%b8%e7%94%a8%e6%9d%a5%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%bf%a1%e5%8f%b7%e9%83%bd%e5%af%b9%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b8%8d%e8%b5%b7%e4%bd%9c%e7%94%a8>#</a></h5><p><strong>示例二</strong></p><h5 id=在宿主机上使用-kill--9-kill--15-杀死容器-1-号进程对应在宿主机上的进程>在宿主机上使用 <code>kill -9, kill -15</code> 杀死容器 1 号进程对应在<strong>宿主机上的进程</strong>
<a class=anchor href=#%e5%9c%a8%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e4%bd%bf%e7%94%a8-kill--9-kill--15-%e6%9d%80%e6%ad%bb%e5%ae%b9%e5%99%a8-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%af%b9%e5%ba%94%e5%9c%a8%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e7%9a%84%e8%bf%9b%e7%a8%8b>#</a></h5><pre tabindex=0><code># 获取宿主机上对应容器的进程
$ docker inspect test | grep Pid
$ kill -15 24446
$ ps -ef | grep 24446
root      24446  24404  0 09:38 ?        00:00:00 sleep 600
root      54735  44623  0 09:48 pts/0    00:00:00 grep --color=auto 24446
$ kill -9 24446
$ ps -ef | grep 24446
root      55167  44623  0 09:48 pts/0    00:00:00 grep --color=auto 24446
</code></pre><h5 id=发现-kill--15-无法杀死容器进程而-kill--9-却可以>发现 <code>kill -15</code> 无法杀死容器进程，而 <code>kill -9</code> 却可以。
<a class=anchor href=#%e5%8f%91%e7%8e%b0-kill--15-%e6%97%a0%e6%b3%95%e6%9d%80%e6%ad%bb%e5%ae%b9%e5%99%a8%e8%bf%9b%e7%a8%8b%e8%80%8c-kill--9-%e5%8d%b4%e5%8f%af%e4%bb%a5>#</a></h5><p><strong>示例三</strong></p><h5 id=在宿主机上使用-docker-stop-container-id-杀死容器>在宿主机上使用 <code>docker stop &lt;container-id></code> 杀死容器
<a class=anchor href=#%e5%9c%a8%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e4%bd%bf%e7%94%a8-docker-stop-container-id-%e6%9d%80%e6%ad%bb%e5%ae%b9%e5%99%a8>#</a></h5><pre tabindex=0><code>$ /usr/bin/time docker stop e58851b5452f
e58851b5452f

real 0m 10.19s
user 0m 0.04s
sys 0m 0.03s
</code></pre><h5 id=发现经过了-10s-左右容器进程才杀死>发现经过了 <code>10s</code> 左右容器进程才杀死。
<a class=anchor href=#%e5%8f%91%e7%8e%b0%e7%bb%8f%e8%bf%87%e4%ba%86-10s-%e5%b7%a6%e5%8f%b3%e5%ae%b9%e5%99%a8%e8%bf%9b%e7%a8%8b%e6%89%8d%e6%9d%80%e6%ad%bb>#</a></h5><p><strong>示例四</strong></p><h5 id=把容器中的-sleep-换成-golang-程序使用-kill--9kill--15-杀死进程>把容器中的 sleep 换成 Golang 程序，使用 <code>kill -9，kill -15</code> 杀死进程
<a class=anchor href=#%e6%8a%8a%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-sleep-%e6%8d%a2%e6%88%90-golang-%e7%a8%8b%e5%ba%8f%e4%bd%bf%e7%94%a8-kill--9kill--15-%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=golang-代码如下>Golang 代码如下：
<a class=anchor href=#golang-%e4%bb%a3%e7%a0%81%e5%a6%82%e4%b8%8b>#</a></h5><pre tabindex=0><code>package main

import (
       &#34;fmt&#34;
       &#34;time&#34;
)

func main() {
       fmt.Println(&#34;Start app\n&#34;)
       time.Sleep(time.Duration(100000) * time.Millisecond)
}
</code></pre><h5 id=dockerfile-如下>Dockerfile 如下：
<a class=anchor href=#dockerfile-%e5%a6%82%e4%b8%8b>#</a></h5><pre tabindex=0><code>FROM ubuntu
# go-demo 就是上面代码编译出的二进制程序
COPY go-demo .
RUN chmod +x go-demo
ENTRYPOINT [&#34;./go-demo&#34;]
</code></pre><h5 id=进入容器操作>进入容器操作
<a class=anchor href=#%e8%bf%9b%e5%85%a5%e5%ae%b9%e5%99%a8%e6%93%8d%e4%bd%9c>#</a></h5><pre tabindex=0><code>$docker exec -it 7a62c48d0d1f bash
[root@7a62c48d0d1f /]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 02:04 ?        00:00:00 ./go-demo
root         10      0  1 02:04 pts/0    00:00:00 bash
root         23     10  0 02:04 pts/0    00:00:00 ps -ef
[root@7a62c48d0d1f /]# kill -9 1
[root@7a62c48d0d1f /]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 02:04 ?        00:00:00 ./go-demo
root         10      0  0 02:04 pts/0    00:00:00 bash
root         24     10  0 02:04 pts/0    00:00:00 ps -ef
[root@7a62c48d0d1f /]# kill 1
</code></pre><h5 id=发现-kill--9-无法杀死进程kill--15-可以>发现 <code>kill -9</code> 无法杀死进程，<code>kill -15</code> 可以。
<a class=anchor href=#%e5%8f%91%e7%8e%b0-kill--9-%e6%97%a0%e6%b3%95%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8bkill--15-%e5%8f%af%e4%bb%a5>#</a></h5><h5 id=要解释以上现象需要先了解-linux-中信号机制>要解释以上现象，需要先了解 Linux 中信号机制。
<a class=anchor href=#%e8%a6%81%e8%a7%a3%e9%87%8a%e4%bb%a5%e4%b8%8a%e7%8e%b0%e8%b1%a1%e9%9c%80%e8%a6%81%e5%85%88%e4%ba%86%e8%a7%a3-linux-%e4%b8%ad%e4%bf%a1%e5%8f%b7%e6%9c%ba%e5%88%b6>#</a></h5><h3 id=linux-信号>Linux 信号
<a class=anchor href=#linux-%e4%bf%a1%e5%8f%b7>#</a></h3><h5 id=我们运行-kill-命令其实在-linux-里就是发送一个信号信号一般会从-1-开始编号通常来说信号编号是-1-到-64在-linux-上我们可以用-kill--l-来看这些信号的编号和名字>我们运行 kill 命令，其实在 Linux 里就是发送一个信号。信号一般会从 1 开始编号，通常来说，信号编号是 1 到 64。在 Linux 上我们可以用 <code>kill -l</code> 来看这些信号的编号和名字
<a class=anchor href=#%e6%88%91%e4%bb%ac%e8%bf%90%e8%a1%8c-kill-%e5%91%bd%e4%bb%a4%e5%85%b6%e5%ae%9e%e5%9c%a8-linux-%e9%87%8c%e5%b0%b1%e6%98%af%e5%8f%91%e9%80%81%e4%b8%80%e4%b8%aa%e4%bf%a1%e5%8f%b7%e4%bf%a1%e5%8f%b7%e4%b8%80%e8%88%ac%e4%bc%9a%e4%bb%8e-1-%e5%bc%80%e5%a7%8b%e7%bc%96%e5%8f%b7%e9%80%9a%e5%b8%b8%e6%9d%a5%e8%af%b4%e4%bf%a1%e5%8f%b7%e7%bc%96%e5%8f%b7%e6%98%af-1-%e5%88%b0-64%e5%9c%a8-linux-%e4%b8%8a%e6%88%91%e4%bb%ac%e5%8f%af%e4%bb%a5%e7%94%a8-kill--l-%e6%9d%a5%e7%9c%8b%e8%bf%99%e4%ba%9b%e4%bf%a1%e5%8f%b7%e7%9a%84%e7%bc%96%e5%8f%b7%e5%92%8c%e5%90%8d%e5%ad%97>#</a></h5><pre tabindex=0><code>$ kill -l
 1) SIGHUP      2) SIGINT    3) SIGQUIT    4) SIGILL    5) SIGTRAP
 6) SIGABRT     7) SIGBUS    8) SIGFPE     9) SIGKILL  10) SIGUSR1
11) SIGSEGV    12) SIGUSR2  13) SIGPIPE   14) SIGALRM  15) SIGTERM
16) SIGSTKFLT  17) SIGCHLD  18) SIGCONT   19) SIGSTOP  20) SIGTSTP
21) SIGTTIN    22) SIGTTOU  23) SIGURG    24) SIGXCPU  25) SIGXFSZ
26) SIGVTALRM  27) SIGPROF  28) SIGWINCH  29) SIGIO    30) SIGPWR
31) SIGSYS
</code></pre><h5 id=典型的使用信号机制的场景>典型的使用信号机制的场景：
<a class=anchor href=#%e5%85%b8%e5%9e%8b%e7%9a%84%e4%bd%bf%e7%94%a8%e4%bf%a1%e5%8f%b7%e6%9c%ba%e5%88%b6%e7%9a%84%e5%9c%ba%e6%99%af>#</a></h5><ul><li><h5 id=-如果我们按下键盘-ctrlc当前运行的进程就会收到一个信号-sigint-而退出>• 如果我们按下键盘 <code>Ctrl+C</code>，当前运行的进程就会收到一个信号 <code>SIGINT</code> 而退出；
<a class=anchor href=#-%e5%a6%82%e6%9e%9c%e6%88%91%e4%bb%ac%e6%8c%89%e4%b8%8b%e9%94%ae%e7%9b%98-ctrlc%e5%bd%93%e5%89%8d%e8%bf%90%e8%a1%8c%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%b0%b1%e4%bc%9a%e6%94%b6%e5%88%b0%e4%b8%80%e4%b8%aa%e4%bf%a1%e5%8f%b7-sigint-%e8%80%8c%e9%80%80%e5%87%ba>#</a></h5></li><li><h5 id=-如果应用程序内存访问出错了当前的进程就会收到另一个信号-sigsegv>• 如果应用程序内存访问出错了，当前的进程就会收到另一个信号 <code>SIGSEGV</code>；
<a class=anchor href=#-%e5%a6%82%e6%9e%9c%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e5%87%ba%e9%94%99%e4%ba%86%e5%bd%93%e5%89%8d%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%b0%b1%e4%bc%9a%e6%94%b6%e5%88%b0%e5%8f%a6%e4%b8%80%e4%b8%aa%e4%bf%a1%e5%8f%b7-sigsegv>#</a></h5></li><li><h5 id=-我们也可以通过命令-kill-直接向一个进程发送一个信号缺省情况下不指定信号的类型那么这个信号就是-sigterm也可以指定信号类型比如命令-kill--9这里的-9就是编号为-9-的信号sigkill-信号>• 我们也可以通过命令 <code>kill</code> ，直接向一个进程发送一个信号，缺省情况下不指定信号的类型，那么这个信号就是 <code>SIGTERM</code>。也可以指定信号类型，比如命令 <code>kill -9</code>，这里的 9，就是编号为 9 的信号，<code>SIGKILL</code> 信号。
<a class=anchor href=#-%e6%88%91%e4%bb%ac%e4%b9%9f%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e5%91%bd%e4%bb%a4-kill-%e7%9b%b4%e6%8e%a5%e5%90%91%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b%e5%8f%91%e9%80%81%e4%b8%80%e4%b8%aa%e4%bf%a1%e5%8f%b7%e7%bc%ba%e7%9c%81%e6%83%85%e5%86%b5%e4%b8%8b%e4%b8%8d%e6%8c%87%e5%ae%9a%e4%bf%a1%e5%8f%b7%e7%9a%84%e7%b1%bb%e5%9e%8b%e9%82%a3%e4%b9%88%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e5%b0%b1%e6%98%af-sigterm%e4%b9%9f%e5%8f%af%e4%bb%a5%e6%8c%87%e5%ae%9a%e4%bf%a1%e5%8f%b7%e7%b1%bb%e5%9e%8b%e6%af%94%e5%a6%82%e5%91%bd%e4%bb%a4-kill--9%e8%bf%99%e9%87%8c%e7%9a%84-9%e5%b0%b1%e6%98%af%e7%bc%96%e5%8f%b7%e4%b8%ba-9-%e7%9a%84%e4%bf%a1%e5%8f%b7sigkill-%e4%bf%a1%e5%8f%b7>#</a></h5></li></ul><h5 id=在操作系统常见手动杀死进程的信号就是-sigterm-和-sigkill-进程在收到信号后就会去做相应的处理对于每一个信号进程对它的处理都有下面三个选择>在操作系统常见手动杀死进程的信号就是 <code>SIGTERM</code> 和 <code>SIGKILL</code> ，进程在收到信号后，就会去做相应的处理。对于每一个信号，进程对它的处理都有下面三个选择。
<a class=anchor href=#%e5%9c%a8%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%b8%b8%e8%a7%81%e6%89%8b%e5%8a%a8%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%bf%a1%e5%8f%b7%e5%b0%b1%e6%98%af-sigterm-%e5%92%8c-sigkill-%e8%bf%9b%e7%a8%8b%e5%9c%a8%e6%94%b6%e5%88%b0%e4%bf%a1%e5%8f%b7%e5%90%8e%e5%b0%b1%e4%bc%9a%e5%8e%bb%e5%81%9a%e7%9b%b8%e5%ba%94%e7%9a%84%e5%a4%84%e7%90%86%e5%af%b9%e4%ba%8e%e6%af%8f%e4%b8%80%e4%b8%aa%e4%bf%a1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%af%b9%e5%ae%83%e7%9a%84%e5%a4%84%e7%90%86%e9%83%bd%e6%9c%89%e4%b8%8b%e9%9d%a2%e4%b8%89%e4%b8%aa%e9%80%89%e6%8b%a9>#</a></h5><p><strong>忽略</strong></p><h5 id=忽略-ignore--就是对这个信号不做任何处理但是有两个信号例外对于-sigkill-和-sigstop-这个两个信号进程是不能忽略的这是因为它们的主要作用是为-linux-kernel-和超级用户提供删除任意进程的特权>忽略( Ignore ) 就是对这个信号不做任何处理，但是有两个信号例外，对于 <code>SIGKILL</code> 和 <code>SIGSTOP</code> 这个两个信号，进程是不能忽略的。这是因为它们的主要作用是为 Linux kernel 和超级用户提供删除任意进程的特权。
<a class=anchor href=#%e5%bf%bd%e7%95%a5-ignore--%e5%b0%b1%e6%98%af%e5%af%b9%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e4%b8%8d%e5%81%9a%e4%bb%bb%e4%bd%95%e5%a4%84%e7%90%86%e4%bd%86%e6%98%af%e6%9c%89%e4%b8%a4%e4%b8%aa%e4%bf%a1%e5%8f%b7%e4%be%8b%e5%a4%96%e5%af%b9%e4%ba%8e-sigkill-%e5%92%8c-sigstop-%e8%bf%99%e4%b8%aa%e4%b8%a4%e4%b8%aa%e4%bf%a1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e6%98%af%e4%b8%8d%e8%83%bd%e5%bf%bd%e7%95%a5%e7%9a%84%e8%bf%99%e6%98%af%e5%9b%a0%e4%b8%ba%e5%ae%83%e4%bb%ac%e7%9a%84%e4%b8%bb%e8%a6%81%e4%bd%9c%e7%94%a8%e6%98%af%e4%b8%ba-linux-kernel-%e5%92%8c%e8%b6%85%e7%ba%a7%e7%94%a8%e6%88%b7%e6%8f%90%e4%be%9b%e5%88%a0%e9%99%a4%e4%bb%bb%e6%84%8f%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%89%b9%e6%9d%83>#</a></h5><p><strong>捕获</strong></p><h5 id=捕获-catch-这个是指让用户进程可以注册自己针对这个信号的-handler对于捕获sigkill-和-sigstop-这两个信号也同样例外这两个信号不能由用户自己的处理代码只能执行系统的缺省行为>捕获( Catch )，这个是指让用户进程可以注册自己针对这个信号的 handler。对于捕获，<code>SIGKILL</code> 和 <code>SIGSTOP</code> 这两个信号也同样例外，这两个信号不能由用户自己的处理代码，只能执行系统的<strong>缺省行为</strong>。
<a class=anchor href=#%e6%8d%95%e8%8e%b7-catch-%e8%bf%99%e4%b8%aa%e6%98%af%e6%8c%87%e8%ae%a9%e7%94%a8%e6%88%b7%e8%bf%9b%e7%a8%8b%e5%8f%af%e4%bb%a5%e6%b3%a8%e5%86%8c%e8%87%aa%e5%b7%b1%e9%92%88%e5%af%b9%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e7%9a%84-handler%e5%af%b9%e4%ba%8e%e6%8d%95%e8%8e%b7sigkill-%e5%92%8c-sigstop-%e8%bf%99%e4%b8%a4%e4%b8%aa%e4%bf%a1%e5%8f%b7%e4%b9%9f%e5%90%8c%e6%a0%b7%e4%be%8b%e5%a4%96%e8%bf%99%e4%b8%a4%e4%b8%aa%e4%bf%a1%e5%8f%b7%e4%b8%8d%e8%83%bd%e7%94%b1%e7%94%a8%e6%88%b7%e8%87%aa%e5%b7%b1%e7%9a%84%e5%a4%84%e7%90%86%e4%bb%a3%e7%a0%81%e5%8f%aa%e8%83%bd%e6%89%a7%e8%a1%8c%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bc%ba%e7%9c%81%e8%a1%8c%e4%b8%ba>#</a></h5><p><strong>缺省行为</strong></p><h5 id=缺省行为-default-linux-为每个信号都定义了一个缺省的行为你可以在-linux-系统中运行-man-7-signal-来查看每个信号的缺省行为对于大部分的信号而言应用程序不需要注册自己的-handler使用系统缺省定义行为就可以了>缺省行为( Default )，Linux 为每个信号都定义了一个缺省的行为，你可以在 Linux 系统中运行 <code>man 7 signal</code> 来查看每个信号的缺省行为。对于大部分的信号而言，应用程序不需要注册自己的 handler，使用系统缺省定义行为就可以了。
<a class=anchor href=#%e7%bc%ba%e7%9c%81%e8%a1%8c%e4%b8%ba-default-linux-%e4%b8%ba%e6%af%8f%e4%b8%aa%e4%bf%a1%e5%8f%b7%e9%83%bd%e5%ae%9a%e4%b9%89%e4%ba%86%e4%b8%80%e4%b8%aa%e7%bc%ba%e7%9c%81%e7%9a%84%e8%a1%8c%e4%b8%ba%e4%bd%a0%e5%8f%af%e4%bb%a5%e5%9c%a8-linux-%e7%b3%bb%e7%bb%9f%e4%b8%ad%e8%bf%90%e8%a1%8c-man-7-signal-%e6%9d%a5%e6%9f%a5%e7%9c%8b%e6%af%8f%e4%b8%aa%e4%bf%a1%e5%8f%b7%e7%9a%84%e7%bc%ba%e7%9c%81%e8%a1%8c%e4%b8%ba%e5%af%b9%e4%ba%8e%e5%a4%a7%e9%83%a8%e5%88%86%e7%9a%84%e4%bf%a1%e5%8f%b7%e8%80%8c%e8%a8%80%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%8d%e9%9c%80%e8%a6%81%e6%b3%a8%e5%86%8c%e8%87%aa%e5%b7%b1%e7%9a%84-handler%e4%bd%bf%e7%94%a8%e7%b3%bb%e7%bb%9f%e7%bc%ba%e7%9c%81%e5%ae%9a%e4%b9%89%e8%a1%8c%e4%b8%ba%e5%b0%b1%e5%8f%af%e4%bb%a5%e4%ba%86>#</a></h5><h5 id=常见的-sigterm-和-sigkill-信号默认行为都是终止进程针对上面说的三个实例详细看看这两个信号>常见的 <code>SIGTERM</code> 和 <code>SIGKILL</code> 信号默认行为都是**终止进程。**针对上面说的三个实例，详细看看这两个信号。
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84-sigterm-%e5%92%8c-sigkill-%e4%bf%a1%e5%8f%b7%e9%bb%98%e8%ae%a4%e8%a1%8c%e4%b8%ba%e9%83%bd%e6%98%af%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b%e9%92%88%e5%af%b9%e4%b8%8a%e9%9d%a2%e8%af%b4%e7%9a%84%e4%b8%89%e4%b8%aa%e5%ae%9e%e4%be%8b%e8%af%a6%e7%bb%86%e7%9c%8b%e7%9c%8b%e8%bf%99%e4%b8%a4%e4%b8%aa%e4%bf%a1%e5%8f%b7>#</a></h5><p><strong>SIGTERM</strong></p><h5 id=这个信号是-linux-命令-kill-缺省发出的前面例子里的命令-kill-1-就是通过-kill-向-1-号进程发送一个信号等价于-kill--15在没有别的参数时这个信号类型就默认为-sigterm>这个信号是 Linux 命令 <code>kill</code> 缺省发出的。前面例子里的命令 <code>kill 1</code> ，就是通过 <code>kill</code> 向 1 号进程发送一个信号，等价于 <code>kill -15</code>，在没有别的参数时，这个信号类型就默认为 <code>SIGTERM</code>。
<a class=anchor href=#%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e6%98%af-linux-%e5%91%bd%e4%bb%a4-kill-%e7%bc%ba%e7%9c%81%e5%8f%91%e5%87%ba%e7%9a%84%e5%89%8d%e9%9d%a2%e4%be%8b%e5%ad%90%e9%87%8c%e7%9a%84%e5%91%bd%e4%bb%a4-kill-1-%e5%b0%b1%e6%98%af%e9%80%9a%e8%bf%87-kill-%e5%90%91-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%8f%91%e9%80%81%e4%b8%80%e4%b8%aa%e4%bf%a1%e5%8f%b7%e7%ad%89%e4%bb%b7%e4%ba%8e-kill--15%e5%9c%a8%e6%b2%a1%e6%9c%89%e5%88%ab%e7%9a%84%e5%8f%82%e6%95%b0%e6%97%b6%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e7%b1%bb%e5%9e%8b%e5%b0%b1%e9%bb%98%e8%ae%a4%e4%b8%ba-sigterm>#</a></h5><h5 id=sigterm-这个信号是可以被捕获的这里的捕获指的就是用户进程可以为这个信号注册自己的-handler而-sigterm-信号一般是用于进程优雅退出><code>SIGTERM</code> 这个信号是可以被捕获的，这里的<strong>捕获</strong>指的就是用户进程可以为这个信号注册自己的 handler，而 <code>SIGTERM</code> 信号一般是用于进程优雅退出。
<a class=anchor href=#sigterm-%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e6%98%af%e5%8f%af%e4%bb%a5%e8%a2%ab%e6%8d%95%e8%8e%b7%e7%9a%84%e8%bf%99%e9%87%8c%e7%9a%84%e6%8d%95%e8%8e%b7%e6%8c%87%e7%9a%84%e5%b0%b1%e6%98%af%e7%94%a8%e6%88%b7%e8%bf%9b%e7%a8%8b%e5%8f%af%e4%bb%a5%e4%b8%ba%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e6%b3%a8%e5%86%8c%e8%87%aa%e5%b7%b1%e7%9a%84-handler%e8%80%8c-sigterm-%e4%bf%a1%e5%8f%b7%e4%b8%80%e8%88%ac%e6%98%af%e7%94%a8%e4%ba%8e%e8%bf%9b%e7%a8%8b%e4%bc%98%e9%9b%85%e9%80%80%e5%87%ba>#</a></h5><p><strong>SIGKILL</strong></p><h5 id=sigkill-9这个信号是-linux-里两个特权信号之一特权信号就是-linux-为-kernel-和超级用户去删除任意进程所保留的不能被忽略也不能被捕获那么进程一旦收到-sigkill就要退出><code>SIGKILL (9)</code>，这个信号是 Linux 里两个特权信号之一。特权信号就是 Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获。那么进程一旦收到 <code>SIGKILL</code>，就要退出。
<a class=anchor href=#sigkill-9%e8%bf%99%e4%b8%aa%e4%bf%a1%e5%8f%b7%e6%98%af-linux-%e9%87%8c%e4%b8%a4%e4%b8%aa%e7%89%b9%e6%9d%83%e4%bf%a1%e5%8f%b7%e4%b9%8b%e4%b8%80%e7%89%b9%e6%9d%83%e4%bf%a1%e5%8f%b7%e5%b0%b1%e6%98%af-linux-%e4%b8%ba-kernel-%e5%92%8c%e8%b6%85%e7%ba%a7%e7%94%a8%e6%88%b7%e5%8e%bb%e5%88%a0%e9%99%a4%e4%bb%bb%e6%84%8f%e8%bf%9b%e7%a8%8b%e6%89%80%e4%bf%9d%e7%95%99%e7%9a%84%e4%b8%8d%e8%83%bd%e8%a2%ab%e5%bf%bd%e7%95%a5%e4%b9%9f%e4%b8%8d%e8%83%bd%e8%a2%ab%e6%8d%95%e8%8e%b7%e9%82%a3%e4%b9%88%e8%bf%9b%e7%a8%8b%e4%b8%80%e6%97%a6%e6%94%b6%e5%88%b0-sigkill%e5%b0%b1%e8%a6%81%e9%80%80%e5%87%ba>#</a></h5><h5 id=在前面的例子里我们运行的命令-kill--9-1-里的参数--9-其实就是指发送编号为-9-的这个-sigkill-信号给-1-号进程>在前面的例子里，我们运行的命令 <code>kill -9 1</code> 里的参数 <code>-9</code> ，其实就是指发送编号为 9 的这个 <code>SIGKILL</code> 信号给 <strong>1 号进程</strong>。
<a class=anchor href=#%e5%9c%a8%e5%89%8d%e9%9d%a2%e7%9a%84%e4%be%8b%e5%ad%90%e9%87%8c%e6%88%91%e4%bb%ac%e8%bf%90%e8%a1%8c%e7%9a%84%e5%91%bd%e4%bb%a4-kill--9-1-%e9%87%8c%e7%9a%84%e5%8f%82%e6%95%b0--9-%e5%85%b6%e5%ae%9e%e5%b0%b1%e6%98%af%e6%8c%87%e5%8f%91%e9%80%81%e7%bc%96%e5%8f%b7%e4%b8%ba-9-%e7%9a%84%e8%bf%99%e4%b8%aa-sigkill-%e4%bf%a1%e5%8f%b7%e7%bb%99-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b>#</a></h5><h3 id=linux-信号处理原理>Linux 信号处理原理
<a class=anchor href=#linux-%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e5%8e%9f%e7%90%86>#</a></h3><h5 id=在了解了-linux-信号机制的概念后再解释上述现象就会较容易理解>在了解了 Linux 信号机制的概念后，再解释上述现象就会较容易理解。
<a class=anchor href=#%e5%9c%a8%e4%ba%86%e8%a7%a3%e4%ba%86-linux-%e4%bf%a1%e5%8f%b7%e6%9c%ba%e5%88%b6%e7%9a%84%e6%a6%82%e5%bf%b5%e5%90%8e%e5%86%8d%e8%a7%a3%e9%87%8a%e4%b8%8a%e8%bf%b0%e7%8e%b0%e8%b1%a1%e5%b0%b1%e4%bc%9a%e8%be%83%e5%ae%b9%e6%98%93%e7%90%86%e8%a7%a3>#</a></h5><h5 id=在-linux-中使用-kill-命令向-1号进程发起信号时linux-内核会根据如下代码逻辑判断是否忽略该信号当下面代码-if-条件为-true-的话则忽略信号否则执行信号默认行为>在 Linux 中，使用 <code>kill</code> 命令向 1号进程发起信号时，Linux 内核会根据如下代码逻辑判断是否忽略该信号。当下面代码 if 条件为 true 的话则忽略信号，否则执行信号默认行为。
<a class=anchor href=#%e5%9c%a8-linux-%e4%b8%ad%e4%bd%bf%e7%94%a8-kill-%e5%91%bd%e4%bb%a4%e5%90%91-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%8f%91%e8%b5%b7%e4%bf%a1%e5%8f%b7%e6%97%b6linux-%e5%86%85%e6%a0%b8%e4%bc%9a%e6%a0%b9%e6%8d%ae%e5%a6%82%e4%b8%8b%e4%bb%a3%e7%a0%81%e9%80%bb%e8%be%91%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e5%bf%bd%e7%95%a5%e8%af%a5%e4%bf%a1%e5%8f%b7%e5%bd%93%e4%b8%8b%e9%9d%a2%e4%bb%a3%e7%a0%81-if-%e6%9d%a1%e4%bb%b6%e4%b8%ba-true-%e7%9a%84%e8%af%9d%e5%88%99%e5%bf%bd%e7%95%a5%e4%bf%a1%e5%8f%b7%e5%90%a6%e5%88%99%e6%89%a7%e8%a1%8c%e4%bf%a1%e5%8f%b7%e9%bb%98%e8%ae%a4%e8%a1%8c%e4%b8%ba>#</a></h5><pre tabindex=0><code>kernel/signal.c
static bool sig_task_ignored(struct task_struct *t, int sig, bool force)
{
        void __user *handler;
        handler = sig_handler(t, sig);

        /* unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) 表示是否为 1 号进程  */
        /* handler == SIG_DFL 表示进程是否使用默认信号行为 */
        /* force 表示发出信号和接受信号是否在同一个 Namespace 下, 在即为 0, 不在为 1 */
        if (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;
            handler == SIG_DFL &amp;&amp; !(force &amp;&amp; sig_kernel_only(sig)))
                return true;

        return sig_handler_ignored(handler, sig);
}
</code></pre><h5 id=分别对上述-if-中的三个条件进行分析>分别对上述 if 中的三个条件进行分析。
<a class=anchor href=#%e5%88%86%e5%88%ab%e5%af%b9%e4%b8%8a%e8%bf%b0-if-%e4%b8%ad%e7%9a%84%e4%b8%89%e4%b8%aa%e6%9d%a1%e4%bb%b6%e8%bf%9b%e8%a1%8c%e5%88%86%e6%9e%90>#</a></h5><p><strong>1、unlikely(t->signal->flags & SIGNAL_UNKILLABLE)</strong></p><h5 id=t-signal-flags--signal_unkillable-表示进程必须是-signal_unkillable-的在每个-namespace-的-init-进程建立的时候就会打上-signal_unkillable-这个标签也就是说只要是-1-号进程就会有这个-flag这个条件也是满足的><code>t->signal->flags & SIGNAL_UNKILLABLE</code> 表示进程必须是 <code>SIGNAL_UNKILLABLE</code> 的。在每个 Namespace 的 init 进程建立的时候，就会打上 <code>SIGNAL_UNKILLABLE</code> 这个标签，也就是说只要是 1 号进程，就会有这个 flag，这个条件也是满足的。
<a class=anchor href=#t-signal-flags--signal_unkillable-%e8%a1%a8%e7%a4%ba%e8%bf%9b%e7%a8%8b%e5%bf%85%e9%a1%bb%e6%98%af-signal_unkillable-%e7%9a%84%e5%9c%a8%e6%af%8f%e4%b8%aa-namespace-%e7%9a%84-init-%e8%bf%9b%e7%a8%8b%e5%bb%ba%e7%ab%8b%e7%9a%84%e6%97%b6%e5%80%99%e5%b0%b1%e4%bc%9a%e6%89%93%e4%b8%8a-signal_unkillable-%e8%bf%99%e4%b8%aa%e6%a0%87%e7%ad%be%e4%b9%9f%e5%b0%b1%e6%98%af%e8%af%b4%e5%8f%aa%e8%a6%81%e6%98%af-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e4%bc%9a%e6%9c%89%e8%bf%99%e4%b8%aa-flag%e8%bf%99%e4%b8%aa%e6%9d%a1%e4%bb%b6%e4%b9%9f%e6%98%af%e6%bb%a1%e8%b6%b3%e7%9a%84>#</a></h5><p><strong>2、handler == SIG_DFL</strong></p><h5 id=判断信号的-handler-是否是-sig_dfl对于每个信号用户进程如果不注册一个自己的-handler就会有一个系统缺省的-handler这个缺省的-handler-就叫作-sig_dfl>判断信号的 handler 是否是 <code>SIG_DFL</code>。对于每个信号，用户进程如果不注册一个自己的 handler，就会有一个系统缺省的 handler，这个缺省的 handler 就叫作 <code>SIG_DFL</code>。
<a class=anchor href=#%e5%88%a4%e6%96%ad%e4%bf%a1%e5%8f%b7%e7%9a%84-handler-%e6%98%af%e5%90%a6%e6%98%af-sig_dfl%e5%af%b9%e4%ba%8e%e6%af%8f%e4%b8%aa%e4%bf%a1%e5%8f%b7%e7%94%a8%e6%88%b7%e8%bf%9b%e7%a8%8b%e5%a6%82%e6%9e%9c%e4%b8%8d%e6%b3%a8%e5%86%8c%e4%b8%80%e4%b8%aa%e8%87%aa%e5%b7%b1%e7%9a%84-handler%e5%b0%b1%e4%bc%9a%e6%9c%89%e4%b8%80%e4%b8%aa%e7%b3%bb%e7%bb%9f%e7%bc%ba%e7%9c%81%e7%9a%84-handler%e8%bf%99%e4%b8%aa%e7%bc%ba%e7%9c%81%e7%9a%84-handler-%e5%b0%b1%e5%8f%ab%e4%bd%9c-sig_dfl>#</a></h5><h5 id=对于-sigkill它是特权信号是不允许被捕获的所以它的-handler-就一直是-sig_dfl对-sigkill来说该条件总是满足的>对于 <code>SIGKILL</code>，它是特权信号，是不允许被捕获的，所以它的 handler 就一直是 <code>SIG_DFL</code>。对 <code>SIGKILL</code>来说该条件总是满足的。
<a class=anchor href=#%e5%af%b9%e4%ba%8e-sigkill%e5%ae%83%e6%98%af%e7%89%b9%e6%9d%83%e4%bf%a1%e5%8f%b7%e6%98%af%e4%b8%8d%e5%85%81%e8%ae%b8%e8%a2%ab%e6%8d%95%e8%8e%b7%e7%9a%84%e6%89%80%e4%bb%a5%e5%ae%83%e7%9a%84-handler-%e5%b0%b1%e4%b8%80%e7%9b%b4%e6%98%af-sig_dfl%e5%af%b9-sigkill%e6%9d%a5%e8%af%b4%e8%af%a5%e6%9d%a1%e4%bb%b6%e6%80%bb%e6%98%af%e6%bb%a1%e8%b6%b3%e7%9a%84>#</a></h5><h5 id=对于-sigterm它是可以被捕获的也就是说如果用户不注册-handler那么这个条件对-sigterm-也是满足的>对于 <code>SIGTERM</code>，它是可以被捕获的。也就是说如果用户不注册 handler，那么这个条件对 <code>SIGTERM</code> 也是满足的。
<a class=anchor href=#%e5%af%b9%e4%ba%8e-sigterm%e5%ae%83%e6%98%af%e5%8f%af%e4%bb%a5%e8%a2%ab%e6%8d%95%e8%8e%b7%e7%9a%84%e4%b9%9f%e5%b0%b1%e6%98%af%e8%af%b4%e5%a6%82%e6%9e%9c%e7%94%a8%e6%88%b7%e4%b8%8d%e6%b3%a8%e5%86%8c-handler%e9%82%a3%e4%b9%88%e8%bf%99%e4%b8%aa%e6%9d%a1%e4%bb%b6%e5%af%b9-sigterm-%e4%b9%9f%e6%98%af%e6%bb%a1%e8%b6%b3%e7%9a%84>#</a></h5><p><strong>3、!(force && sig_kernel_only(sig))</strong></p><h5 id=force-表示如果发出信号的进程与接受信号的进程在同一个-namespace-中值为-false否则为-true-><code>force</code> 表示如果发出信号的进程与接受信号的进程在同一个 Namespace 中值为 <code>false</code>，否则为 <code>true</code> 。
<a class=anchor href=#force-%e8%a1%a8%e7%a4%ba%e5%a6%82%e6%9e%9c%e5%8f%91%e5%87%ba%e4%bf%a1%e5%8f%b7%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%b8%8e%e6%8e%a5%e5%8f%97%e4%bf%a1%e5%8f%b7%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%9c%a8%e5%90%8c%e4%b8%80%e4%b8%aa-namespace-%e4%b8%ad%e5%80%bc%e4%b8%ba-false%e5%90%a6%e5%88%99%e4%b8%ba-true->#</a></h5><h5 id=sig_kernel_onlysig-表示信号是否为特权信号sigkill-为特权信号sigterm-不是><code>sig_kernel_only(sig)</code> ****表示信号是否为特权信号，<code>SIGKILL</code> 为特权信号，<code>SIGTERM</code> 不是。
<a class=anchor href=#sig_kernel_onlysig-%e8%a1%a8%e7%a4%ba%e4%bf%a1%e5%8f%b7%e6%98%af%e5%90%a6%e4%b8%ba%e7%89%b9%e6%9d%83%e4%bf%a1%e5%8f%b7sigkill-%e4%b8%ba%e7%89%b9%e6%9d%83%e4%bf%a1%e5%8f%b7sigterm-%e4%b8%8d%e6%98%af>#</a></h5><p>所以 <code>!(force && sig_kernel_only(si5g))</code> 这个条件对于 <code>SIGKILL</code> 来说是 true，对于 <code>SIGTERM</code> 来说是 false。</p><blockquote><p>Namespace 概念不了解的话，可参考前期文章 <a href="http://mp.weixin.qq.com/s?__biz=MzkyNDMyNjAyMg==&amp;mid=2247484030&amp;idx=1&amp;sn=43bd06072aa327ded21d6513b891d84d&amp;chksm=c1d6c397f6a14a81cbef67203522f0a5201492b161d1faf205d7d271b2e6afe64f1a2b710391&amp;scene=21#wechat_redirect">容器原理</a></p></blockquote><p>上述逻辑可参考下图：</p><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/picture/202403191525373.png alt=image-20240319152513316></p><p><strong>示例一解释</strong></p><h5 id=现在再来看第一个示例示例中容器的-1-号进程是-sleep同时发信号和接受信号都在容器内部属于同一个-namespace同时由于-sleep-命令自身没有注册-handler满足上述三个条件导致-kill--9kill--15-被-linux-内核忽略>现在再来看第一个示例，示例中容器的 1 号进程是 <code>sleep</code>，同时发信号和接受信号都在容器内部，属于同一个 Namespace，同时由于 <code>sleep</code> 命令自身没有注册 handler，满足上述三个条件。导致 <code>kill -9，kill -15</code> 被 Linux 内核忽略。
<a class=anchor href=#%e7%8e%b0%e5%9c%a8%e5%86%8d%e6%9d%a5%e7%9c%8b%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%a4%ba%e4%be%8b%e7%a4%ba%e4%be%8b%e4%b8%ad%e5%ae%b9%e5%99%a8%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e6%98%af-sleep%e5%90%8c%e6%97%b6%e5%8f%91%e4%bf%a1%e5%8f%b7%e5%92%8c%e6%8e%a5%e5%8f%97%e4%bf%a1%e5%8f%b7%e9%83%bd%e5%9c%a8%e5%ae%b9%e5%99%a8%e5%86%85%e9%83%a8%e5%b1%9e%e4%ba%8e%e5%90%8c%e4%b8%80%e4%b8%aa-namespace%e5%90%8c%e6%97%b6%e7%94%b1%e4%ba%8e-sleep-%e5%91%bd%e4%bb%a4%e8%87%aa%e8%ba%ab%e6%b2%a1%e6%9c%89%e6%b3%a8%e5%86%8c-handler%e6%bb%a1%e8%b6%b3%e4%b8%8a%e8%bf%b0%e4%b8%89%e4%b8%aa%e6%9d%a1%e4%bb%b6%e5%af%bc%e8%87%b4-kill--9kill--15-%e8%a2%ab-linux-%e5%86%85%e6%a0%b8%e5%bf%bd%e7%95%a5>#</a></h5><p><strong>示例二解释</strong></p><h5 id=对于示例二由于在宿主机操作容器内的进程这样就是发出信号的进程和接受信号的进程不属于同一个-namespaceforce--true-对于-sigterm-信号它不是特权信号所以-sig_kernel_onlysigfalse--force--sig_kernel_onlysig--true--kill--15-忽略>对于示例二，由于在宿主机操作容器内的进程，这样就是发出信号的进程和接受信号的进程不属于同一个 Namespace，<code>force = true</code> ，对于 <code>SIGTERM</code> 信号，它不是特权信号，所以 <code>sig_kernel_only(sig)=false</code> —> <code>!(force && sig_kernel_only(sig)) = true</code> —> <code>kill -15</code> 忽略。
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e7%a4%ba%e4%be%8b%e4%ba%8c%e7%94%b1%e4%ba%8e%e5%9c%a8%e5%ae%bf%e4%b8%bb%e6%9c%ba%e6%93%8d%e4%bd%9c%e5%ae%b9%e5%99%a8%e5%86%85%e7%9a%84%e8%bf%9b%e7%a8%8b%e8%bf%99%e6%a0%b7%e5%b0%b1%e6%98%af%e5%8f%91%e5%87%ba%e4%bf%a1%e5%8f%b7%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%92%8c%e6%8e%a5%e5%8f%97%e4%bf%a1%e5%8f%b7%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%b8%8d%e5%b1%9e%e4%ba%8e%e5%90%8c%e4%b8%80%e4%b8%aa-namespaceforce--true-%e5%af%b9%e4%ba%8e-sigterm-%e4%bf%a1%e5%8f%b7%e5%ae%83%e4%b8%8d%e6%98%af%e7%89%b9%e6%9d%83%e4%bf%a1%e5%8f%b7%e6%89%80%e4%bb%a5-sig_kernel_onlysigfalse--force--sig_kernel_onlysig--true--kill--15-%e5%bf%bd%e7%95%a5>#</a></h5><h5 id=对于-sigkill-信号来说它是特权信号所以-sig_kernel_onlysigtrue--force--sig_kernel_onlysig--false--kill--9执行动作>对于 <code>SIGKILL</code> 信号来说，它是特权信号，所以 <code>sig_kernel_only(sig)=true</code> —> <code>!(force && sig_kernel_only(sig)) = false</code> —> <code>kill -9</code>执行动作。
<a class=anchor href=#%e5%af%b9%e4%ba%8e-sigkill-%e4%bf%a1%e5%8f%b7%e6%9d%a5%e8%af%b4%e5%ae%83%e6%98%af%e7%89%b9%e6%9d%83%e4%bf%a1%e5%8f%b7%e6%89%80%e4%bb%a5-sig_kernel_onlysigtrue--force--sig_kernel_onlysig--false--kill--9%e6%89%a7%e8%a1%8c%e5%8a%a8%e4%bd%9c>#</a></h5><p><strong>示例三解释</strong></p><h5 id=示例三其实和示例二的原理一样因为-docker-stop-containier-id-背后其实先向容器进程发出-sigterm-信号如果-10s-后进程还在那么直接再发出-sigkill-信号>示例三其实和示例二的原理一样，因为 <code>docker stop &lt;containier-id></code> 背后其实先向容器进程发出 <code>SIGTERM</code> 信号，如果 10s 后进程还在，那么直接再发出 <code>SIGKILL</code> 信号。
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e4%b8%89%e5%85%b6%e5%ae%9e%e5%92%8c%e7%a4%ba%e4%be%8b%e4%ba%8c%e7%9a%84%e5%8e%9f%e7%90%86%e4%b8%80%e6%a0%b7%e5%9b%a0%e4%b8%ba-docker-stop-containier-id-%e8%83%8c%e5%90%8e%e5%85%b6%e5%ae%9e%e5%85%88%e5%90%91%e5%ae%b9%e5%99%a8%e8%bf%9b%e7%a8%8b%e5%8f%91%e5%87%ba-sigterm-%e4%bf%a1%e5%8f%b7%e5%a6%82%e6%9e%9c-10s-%e5%90%8e%e8%bf%9b%e7%a8%8b%e8%bf%98%e5%9c%a8%e9%82%a3%e4%b9%88%e7%9b%b4%e6%8e%a5%e5%86%8d%e5%8f%91%e5%87%ba-sigkill-%e4%bf%a1%e5%8f%b7>#</a></h5><p><strong>示例四解释</strong></p><h5 id=再看第四个示例第四个示例容器的-1-号进程是-golang-程序然而-golang-程序默认自带了-handlerkill--9-发出的是-sigkill-信号不允许被捕获满足以上三个条件导致-kill--9-不生效>再看第四个示例，第四个示例容器的 1 号进程是 Golang 程序，然而 Golang 程序默认自带了 handler，kill -9 发出的是 <code>SIGKILL</code> 信号，不允许被捕获，满足以上三个条件，导致 <code>kill -9</code> 不生效。
<a class=anchor href=#%e5%86%8d%e7%9c%8b%e7%ac%ac%e5%9b%9b%e4%b8%aa%e7%a4%ba%e4%be%8b%e7%ac%ac%e5%9b%9b%e4%b8%aa%e7%a4%ba%e4%be%8b%e5%ae%b9%e5%99%a8%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e6%98%af-golang-%e7%a8%8b%e5%ba%8f%e7%84%b6%e8%80%8c-golang-%e7%a8%8b%e5%ba%8f%e9%bb%98%e8%ae%a4%e8%87%aa%e5%b8%a6%e4%ba%86-handlerkill--9-%e5%8f%91%e5%87%ba%e7%9a%84%e6%98%af-sigkill-%e4%bf%a1%e5%8f%b7%e4%b8%8d%e5%85%81%e8%ae%b8%e8%a2%ab%e6%8d%95%e8%8e%b7%e6%bb%a1%e8%b6%b3%e4%bb%a5%e4%b8%8a%e4%b8%89%e4%b8%aa%e6%9d%a1%e4%bb%b6%e5%af%bc%e8%87%b4-kill--9-%e4%b8%8d%e7%94%9f%e6%95%88>#</a></h5><h5 id=kill--15-发出的是-sigterm-信号该信号允许捕获所以使用自带的-handler即不满足条件-2导致-kill--15-可以杀死进程><code>kill -15</code> 发出的是 <code>SIGTERM</code> 信号，该信号允许捕获，所以使用自带的 handler，即不满足条件 2，导致 <code>kill -15</code> 可以杀死进程。
<a class=anchor href=#kill--15-%e5%8f%91%e5%87%ba%e7%9a%84%e6%98%af-sigterm-%e4%bf%a1%e5%8f%b7%e8%af%a5%e4%bf%a1%e5%8f%b7%e5%85%81%e8%ae%b8%e6%8d%95%e8%8e%b7%e6%89%80%e4%bb%a5%e4%bd%bf%e7%94%a8%e8%87%aa%e5%b8%a6%e7%9a%84-handler%e5%8d%b3%e4%b8%8d%e6%bb%a1%e8%b6%b3%e6%9d%a1%e4%bb%b6-2%e5%af%bc%e8%87%b4-kill--15-%e5%8f%af%e4%bb%a5%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8b>#</a></h5><blockquote><p>Golang 语言 runtime 自动注册了 <code>SIGTERM</code> 信号 handler，https://pkg.go.dev/os/signal#section-directories</p></blockquote><h5 id=通过上面的分析我们了解了容器中的-1号进程以及解释了在容器中为什么杀不掉-1-号进程>通过上面的分析，我们了解了容器中的 1号进程以及解释了在容器中为什么杀不掉 1 号进程。
<a class=anchor href=#%e9%80%9a%e8%bf%87%e4%b8%8a%e9%9d%a2%e7%9a%84%e5%88%86%e6%9e%90%e6%88%91%e4%bb%ac%e4%ba%86%e8%a7%a3%e4%ba%86%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%bb%a5%e5%8f%8a%e8%a7%a3%e9%87%8a%e4%ba%86%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9d%80%e4%b8%8d%e6%8e%89-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b>#</a></h5><hr><h2 id=1-号进程与-init-进程>1 号进程与 init 进程
<a class=anchor href=#1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b8%8e-init-%e8%bf%9b%e7%a8%8b>#</a></h2><h5 id=在-linux-中-1号进程也叫-init-进程但是在不同环境下-1号进程与-init-进程并不是等价的>在 Linux 中 1号进程也叫 init 进程，但是在不同环境下 1号进程与 init 进程并不是等价的。
<a class=anchor href=#%e5%9c%a8-linux-%e4%b8%ad-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b9%9f%e5%8f%ab-init-%e8%bf%9b%e7%a8%8b%e4%bd%86%e6%98%af%e5%9c%a8%e4%b8%8d%e5%90%8c%e7%8e%af%e5%a2%83%e4%b8%8b-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b8%8e-init-%e8%bf%9b%e7%a8%8b%e5%b9%b6%e4%b8%8d%e6%98%af%e7%ad%89%e4%bb%b7%e7%9a%84>#</a></h5><h5 id=1-号进程与-init-进程是什么关系又有什么区别>1 号进程与 init 进程是什么关系，又有什么区别？
<a class=anchor href=#1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b8%8e-init-%e8%bf%9b%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb%e5%8f%88%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab>#</a></h5><h5 id=init-进程就是-1-号进程但是-1-号进程不一定是-init-进程>init 进程就是 1 号进程，但是 1 号进程不一定是 init 进程。
<a class=anchor href=#init-%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%af-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%bd%86%e6%98%af-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b8%8d%e4%b8%80%e5%ae%9a%e6%98%af-init-%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=我们看看-1-号进程和-init-进程的特性>我们看看 1 号进程和 init 进程的特性：
<a class=anchor href=#%e6%88%91%e4%bb%ac%e7%9c%8b%e7%9c%8b-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%92%8c-init-%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%89%b9%e6%80%a7>#</a></h5><h3 id=1-号进程><strong>1 号进程</strong>
<a class=anchor href=#1-%e5%8f%b7%e8%bf%9b%e7%a8%8b>#</a></h3><ul><li><h5 id=-操作系统第一个进程>• 操作系统第一个进程
<a class=anchor href=#-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%ac%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b>#</a></h5></li><li><h5 id=-是所有用户态进程的父进程>• 是所有用户态进程的父进程
<a class=anchor href=#-%e6%98%af%e6%89%80%e6%9c%89%e7%94%a8%e6%88%b7%e6%80%81%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%88%b6%e8%bf%9b%e7%a8%8b>#</a></h5></li></ul><h3 id=init-进程><strong>init 进程</strong>
<a class=anchor href=#init-%e8%bf%9b%e7%a8%8b>#</a></h3><ul><li><h5 id=-操作系统第一个进程-1>• 操作系统第一个进程
<a class=anchor href=#-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%ac%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b-1>#</a></h5></li><li><h5 id=-是所有用户态进程的父进程-1>• 是所有用户态进程的父进程
<a class=anchor href=#-%e6%98%af%e6%89%80%e6%9c%89%e7%94%a8%e6%88%b7%e6%80%81%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%88%b6%e8%bf%9b%e7%a8%8b-1>#</a></h5></li><li><h5 id=-可以回收僵尸进程失去了父进程的子进程就都会以-init-作为它们的父进程>• 可以回收<strong>僵尸进程</strong>(失去了父进程的子进程就都会以 init 作为它们的父进程)
<a class=anchor href=#-%e5%8f%af%e4%bb%a5%e5%9b%9e%e6%94%b6%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e5%a4%b1%e5%8e%bb%e4%ba%86%e7%88%b6%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%ad%90%e8%bf%9b%e7%a8%8b%e5%b0%b1%e9%83%bd%e4%bc%9a%e4%bb%a5-init-%e4%bd%9c%e4%b8%ba%e5%ae%83%e4%bb%ac%e7%9a%84%e7%88%b6%e8%bf%9b%e7%a8%8b>#</a></h5></li><li><h5 id=-可以向子进程发送操作系统信号>• 可以向子进程发送操作系统信号
<a class=anchor href=#-%e5%8f%af%e4%bb%a5%e5%90%91%e5%ad%90%e8%bf%9b%e7%a8%8b%e5%8f%91%e9%80%81%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%bf%a1%e5%8f%b7>#</a></h5></li></ul><h5 id=对于宿主机和容器的关系在宿主机中-1-号进程和-init-进程是等价的在容器中-1-号进程不一定是-init-进程取决与用户对容器的定义下面详细看看>对于宿主机和容器的关系，在宿主机中 1 号进程和 init 进程是等价的，在容器中 1 号进程不一定是 init 进程，取决与用户对容器的定义，下面详细看看。
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e5%ae%bf%e4%b8%bb%e6%9c%ba%e5%92%8c%e5%ae%b9%e5%99%a8%e7%9a%84%e5%85%b3%e7%b3%bb%e5%9c%a8%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%ad-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%92%8c-init-%e8%bf%9b%e7%a8%8b%e6%98%af%e7%ad%89%e4%bb%b7%e7%9a%84%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b8%8d%e4%b8%80%e5%ae%9a%e6%98%af-init-%e8%bf%9b%e7%a8%8b%e5%8f%96%e5%86%b3%e4%b8%8e%e7%94%a8%e6%88%b7%e5%af%b9%e5%ae%b9%e5%99%a8%e7%9a%84%e5%ae%9a%e4%b9%89%e4%b8%8b%e9%9d%a2%e8%af%a6%e7%bb%86%e7%9c%8b%e7%9c%8b>#</a></h5><hr><h2 id=容器中的-init-进程>容器中的 init 进程
<a class=anchor href=#%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-init-%e8%bf%9b%e7%a8%8b>#</a></h2><h5 id=容器中的-1-号进程是否具有-init-进程的特性取决于容器启动的命令在-dockerfile-中cmdentrypoint-可以启动容器它们都有两种模式shell-模式exec-模式>容器中的 1 号进程是否具有 init 进程的特性取决于容器启动的命令。在 Dockerfile 中，CMD、ENTRYPOINT 可以启动容器，它们都有两种模式：<strong>shell 模式</strong>，<strong>exec 模式</strong>
<a class=anchor href=#%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e6%98%af%e5%90%a6%e5%85%b7%e6%9c%89-init-%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%89%b9%e6%80%a7%e5%8f%96%e5%86%b3%e4%ba%8e%e5%ae%b9%e5%99%a8%e5%90%af%e5%8a%a8%e7%9a%84%e5%91%bd%e4%bb%a4%e5%9c%a8-dockerfile-%e4%b8%adcmdentrypoint-%e5%8f%af%e4%bb%a5%e5%90%af%e5%8a%a8%e5%ae%b9%e5%99%a8%e5%ae%83%e4%bb%ac%e9%83%bd%e6%9c%89%e4%b8%a4%e7%a7%8d%e6%a8%a1%e5%bc%8fshell-%e6%a8%a1%e5%bc%8fexec-%e6%a8%a1%e5%bc%8f>#</a></h5><h5 id=这里用-entrypoint-举例cmd-是一样的>这里用 ENTRYPOINT 举例，CMD 是一样的。
<a class=anchor href=#%e8%bf%99%e9%87%8c%e7%94%a8-entrypoint-%e4%b8%be%e4%be%8bcmd-%e6%98%af%e4%b8%80%e6%a0%b7%e7%9a%84>#</a></h5><h3 id=shell-模式>shell 模式
<a class=anchor href=#shell-%e6%a8%a1%e5%bc%8f>#</a></h3><h5 id=该模式下会开启一个-shell-来执行后面的命令即使用-binsh--c-启动业务进程那么容器中的-1-号进程就是-shell用法entrypoint-command>该模式下会开启一个 shell 来执行后面的命令，即使用 <code>/bin/sh -c</code> 启动业务进程，那么容器中的 1 号进程就是 shell。用法：<code>ENTRYPOINT command</code>
<a class=anchor href=#%e8%af%a5%e6%a8%a1%e5%bc%8f%e4%b8%8b%e4%bc%9a%e5%bc%80%e5%90%af%e4%b8%80%e4%b8%aa-shell-%e6%9d%a5%e6%89%a7%e8%a1%8c%e5%90%8e%e9%9d%a2%e7%9a%84%e5%91%bd%e4%bb%a4%e5%8d%b3%e4%bd%bf%e7%94%a8-binsh--c-%e5%90%af%e5%8a%a8%e4%b8%9a%e5%8a%a1%e8%bf%9b%e7%a8%8b%e9%82%a3%e4%b9%88%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%af-shell%e7%94%a8%e6%b3%95entrypoint-command>#</a></h5><pre tabindex=0><code>FROM ubuntu
# go-demo 是 go 语言程序, 内部是 sleep 100s
COPY go-demo .
ENTRYPOINT ./go-demo
</code></pre><h5 id=启动该容器后容器的-1-号进程就是-sh-go-demo-是-sh-的子进程>启动该容器后，容器的 1 号进程就是 <code>sh</code> ，<code>go-demo</code> 是 <code>sh</code> 的子进程。
<a class=anchor href=#%e5%90%af%e5%8a%a8%e8%af%a5%e5%ae%b9%e5%99%a8%e5%90%8e%e5%ae%b9%e5%99%a8%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%af-sh-go-demo-%e6%98%af-sh-%e7%9a%84%e5%ad%90%e8%bf%9b%e7%a8%8b>#</a></h5><pre tabindex=0><code>$ docker exec -it test-go-init ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 08:45 ?        00:00:00 /bin/sh -c ./go-demo
root          6      1  0 08:45 ?        00:00:00 ./go-demo
root         11      0  0 08:46 pts/0    00:00:00 ps -ef
</code></pre><h3 id=exec-模式>exec 模式
<a class=anchor href=#exec-%e6%a8%a1%e5%bc%8f>#</a></h3><h5 id=该模式下直接运行命令容器中的-1-号进程就是业务应用进程用法entrypoint-command>该模式下直接运行命令，容器中的 1 号进程就是业务应用进程。用法：<code>ENTRYPOINT ["command"]</code>
<a class=anchor href=#%e8%af%a5%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9b%b4%e6%8e%a5%e8%bf%90%e8%a1%8c%e5%91%bd%e4%bb%a4%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%af%e4%b8%9a%e5%8a%a1%e5%ba%94%e7%94%a8%e8%bf%9b%e7%a8%8b%e7%94%a8%e6%b3%95entrypoint-command>#</a></h5><pre tabindex=0><code>FROM ubuntu
COPY go-demo .
ENTRYPOINT [&#34;./go-demo&#34;]
</code></pre><h5 id=启动该容器后容器的-1-号进程就是-go-demo>启动该容器后，容器的 1 号进程就是 <code>go-demo</code>
<a class=anchor href=#%e5%90%af%e5%8a%a8%e8%af%a5%e5%ae%b9%e5%99%a8%e5%90%8e%e5%ae%b9%e5%99%a8%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%af-go-demo>#</a></h5><pre tabindex=0><code>$ docker exec -it test-go-init ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 08:49 ?        00:00:00 ./go-demo
root         18      0  0 08:51 pts/0    00:00:00 ps -ef
</code></pre><h3 id=使用-exec-命令>使用 exec 命令
<a class=anchor href=#%e4%bd%bf%e7%94%a8-exec-%e5%91%bd%e4%bb%a4>#</a></h3><h5 id=在-shell-模式下使用-exec-命令也可以达到-exec-模式的效果用法entrypoint-exec-command>在 shell 模式下使用 <code>exec</code> 命令也可以达到 <strong>exec 模式</strong>的效果，用法：<code>ENTRYPOINT exec command</code>
<a class=anchor href=#%e5%9c%a8-shell-%e6%a8%a1%e5%bc%8f%e4%b8%8b%e4%bd%bf%e7%94%a8-exec-%e5%91%bd%e4%bb%a4%e4%b9%9f%e5%8f%af%e4%bb%a5%e8%be%be%e5%88%b0-exec-%e6%a8%a1%e5%bc%8f%e7%9a%84%e6%95%88%e6%9e%9c%e7%94%a8%e6%b3%95entrypoint-exec-command>#</a></h5><pre tabindex=0><code>FROM ubuntu
COPY go-demo .
ENTRYPOINT exec ./go-demo
</code></pre><h5 id=同样容器启动后容器的-1-号进程就是-go-demo>同样容器启动后，容器的 1 号进程就是 <code>go-demo</code>
<a class=anchor href=#%e5%90%8c%e6%a0%b7%e5%ae%b9%e5%99%a8%e5%90%af%e5%8a%a8%e5%90%8e%e5%ae%b9%e5%99%a8%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%af-go-demo>#</a></h5><pre tabindex=0><code>$ docker exec -it test-go-init ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 08:59 ?        00:00:00 ./go-demo
root         10      0  0 08:59 pts/0    00:00:00 ps -ef
</code></pre><h3 id=使用-tini>使用 tini
<a class=anchor href=#%e4%bd%bf%e7%94%a8-tini>#</a></h3><h5 id=上面说了如果容器需要实现优雅退出要么也用进程作为-1号进程且实现-sigterm-handler要么启动-init-进程下面看看如何在容器中启动-init-进程>上面说了如果容器需要实现优雅退出，要么也用进程作为 1号进程且实现 <strong>SIGTERM</strong> handler，要么启动 init 进程。下面看看如何在容器中启动 init 进程。
<a class=anchor href=#%e4%b8%8a%e9%9d%a2%e8%af%b4%e4%ba%86%e5%a6%82%e6%9e%9c%e5%ae%b9%e5%99%a8%e9%9c%80%e8%a6%81%e5%ae%9e%e7%8e%b0%e4%bc%98%e9%9b%85%e9%80%80%e5%87%ba%e8%a6%81%e4%b9%88%e4%b9%9f%e7%94%a8%e8%bf%9b%e7%a8%8b%e4%bd%9c%e4%b8%ba-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%b8%94%e5%ae%9e%e7%8e%b0-sigterm-handler%e8%a6%81%e4%b9%88%e5%90%af%e5%8a%a8-init-%e8%bf%9b%e7%a8%8b%e4%b8%8b%e9%9d%a2%e7%9c%8b%e7%9c%8b%e5%a6%82%e4%bd%95%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e5%90%af%e5%8a%a8-init-%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=在容器中添加一个-init-系统init-系统有很多种推荐使用-tini1使用如下>在容器中添加一个 <strong>init 系统</strong>。init 系统有很多种，推荐使用 tini[1]，使用如下：
<a class=anchor href=#%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e6%b7%bb%e5%8a%a0%e4%b8%80%e4%b8%aa-init-%e7%b3%bb%e7%bb%9finit-%e7%b3%bb%e7%bb%9f%e6%9c%89%e5%be%88%e5%a4%9a%e7%a7%8d%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8-tini1%e4%bd%bf%e7%94%a8%e5%a6%82%e4%b8%8b>#</a></h5><ul><li><h5 id=-安装-tini>• 安装 tini
<a class=anchor href=#-%e5%ae%89%e8%a3%85-tini>#</a></h5></li><li><h5 id=-将-tini-作为容器中的-1号进程>• 将 tini 作为容器中的 1号进程
<a class=anchor href=#-%e5%b0%86-tini-%e4%bd%9c%e4%b8%ba%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-1%e5%8f%b7%e8%bf%9b%e7%a8%8b>#</a></h5></li><li><p>• <strong>用户进程启动命令</strong>作为 tini 参数</p></li></ul><p>可参考如下 Dockerfile：</p><pre tabindex=0><code>FROM ubuntu
RUN apt-get install tini
COPY test.sh .
RUN chmod +x test.sh
ENTRYPOINT [&#34;/sbin/tini&#34;, &#34;--&#34;, &#34;./test.sh&#34;]
</code></pre><h5 id=现在-tini-就是-1-号进程它会将收到的系统信号转发给子进程-testsh-使用-docker-stop-container-id-就可以瞬间杀死容器了docker-发送-sigterm-信号给容器的-tinitini-将信号转发给-testsh如果-testsh-对-sigterm-信号有自定义-handler那么执行完-handler-退出>现在 tini 就是 <strong>1 号进程</strong>，它会将收到的系统信号转发给子进程 <code>test.sh</code> 。使用 <code>docker stop &lt;container-id></code> 就可以瞬间杀死容器了，docker 发送 <code>SIGTERM</code> 信号给容器的 tini，tini 将信号转发给 test.sh，如果 test.sh 对 <code>SIGTERM</code> 信号有自定义 handler，那么执行完 handler 退出；
<a class=anchor href=#%e7%8e%b0%e5%9c%a8-tini-%e5%b0%b1%e6%98%af-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%ae%83%e4%bc%9a%e5%b0%86%e6%94%b6%e5%88%b0%e7%9a%84%e7%b3%bb%e7%bb%9f%e4%bf%a1%e5%8f%b7%e8%bd%ac%e5%8f%91%e7%bb%99%e5%ad%90%e8%bf%9b%e7%a8%8b-testsh-%e4%bd%bf%e7%94%a8-docker-stop-container-id-%e5%b0%b1%e5%8f%af%e4%bb%a5%e7%9e%ac%e9%97%b4%e6%9d%80%e6%ad%bb%e5%ae%b9%e5%99%a8%e4%ba%86docker-%e5%8f%91%e9%80%81-sigterm-%e4%bf%a1%e5%8f%b7%e7%bb%99%e5%ae%b9%e5%99%a8%e7%9a%84-tinitini-%e5%b0%86%e4%bf%a1%e5%8f%b7%e8%bd%ac%e5%8f%91%e7%bb%99-testsh%e5%a6%82%e6%9e%9c-testsh-%e5%af%b9-sigterm-%e4%bf%a1%e5%8f%b7%e6%9c%89%e8%87%aa%e5%ae%9a%e4%b9%89-handler%e9%82%a3%e4%b9%88%e6%89%a7%e8%a1%8c%e5%ae%8c-handler-%e9%80%80%e5%87%ba>#</a></h5><h5 id=如果-testsh-没有对-sigterm-信号处理那么执行默认行为即直接退出因为现在的-testsh-已经不是-1号进程了仅仅是一个普通进程所以并不会上面说的示例二的现象所以要实现应用进程真正的优雅退出应用程序也得实现-sigterm-的-handler>如果 test.sh 没有对 <code>SIGTERM</code> 信号处理，那么执行默认行为，即直接退出。因为现在的 test.sh 已经不是 1号进程了，仅仅是一个普通进程，所以并不会上面说的<strong>示例二</strong>的现象。所以要实现应用进程真正的优雅退出，应用程序也得实现 <code>SIGTERM</code> 的 handler。
<a class=anchor href=#%e5%a6%82%e6%9e%9c-testsh-%e6%b2%a1%e6%9c%89%e5%af%b9-sigterm-%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e9%82%a3%e4%b9%88%e6%89%a7%e8%a1%8c%e9%bb%98%e8%ae%a4%e8%a1%8c%e4%b8%ba%e5%8d%b3%e7%9b%b4%e6%8e%a5%e9%80%80%e5%87%ba%e5%9b%a0%e4%b8%ba%e7%8e%b0%e5%9c%a8%e7%9a%84-testsh-%e5%b7%b2%e7%bb%8f%e4%b8%8d%e6%98%af-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e4%ba%86%e4%bb%85%e4%bb%85%e6%98%af%e4%b8%80%e4%b8%aa%e6%99%ae%e9%80%9a%e8%bf%9b%e7%a8%8b%e6%89%80%e4%bb%a5%e5%b9%b6%e4%b8%8d%e4%bc%9a%e4%b8%8a%e9%9d%a2%e8%af%b4%e7%9a%84%e7%a4%ba%e4%be%8b%e4%ba%8c%e7%9a%84%e7%8e%b0%e8%b1%a1%e6%89%80%e4%bb%a5%e8%a6%81%e5%ae%9e%e7%8e%b0%e5%ba%94%e7%94%a8%e8%bf%9b%e7%a8%8b%e7%9c%9f%e6%ad%a3%e7%9a%84%e4%bc%98%e9%9b%85%e9%80%80%e5%87%ba%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b9%9f%e5%be%97%e5%ae%9e%e7%8e%b0-sigterm-%e7%9a%84-handler>#</a></h5><h5 id=tini-作为-init-进程还可以清理容器中的僵尸进程>tini 作为 init 进程，还可以清理容器中的僵尸进程。
<a class=anchor href=#tini-%e4%bd%9c%e4%b8%ba-init-%e8%bf%9b%e7%a8%8b%e8%bf%98%e5%8f%af%e4%bb%a5%e6%b8%85%e7%90%86%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b>#</a></h5><blockquote><p>如果你想直接通过 docker 命令来运行容器，可以直接通过参数 <code>--init</code> 来使用 tini，不需要在镜像中安装 tini。如果是 <code>Kubernetes</code> 就不行了，必须手动安装 tini。</p></blockquote><h3 id=使用场景>使用场景
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><h5 id=那么为什么有-shell-模式和-exec-模式分别在什么场景下使用>那么为什么有 <strong>shell 模式</strong>和 <strong>exec 模式</strong>，分别在什么场景下使用？
<a class=anchor href=#%e9%82%a3%e4%b9%88%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89-shell-%e6%a8%a1%e5%bc%8f%e5%92%8c-exec-%e6%a8%a1%e5%bc%8f%e5%88%86%e5%88%ab%e5%9c%a8%e4%bb%80%e4%b9%88%e5%9c%ba%e6%99%af%e4%b8%8b%e4%bd%bf%e7%94%a8>#</a></h5><p><strong>优雅退出</strong></p><h5 id=shell-模式的一号进程是-sh而且-sh-不能传递信号所以就无法实现容器内进程优雅退出了-docker-stop-container-id-只能等待-10s-强制杀死这时候就可以就考虑使用-exec-模式><strong>shell 模式</strong>的一号进程是 <code>sh</code>，而且 <code>sh</code> 不能传递信号，所以就无法实现容器内进程优雅退出了( <code>docker stop &lt;container-id></code> 只能等待 10s 强制杀死)，这时候就可以就考虑使用 <strong>exec 模式</strong>，
<a class=anchor href=#shell-%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%b8%80%e5%8f%b7%e8%bf%9b%e7%a8%8b%e6%98%af-sh%e8%80%8c%e4%b8%94-sh-%e4%b8%8d%e8%83%bd%e4%bc%a0%e9%80%92%e4%bf%a1%e5%8f%b7%e6%89%80%e4%bb%a5%e5%b0%b1%e6%97%a0%e6%b3%95%e5%ae%9e%e7%8e%b0%e5%ae%b9%e5%99%a8%e5%86%85%e8%bf%9b%e7%a8%8b%e4%bc%98%e9%9b%85%e9%80%80%e5%87%ba%e4%ba%86-docker-stop-container-id-%e5%8f%aa%e8%83%bd%e7%ad%89%e5%be%85-10s-%e5%bc%ba%e5%88%b6%e6%9d%80%e6%ad%bb%e8%bf%99%e6%97%b6%e5%80%99%e5%b0%b1%e5%8f%af%e4%bb%a5%e5%b0%b1%e8%80%83%e8%99%91%e4%bd%bf%e7%94%a8-exec-%e6%a8%a1%e5%bc%8f>#</a></h5><h5 id=因为-exec-模式的-1号进程就是自身自身实现-sigterm-handler-即可>因为 <strong>exec 模式</strong>的 1号进程就是自身，自身实现 <code>SIGTERM</code> handler 即可。
<a class=anchor href=#%e5%9b%a0%e4%b8%ba-exec-%e6%a8%a1%e5%bc%8f%e7%9a%84-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%af%e8%87%aa%e8%ba%ab%e8%87%aa%e8%ba%ab%e5%ae%9e%e7%8e%b0-sigterm-handler-%e5%8d%b3%e5%8f%af>#</a></h5><p><strong>环境变量</strong></p><h5 id=在-exec-模式下没有办法获取容器内的环境变量dockerfile-如下>在 <strong>exec 模式</strong>下，没有办法获取容器内的<strong>环境变量</strong>，Dockerfile 如下：
<a class=anchor href=#%e5%9c%a8-exec-%e6%a8%a1%e5%bc%8f%e4%b8%8b%e6%b2%a1%e6%9c%89%e5%8a%9e%e6%b3%95%e8%8e%b7%e5%8f%96%e5%ae%b9%e5%99%a8%e5%86%85%e7%9a%84%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8fdockerfile-%e5%a6%82%e4%b8%8b>#</a></h5><pre tabindex=0><code>FROM ubuntu
# 自定义环境变量
ENV CUSTOMENAME test-exec
# 输出自定义环境变量和系统自带环境变量的值
ENTRYPOINT [&#34;echo&#34;, &#34;Welcome, $CUSTOMENAME $HOSTNAME&#34;]
</code></pre><h5 id=运行输出发现并没有输出对应值>运行输出发现并没有输出对应值。
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e8%be%93%e5%87%ba%e5%8f%91%e7%8e%b0%e5%b9%b6%e6%b2%a1%e6%9c%89%e8%be%93%e5%87%ba%e5%af%b9%e5%ba%94%e5%80%bc>#</a></h5><pre tabindex=0><code>$ docker run --rm test-exec:v1
Welcome, $CUSTOMENAME&#34;, &#34;$HOSTNAME
</code></pre><h5 id=使用-shell-模式或者-exec-命令看看>使用 <strong>shell 模式</strong>或者 <strong>exec 命令</strong>看看。
<a class=anchor href=#%e4%bd%bf%e7%94%a8-shell-%e6%a8%a1%e5%bc%8f%e6%88%96%e8%80%85-exec-%e5%91%bd%e4%bb%a4%e7%9c%8b%e7%9c%8b>#</a></h5><pre tabindex=0><code>FROM ubuntu
# 自定义环境变量
ENV CUSTOMENAME test-exec
# 输出自定义环境变量和系统自带环境变量的值
ENTRYPOINT echo $CUSTOMENAME
</code></pre><h5 id=运行输出可以输出环境变量的值>运行输出可以输出环境变量的值
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e8%be%93%e5%87%ba%e5%8f%af%e4%bb%a5%e8%be%93%e5%87%ba%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc>#</a></h5><pre tabindex=0><code>$ docker run --rm test-exec:v1
test-exec
</code></pre><h5 id=所以-shell-模式和-exec-模式都有对应的使用限制和优势>所以 <strong>shell 模式</strong>和 <strong>exec 模式</strong>都有对应的使用限制和优势。
<a class=anchor href=#%e6%89%80%e4%bb%a5-shell-%e6%a8%a1%e5%bc%8f%e5%92%8c-exec-%e6%a8%a1%e5%bc%8f%e9%83%bd%e6%9c%89%e5%af%b9%e5%ba%94%e7%9a%84%e4%bd%bf%e7%94%a8%e9%99%90%e5%88%b6%e5%92%8c%e4%bc%98%e5%8a%bf>#</a></h5><hr><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><h5 id=本文主要讲述了两段内容>本文主要讲述了两段内容：
<a class=anchor href=#%e6%9c%ac%e6%96%87%e4%b8%bb%e8%a6%81%e8%ae%b2%e8%bf%b0%e4%ba%86%e4%b8%a4%e6%ae%b5%e5%86%85%e5%ae%b9>#</a></h5><ul><li><h5 id=-通过-linux-信号处理的机制分析了在容器中为什么杀不死-1号进程的原因>• 通过 Linux 信号处理的机制分析了在容器中为什么杀不死 1号进程的原因；
<a class=anchor href=#-%e9%80%9a%e8%bf%87-linux-%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86%e7%9a%84%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90%e4%ba%86%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9d%80%e4%b8%8d%e6%ad%bb-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%8e%9f%e5%9b%a0>#</a></h5></li><li><h5 id=-介绍了-1号进程和-init-进程的关系和区别同时展开说明容器中的-1-号进程和-init-进程的使用>• 介绍了 1号进程和 init 进程的关系和区别，同时展开说明容器中的 1 号进程和 init 进程的使用。
<a class=anchor href=#-%e4%bb%8b%e7%bb%8d%e4%ba%86-1%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%92%8c-init-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%85%b3%e7%b3%bb%e5%92%8c%e5%8c%ba%e5%88%ab%e5%90%8c%e6%97%b6%e5%b1%95%e5%bc%80%e8%af%b4%e6%98%8e%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84-1-%e5%8f%b7%e8%bf%9b%e7%a8%8b%e5%92%8c-init-%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%bd%bf%e7%94%a8>#</a></h5></li></ul><h5 id=相信看完这篇文章可以对容器中的进程有了一些原理性的理解>相信看完这篇文章，可以对容器中的进程有了一些原理性的理解。
<a class=anchor href=#%e7%9b%b8%e4%bf%a1%e7%9c%8b%e5%ae%8c%e8%bf%99%e7%af%87%e6%96%87%e7%ab%a0%e5%8f%af%e4%bb%a5%e5%af%b9%e5%ae%b9%e5%99%a8%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e6%9c%89%e4%ba%86%e4%b8%80%e4%ba%9b%e5%8e%9f%e7%90%86%e6%80%a7%e7%9a%84%e7%90%86%e8%a7%a3>#</a></h5><h5 id=上文-为什么杀不掉容器中-1号进程-的示例中的-dockerfile-都是-exec-模式如果换成-shell-模式是否会出现不同情况有兴趣可以实验验证下>上文 <strong>为什么杀不掉容器中 1号进程</strong> 的示例中的 Dockerfile 都是 <strong>exec 模式</strong>，如果换成 <strong>shell 模式</strong>，是否会出现不同情况，有兴趣可以实验验证下。
<a class=anchor href=#%e4%b8%8a%e6%96%87-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9d%80%e4%b8%8d%e6%8e%89%e5%ae%b9%e5%99%a8%e4%b8%ad-1%e5%8f%b7%e8%bf%9b%e7%a8%8b-%e7%9a%84%e7%a4%ba%e4%be%8b%e4%b8%ad%e7%9a%84-dockerfile-%e9%83%bd%e6%98%af-exec-%e6%a8%a1%e5%bc%8f%e5%a6%82%e6%9e%9c%e6%8d%a2%e6%88%90-shell-%e6%a8%a1%e5%bc%8f%e6%98%af%e5%90%a6%e4%bc%9a%e5%87%ba%e7%8e%b0%e4%b8%8d%e5%90%8c%e6%83%85%e5%86%b5%e6%9c%89%e5%85%b4%e8%b6%a3%e5%8f%af%e4%bb%a5%e5%ae%9e%e9%aa%8c%e9%aa%8c%e8%af%81%e4%b8%8b>#</a></h5><h4 id=引用链接>引用链接
<a class=anchor href=#%e5%bc%95%e7%94%a8%e9%93%be%e6%8e%a5>#</a></h4><p><code>[1]</code> tini: <em><a href=https://github.com/krallin/tini.git>https://github.com/krallin/tini.git</a></em></p><hr></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li></li></ul></li><li><a href=#为什么杀不掉容器中-1号进程>为什么杀不掉容器中 1号进程</a><ul><li></li><li><a href=#现象>现象</a></li><li><a href=#linux-信号>Linux 信号</a></li><li><a href=#linux-信号处理原理>Linux 信号处理原理</a></li></ul></li><li><a href=#1-号进程与-init-进程>1 号进程与 init 进程</a><ul><li></li><li><a href=#1-号进程><strong>1 号进程</strong></a></li><li><a href=#init-进程><strong>init 进程</strong></a></li></ul></li><li><a href=#容器中的-init-进程>容器中的 init 进程</a><ul><li></li><li><a href=#shell-模式>shell 模式</a></li><li><a href=#exec-模式>exec 模式</a></li><li><a href=#使用-exec-命令>使用 exec 命令</a></li><li><a href=#使用-tini>使用 tini</a></li><li><a href=#使用场景>使用场景</a></li></ul></li><li><a href=#总结>总结</a><ul><li></li></ul></li></ul></nav></div></aside></main></body></html>