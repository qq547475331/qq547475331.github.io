<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  delete pvc时 设置什么字段可以保证pv不被删除
  #

在 Kubernetes 中，当你删除 PersistentVolumeClaim（PVC） 时，默认情况下与之关联的 PersistentVolume（PV） 会根据 PV 的 回收策略 被删除。为了确保在删除 PVC 时 PV 不被删除，你需要修改 PV 的 回收策略（reclaimPolicy） 字段。

  步骤
  #



设置 PV 的回收策略：


回收策略
：Kubernetes 支持几种 PV 的回收策略，常见的有：

Retain：保持 PV 不删除，手动处理。
Recycle：回收 PV（已废弃，不推荐使用）。
Delete：删除 PV（这是默认设置，当 PVC 删除时 PV 会被删除）。



如果你希望 PVC 删除时 PV 不被删除，需要将 PV 的回收策略设置为 Retain。这样，当 PVC 删除时，PV 仍然会保留，必须手动清理或者重新配置。


如何修改回收策略：

编辑你的 PersistentVolume（PV） 对象，修改 reclaimPolicy 为 Retain。

下面是一个例子：
apiVersion: v1
kind: PersistentVolume
metadata:
  name: my-pv
spec:
  capacity:
    storage: 10Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain   # 设置回收策略为 Retain
  storageClassName: manual
  hostPath:
    path: /mnt/data
在这个例子中，persistentVolumeReclaimPolicy: Retain 确保当与该 PV 关联的 PVC 被删除时，PV 并不会被删除。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2025-2-20 面试0220"><meta property="og:description" content="delete pvc时 设置什么字段可以保证pv不被删除 # 在 Kubernetes 中，当你删除 PersistentVolumeClaim（PVC） 时，默认情况下与之关联的 PersistentVolume（PV） 会根据 PV 的 回收策略 被删除。为了确保在删除 PVC 时 PV 不被删除，你需要修改 PV 的 回收策略（reclaimPolicy） 字段。
步骤 # 设置 PV 的回收策略：
回收策略
：Kubernetes 支持几种 PV 的回收策略，常见的有：
Retain：保持 PV 不删除，手动处理。 Recycle：回收 PV（已废弃，不推荐使用）。 Delete：删除 PV（这是默认设置，当 PVC 删除时 PV 会被删除）。 如果你希望 PVC 删除时 PV 不被删除，需要将 PV 的回收策略设置为 Retain。这样，当 PVC 删除时，PV 仍然会保留，必须手动清理或者重新配置。
如何修改回收策略：
编辑你的 PersistentVolume（PV） 对象，修改 reclaimPolicy 为 Retain。 下面是一个例子：
apiVersion: v1 kind: PersistentVolume metadata: name: my-pv spec: capacity: storage: 10Gi volumeMode: Filesystem accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain # 设置回收策略为 Retain storageClassName: manual hostPath: path: /mnt/data 在这个例子中，persistentVolumeReclaimPolicy: Retain 确保当与该 PV 关联的 PVC 被删除时，PV 并不会被删除。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2025-2-20 面试0220 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.3c324ac138affce4ebf1b0fba2b35185d375d1ba7cc73b75b89a68941a98ebad.js integrity="sha256-PDJKwTiv/OTr8bD7orNRhdN10bp8xzt1uJpolBqY660=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-7 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-7 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-7 k8s组件</a></li><li><a href=/docs/2025-2-28-prometheus/>2025-2-28 prometheus 面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/ class=active>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2025-1-16 k8s流量链路剖析</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2025-1-16 CSI剖析演进</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-8-1 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 k8s面试题</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-5-1 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-4-17 面试总结</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-3-8 面试</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-3-4 CNI剖析演进</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-3-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2024-3-14 vivo面试</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-2-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-2-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-2-22 k8s架构师面试大全</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-2-20 面试0220</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#delete-pvc时-设置什么字段可以保证pv不被删除>delete pvc时 设置什么字段可以保证pv不被删除</a><ul><li><a href=#步骤>步骤</a></li><li><a href=#总结>总结：</a></li></ul></li><li><a href=#重新绑定到一个新的-pvc-数据还在吗>重新绑定到一个新的 PVC 数据还在吗</a><ul><li><a href=#如何运作>如何运作：</a></li><li><a href=#例子>例子：</a></li><li><a href=#注意事项>注意事项：</a></li><li><a href=#总结-1>总结：</a></li></ul></li><li><a href=#临时存储的字段是啥>临时存储的字段是啥</a><ul><li><a href=#1-emptydir>1. <strong>emptyDir</strong></a></li><li><a href=#2-ephemeral>2. <strong>ephemeral</strong></a></li><li><a href=#3-hostpath>3. <strong>hostPath</strong></a></li><li><a href=#4-临时存储请求>4. <strong>临时存储请求（<code>ephemeral-storage</code>）</strong></a></li><li><a href=#总结-2>总结</a></li></ul></li><li><a href=#metric-server-干啥的>metric-server 干啥的</a><ul><li><a href=#metric-server-的功能>Metric Server 的功能</a></li><li><a href=#metric-server-的工作原理>Metric Server 的工作原理</a></li><li><a href=#安装与配置>安装与配置</a></li><li><a href=#常见问题>常见问题</a></li><li><a href=#总结-3>总结</a></li><li><a href=#更深入的工作原理>更深入的工作原理</a></li><li><a href=#数据流动示例>数据流动示例</a></li><li><a href=#cadvisor-和-metric-server-的协作>cAdvisor 和 Metric Server 的协作</a></li><li><a href=#为什么-cadvisor-和-metric-server-配合使用>为什么 cAdvisor 和 Metric Server 配合使用？</a></li><li><a href=#其他相关工具>其他相关工具</a></li><li><a href=#总结-4>总结</a></li></ul></li><li><a href=#deploy里面定义secrect的字段是啥>deploy里面定义secrect的字段是啥</a><ul><li><a href=#1-通过环境变量传递-secret>1. 通过环境变量传递 Secret</a></li><li><a href=#2-通过卷挂载-secret>2. 通过卷挂载 Secret</a></li><li><a href=#总结-5>总结</a></li></ul></li><li><a href=#pod被调度的方式有哪些>pod被调度的方式有哪些</a><ul><li><a href=#1-默认调度>1. <strong>默认调度</strong></a></li><li><a href=#2-node-affinity节点亲和性>2. <strong>Node Affinity（节点亲和性）</strong></a></li><li><a href=#3-pod-affinity-和-pod-anti-affinity>3. <strong>Pod Affinity 和 Pod Anti-Affinity</strong></a></li><li><a href=#4-taints-和-tolerations污点和容忍>4. <strong>Taints 和 Tolerations（污点和容忍）</strong></a></li><li><a href=#5-资源请求和限制resource-requests-and-limits>5. <strong>资源请求和限制（Resource Requests and Limits）</strong></a></li><li><a href=#6-priority-class优先级类>6. <strong>Priority Class（优先级类）</strong></a></li><li><a href=#7-topology-spread-constraints拓扑分布约束>7. <strong>Topology Spread Constraints（拓扑分布约束）</strong></a></li><li><a href=#总结-6>总结</a></li></ul></li><li><a href=#daemonset-忽略污点-使其可以调度到所有节点>daemonset 忽略污点 使其可以调度到所有节点</a><ul><li><a href=#1-理解污点和容忍>1. <strong>理解污点和容忍</strong></a></li><li><a href=#2-修改-daemonset-的配置>2. <strong>修改 DaemonSet 的配置</strong></a></li><li><a href=#3-解释上述配置>3. <strong>解释上述配置</strong></a></li><li><a href=#4-使其可以调度到所有节点>4. <strong>使其可以调度到所有节点</strong></a></li><li><a href=#5-应用配置>5. <strong>应用配置</strong></a></li><li><a href=#总结-7>总结</a></li></ul></li><li><a href=#pod的状态有哪些>pod的状态有哪些？</a><ul><li><a href=#1-pending等待中>1. <strong>Pending（等待中）</strong></a></li><li><a href=#2-running运行中>2. <strong>Running（运行中）</strong></a></li><li><a href=#3-succeeded成功>3. <strong>Succeeded（成功）</strong></a></li><li><a href=#4-failed失败>4. <strong>Failed（失败）</strong></a></li><li><a href=#5-unknown未知>5. <strong>Unknown（未知）</strong></a></li><li><a href=#pod-状态的详细说明>Pod 状态的详细说明</a></li><li><a href=#pod-状态的细化字段容器级>Pod 状态的细化字段（容器级）</a></li><li><a href=#容器状态示例>容器状态示例：</a></li><li><a href=#总结-8>总结</a></li></ul></li><li><a href=#evicted呢>evicted呢？</a><ul><li><a href=#evicted-状态的原因><strong>Evicted</strong> 状态的原因</a></li><li><a href=#evicted-状态的标志><strong>Evicted</strong> 状态的标志</a></li><li><a href=#evicted-的后续处理><strong>Evicted</strong> 的后续处理</a></li><li><a href=#总结-9>总结</a></li></ul></li><li><a href=#如果同一个pod-出现几十几百次的evicted-是啥原因>如果同一个pod 出现几十几百次的evicted 是啥原因？</a><ul><li></li><li><a href=#1-资源不足-memorypressure--diskpressure>1. <strong>资源不足 (MemoryPressure / DiskPressure)</strong></a></li><li><a href=#2-pod-配置问题>2. <strong>Pod 配置问题</strong></a></li><li><a href=#3-pod-驱逐策略taints-和-tolerations>3. <strong>Pod 驱逐策略（Taints 和 Tolerations）</strong></a></li><li><a href=#4-调度和优先级问题>4. <strong>调度和优先级问题</strong></a></li><li><a href=#5-poddisruptionbudget-pdb>5. <strong>PodDisruptionBudget (PDB)</strong></a></li><li><a href=#6-集群健康和调度器问题>6. <strong>集群健康和调度器问题</strong></a></li><li><a href=#如何解决>如何解决？</a></li><li><a href=#总结-10>总结</a></li></ul></li><li><a href=#如果pod超出资源限制被杀死那他时重启-重建还是什么呢>如果pod超出资源限制被杀死，那他时重启 重建还是什么呢？</a><ul><li><a href=#1-容器被杀死时的行为>1. <strong>容器被杀死时的行为</strong></a></li><li><a href=#2-容器的重启行为>2. <strong>容器的重启行为</strong></a></li><li><a href=#3-由控制器管理的行为>3. <strong>由控制器管理的行为</strong></a></li><li><a href=#4-oom-kill-与重启的细节>4. <strong>OOM Kill 与重启的细节</strong></a></li><li><a href=#5-pod-状态变化>5. <strong>Pod 状态变化</strong></a></li><li><a href=#6-如何避免-pod-被-oom-杀死>6. <strong>如何避免 Pod 被 OOM 杀死</strong></a></li><li><a href=#总结-11>总结</a></li></ul></li><li><a href=#如果-pod-配置了-restartpolicy-always这是-deploymentreplicaset-等控制器的默认重启策略即使容器被-oom-杀死或因其他原因退出kubernetes-会自动重新启动容器-控制器行为如果是由-deployment-或-replicaset-管理的-pod当容器因资源超限而被杀死时kubernetes-会自动重新调度一个新的容器实例以确保-pod-的副本数不变-自相矛盾了吧>如果 Pod 配置了 restartPolicy: Always（这是 Deployment、ReplicaSet 等控制器的默认重启策略），即使容器被 OOM 杀死或因其他原因退出，Kubernetes 会自动重新启动容器。 控制器行为：如果是由 Deployment 或 ReplicaSet 管理的 Pod，当容器因资源超限而被杀死时，Kubernetes 会自动重新调度一个新的容器实例，以确保 Pod 的副本数不变。 自相矛盾了吧</a><ul><li></li><li><a href=#restartpolicy-always-和-控制器行为><code>restartPolicy: Always</code> 和 控制器行为</a></li><li><a href=#控制器的行为>控制器的行为：</a></li><li><a href=#细节容器的重启-vs-pod-重建>细节：容器的重启 vs Pod 重建</a></li></ul></li><li><a href=#debug容器调试老是crashbackof的pod>debug容器调试老是crashbackof的pod？</a><ul><li><a href=#crashbackoff-产生的常见原因><strong>CrashBackOff</strong> 产生的常见原因</a></li><li><a href=#调试-crashbackoff-的步骤><strong>调试 CrashBackOff 的步骤</strong></a></li><li><a href=#示例查看容器日志><strong>示例</strong>：查看容器日志</a></li><li><a href=#常见的-crashbackoff-问题和解决方案><strong>常见的 CrashBackOff 问题和解决方案</strong></a></li><li><a href=#总结-12>总结</a></li></ul></li><li><a href=#kubectl-exec-进不去因为-会一直重启>kubectl exec 进不去因为 会一直重启</a><ul><li><a href=#1-使用>1. <strong>使用 <code>kubectl logs</code> 查看日志</strong></a></li><li><a href=#2-暂时设置重启策略为>2. <strong>暂时设置重启策略为 <code>Never</code></strong></a></li><li><a href=#3-增加容器启动延迟>3. <strong>增加容器启动延迟</strong></a></li><li><a href=#4-修改容器的启动命令为调试模式>4. <strong>修改容器的启动命令为调试模式</strong></a></li><li><a href=#5-使用>5. <strong>使用 <code>kubectl run</code> 创建临时 Pod 进行调试</strong></a></li><li><a href=#6-查看-pod-状态和事件>6. <strong>查看 Pod 状态和事件</strong></a></li><li><a href=#7-通过>7. <strong>通过 <code>kubectl debug</code> 创建调试容器</strong></a></li><li><a href=#总结-13>总结</a></li></ul></li><li><a href=#默认日志存在宿主机那个位置>默认日志存在宿主机那个位置？</a><ul><li><a href=#1-docker-容器日志默认路径>1. <strong>Docker 容器日志默认路径</strong></a></li><li><a href=#2-containerd-容器日志默认路径>2. <strong>containerd 容器日志默认路径</strong></a></li><li><a href=#3-kubernetes-节点日志varlogcontainers>3. <strong>Kubernetes 节点日志（/var/log/containers）</strong></a></li><li><a href=#4-查看日志的其它方式>4. <strong>查看日志的其它方式</strong></a></li><li><a href=#总结-14>总结</a></li></ul></li><li><a href=#docker的网络模式有哪些>docker的网络模式有哪些</a></li><li><a href=#nginx的location的proxy的地址后面加和不加的区别>nginx的location的proxy的地址后面加/和不加/的区别</a><ul><li><a href=#1-加>1. <strong>加 <code>/</code>：</strong></a></li><li><a href=#2-不加>2. <strong>不加 <code>/</code>：</strong></a></li><li><a href=#小结>小结：</a></li></ul></li><li><a href=#k8s的dns的影响clusterfist-还有哪些>k8s的dns的影响clusterfist 还有哪些</a><ul><li><a href=#1-clusterfirst-和-clusterfirstwithhostnet>1. <strong>ClusterFirst 和 ClusterFirstWithHostNet</strong></a></li><li><a href=#2-dns解析的依赖性>2. <strong>DNS解析的依赖性</strong></a></li><li><a href=#3-dns配置中的>3. <strong>DNS配置中的<code>search</code>和<code>resolve</code></strong></a></li><li><a href=#4-networkpolicy的影响>4. <strong>NetworkPolicy的影响</strong></a></li><li><a href=#5-coredns和>5. <strong>CoreDNS和<code>kube-dns</code></strong></a></li><li><a href=#6-集群网络插件cni>6. <strong>集群网络插件（CNI）</strong></a></li><li><a href=#7-dns-pod和service的高可用性>7. <strong>DNS Pod和Service的高可用性</strong></a></li><li><a href=#8-externaldns>8. <strong>ExternalDNS</strong></a></li><li><a href=#小结-1>小结：</a></li></ul></li><li><a href=#calico和flannel有什么区别>calico和flannel有什么区别</a><ul><li><a href=#1-设计理念>1. <strong>设计理念</strong></a></li><li><a href=#2-网络模式>2. <strong>网络模式</strong></a></li><li><a href=#3-网络策略network-policy>3. <strong>网络策略（Network Policy）</strong></a></li><li><a href=#4-性能>4. <strong>性能</strong></a></li><li><a href=#5-可扩展性>5. <strong>可扩展性</strong></a></li><li><a href=#6-安装与配置>6. <strong>安装与配置</strong></a></li><li><a href=#7-社区支持与生态>7. <strong>社区支持与生态</strong></a></li><li><a href=#8-支持的功能>8. <strong>支持的功能</strong></a></li><li><a href=#总结-15>总结</a></li></ul></li><li><a href=#efk-elasticsearch-fluentd-kibana-怎么用-干嘛的-怎么收集pod日志-存储展示>efk elasticsearch fluentd kibana 怎么用 干嘛的 怎么收集pod日志 存储展示</a><ul><li><a href=#1-efk-组件介绍>1. <strong>EFK 组件介绍</strong></a></li><li><a href=#2-efk-体系架构>2. <strong>EFK 体系架构</strong></a></li><li><a href=#3-efk-的用途>3. <strong>EFK 的用途</strong></a></li><li><a href=#4-如何配置-efk-以收集-kubernetes-pod-日志>4. <strong>如何配置 EFK 以收集 Kubernetes Pod 日志</strong></a></li><li><a href=#5-查看和分析日志>5. <strong>查看和分析日志</strong></a></li><li><a href=#6-日志存储和展示的最佳实践>6. <strong>日志存储和展示的最佳实践</strong></a></li><li><a href=#总结-16>总结</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=delete-pvc时-设置什么字段可以保证pv不被删除>delete pvc时 设置什么字段可以保证pv不被删除
<a class=anchor href=#delete-pvc%e6%97%b6-%e8%ae%be%e7%bd%ae%e4%bb%80%e4%b9%88%e5%ad%97%e6%ae%b5%e5%8f%af%e4%bb%a5%e4%bf%9d%e8%af%81pv%e4%b8%8d%e8%a2%ab%e5%88%a0%e9%99%a4>#</a></h2><p>在 Kubernetes 中，当你删除 <strong>PersistentVolumeClaim（PVC）</strong> 时，默认情况下与之关联的 <strong>PersistentVolume（PV）</strong> 会根据 PV 的 <strong>回收策略</strong> 被删除。为了确保在删除 PVC 时 <strong>PV 不被删除</strong>，你需要修改 PV 的 <strong>回收策略（reclaimPolicy）</strong> 字段。</p><h3 id=步骤>步骤
<a class=anchor href=#%e6%ad%a5%e9%aa%a4>#</a></h3><ol><li><p><strong>设置 PV 的回收策略</strong>：</p><ul><li><p>回收策略</p><p>：Kubernetes 支持几种 PV 的回收策略，常见的有：</p><ul><li><strong>Retain</strong>：保持 PV 不删除，手动处理。</li><li><strong>Recycle</strong>：回收 PV（已废弃，不推荐使用）。</li><li><strong>Delete</strong>：删除 PV（这是默认设置，当 PVC 删除时 PV 会被删除）。</li></ul></li></ul><p>如果你希望 PVC 删除时 <strong>PV 不被删除</strong>，需要将 PV 的回收策略设置为 <code>Retain</code>。这样，当 PVC 删除时，PV 仍然会保留，必须手动清理或者重新配置。</p></li><li><p><strong>如何修改回收策略</strong>：</p><ul><li>编辑你的 <strong>PersistentVolume（PV）</strong> 对象，修改 <code>reclaimPolicy</code> 为 <code>Retain</code>。</li></ul><p>下面是一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolume</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pv</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>capacity</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>10Gi</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumeMode</span>: <span style=color:#ae81ff>Filesystem</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>persistentVolumeReclaimPolicy</span>: <span style=color:#ae81ff>Retain  </span> <span style=color:#75715e># 设置回收策略为 Retain</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>storageClassName</span>: <span style=color:#ae81ff>manual</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/mnt/data</span>
</span></span></code></pre></div><p>在这个例子中，<code>persistentVolumeReclaimPolicy: Retain</code> 确保当与该 PV 关联的 PVC 被删除时，PV 并不会被删除。</p></li><li><p><strong>删除 PVC 后 PV 的状态</strong>：</p><ul><li>如果 PV 的回收策略设置为 <code>Retain</code>，删除 PVC 后，PV 的状态将会变成 <code>Released</code>，意味着 PV 被释放，但仍然存在于集群中。</li><li>你可以手动清理 PV 或将其重新绑定到一个新的 PVC。</li></ul></li></ol><hr><h3 id=总结>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><p>为了确保在删除 PVC 时 PV 不被删除，您只需在 PV 的定义中设置 <code>persistentVolumeReclaimPolicy: Retain</code>。这样，PVC 删除时，PV 会保持在集群中，并可以由管理员手动处理。</p><h2 id=重新绑定到一个新的-pvc-数据还在吗>重新绑定到一个新的 PVC 数据还在吗
<a class=anchor href=#%e9%87%8d%e6%96%b0%e7%bb%91%e5%ae%9a%e5%88%b0%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84-pvc-%e6%95%b0%e6%8d%ae%e8%bf%98%e5%9c%a8%e5%90%97>#</a></h2><p>是的，当你将一个 <strong>PersistentVolume（PV）</strong> 重新绑定到一个新的 <strong>PersistentVolumeClaim（PVC）</strong> 时，<strong>数据仍然存在</strong>，前提是 PV 是在其原有数据存储上创建的。这里是相关的详细情况：</p><h3 id=如何运作>如何运作：
<a class=anchor href=#%e5%a6%82%e4%bd%95%e8%bf%90%e4%bd%9c>#</a></h3><ol><li><strong>数据存储位置</strong>：PersistentVolume 是与某种存储系统（如 NFS、iSCSI、云存储服务等）相关联的，这意味着 PV 存储的数据通常与 PVC 绑定时存储在持久存储上。无论你是否删除了 PVC，数据仍然保留在该存储系统中，直到手动删除或格式化。</li><li><strong>PV 的生命周期</strong>：<ul><li><strong><code>Retain</code> 策略</strong>：当 PV 的回收策略为 <code>Retain</code> 时，即使与 PV 绑定的 PVC 被删除，PV 不会被删除。这个 PV 会被标记为 <code>Released</code>，表示它不再与任何 PVC 关联，仍然保留其数据。</li><li>这个时候，如果你有另一个 PVC（新的 PVC），并且它的 <strong>存储需求</strong>（如大小和访问模式）与 PV 匹配，你可以将这个新的 PVC 绑定到这个 PV 上。</li></ul></li><li><strong>重新绑定 PVC</strong>：<ul><li>如果新的 PVC 请求的存储大小与 PV 的大小一致，且访问模式（如 <code>ReadWriteOnce</code>, <code>ReadWriteMany</code> 等）也匹配，那么 Kubernetes 会将 PV 重新绑定到这个 PVC。</li><li>重新绑定时，数据是 <strong>不丢失的</strong>，新的 PVC 可以继续访问 PV 中原先存储的数据。</li></ul></li></ol><h3 id=例子>例子：
<a class=anchor href=#%e4%be%8b%e5%ad%90>#</a></h3><p>假设你有一个 PV 已经与一个 PVC 绑定并存储了一些数据，之后你删除了原来的 PVC，但你希望重新将这个 PV 绑定到一个新的 PVC。</p><ol><li><strong>删除原 PVC</strong> 后，PV 会变成 <code>Released</code> 状态。</li><li>创建一个新的 PVC，确保它的存储要求（大小、访问模式等）与 PV 匹配。</li><li>Kubernetes 会将新的 PVC 绑定到这个 PV，并且原有的数据仍然会保留在 PV 上，新的 PVC 可以访问这些数据。</li></ol><h3 id=注意事项>注意事项：
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h3><ul><li><strong>存储类型</strong>：这取决于你使用的存储类型（如 NFS、EBS、Ceph、GlusterFS 等）。大多数情况下，数据会在存储中保留，直到手动清理或删除存储。</li><li><strong>访问模式</strong>：如果新的 PVC 请求的访问模式不匹配（比如原 PVC 使用 <code>ReadWriteOnce</code> 而新 PVC 请求 <code>ReadWriteMany</code>），则 PV 无法与新 PVC 绑定。在这种情况下，你需要修改 PVC 或 PV 来确保访问模式匹配。</li></ul><h3 id=总结-1>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-1>#</a></h3><p>只要你没有删除或覆盖数据存储，重新绑定到新的 PVC 时，<strong>数据是不会丢失的</strong>。这个过程与 PV 和 PVC 的回收策略、存储类型和访问模式相关。在大多数情况下，数据会保留在存储系统中，直到手动清理。</p><h2 id=临时存储的字段是啥>临时存储的字段是啥
<a class=anchor href=#%e4%b8%b4%e6%97%b6%e5%ad%98%e5%82%a8%e7%9a%84%e5%ad%97%e6%ae%b5%e6%98%af%e5%95%a5>#</a></h2><p>在 Kubernetes 中，<strong>临时存储</strong>（通常用于临时存储数据，如 Pod 在运行时需要使用的缓存或中间数据）一般是通过 <strong>emptyDir</strong>、<strong>ephemeral</strong> 或 <strong>hostPath</strong> 等存储方式来实现的。临时存储不会持久化，Pod 被删除时，相关数据也会被清除。</p><p>在定义 PV（PersistentVolume）或 PVC（PersistentVolumeClaim）时，没有专门针对临时存储的字段，但可以通过一些特殊的配置来创建临时存储卷。以下是一些关键字段和概念：</p><h3 id=1-emptydir>1. <strong>emptyDir</strong>
<a class=anchor href=#1-emptydir>#</a></h3><p><code>emptyDir</code> 是一种最常用的临时存储方式。它的特点是，当 Pod 被删除时，<code>emptyDir</code> 中的数据会丢失，适用于临时存储需求，比如缓存或临时文件。</p><ul><li><strong>字段</strong>：<code>emptyDir</code> 在 <strong>PodSpec</strong> 中定义，并且与容器挂载的路径相关联。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/tmp</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>tmp-storage</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>tmp-storage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>emptyDir</span>: {}
</span></span></code></pre></div><ul><li><p>说明</p><p>：</p><ul><li><code>emptyDir: {}</code> 指定了一个空的临时目录，挂载在容器内的 <code>/tmp</code> 路径。</li><li>这个临时目录会随着 Pod 生命周期的结束而删除。<code>emptyDir</code> 是最简单的临时存储方式，适合容器运行期间存储短期数据。</li></ul></li></ul><h3 id=2-ephemeral>2. <strong>ephemeral</strong>
<a class=anchor href=#2-ephemeral>#</a></h3><p>在 Kubernetes 1.23+ 中，<code>ephemeral</code> 存储类引入了更加明确的临时存储概念，允许你使用类似 <code>emptyDir</code> 的临时存储方式，并且提供了更多的控制，如指定存储类型（例如 <code>ephemeral-storage</code>，即本地存储）。</p><ul><li><strong>字段</strong>：<code>ephemeral</code> 在 <code>volume</code> 的定义中。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>ephemeral-storage-example</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>ephemeral-storage</span>: <span style=color:#e6db74>&#34;1Gi&#34;</span>  <span style=color:#75715e># 请求1Gi的临时存储</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/mnt/ephemeral</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>ephemeral-storage</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>ephemeral-storage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ephemeral</span>: {}  <span style=color:#75715e># 指定临时存储</span>
</span></span></code></pre></div><ul><li><p>说明</p><p>：</p><ul><li><code>ephemeral</code> 存储是 Kubernetes 1.23 引入的新的存储类，用于更加明确的临时存储需求。它可与资源请求和限制一起使用。</li><li>该存储在 Pod 生命周期内有效，并会在 Pod 删除时被清除。</li></ul></li></ul><h3 id=3-hostpath>3. <strong>hostPath</strong>
<a class=anchor href=#3-hostpath>#</a></h3><p><code>hostPath</code> 是另一种临时存储方式，允许 Pod 挂载宿主机的文件系统目录，作为临时存储使用。注意，<code>hostPath</code> 不会随着 Pod 删除而清除，它可能会对宿主机文件系统产生影响，因此要小心使用。</p><ul><li><strong>字段</strong>：<code>hostPath</code> 存储类型需要在 <strong>PodSpec</strong> 中定义。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hostpath-example</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/mnt/host</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>host-storage</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>host-storage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/tmp/data </span> <span style=color:#75715e># 宿主机上的路径</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>type</span>: <span style=color:#ae81ff>Directory</span>
</span></span></code></pre></div><ul><li><p>说明</p><p>：</p><ul><li><code>hostPath</code> 将宿主机的 <code>/tmp/data</code> 目录挂载到容器内的 <code>/mnt/host</code> 路径上。</li><li>这种存储方式并不完全是临时的，因为数据会存储在宿主机的文件系统中，直到手动删除或清理。</li></ul></li></ul><h3 id=4-临时存储请求>4. <strong>临时存储请求（<code>ephemeral-storage</code>）</strong>
<a class=anchor href=#4-%e4%b8%b4%e6%97%b6%e5%ad%98%e5%82%a8%e8%af%b7%e6%b1%82>#</a></h3><p>除了 <code>emptyDir</code> 和 <code>ephemeral</code>，还可以通过容器的 <code>resources</code> 字段为容器请求和限制临时存储资源（即 <code>ephemeral-storage</code>），确保容器有足够的本地存储空间。</p><ul><li><strong>字段</strong>：<code>resources.requests</code> 和 <code>resources.limits</code> 中定义 <code>ephemeral-storage</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pod-with-ephemeral-storage</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>ephemeral-storage</span>: <span style=color:#e6db74>&#34;1Gi&#34;</span>  <span style=color:#75715e># 请求1Gi的临时存储</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>ephemeral-storage</span>: <span style=color:#e6db74>&#34;2Gi&#34;</span>  <span style=color:#75715e># 限制最大使用2Gi的临时存储</span>
</span></span></code></pre></div><ul><li><p>说明</p><p>：</p><ul><li><code>ephemeral-storage</code> 用于请求容器的本地存储（例如节点上的磁盘）。容器在运行期间可能会产生一些临时数据，这些数据需要一定量的存储空间。</li><li>这种方式与 <code>emptyDir</code> 类似，但它是通过请求和限制本地存储来实现的。</li></ul></li></ul><h3 id=总结-2>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-2>#</a></h3><p>在 Kubernetes 中，临时存储的字段通常可以通过以下几种方式定义：</p><ul><li><strong><code>emptyDir</code></strong>：提供一个临时存储卷，Pod 删除时清空。</li><li><strong><code>ephemeral</code></strong>：明确的临时存储类（Kubernetes 1.23+）。</li><li><strong><code>hostPath</code></strong>：可以用宿主机的存储目录来作为临时存储，但不会随 Pod 删除而清除。</li><li><strong><code>ephemeral-storage</code></strong>：在资源请求和限制中定义，确保容器有足够的本地存储。</li></ul><p>这些临时存储方式是为了满足 Pod 在生命周期内对临时数据存储的需求，数据会随着 Pod 删除而丢失（在没有持久化配置的情况下）。</p><h2 id=metric-server-干啥的>metric-server 干啥的
<a class=anchor href=#metric-server-%e5%b9%b2%e5%95%a5%e7%9a%84>#</a></h2><p><strong>Metric Server</strong> 是 Kubernetes 集群中的一个核心组件，它负责收集和提供集群内各个节点和容器的性能数据（如 CPU、内存、磁盘等）。这些性能指标（metrics）可以用来进行资源管理、自动扩缩容、监控等。</p><h3 id=metric-server-的功能>Metric Server 的功能
<a class=anchor href=#metric-server-%e7%9a%84%e5%8a%9f%e8%83%bd>#</a></h3><ol><li><strong>资源监控</strong>：Metric Server 会定期收集每个节点和容器的资源使用情况（如 CPU 使用率、内存占用、网络流量等），并将这些数据提供给 Kubernetes 组件。</li><li><strong>HPA（Horizontal Pod Autoscaler）支持</strong>：Metric Server 是 <strong>水平 Pod 自动伸缩（HPA）</strong> 功能的基础。HPA 根据 Pod 的 CPU 或内存使用情况，自动调整 Pod 的副本数，保证应用的负载均衡。Metric Server 为 HPA 提供实时的性能指标数据，使其可以根据当前资源消耗来决定是否扩展或缩减 Pod 的数量。</li><li><strong>监控和报警</strong>：虽然 Metric Server 本身不做长期的监控或报警，但它提供了集群中各个节点和容器的实时指标数据，这些数据可以被其他监控系统（如 Prometheus）进一步存储、分析并触发报警。</li><li><strong>kubectl top 命令</strong>：Metric Server 提供了 <strong><code>kubectl top</code></strong> 命令支持，允许用户查看当前节点或 Pod 的资源使用情况。例如：<ul><li><code>kubectl top nodes</code>：查看每个节点的资源使用情况（CPU、内存等）。</li><li><code>kubectl top pods</code>：查看每个 Pod 的资源使用情况。</li></ul></li></ol><h3 id=metric-server-的工作原理>Metric Server 的工作原理
<a class=anchor href=#metric-server-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h3><ol><li><strong>数据来源</strong>：Metric Server 从 <strong>Kubelet</strong> 收集每个节点和容器的资源使用数据。Kubelet 会定期（通常每分钟）采集节点和容器的资源使用情况（如 CPU、内存、磁盘等）并将这些数据提供给 Metric Server。</li><li><strong>存储与查询</strong>：Metric Server 并不会永久存储这些数据，而是作为一个中间层，提供实时的资源指标查询。当 Kubernetes 需要获取这些指标时（如通过 HPA），Metric Server 会即时响应这些请求。</li><li><strong>API 提供</strong>：Metric Server 通过 Kubernetes 的 <strong>Metrics API</strong> 提供资源使用数据。这个 API 允许其他 Kubernetes 组件（如 HPA）查询各个节点和容器的性能指标。</li></ol><h3 id=安装与配置>安装与配置
<a class=anchor href=#%e5%ae%89%e8%a3%85%e4%b8%8e%e9%85%8d%e7%bd%ae>#</a></h3><ol><li><p><strong>安装</strong>： Metric Server 作为一个独立的服务运行，通常可以通过 Helm 安装或者直接应用 Kubernetes 中提供的资源清单进行安装。例如，使用官方 YAML 文件进行安装：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
</span></span></code></pre></div></li><li><p><strong>配置</strong>： Metric Server 默认情况下会向每个节点的 Kubelet 请求指标数据。如果集群中的 Kubelet 没有正确配置（如禁用了 <strong><code>--read-only-port</code></strong> 或没有启用 <strong><code>--kubelet-insecure-tls</code></strong>），Metric Server 可能无法获取数据。确保 Kubelet 的配置允许 Metric Server 获取指标数据。</p></li><li><p><strong>认证</strong>：Metric Server 需要 Kubernetes API 访问权限来提供数据，通常是通过 RBAC（角色访问控制）进行管理。</p></li></ol><h3 id=常见问题>常见问题
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98>#</a></h3><ul><li><strong>Metric Server 无法工作</strong>：<ul><li>检查 Metric Server 是否已正确安装，并且在集群中正常运行。</li><li>确保 Kubelet 配置允许 Metric Server 获取节点和容器的资源数据。</li><li>如果遇到 <strong>metric API</strong> 不可用的情况，可能是由于 Metric Server 与 API Server 之间的通信问题，检查相关日志和网络配置。</li></ul></li><li><strong>与 Prometheus 的区别</strong>：<ul><li>Metric Server 提供的主要是集群内的 <strong>实时性能数据</strong>（如 CPU、内存使用情况），这些数据通常用于 <strong>自动扩缩容</strong>（HPA）。</li><li><strong>Prometheus</strong> 则是一个完整的监控系统，它可以收集历史性能数据、监控各类应用、支持复杂的查询和报警规则。Prometheus 是长期监控的解决方案，而 Metric Server 更侧重于提供资源管理的基本支持。</li></ul></li></ul><h3 id=总结-3>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-3>#</a></h3><p>Metric Server 是 Kubernetes 集群中用于收集和提供节点、Pod 和容器资源使用情况的组件，它为 HPA 和其他集群组件提供实时的性能指标数据。通过它，Kubernetes 可以根据负载自动扩缩容，保证应用的稳定运行。同时，Metric Server 也为开发者提供了 <strong><code>kubectl top</code></strong> 等命令，帮助快速查看集群资源的使用情况。</p><p>metric-server 更深入的话时通过什么提供指标的 cadvisior？</p><p>是的，<strong>cAdvisor</strong>（Container Advisor）是 <strong>Metric Server</strong> 获取容器级别指标的关键组件之一。它是 <strong>Kubernetes</strong> 集群中的 <strong>Kubelet</strong> 的一部分，负责监控和收集容器的资源使用数据（如 CPU、内存、网络等）。<strong>Metric Server</strong> 从 <strong>cAdvisor</strong> 获取这些容器和节点的性能指标，并提供给其他 Kubernetes 组件（如 <strong>Horizontal Pod Autoscaler</strong>）和用户查询。</p><h3 id=更深入的工作原理>更深入的工作原理
<a class=anchor href=#%e6%9b%b4%e6%b7%b1%e5%85%a5%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h3><ol><li><p><strong>cAdvisor 在 Kubelet 中的作用</strong>：</p><ul><li><p>cAdvisor</p><p>是由 Google 开发的一个用于容器资源监控的工具，它会在 Kubelet 进程内运行并监控每个容器的资源使用情况。它收集的指标包括：</p><ul><li>CPU 使用情况</li><li>内存使用情况</li><li>磁盘 I/O</li><li>网络流量</li><li>文件系统使用等</li></ul></li><li><p><strong>cAdvisor</strong> 将这些数据暴露在 Kubelet 的 <strong>/stats/summary</strong> 或 <strong>/metrics/cadvisor</strong> 等端点上，以便其他服务（如 Metric Server）访问。</p></li></ul></li><li><p><strong>Metric Server 获取数据</strong>：</p><ul><li><strong>Metric Server</strong> 不直接从容器获取数据，而是从 <strong>Kubelet</strong> 获取这些指标。具体而言，Metric Server 会访问 Kubelet 提供的 <strong>Metrics API</strong>，而这些数据实际上是通过 <strong>cAdvisor</strong> 生成的。</li><li><strong>Kubelet</strong> 提供的 API 会以 JSON 格式返回节点和容器的资源使用情况。Metric Server 定期从这些端点拉取数据并将其格式化成标准化的指标，供 Kubernetes 的其他组件（如 HPA）或外部系统（如 Prometheus）使用。</li></ul></li><li><p><strong>cAdvisor 与 Metric Server 的关系</strong>：</p><ul><li><strong>cAdvisor</strong> 负责在容器级别采集资源数据，并提供数据给 Kubelet。</li><li><strong>Metric Server</strong> 通过 Kubelet 获取这些数据，并将其以 Kubernetes 的 <strong>Metrics API</strong> 的形式提供给其他组件。</li><li>它们之间的关系可以看作是 <strong>cAdvisor</strong> 负责采集数据，而 <strong>Metric Server</strong> 负责提供这些数据。</li></ul></li></ol><h3 id=数据流动示例>数据流动示例
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%b5%81%e5%8a%a8%e7%a4%ba%e4%be%8b>#</a></h3><ol><li><strong>Kubelet</strong> 启动并开始运行容器。</li><li><strong>cAdvisor</strong> 在容器内监控并采集资源使用数据（如 CPU、内存等）。</li><li><strong>Kubelet</strong> 定期访问 <strong>cAdvisor</strong> 生成的资源使用数据，并将其公开在内部的 <code>/stats/summary</code> 或 <code>/metrics/cadvisor</code> 等端点上。</li><li><strong>Metric Server</strong> 定期向 Kubelet 的 Metrics API 请求数据（如容器的 CPU 使用率、内存占用等）。</li><li><strong>Metric Server</strong> 获取数据后，将其存储在 Kubernetes 集群中，供 <strong>Horizontal Pod Autoscaler (HPA)</strong>、<code>kubectl top</code> 等工具使用。</li></ol><h3 id=cadvisor-和-metric-server-的协作>cAdvisor 和 Metric Server 的协作
<a class=anchor href=#cadvisor-%e5%92%8c-metric-server-%e7%9a%84%e5%8d%8f%e4%bd%9c>#</a></h3><ul><li><strong>cAdvisor</strong> 主要用于提供容器级别的资源数据。它依赖 <strong>Kubelet</strong> 来暴露容器资源使用的统计信息（包括 CPU、内存、磁盘和网络流量等），并通过 <strong>Kubelet</strong> 的 API 提供这些数据。</li><li><strong>Metric Server</strong> 则是一个轻量级的聚合器，它从 <strong>Kubelet</strong> 获取这些数据，进行格式化后提供给其他 Kubernetes 组件和工具。Metric Server 本身不存储这些数据，而是将其暴露给需要它的系统（例如 HPA）。</li></ul><h3 id=为什么-cadvisor-和-metric-server-配合使用>为什么 cAdvisor 和 Metric Server 配合使用？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88-cadvisor-%e5%92%8c-metric-server-%e9%85%8d%e5%90%88%e4%bd%bf%e7%94%a8>#</a></h3><ul><li><strong>cAdvisor</strong> 提供了容器级别的指标采集，确保 Kubernetes 可以获取最精细的资源消耗数据。</li><li><strong>Metric Server</strong> 聚合和规范化这些数据，使得它可以在 Kubernetes 环境中广泛使用，特别是在自动扩缩容、监控、调度等方面。</li></ul><h3 id=其他相关工具>其他相关工具
<a class=anchor href=#%e5%85%b6%e4%bb%96%e7%9b%b8%e5%85%b3%e5%b7%a5%e5%85%b7>#</a></h3><ul><li><strong>Prometheus</strong>：与 <strong>cAdvisor</strong> 类似，Prometheus 也可以收集和存储指标数据，通常用于长期存储和高级监控。Prometheus 可以通过 <strong>Kubernetes 服务发现</strong> 机制来发现和拉取集群中的所有容器的指标数据，包括来自 <strong>cAdvisor</strong> 的指标。</li><li><strong>Kube-State-Metrics</strong>：另一个补充工具，它提供集群的状态指标数据（如 Pod、Deployment 的状态、ReplicaSet 的数量等），这些数据通常不通过 <strong>cAdvisor</strong> 获取，而是直接从 Kubernetes API 服务器获取。</li></ul><h3 id=总结-4>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-4>#</a></h3><ul><li><strong>cAdvisor</strong> 是 <strong>Kubelet</strong> 的一部分，负责容器级别的资源监控。</li><li><strong>Metric Server</strong> 从 Kubelet 获取这些数据，并将它们以标准格式提供给其他 Kubernetes 组件（如 HPA）和工具（如 <code>kubectl top</code>）。</li><li><strong>Metric Server</strong> 和 <strong>cAdvisor</strong> 协作，共同提供容器和节点的实时资源监控数据。</li></ul><h2 id=deploy里面定义secrect的字段是啥>deploy里面定义secrect的字段是啥
<a class=anchor href=#deploy%e9%87%8c%e9%9d%a2%e5%ae%9a%e4%b9%89secrect%e7%9a%84%e5%ad%97%e6%ae%b5%e6%98%af%e5%95%a5>#</a></h2><p>在 Kubernetes 中，<code>Secret</code> 用于存储敏感数据，如密码、OAuth 令牌、SSH 密钥等。在 Kubernetes 部署（<code>Deployment</code>）中，你可以通过挂载 <code>Secret</code> 来保护这些敏感数据，并将其提供给容器。你可以通过两种方式在 <code>Deployment</code> 中定义 <code>Secret</code>：</p><ol><li><strong>通过环境变量</strong> (<code>envFrom</code> 或 <code>env</code> 字段)</li><li><strong>通过卷挂载</strong> (<code>volumes</code> 和 <code>volumeMounts</code> 字段)</li></ol><p>下面是这两种方式的详细说明和示例：</p><h3 id=1-通过环境变量传递-secret>1. 通过环境变量传递 Secret
<a class=anchor href=#1-%e9%80%9a%e8%bf%87%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e4%bc%a0%e9%80%92-secret>#</a></h3><p>你可以通过环境变量将 <code>Secret</code> 的数据传递到容器中，这是一种比较常见的方式。</p><ul><li><strong>envFrom</strong>：允许将整个 <code>Secret</code> 中的键值对作为环境变量传递给容器。</li><li><strong>env</strong>：可以选择性地传递 <code>Secret</code> 中的特定键值对作为环境变量。</li></ul><h4 id=示例通过-envfrom-将-secret-传递给容器>示例：通过 <code>envFrom</code> 将 <code>Secret</code> 传递给容器
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e9%80%9a%e8%bf%87-envfrom-%e5%b0%86-secret-%e4%bc%a0%e9%80%92%e7%bb%99%e5%ae%b9%e5%99%a8>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>envFrom</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>secretRef</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-secret  </span> <span style=color:#75715e># 传入名为 &#34;my-secret&#34; 的 Secret</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：在这个例子中，<code>envFrom</code> 字段引用了一个名为 <code>my-secret</code> 的 Secret。这个 Secret 中的所有键值对会作为环境变量传递到容器中。</li></ul><h4 id=示例通过-env-选择性传递-secret-中的某些键>示例：通过 <code>env</code> 选择性传递 Secret 中的某些键
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e9%80%9a%e8%bf%87-env-%e9%80%89%e6%8b%a9%e6%80%a7%e4%bc%a0%e9%80%92-secret-%e4%b8%ad%e7%9a%84%e6%9f%90%e4%ba%9b%e9%94%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>DB_PASSWORD      </span> <span style=color:#75715e># 环境变量的名称</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>secretKeyRef</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-secret    </span> <span style=color:#75715e># 引用的 Secret 名称</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>key</span>: <span style=color:#ae81ff>password     </span> <span style=color:#75715e># Secret 中的具体键（值）</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：在这个例子中，<code>env</code> 字段通过 <code>secretKeyRef</code> 引用了 <code>my-secret</code> Secret 中的 <code>password</code> 键，并将其传递给容器作为环境变量 <code>DB_PASSWORD</code>。</li></ul><h3 id=2-通过卷挂载-secret>2. 通过卷挂载 Secret
<a class=anchor href=#2-%e9%80%9a%e8%bf%87%e5%8d%b7%e6%8c%82%e8%bd%bd-secret>#</a></h3><p>你还可以将 <code>Secret</code> 以文件的形式挂载到容器内。这通常用于将配置文件或者密钥文件直接提供给应用。</p><h4 id=示例通过卷挂载-secret>示例：通过卷挂载 Secret
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e9%80%9a%e8%bf%87%e5%8d%b7%e6%8c%82%e8%bd%bd-secret>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>secret-volume</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/etc/secret-volume </span> <span style=color:#75715e># 容器内挂载路径</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>secret-volume</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>secret</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>secretName</span>: <span style=color:#ae81ff>my-secret  </span> <span style=color:#75715e># 引用 Secret 名称</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：在这个例子中，<code>volumes</code> 字段将 <code>my-secret</code> Secret 挂载到容器的 <code>/etc/secret-volume</code> 路径下。Secret 中的每个键都会成为文件名，并且文件的内容就是对应的 Secret 键的值。容器内应用可以通过读取这些文件来获取敏感信息。</li></ul><h3 id=总结-5>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-5>#</a></h3><p>在 <code>Deployment</code> 中引用 <code>Secret</code> 时，通常用到以下两个字段：</p><ul><li><strong>envFrom</strong>：将整个 <code>Secret</code> 的内容作为环境变量传递给容器。</li><li><strong>env</strong>：将 <code>Secret</code> 中的特定键作为环境变量传递给容器。</li><li><strong>volumes</strong> 和 <strong>volumeMounts</strong>：将 <code>Secret</code> 挂载为文件，容器通过文件读取敏感数据。</li></ul><p>这些方法可以帮助你安全地将敏感数据注入到容器中，并避免将敏感信息硬编码到应用中。</p><h2 id=pod被调度的方式有哪些>pod被调度的方式有哪些
<a class=anchor href=#pod%e8%a2%ab%e8%b0%83%e5%ba%a6%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h2><p>在 Kubernetes 中，Pod 的调度是指将 Pod 安排到集群中的节点（Node）上执行的过程。调度策略基于多种因素，包括资源需求、拓扑、亲和性/反亲和性、节点负载、硬件特性等。调度过程通常由 <strong>Kube-scheduler</strong> 完成，它是 Kubernetes 的一个控制器，负责决定哪些节点能运行给定的 Pod。</p><p>Kubernetes 提供了多种方式来控制和影响 Pod 的调度。以下是常见的调度方式和策略：</p><h3 id=1-默认调度>1. <strong>默认调度</strong>
<a class=anchor href=#1-%e9%bb%98%e8%ae%a4%e8%b0%83%e5%ba%a6>#</a></h3><p>默认情况下，Kubernetes 的调度器会根据以下条件将 Pod 调度到一个合适的节点：</p><ul><li><strong>资源请求</strong>：Pod 的资源请求（如 CPU 和内存）与节点的可用资源匹配。</li><li><strong>节点选择</strong>：Kubernetes 调度器会选择一个具有足够资源的节点（例如，满足 CPU 和内存要求）来运行 Pod。</li></ul><h3 id=2-node-affinity节点亲和性>2. <strong>Node Affinity（节点亲和性）</strong>
<a class=anchor href=#2-node-affinity%e8%8a%82%e7%82%b9%e4%ba%b2%e5%92%8c%e6%80%a7>#</a></h3><p><strong>Node Affinity</strong> 是一种影响调度的约束条件，用于指定 Pod 应该调度到哪些节点。它基于节点的标签来决定 Pod 是否可以调度到某个节点。节点亲和性包括两种类型：</p><ul><li><strong>requiredDuringSchedulingIgnoredDuringExecution</strong>：这是强制的约束，调度器必须满足该条件才能将 Pod 调度到节点上。</li><li><strong>preferredDuringSchedulingIgnoredDuringExecution</strong>：这是一个偏好条件，调度器会尽量满足，但不是强制的。</li></ul><h4 id=示例node-affinity-配置>示例：Node Affinity 配置
<a class=anchor href=#%e7%a4%ba%e4%be%8bnode-affinity-%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>affinity</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nodeAffinity</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requiredDuringSchedulingIgnoredDuringExecution</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>nodeSelectorTerms</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>matchExpressions</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;disktype&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>operator</span>: <span style=color:#ae81ff>In</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>values</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>ssd</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：这个例子指定了 <code>Node Affinity</code>，要求 Pod 只能调度到具有 <code>disktype=ssd</code> 标签的节点上。</li></ul><h3 id=3-pod-affinity-和-pod-anti-affinity>3. <strong>Pod Affinity 和 Pod Anti-Affinity</strong>
<a class=anchor href=#3-pod-affinity-%e5%92%8c-pod-anti-affinity>#</a></h3><ul><li><strong>Pod Affinity</strong>：允许 Pod 调度到靠近其他特定 Pod 的节点上，适用于有依赖关系的服务。</li><li><strong>Pod Anti-Affinity</strong>：要求 Pod 不与其他特定的 Pod 调度到同一个节点上，适用于避免 Pod 之间的资源争用或提高高可用性。</li></ul><h4 id=示例pod-affinity-配置>示例：Pod Affinity 配置
<a class=anchor href=#%e7%a4%ba%e4%be%8bpod-affinity-%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>affinity</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>podAffinity</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requiredDuringSchedulingIgnoredDuringExecution</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>labelSelector</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>app</span>: <span style=color:#ae81ff>frontend</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>topologyKey</span>: <span style=color:#e6db74>&#34;kubernetes.io/hostname&#34;</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：这个例子表示 Pod 只会调度到与 <code>app=frontend</code> 标签的 Pod 运行在同一节点上的位置。</li></ul><h4 id=示例pod-anti-affinity-配置>示例：Pod Anti-Affinity 配置
<a class=anchor href=#%e7%a4%ba%e4%be%8bpod-anti-affinity-%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>affinity</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>podAntiAffinity</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requiredDuringSchedulingIgnoredDuringExecution</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>labelSelector</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>app</span>: <span style=color:#ae81ff>frontend</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>topologyKey</span>: <span style=color:#e6db74>&#34;kubernetes.io/hostname&#34;</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：这个例子要求 Pod 不与 <code>app=frontend</code> 标签的 Pod 调度到同一节点上。</li></ul><h3 id=4-taints-和-tolerations污点和容忍>4. <strong>Taints 和 Tolerations（污点和容忍）</strong>
<a class=anchor href=#4-taints-%e5%92%8c-tolerations%e6%b1%a1%e7%82%b9%e5%92%8c%e5%ae%b9%e5%bf%8d>#</a></h3><ul><li><strong>Taints</strong> 是节点的属性，表示该节点上有某种限制，只有具备相应容忍（Tolerations）的 Pod 才能被调度到该节点上。</li><li><strong>Tolerations</strong> 使得 Pod 可以被调度到带有某些污点的节点上。</li></ul><h4 id=示例taint-和-toleration-配置>示例：Taint 和 Toleration 配置
<a class=anchor href=#%e7%a4%ba%e4%be%8btaint-%e5%92%8c-toleration-%e9%85%8d%e7%bd%ae>#</a></h4><ol><li><strong>Taint 节点</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl taint nodes node1 key<span style=color:#f92672>=</span>value:NoSchedule
</span></span></code></pre></div><ol><li><strong>Toleration 配置</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>tolerations</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;key&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>operator</span>: <span style=color:#e6db74>&#34;Equal&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;value&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>effect</span>: <span style=color:#e6db74>&#34;NoSchedule&#34;</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：这个例子在节点 <code>node1</code> 上设置了一个污点 <code>key=value:NoSchedule</code>，而 Pod 使用了 <code>tolerations</code> 来容忍这个污点，允许 Pod 被调度到该节点。</li></ul><h3 id=5-资源请求和限制resource-requests-and-limits>5. <strong>资源请求和限制（Resource Requests and Limits）</strong>
<a class=anchor href=#5-%e8%b5%84%e6%ba%90%e8%af%b7%e6%b1%82%e5%92%8c%e9%99%90%e5%88%b6resource-requests-and-limits>#</a></h3><p>每个 Pod 和容器都可以定义资源请求（<code>requests</code>）和限制（<code>limits</code>），以便调度器能合理分配资源。调度器会根据资源的需求来选择合适的节点。</p><ul><li><strong>请求（Requests）</strong>：是调度时考虑的资源需求，表示 Pod 需要的最小资源。</li><li><strong>限制（Limits）</strong>：是容器能够使用的最大资源，超过这个限制会被限制。</li></ul><h4 id=示例资源请求和限制配置>示例：资源请求和限制配置
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e8%b5%84%e6%ba%90%e8%af%b7%e6%b1%82%e5%92%8c%e9%99%90%e5%88%b6%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;64Mi&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;250m&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;128Mi&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;500m&#34;</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：这个例子为容器配置了内存和 CPU 的资源请求和限制。调度器会根据这些信息来选择合适的节点。</li></ul><h3 id=6-priority-class优先级类>6. <strong>Priority Class（优先级类）</strong>
<a class=anchor href=#6-priority-class%e4%bc%98%e5%85%88%e7%ba%a7%e7%b1%bb>#</a></h3><p>优先级类用于定义 Pod 的调度优先级。Pod 可以指定一个优先级类，调度器会根据优先级类来确定 Pod 调度的顺序。高优先级的 Pod 会优先被调度，低优先级的 Pod 可能会被抢占或者延迟调度。</p><h4 id=示例priority-class-配置>示例：Priority Class 配置
<a class=anchor href=#%e7%a4%ba%e4%be%8bpriority-class-%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>scheduling.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PriorityClass</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>high-priority</span>
</span></span><span style=display:flex><span><span style=color:#f92672>value</span>: <span style=color:#ae81ff>1000000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>globalDefault</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#f92672>description</span>: <span style=color:#e6db74>&#34;This priority class is for critical workloads.&#34;</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：这个例子定义了一个高优先级类 <code>high-priority</code>，并为高优先级的 Pod 配置了该类。</li></ul><h3 id=7-topology-spread-constraints拓扑分布约束>7. <strong>Topology Spread Constraints（拓扑分布约束）</strong>
<a class=anchor href=#7-topology-spread-constraints%e6%8b%93%e6%89%91%e5%88%86%e5%b8%83%e7%ba%a6%e6%9d%9f>#</a></h3><p>拓扑分布约束用于控制 Pod 在集群中的分布，确保 Pod 分布在不同的区域或节点上，以提高可用性并避免资源集中。</p><h4 id=示例拓扑分布约束配置>示例：拓扑分布约束配置
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e6%8b%93%e6%89%91%e5%88%86%e5%b8%83%e7%ba%a6%e6%9d%9f%e9%85%8d%e7%bd%ae>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>topologySpreadConstraints</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>maxSkew</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>topologyKey</span>: <span style=color:#e6db74>&#34;kubernetes.io/hostname&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>whenUnsatisfiable</span>: <span style=color:#ae81ff>DoNotSchedule</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>labelSelector</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span></code></pre></div><ul><li><strong>说明</strong>：这个例子确保 Pod 在不同的节点上均匀分布，避免所有 Pod 都调度到同一个节点。</li></ul><h3 id=总结-6>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-6>#</a></h3><p>Pod 的调度方式有很多种，主要通过以下策略来控制：</p><ol><li><strong>Node Affinity</strong>：控制 Pod 只能调度到具有特定标签的节点。</li><li><strong>Pod Affinity 和 Pod Anti-Affinity</strong>：控制 Pod 在集群中与其他 Pod 的亲和性或反亲和性。</li><li><strong>Taints 和 Tolerations</strong>：控制哪些 Pod 能够调度到具有特定污点的节点。</li><li><strong>资源请求和限制</strong>：根据 Pod 的资源需求选择合适的节点。</li><li><strong>Priority Class</strong>：控制 Pod 的调度优先级。</li><li><strong>Topology Spread Constraints</strong>：控制 Pod 在不同节点、区域的分布。</li></ol><p>这些调度策略提供了灵活的方式来控制 Pod 的调度，以满足特定的业务需求和集群配置。</p><h2 id=daemonset-忽略污点-使其可以调度到所有节点>daemonset 忽略污点 使其可以调度到所有节点
<a class=anchor href=#daemonset-%e5%bf%bd%e7%95%a5%e6%b1%a1%e7%82%b9-%e4%bd%bf%e5%85%b6%e5%8f%af%e4%bb%a5%e8%b0%83%e5%ba%a6%e5%88%b0%e6%89%80%e6%9c%89%e8%8a%82%e7%82%b9>#</a></h2><p>要让一个 <code>DaemonSet</code> 忽略污点并且能够调度到所有节点，可以通过设置 <code>tolerations</code> 来实现。<code>tolerations</code> 允许调度器忽略节点上的污点，允许 Pod 调度到那些被标记为“有污点”的节点。</p><h3 id=1-理解污点和容忍>1. <strong>理解污点和容忍</strong>
<a class=anchor href=#1-%e7%90%86%e8%a7%a3%e6%b1%a1%e7%82%b9%e5%92%8c%e5%ae%b9%e5%bf%8d>#</a></h3><ul><li><strong>污点 (Taints)</strong>: 污点是用于标记节点的属性，它防止特定的 Pod 被调度到这些节点上。污点有三种类型：<code>NoSchedule</code>、<code>PreferNoSchedule</code> 和 <code>NoExecute</code>。</li><li><strong>容忍 (Tolerations)</strong>: 容忍允许 Pod 忽略节点的污点，允许它们调度到这些节点上。</li></ul><h3 id=2-修改-daemonset-的配置>2. <strong>修改 DaemonSet 的配置</strong>
<a class=anchor href=#2-%e4%bf%ae%e6%94%b9-daemonset-%e7%9a%84%e9%85%8d%e7%bd%ae>#</a></h3><p>在 DaemonSet 的 Pod 模板中添加 <code>tolerations</code>，使其容忍所有节点上的污点。示例配置如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>DaemonSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-daemonset</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>example</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>example</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>tolerations</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;node.kubernetes.io/not-ready&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>operator</span>: <span style=color:#e6db74>&#34;Exists&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>effect</span>: <span style=color:#e6db74>&#34;NoSchedule&#34;</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;node.kubernetes.io/unreachable&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>operator</span>: <span style=color:#e6db74>&#34;Exists&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>effect</span>: <span style=color:#e6db74>&#34;NoExecute&#34;</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;some-taint-key&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>operator</span>: <span style=color:#e6db74>&#34;Exists&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>effect</span>: <span style=color:#e6db74>&#34;NoSchedule&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-container</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span></code></pre></div><h3 id=3-解释上述配置>3. <strong>解释上述配置</strong>
<a class=anchor href=#3-%e8%a7%a3%e9%87%8a%e4%b8%8a%e8%bf%b0%e9%85%8d%e7%bd%ae>#</a></h3><ul><li><pre tabindex=0><code>tolerations
</code></pre><p>字段允许 DaemonSet 忽略特定污点。</p><ul><li><code>key</code>: 污点的键。</li><li><code>operator: "Exists"</code>: 表示只要节点上有相应的污点，Pod 就能容忍并调度到该节点。</li><li><code>effect</code>: 污点的作用，<code>NoSchedule</code> 表示该节点不允许调度到 Pod，<code>NoExecute</code> 表示已经调度到节点的 Pod 会被驱逐。</li></ul></li></ul><p>在上述配置中，<code>DaemonSet</code> 会容忍节点上的 <code>not-ready</code>、<code>unreachable</code> 和自定义的污点 <code>some-taint-key</code>，从而允许 Pod 调度到这些被污点标记的节点上。</p><h3 id=4-使其可以调度到所有节点>4. <strong>使其可以调度到所有节点</strong>
<a class=anchor href=#4-%e4%bd%bf%e5%85%b6%e5%8f%af%e4%bb%a5%e8%b0%83%e5%ba%a6%e5%88%b0%e6%89%80%e6%9c%89%e8%8a%82%e7%82%b9>#</a></h3><p>如果希望 <code>DaemonSet</code> 忽略所有污点并且可以调度到所有节点，可以添加一个容忍，表示所有污点都能容忍：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>      <span style=color:#f92672>tolerations</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>operator</span>: <span style=color:#e6db74>&#34;Exists&#34;</span>
</span></span></code></pre></div><p>这样配置后，<code>DaemonSet</code> 的 Pod 将容忍所有污点，从而能够调度到所有节点。</p><h3 id=5-应用配置>5. <strong>应用配置</strong>
<a class=anchor href=#5-%e5%ba%94%e7%94%a8%e9%85%8d%e7%bd%ae>#</a></h3><p>将修改后的 DaemonSet 配置保存为 YAML 文件，然后应用到 Kubernetes 集群：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f daemonset.yaml
</span></span></code></pre></div><h3 id=总结-7>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-7>#</a></h3><p>通过在 <code>DaemonSet</code> 的 <code>spec.template.spec.tolerations</code> 中添加容忍规则，可以让 <code>DaemonSet</code> 忽略节点的污点，进而使 Pod 能够调度到所有节点，包括那些被污点标记的节点。</p><h2 id=pod的状态有哪些>pod的状态有哪些？
<a class=anchor href=#pod%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h2><p>Kubernetes 中的 <strong>Pod</strong> 是最基本的部署单元，它的生命周期包括多个不同的 <strong>状态</strong>，每个状态反映了 Pod 在运行时的不同阶段或情况。Pod 的状态主要包括以下几种，每种状态都有不同的意义和用途：</p><h3 id=1-pending等待中>1. <strong>Pending（等待中）</strong>
<a class=anchor href=#1-pending%e7%ad%89%e5%be%85%e4%b8%ad>#</a></h3><ul><li><strong>描述</strong>：Pod 被调度到集群中的节点，但容器尚未启动。这通常发生在以下几种情况：<ul><li>Pod 被调度到一个节点，但节点上没有足够的资源来启动容器。</li><li>Pod 在等待调度（例如，调度器正在选择最合适的节点）。</li><li>容器镜像正在下载或拉取中。</li></ul></li><li><strong>典型原因</strong>：<ul><li>节点资源不足，Pod 无法调度。</li><li>容器镜像还未完全下载到节点。</li><li>必须满足某些调度约束（如 <code>NodeAffinity</code>）但未找到合适的节点。</li></ul></li></ul><h3 id=2-running运行中>2. <strong>Running（运行中）</strong>
<a class=anchor href=#2-running%e8%bf%90%e8%a1%8c%e4%b8%ad>#</a></h3><ul><li><strong>描述</strong>：Pod 已经成功调度到节点上，并且至少一个容器正在运行。Pod 进入这个状态意味着：<ul><li>容器已成功启动并在运行中。</li><li>所有容器都在运行或者至少有一个容器在运行。</li></ul></li><li><strong>典型原因</strong>：<ul><li>所有容器已经启动并正在处理任务。</li><li>部分容器可能在运行中，其他容器可能处于 <code>waiting</code> 状态，但 Pod 仍然视为 <code>Running</code>。</li></ul></li></ul><h3 id=3-succeeded成功>3. <strong>Succeeded（成功）</strong>
<a class=anchor href=#3-succeeded%e6%88%90%e5%8a%9f>#</a></h3><ul><li><strong>描述</strong>：Pod 中的所有容器都成功完成并退出。通常表示该 Pod 中的容器是 <strong>一次性</strong>（如批处理任务），执行完任务后容器退出。Pod 被认为是 <strong>成功的</strong>，即所有容器都没有错误退出。</li><li><strong>典型原因</strong>：<ul><li>所有容器执行完毕并正常退出，Pod 的生命周期结束。</li></ul></li></ul><h3 id=4-failed失败>4. <strong>Failed（失败）</strong>
<a class=anchor href=#4-failed%e5%a4%b1%e8%b4%a5>#</a></h3><ul><li><strong>描述</strong>：Pod 中的容器之一或多个容器异常退出（例如，容器退出状态码非零）。这意味着至少有一个容器运行失败，Pod 被认为处于失败状态。</li><li><strong>典型原因</strong>：<ul><li>容器启动失败或退出代码表示失败（如非零退出状态）。</li><li>应用崩溃或出错导致容器停止运行。</li></ul></li></ul><h3 id=5-unknown未知>5. <strong>Unknown（未知）</strong>
<a class=anchor href=#5-unknown%e6%9c%aa%e7%9f%a5>#</a></h3><ul><li><strong>描述</strong>：Pod 的状态未知，通常是因为节点失联，无法从节点获取关于该 Pod 的状态。可能是由于网络问题或者节点故障，Kubernetes 控制平面无法向集群报告 Pod 的状态。</li><li><strong>典型原因</strong>：<ul><li>节点宕机或无法连接。</li><li>网络或控制面问题，导致状态无法更新。</li></ul></li></ul><h3 id=pod-状态的详细说明>Pod 状态的详细说明
<a class=anchor href=#pod-%e7%8a%b6%e6%80%81%e7%9a%84%e8%af%a6%e7%bb%86%e8%af%b4%e6%98%8e>#</a></h3><p>在 Kubernetes 中，Pod 的状态不仅仅是一个简单的标签，它还包含了详细的容器信息，诸如容器的当前状态、是否正在重启、资源使用情况等。你可以通过 <code>kubectl describe pod &lt;pod-name></code> 命令查看 Pod 的详细状态信息，了解更多关于 Pod 和其容器的状态。</p><h3 id=pod-状态的细化字段容器级>Pod 状态的细化字段（容器级）
<a class=anchor href=#pod-%e7%8a%b6%e6%80%81%e7%9a%84%e7%bb%86%e5%8c%96%e5%ad%97%e6%ae%b5%e5%ae%b9%e5%99%a8%e7%ba%a7>#</a></h3><p>每个 Pod 中的容器会有以下几个状态字段：</p><ol><li><strong>Waiting（等待中）</strong>：<ul><li>容器还没有启动，可能正在等待某些资源（例如镜像拉取或容器启动失败）。</li><li><code>reason</code> 字段会告诉为什么容器处于 <code>Waiting</code> 状态，比如 <code>ImagePullBackOff</code>（镜像拉取失败）或者 <code>CrashLoopBackOff</code>（容器崩溃并尝试重新启动）。</li></ul></li><li><strong>Running（运行中）</strong>：<ul><li>容器正在运行并且没有问题。容器进入 <code>Running</code> 状态后，它可以处理请求并进行任务。</li></ul></li><li><strong>Terminated（终止）</strong>：<ul><li>容器已经停止或被终止。终止可以是正常退出（<code>exit code 0</code>）或者异常退出（<code>exit code != 0</code>）。</li><li>如果容器正常退出并且 Pod 被设计为一次性任务，它会进入 <code>Succeeded</code> 状态。反之，如果有错误发生，容器会进入 <code>Failed</code> 状态。</li></ul></li></ol><h3 id=容器状态示例>容器状态示例：
<a class=anchor href=#%e5%ae%b9%e5%99%a8%e7%8a%b6%e6%80%81%e7%a4%ba%e4%be%8b>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>status</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containerStatuses</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>running</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>startedAt</span>: <span style=color:#e6db74>&#34;2025-02-19T15:03:06Z&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>lastState</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>terminated</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>exitCode</span>: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>reason</span>: <span style=color:#ae81ff>Completed</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>startedAt</span>: <span style=color:#e6db74>&#34;2025-02-19T14:59:06Z&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>finishedAt</span>: <span style=color:#e6db74>&#34;2025-02-19T15:03:06Z&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ready</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restartCount</span>: <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><ul><li><code>state</code>：表示容器的当前状态，可以是 <code>waiting</code>, <code>running</code> 或 <code>terminated</code>。</li><li><code>lastState</code>：表示容器最近一次的状态，只有在容器终止时才会显示。</li><li><code>restartCount</code>：表示容器的重启次数。</li></ul><h3 id=总结-8>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-8>#</a></h3><p>Kubernetes 中的 Pod 状态分为几种主要类型，每种状态反映了 Pod 在集群中执行的不同阶段：</p><ol><li><strong>Pending</strong>：Pod 正在等待调度或资源。</li><li><strong>Running</strong>：Pod 正在运行，至少有一个容器在运行。</li><li><strong>Succeeded</strong>：Pod 中的所有容器已经成功完成并退出。</li><li><strong>Failed</strong>：Pod 中至少一个容器运行失败。</li><li><strong>Unknown</strong>：Pod 的状态未知，通常是节点失联时出现。</li></ol><p>理解这些状态能够帮助你排查和诊断 Pod 运行时的各种问题，从而采取合适的措施解决问题。</p><h2 id=evicted呢>evicted呢？
<a class=anchor href=#evicted%e5%91%a2>#</a></h2><p>在 Kubernetes 中，<strong>Evicted</strong> 状态表示 Pod 被从节点中驱逐（Evicted）。这通常发生在节点资源不足或节点上有其他约束条件时。Pod 被标记为 <strong>Evicted</strong>，并且不能再继续运行。</p><h3 id=evicted-状态的原因><strong>Evicted</strong> 状态的原因
<a class=anchor href=#evicted-%e7%8a%b6%e6%80%81%e7%9a%84%e5%8e%9f%e5%9b%a0>#</a></h3><p>Pod 被驱逐的主要原因通常是资源压力，例如节点上的 <strong>内存</strong>、<strong>磁盘</strong> 或 <strong>CPU</strong> 不足。驱逐通常是由于以下原因：</p><ol><li><strong>节点资源不足（例如，内存、磁盘或 CPU）</strong>：<ul><li>当节点的内存、磁盘或 CPU 等资源不足时，Kubernetes 会选择驱逐某些 Pod，以释放资源供更高优先级或关键 Pod 使用。</li><li>例如，如果节点的内存使用率过高，Kubernetes 可能会驱逐一些 Pod，尤其是当启用了 <strong>优先级</strong>（Priority）和 <strong>抢占</strong>（Preemption）机制时，低优先级的 Pod 会被优先驱逐。</li></ul></li><li><strong>磁盘压力（DiskPressure）</strong>：<ul><li>当节点的磁盘空间不足时，Kubernetes 会将标记为 <strong>DiskPressure</strong> 的节点上的 Pod 驱逐出去，以释放磁盘空间。</li></ul></li><li><strong>内存压力（MemoryPressure）</strong>：<ul><li>如果节点的内存使用达到临界点，Kubernetes 会驱逐某些 Pod，以腾出内存。驱逐通常从资源请求较低的 Pod 开始。</li></ul></li><li><strong>节点维护（如，节点被标记为不可调度）</strong>：<ul><li>如果节点被管理员手动标记为不可调度，Kubernetes 会尝试驱逐该节点上的 Pod，以便将它们迁移到其他健康的节点上。</li></ul></li><li><strong>NodeTaints 和 Tolerations</strong>：<ul><li>节点可能被标记为某种特定的 <strong>Taint</strong>，并且如果某些 Pod 没有合适的 <strong>Tolerations</strong>，这些 Pod 可能会被驱逐。</li></ul></li><li><strong>Pod 驱逐策略</strong>：<ul><li>如果 Pod 配置了特定的驱逐策略或 <code>PodDisruptionBudget</code>（PDB）允许驱逐，Pod 也可能被驱逐。</li></ul></li></ol><h3 id=evicted-状态的标志><strong>Evicted</strong> 状态的标志
<a class=anchor href=#evicted-%e7%8a%b6%e6%80%81%e7%9a%84%e6%a0%87%e5%bf%97>#</a></h3><p>在 Pod 的状态中，如果 Pod 被驱逐，它的 <code>status</code> 字段会显示 <strong>Evicted</strong>。你可以使用 <code>kubectl describe pod &lt;pod-name></code> 查看 Pod 的详细信息，驱逐的原因通常会在 <code>Events</code> 中显示出来。</p><h4 id=示例>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>你可能会看到类似以下的信息：</p><pre tabindex=0><code>Events:
  Type     Reason     Age   From                     Message
  ----     ------     ----  ----                     -------
  Normal   Evicted    10m   kubelet, node-1           Pod was evicted due to memory pressure
</code></pre><ul><li><strong>Reason</strong>：Evicted</li><li><strong>Message</strong>：Pod 被驱逐的原因，比如 <code>memory pressure</code>（内存压力）或 <code>disk pressure</code>（磁盘压力）。</li></ul><h3 id=evicted-的后续处理><strong>Evicted</strong> 的后续处理
<a class=anchor href=#evicted-%e7%9a%84%e5%90%8e%e7%bb%ad%e5%a4%84%e7%90%86>#</a></h3><ul><li><strong>Pod 不会自动重启</strong>：驱逐的 Pod 会被终止，但 Kubernetes 不会自动重启它们，除非你使用了 <strong>Deployment</strong>、<strong>StatefulSet</strong> 或其他控制器来管理 Pod。控制器会根据定义的副本数重新调度一个新的 Pod 来替代被驱逐的 Pod。</li><li><strong>重新调度</strong>：如果 Pod 被驱逐并且没有控制器管理（如 <code>Deployment</code>），则 Pod 不会自动重新调度。在这种情况下，可能需要手动重新调度 Pod，或者通过增加节点资源和优化调度策略来避免驱逐。</li><li><strong>资源优化</strong>：驱逐通常是资源不足的信号。你可以考虑：<ul><li>调整 Pod 的资源请求和限制（<code>requests</code> 和 <code>limits</code>）。</li><li>增加节点资源或添加更多节点。</li><li>调整节点资源的调度策略，例如通过 <code>Node Affinity</code> 或 <code>Pod Affinity</code> 限制资源紧张的节点的 Pod 数量。</li></ul></li></ul><h3 id=总结-9>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-9>#</a></h3><p><strong>Evicted</strong> 状态表示 Pod 被从节点上驱逐，通常是由于资源不足（如内存、磁盘压力等）。Pod 被驱逐后，它不会自动重启，而是需要通过控制器（如 <code>Deployment</code>）重新调度或手动重新部署。理解和监控驱逐的原因有助于优化集群资源分配，减少 Pod 被驱逐的情况。</p><h2 id=如果同一个pod-出现几十几百次的evicted-是啥原因>如果同一个pod 出现几十几百次的evicted 是啥原因？
<a class=anchor href=#%e5%a6%82%e6%9e%9c%e5%90%8c%e4%b8%80%e4%b8%aapod-%e5%87%ba%e7%8e%b0%e5%87%a0%e5%8d%81%e5%87%a0%e7%99%be%e6%ac%a1%e7%9a%84evicted-%e6%98%af%e5%95%a5%e5%8e%9f%e5%9b%a0>#</a></h2><h6><a class=anchor href=#>#</a></h6><p>如果同一个 Pod 多次被驱逐（<strong>Evicted</strong>），尤其是出现几十次甚至几百次的驱逐，这通常是由集群资源压力、Pod 配置问题、或者调度策略不当导致的。以下是一些可能的原因及其排查方式：</p><h3 id=1-资源不足-memorypressure--diskpressure>1. <strong>资源不足 (MemoryPressure / DiskPressure)</strong>
<a class=anchor href=#1-%e8%b5%84%e6%ba%90%e4%b8%8d%e8%b6%b3-memorypressure--diskpressure>#</a></h3><p>最常见的原因是集群中的节点资源（尤其是内存或磁盘）不足。当节点资源不足时，Kubernetes 会驱逐资源消耗较多的 Pod。Pod 被驱逐后，由于资源压力可能没有得到缓解，Pod 会再次被调度到同一节点或其他资源同样紧张的节点，导致多次驱逐。</p><h4 id=可能原因>可能原因：
<a class=anchor href=#%e5%8f%af%e8%83%bd%e5%8e%9f%e5%9b%a0>#</a></h4><ul><li><strong>节点内存或磁盘压力</strong>：如果节点的内存或磁盘已达到高使用率，Kubernetes 可能会不断驱逐 Pod，特别是当 Pod 请求的资源比节点可用的资源还要多时。</li><li><strong>Pod 请求的资源过高</strong>：Pod 配置的 <code>requests</code> 和 <code>limits</code> 可能过高，导致 Pod 经常在节点上没有足够的资源可用。</li></ul><h4 id=排查方法>排查方法：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95>#</a></h4><ul><li><p><strong>检查节点资源使用情况</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl top nodes
</span></span></code></pre></div><p>检查节点的 <strong>CPU</strong>、<strong>内存</strong>、<strong>磁盘</strong> 使用情况，看看是否有节点的资源过度使用。</p></li><li><p><strong>检查 Pod 资源请求</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>查看 Pod 的资源请求（<code>requests</code>）和限制（<code>limits</code>）是否合理。</p></li><li><p><strong>检查节点磁盘使用情况</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe node &lt;node-name&gt;
</span></span></code></pre></div><p>查看节点的磁盘使用情况，看看是否存在 <strong>DiskPressure</strong>，并检查磁盘空间是否紧张。</p></li></ul><h3 id=2-pod-配置问题>2. <strong>Pod 配置问题</strong>
<a class=anchor href=#2-pod-%e9%85%8d%e7%bd%ae%e9%97%ae%e9%a2%98>#</a></h3><p>Pod 本身的配置可能导致其无法在节点上稳定运行。例如，容器镜像拉取失败、启动时间过长等，都可能导致 Pod 被反复驱逐。</p><h4 id=可能原因-1>可能原因：
<a class=anchor href=#%e5%8f%af%e8%83%bd%e5%8e%9f%e5%9b%a0-1>#</a></h4><ul><li><strong>镜像拉取失败</strong>：如果 Pod 启动时需要拉取镜像，但镜像无法成功拉取（例如，镜像仓库问题、镜像大小过大等），Pod 可能会进入 <code>Evicted</code> 状态。</li><li><strong>初始化容器（Init Containers）失败</strong>：如果 Pod 配置了初始化容器，而初始化容器失败，Pod 也可能多次被驱逐。</li></ul><h4 id=排查方法-1>排查方法：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95-1>#</a></h4><ul><li><p><strong>查看事件日志</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>查看 <strong>Events</strong> 字段，检查是否有镜像拉取失败或其他错误信息。</p></li><li><p><strong>检查容器和初始化容器状态</strong>： 查看 Pod 的容器是否有异常退出或启动失败，导致反复重启和驱逐。</p></li></ul><h3 id=3-pod-驱逐策略taints-和-tolerations>3. <strong>Pod 驱逐策略（Taints 和 Tolerations）</strong>
<a class=anchor href=#3-pod-%e9%a9%b1%e9%80%90%e7%ad%96%e7%95%a5taints-%e5%92%8c-tolerations>#</a></h3><p>如果节点设置了 <strong>Taints</strong>（污点），并且 Pod 没有相应的 <strong>Tolerations</strong>（容忍），Pod 可能会频繁被驱逐。特别是在使用了节点亲和性或调度策略的情况下，如果集群的资源分配不均，Pod 可能会频繁在资源不足的节点之间迁移。</p><h4 id=可能原因-2>可能原因：
<a class=anchor href=#%e5%8f%af%e8%83%bd%e5%8e%9f%e5%9b%a0-2>#</a></h4><ul><li><strong>节点的 Taints 设置</strong>：如果节点上设置了 Taints，而 Pod 没有适当的 Tolerations，Pod 会被驱逐并且无法在该节点上稳定运行。</li></ul><h4 id=排查方法-2>排查方法：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95-2>#</a></h4><ul><li><p>检查节点的 Taints</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe node &lt;node-name&gt;
</span></span></code></pre></div><p>查看节点是否有 Taints 设置，并检查 Pod 是否有合适的 Tolerations。</p></li></ul><h3 id=4-调度和优先级问题>4. <strong>调度和优先级问题</strong>
<a class=anchor href=#4-%e8%b0%83%e5%ba%a6%e5%92%8c%e4%bc%98%e5%85%88%e7%ba%a7%e9%97%ae%e9%a2%98>#</a></h3><p>如果 Pod 配置了低优先级（Priority），且节点资源有限，Kubernetes 调度器可能会选择驱逐这些低优先级的 Pod，来腾出资源给更高优先级的 Pod。</p><h4 id=可能原因-3>可能原因：
<a class=anchor href=#%e5%8f%af%e8%83%bd%e5%8e%9f%e5%9b%a0-3>#</a></h4><ul><li><strong>优先级较低的 Pod</strong>：如果 Pod 配置了较低的 <strong>PriorityClass</strong>，在节点资源紧张时，这些 Pod 更容易被驱逐。</li></ul><h4 id=排查方法-3>排查方法：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95-3>#</a></h4><ul><li><strong>检查 Pod 的优先级</strong>： 查看 Pod 是否有配置 <strong>PriorityClass</strong>，并根据优先级调整 Pod 的资源调度策略。</li></ul><h3 id=5-poddisruptionbudget-pdb>5. <strong>PodDisruptionBudget (PDB)</strong>
<a class=anchor href=#5-poddisruptionbudget-pdb>#</a></h3><p><strong>PodDisruptionBudget</strong>（PDB）用于控制在进行自主操作（例如，删除 Pod）时，允许的最小可用副本数。如果设置不当，PDB 可能导致 Pod 被驱逐。</p><h4 id=可能原因-4>可能原因：
<a class=anchor href=#%e5%8f%af%e8%83%bd%e5%8e%9f%e5%9b%a0-4>#</a></h4><ul><li><strong>PDB 设置过于严格</strong>：PDB 的配置可能限制了 Pod 副本数，导致 Pod 频繁被驱逐。</li></ul><h4 id=排查方法-4>排查方法：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95-4>#</a></h4><ul><li><p>检查 PodDisruptionBudget 配置</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pdb
</span></span></code></pre></div><p>查看集群中是否有</p><p>PodDisruptionBudget</p><p>配置，并检查设置是否符合预期。</p></li></ul><h3 id=6-集群健康和调度器问题>6. <strong>集群健康和调度器问题</strong>
<a class=anchor href=#6-%e9%9b%86%e7%be%a4%e5%81%a5%e5%ba%b7%e5%92%8c%e8%b0%83%e5%ba%a6%e5%99%a8%e9%97%ae%e9%a2%98>#</a></h3><p>如果集群的调度器存在问题，或者调度器无法为 Pod 分配合适的节点，Pod 可能会反复被调度到同一个资源紧张的节点，并最终被驱逐。</p><h4 id=可能原因-5>可能原因：
<a class=anchor href=#%e5%8f%af%e8%83%bd%e5%8e%9f%e5%9b%a0-5>#</a></h4><ul><li><strong>调度器 bug 或配置错误</strong>：可能存在调度器错误导致 Pod 被错误地调度到不可用的节点。</li></ul><h4 id=排查方法-5>排查方法：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95-5>#</a></h4><ul><li><strong>检查调度器日志</strong>： 检查 Kubernetes 调度器（<code>kube-scheduler</code>）的日志，查看是否有调度异常。</li></ul><h3 id=如何解决>如何解决？
<a class=anchor href=#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3>#</a></h3><ol><li><strong>优化资源请求和限制</strong>：检查 Pod 的资源请求和限制配置，确保它们合理。避免过高的资源请求，特别是当集群资源紧张时。</li><li><strong>增加节点资源</strong>：增加集群中节点的数量或资源（如内存、磁盘空间等），减少资源不足引起的驱逐。</li><li><strong>提高节点的资源可用性</strong>：使用 <code>Node Affinity</code> 和 <code>Pod Affinity</code> 控制 Pod 调度到资源充足的节点。</li><li><strong>调整 Pod 优先级</strong>：为关键的 Pod 设置更高的优先级，以确保它们不会被低优先级 Pod 驱逐。</li><li><strong>检查并优化调度策略</strong>：检查调度策略，确保 Pod 被调度到合适的节点，避免资源集中在某个节点导致频繁驱逐。</li></ol><h3 id=总结-10>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-10>#</a></h3><p>Pod 多次被驱逐通常是由于集群资源不足、Pod 配置问题或调度策略不当等原因。通过优化 Pod 的资源请求、调整调度策略、增加集群资源或修复配置问题，可以减少 Pod 被频繁驱逐的情况。</p><h2 id=如果pod超出资源限制被杀死那他时重启-重建还是什么呢>如果pod超出资源限制被杀死，那他时重启 重建还是什么呢？
<a class=anchor href=#%e5%a6%82%e6%9e%9cpod%e8%b6%85%e5%87%ba%e8%b5%84%e6%ba%90%e9%99%90%e5%88%b6%e8%a2%ab%e6%9d%80%e6%ad%bb%e9%82%a3%e4%bb%96%e6%97%b6%e9%87%8d%e5%90%af-%e9%87%8d%e5%bb%ba%e8%bf%98%e6%98%af%e4%bb%80%e4%b9%88%e5%91%a2>#</a></h2><p>当一个 Pod 超出资源限制（如 <strong>CPU</strong> 或 <strong>内存</strong>）并被杀死时，Kubernetes 会根据 Pod 的控制器类型（如 <strong>Deployment</strong>、<strong>StatefulSet</strong> 等）采取不同的处理方式。下面是具体的行为：</p><h3 id=1-容器被杀死时的行为>1. <strong>容器被杀死时的行为</strong>
<a class=anchor href=#1-%e5%ae%b9%e5%99%a8%e8%a2%ab%e6%9d%80%e6%ad%bb%e6%97%b6%e7%9a%84%e8%a1%8c%e4%b8%ba>#</a></h3><ul><li><strong>内存限制超出（Out of Memory，OOM）</strong>：当 Pod 的容器超出了定义的内存限制时，容器会被操作系统内核（Linux 的 OOM Killer）杀死。这通常发生在容器使用的内存超出了指定的限制。容器会退出，并且退出状态码为 <code>137</code>（表示容器因接收到 <code>SIGKILL</code> 信号而终止）。</li><li><strong>CPU 限制超出</strong>：Kubernetes 本身不会直接杀死容器，尽管容器的 CPU 使用超过限制，Kubernetes 会限制容器的 CPU 使用，不会让它占用更多的资源，容器仍然可以运行，但可能会因为 CPU 过度消耗而影响性能。</li></ul><h3 id=2-容器的重启行为>2. <strong>容器的重启行为</strong>
<a class=anchor href=#2-%e5%ae%b9%e5%99%a8%e7%9a%84%e9%87%8d%e5%90%af%e8%a1%8c%e4%b8%ba>#</a></h3><p>当容器因超出资源限制被杀死时，容器的处理方式由 <strong>Pod 的重启策略</strong> 决定。Pod 的重启策略由以下几种：</p><h4 id=a-always默认值>A. <strong>Always</strong>（默认值）
<a class=anchor href=#a-always%e9%bb%98%e8%ae%a4%e5%80%bc>#</a></h4><ul><li>如果 Pod 配置了 <code>restartPolicy: Always</code>（这是 <code>Deployment</code>、<code>ReplicaSet</code> 等控制器的默认重启策略），即使容器被 OOM 杀死或因其他原因退出，Kubernetes 会自动重新启动容器。</li><li><strong>控制器行为</strong>：如果是由 <strong>Deployment</strong> 或 <strong>ReplicaSet</strong> 管理的 Pod，当容器因资源超限而被杀死时，Kubernetes 会自动重新调度一个新的容器实例，以确保 Pod 的副本数不变。</li></ul><h4 id=b-onfailure>B. <strong>OnFailure</strong>
<a class=anchor href=#b-onfailure>#</a></h4><ul><li>如果 Pod 的重启策略是 <code>restartPolicy: OnFailure</code>，只有当容器以非零状态码退出时（即容器因错误退出），Kubernetes 才会重启容器。</li><li>如果容器是因 OOM 被杀死（即退出状态码 <code>137</code>），它会被认为是 &ldquo;失败&rdquo;（<code>failure</code>），因此 Pod 会被重启。但如果是正常退出（例如容器自行退出），则不会重启。</li></ul><h4 id=c-never>C. <strong>Never</strong>
<a class=anchor href=#c-never>#</a></h4><ul><li>如果 Pod 的重启策略是 <code>restartPolicy: Never</code>，则无论容器退出的原因是什么，Kubernetes 都不会自动重启容器，Pod 将停止运行。如果你使用的是此策略，你需要手动删除 Pod 或重新创建它。</li></ul><h3 id=3-由控制器管理的行为>3. <strong>由控制器管理的行为</strong>
<a class=anchor href=#3-%e7%94%b1%e6%8e%a7%e5%88%b6%e5%99%a8%e7%ae%a1%e7%90%86%e7%9a%84%e8%a1%8c%e4%b8%ba>#</a></h3><p>当 Pod 由 <strong>Deployment</strong>、<strong>StatefulSet</strong> 或其他控制器管理时，它们会尝试 <strong>重建</strong> Pod 来保持所需的副本数。例如：</p><ul><li><strong>Deployment</strong>：如果 Pod 被杀死（因资源限制或其他原因），<code>Deployment</code> 会自动创建一个新的 Pod 来替代被删除的 Pod，以确保副本数始终保持一致。</li><li><strong>StatefulSet</strong>：对于有持久化状态的应用（例如数据库），<code>StatefulSet</code> 会在 Pod 被杀死后重新调度新的 Pod，并保持原有的持久存储和网络身份。</li><li><strong>DaemonSet</strong>：如果 Pod 被杀死，<code>DaemonSet</code> 会确保在每个节点上始终运行 Pod 实例。</li></ul><h3 id=4-oom-kill-与重启的细节>4. <strong>OOM Kill 与重启的细节</strong>
<a class=anchor href=#4-oom-kill-%e4%b8%8e%e9%87%8d%e5%90%af%e7%9a%84%e7%bb%86%e8%8a%82>#</a></h3><p>当容器因内存超出限制被杀死时，容器的 <strong>退出状态码</strong> 会是 <code>137</code>（表示收到 <code>SIGKILL</code> 信号）。这种情况下，如果 Pod 的重启策略是 <code>Always</code> 或 <code>OnFailure</code>，Kubernetes 会重新启动容器。</p><ul><li><strong>重启策略为 <code>Always</code></strong>：容器会立即被重启。</li><li><strong>重启策略为 <code>OnFailure</code></strong>：容器会被重启，前提是退出状态码是非零（例如 OOM 导致退出）。</li></ul><h3 id=5-pod-状态变化>5. <strong>Pod 状态变化</strong>
<a class=anchor href=#5-pod-%e7%8a%b6%e6%80%81%e5%8f%98%e5%8c%96>#</a></h3><p>在 Pod 被杀死并重新启动时，你可以使用 <code>kubectl describe pod &lt;pod-name></code> 命令查看 Pod 的状态和事件日志。例如，OOM 杀死的容器通常会记录类似以下的事件：</p><pre tabindex=0><code>Events:
  Type     Reason     Age   From                     Message
  ----     ------     ----  ----                     -------
  Normal   Killing    5m    kubelet, node-1           Killing container with id docker://&lt;container-id&gt;:Container exceeded memory limit
  Normal   Pulled     4m    kubelet, node-1           Container image &#34;nginx&#34; already present on machine
  Normal   Created    4m    kubelet, node-1           Created container
  Normal   Started    4m    kubelet, node-1           Started container
</code></pre><h3 id=6-如何避免-pod-被-oom-杀死>6. <strong>如何避免 Pod 被 OOM 杀死</strong>
<a class=anchor href=#6-%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d-pod-%e8%a2%ab-oom-%e6%9d%80%e6%ad%bb>#</a></h3><p>为了避免 Pod 因内存限制被杀死，可以采取以下措施：</p><ol><li><p><strong>调整资源请求和限制</strong>：</p><ul><li>确保容器的 <strong>内存请求</strong> 和 <strong>内存限制</strong> 设置合理。请求值应该是容器正常运行时所需的最小内存，而限制值是容器可以使用的最大内存。</li></ul><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;256Mi&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;500m&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;512Mi&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;1&#34;</span>
</span></span></code></pre></div></li><li><p><strong>增加节点资源</strong>：</p><ul><li>如果集群资源紧张，考虑增加节点，或者优化现有节点的资源分配。</li></ul></li><li><p><strong>优化应用程序的内存使用</strong>：</p><ul><li>如果应用程序内存使用过高，可以优化代码或者配置，以减少内存占用。</li></ul></li></ol><h3 id=总结-11>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-11>#</a></h3><p>当 Pod 因超出资源限制被杀死时，容器会根据 Pod 的 <strong>重启策略</strong> 进行 <strong>重启</strong> 或 <strong>重新创建</strong>。如果是 <strong>Deployment</strong> 等控制器管理的 Pod，Pod 会被重建以确保副本数不变。如果是 <strong>OOM（Out of Memory）</strong> 导致的，容器退出状态码为 <code>137</code>，并会根据重启策略决定是否重启。如果是 <strong>CPU 限制</strong>，容器不会被杀死，只是 CPU 资源被限制，容器仍然会继续运行。</p><h2 id=如果-pod-配置了-restartpolicy-always这是-deploymentreplicaset-等控制器的默认重启策略即使容器被-oom-杀死或因其他原因退出kubernetes-会自动重新启动容器-控制器行为如果是由-deployment-或-replicaset-管理的-pod当容器因资源超限而被杀死时kubernetes-会自动重新调度一个新的容器实例以确保-pod-的副本数不变-自相矛盾了吧>如果 Pod 配置了 restartPolicy: Always（这是 Deployment、ReplicaSet 等控制器的默认重启策略），即使容器被 OOM 杀死或因其他原因退出，Kubernetes 会自动重新启动容器。 控制器行为：如果是由 Deployment 或 ReplicaSet 管理的 Pod，当容器因资源超限而被杀死时，Kubernetes 会自动重新调度一个新的容器实例，以确保 Pod 的副本数不变。 自相矛盾了吧
<a class=anchor href=#%e5%a6%82%e6%9e%9c-pod-%e9%85%8d%e7%bd%ae%e4%ba%86-restartpolicy-always%e8%bf%99%e6%98%af-deploymentreplicaset-%e7%ad%89%e6%8e%a7%e5%88%b6%e5%99%a8%e7%9a%84%e9%bb%98%e8%ae%a4%e9%87%8d%e5%90%af%e7%ad%96%e7%95%a5%e5%8d%b3%e4%bd%bf%e5%ae%b9%e5%99%a8%e8%a2%ab-oom-%e6%9d%80%e6%ad%bb%e6%88%96%e5%9b%a0%e5%85%b6%e4%bb%96%e5%8e%9f%e5%9b%a0%e9%80%80%e5%87%bakubernetes-%e4%bc%9a%e8%87%aa%e5%8a%a8%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8%e5%ae%b9%e5%99%a8-%e6%8e%a7%e5%88%b6%e5%99%a8%e8%a1%8c%e4%b8%ba%e5%a6%82%e6%9e%9c%e6%98%af%e7%94%b1-deployment-%e6%88%96-replicaset-%e7%ae%a1%e7%90%86%e7%9a%84-pod%e5%bd%93%e5%ae%b9%e5%99%a8%e5%9b%a0%e8%b5%84%e6%ba%90%e8%b6%85%e9%99%90%e8%80%8c%e8%a2%ab%e6%9d%80%e6%ad%bb%e6%97%b6kubernetes-%e4%bc%9a%e8%87%aa%e5%8a%a8%e9%87%8d%e6%96%b0%e8%b0%83%e5%ba%a6%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84%e5%ae%b9%e5%99%a8%e5%ae%9e%e4%be%8b%e4%bb%a5%e7%a1%ae%e4%bf%9d-pod-%e7%9a%84%e5%89%af%e6%9c%ac%e6%95%b0%e4%b8%8d%e5%8f%98-%e8%87%aa%e7%9b%b8%e7%9f%9b%e7%9b%be%e4%ba%86%e5%90%a7>#</a></h2><h6><a class=anchor href=#>#</a></h6><p>你说得对！我在这段描述中确实存在自相矛盾的表述，感谢你指出来。让我澄清一下这部分内容。</p><h3 id=restartpolicy-always-和-控制器行为><code>restartPolicy: Always</code> 和 控制器行为
<a class=anchor href=#restartpolicy-always-%e5%92%8c-%e6%8e%a7%e5%88%b6%e5%99%a8%e8%a1%8c%e4%b8%ba>#</a></h3><p>对于由 <strong>Deployment</strong>、<strong>ReplicaSet</strong> 等控制器管理的 Pod，即使容器因为 <strong>OOM（Out of Memory）</strong> 被杀死，<strong>容器本身</strong> 会 <strong>重新启动</strong>，而不是直接重建。实际上，控制器会确保 Pod 的副本数保持一致，并且容器会被 <strong>重新调度重启</strong>，而不是创建一个新的 Pod。</p><p>但是，有一些细节需要进一步说明：</p><h3 id=控制器的行为>控制器的行为：
<a class=anchor href=#%e6%8e%a7%e5%88%b6%e5%99%a8%e7%9a%84%e8%a1%8c%e4%b8%ba>#</a></h3><ol><li><p>Deployment / ReplicaSet 等控制器</p><p>：</p><ul><li>这些控制器会确保集群中有 <strong>指定数量的 Pod 副本</strong>。</li><li>如果 Pod 的容器因 OOM 被杀死（或因为其他原因退出），<strong>Pod 会被重新启动</strong>（容器重启）。</li><li>但是，如果 Pod 出现问题，无法重启（例如，<code>restartPolicy: Never</code>），控制器会创建一个新的 Pod 来替代已经退出的 Pod，以保持副本数。</li></ul></li></ol><h3 id=细节容器的重启-vs-pod-重建>细节：容器的重启 vs Pod 重建
<a class=anchor href=#%e7%bb%86%e8%8a%82%e5%ae%b9%e5%99%a8%e7%9a%84%e9%87%8d%e5%90%af-vs-pod-%e9%87%8d%e5%bb%ba>#</a></h3><ul><li><strong>容器重启</strong>：在 <code>restartPolicy: Always</code> 的情况下，Pod 的容器会被自动重启。这意味着，如果一个容器因为 OOM 被杀死，它会被重新启动，而不会导致整个 Pod 被删除或替换。</li><li><strong>Pod 被重建</strong>：如果控制器管理的 Pod 发生 <strong>不再能重启</strong> 的情况（例如，Pod 本身无法启动），控制器会 <strong>删除原 Pod 并创建新的 Pod</strong>，以确保副本数维持不变。</li></ul><h4 id=示例-1>示例：
<a class=anchor href=#%e7%a4%ba%e4%be%8b-1>#</a></h4><p>假设我们有一个 <strong>Deployment</strong> 管理的 Pod：</p><ul><li>Pod 中的容器因为 OOM 被杀死（退出状态码 <code>137</code>）。</li><li>Kubernetes 会根据 <code>restartPolicy: Always</code> 重启容器，而不需要删除 Pod。</li><li>控制器会确保副本数不会降低，因此如果容器无法重新启动，控制器会创建一个新的 Pod。</li></ul><p>总结：</p><ul><li><strong>容器重启</strong>：容器被 OOM 杀死后会自动重启（如果重启策略是 <code>Always</code>）。</li><li><strong>Pod 重建</strong>：如果容器无法重启或 Pod 出现其他不可恢复的故障，控制器会创建新的 Pod，以保持副本数。</li></ul><p>希望这个解释更清晰地解决了你的疑问！再次感谢你指出问题，确保了描述更准确。</p><h2 id=debug容器调试老是crashbackof的pod>debug容器调试老是crashbackof的pod？
<a class=anchor href=#debug%e5%ae%b9%e5%99%a8%e8%b0%83%e8%af%95%e8%80%81%e6%98%afcrashbackof%e7%9a%84pod>#</a></h2><p>当你在调试容器时遇到 <strong>CrashBackOff</strong> 状态，通常意味着容器在启动后立即崩溃，且 Kubernetes 在多次尝试重启容器后进入了“退避”（BackOff）状态。<code>CrashBackOff</code> 表示容器的启动失败并且 Kubernetes 正在延迟重启容器。这个问题通常与容器启动过程中出现的错误相关。</p><h3 id=crashbackoff-产生的常见原因><strong>CrashBackOff</strong> 产生的常见原因
<a class=anchor href=#crashbackoff-%e4%ba%a7%e7%94%9f%e7%9a%84%e5%b8%b8%e8%a7%81%e5%8e%9f%e5%9b%a0>#</a></h3><ol><li><strong>容器启动失败</strong>：<ul><li>容器可能因为应用程序崩溃、配置错误或缺少依赖等原因启动失败。</li><li>例如，容器可能需要某些环境变量或配置文件，但这些缺失或配置错误导致容器无法正常启动。</li></ul></li><li><strong>内存超限（OOM）</strong>：<ul><li>容器可能在启动时消耗的内存超过了指定的内存限制，从而被操作系统的 OOM（Out of Memory）杀死。</li></ul></li><li><strong>错误的启动命令</strong>：<ul><li>如果容器启动时使用的命令或入口点（<code>ENTRYPOINT</code> 或 <code>CMD</code>）不正确，容器会在启动时立即崩溃。</li></ul></li><li><strong>依赖服务不可用</strong>：<ul><li>如果容器依赖的其他服务或资源不可用（例如，数据库连接失败、网络不可达等），容器启动时会崩溃。</li></ul></li><li><strong>权限问题</strong>：<ul><li>如果容器需要特定的权限来访问文件或执行操作，而这些权限没有正确配置，容器也会崩溃。</li></ul></li></ol><h3 id=调试-crashbackoff-的步骤><strong>调试 CrashBackOff 的步骤</strong>
<a class=anchor href=#%e8%b0%83%e8%af%95-crashbackoff-%e7%9a%84%e6%ad%a5%e9%aa%a4>#</a></h3><ol><li><p><strong>查看 Pod 和容器的日志</strong>：</p><ul><li>通过查看容器的日志，可以找到导致崩溃的具体错误。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;
</span></span></code></pre></div><p>如果 Pod 有多个容器，可以指定容器名称。查看日志输出，找出异常信息或错误提示。</p><ul><li>如果容器已经崩溃，你还可以尝试查看容器的 <strong>previous logs</strong>（上一个容器的日志）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt; --previous
</span></span></code></pre></div></li><li><p><strong>检查 Pod 的事件</strong>：</p><ul><li>使用 <code>kubectl describe</code> 命令查看 Pod 事件，这可以帮助你识别容器崩溃的原因。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>查看 <code>Events</code> 部分，检查是否有资源限制、OOM 或其他错误导致容器崩溃的信息。</p></li><li><p><strong>确认容器的资源请求和限制</strong>：</p><ul><li>确保 Pod 配置了合理的 <code>resources.requests</code> 和 <code>resources.limits</code>。如果内存请求过小，可能会导致容器启动时被 OOM 杀死。</li><li>检查是否有 <code>MemoryLimit</code> 或 <code>CPULimit</code> 设置得太低，导致容器被系统强制终止。</li></ul><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;128Mi&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;500m&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;256Mi&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;1&#34;</span>
</span></span></code></pre></div></li><li><p><strong>查看容器的退出状态</strong>：</p><ul><li>查看容器退出的状态码（Exit Code）。如果是 <code>137</code>，则说明容器是因为 OOM 被杀死；如果是其他非零状态码，可能是应用崩溃。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod &lt;pod-name&gt; -o jsonpath<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;{.status.containerStatuses[0].state.terminated.exitCode}&#39;</span>
</span></span></code></pre></div></li><li><p><strong>检查 Pod 的启动命令和配置</strong>：</p><ul><li>确保容器的启动命令（<code>ENTRYPOINT</code> 和 <code>CMD</code>）正确无误，并且容器内部的所有依赖项（例如文件、环境变量、配置）都已正确配置。</li></ul></li><li><p><strong>增加调试信息</strong>：</p><ul><li>如果可能，可以增加容器内应用的调试日志，或者在启动命令中加上更多的输出（如 <code>echo</code>，<code>sleep</code> 等），从而帮助诊断问题。</li></ul></li><li><p><strong>查看节点的资源使用情况</strong>：</p><ul><li>如果是由于节点资源紧张导致的 CrashBackOff（例如，内存或 CPU 不足），你可以查看节点的资源使用情况：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl top nodes
</span></span></code></pre></div></li><li><p><strong>调整重启策略</strong>：</p><ul><li>如果想要进一步调试容器，可以暂时修改重启策略为 <code>Never</code>，这样容器崩溃时不会自动重启，可以便于调试。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</span></span></code></pre></div></li><li><p><strong>使用 <code>kubectl exec</code> 进入容器</strong>：</p><ul><li>如果容器已经启动并且能短暂运行，可以通过 <code>kubectl exec</code> 进入容器中进行调试，检查环境变量、依赖、配置文件等。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec -it &lt;pod-name&gt; -- /bin/bash
</span></span></code></pre></div></li></ol><h3 id=示例查看容器日志><strong>示例</strong>：查看容器日志
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e6%9f%a5%e7%9c%8b%e5%ae%b9%e5%99%a8%e6%97%a5%e5%bf%97>#</a></h3><ol><li><p>查看容器日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;
</span></span></code></pre></div></li><li><p>查看退出状态码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod &lt;pod-name&gt; -o jsonpath<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;{.status.containerStatuses[0].state.terminated.exitCode}&#39;</span>
</span></span></code></pre></div></li><li><p>查看 Pod 事件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div></li></ol><h3 id=常见的-crashbackoff-问题和解决方案><strong>常见的 CrashBackOff 问题和解决方案</strong>
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84-crashbackoff-%e9%97%ae%e9%a2%98%e5%92%8c%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88>#</a></h3><ul><li><strong>OOM 错误</strong>：增加 <code>resources.requests</code> 和 <code>resources.limits</code> 中的内存限制。</li><li><strong>错误的启动命令</strong>：检查容器的启动命令（<code>ENTRYPOINT</code> 和 <code>CMD</code>），确保没有拼写错误或路径错误。</li><li><strong>缺少依赖</strong>：确保容器内所需的所有文件、环境变量和网络服务都能正常访问。</li><li><strong>权限问题</strong>：检查容器是否有足够的权限访问所需的文件和网络资源。</li></ul><h3 id=总结-12>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-12>#</a></h3><p>当 Pod 进入 <strong>CrashBackOff</strong> 状态时，通常是由于容器启动失败或异常退出。通过查看日志、描述事件、检查资源配置和启动命令，你可以找到并解决容器崩溃的根本原因。如果有必要，还可以调整 Pod 的重启策略、添加调试信息，或者使用 <code>kubectl exec</code> 进入容器进行更深入的调试。</p><h2 id=kubectl-exec-进不去因为-会一直重启>kubectl exec 进不去因为 会一直重启
<a class=anchor href=#kubectl-exec-%e8%bf%9b%e4%b8%8d%e5%8e%bb%e5%9b%a0%e4%b8%ba-%e4%bc%9a%e4%b8%80%e7%9b%b4%e9%87%8d%e5%90%af>#</a></h2><p>当容器处于 <strong>CrashBackOff</strong> 状态时，由于容器会不断重启，你是无法通过 <code>kubectl exec</code> 直接进入容器的，因为容器可能根本没有持续运行足够长的时间来建立连接。这种情况需要一些特别的操作来调试和诊断问题。以下是一些解决方案和调试技巧：</p><h3 id=1-使用>1. <strong>使用 <code>kubectl logs</code> 查看日志</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8>#</a></h3><p>首先，最简单的办法是查看容器的日志，尽管容器在 CrashBackOff 状态，但通常会有一些日志记录（如错误信息或异常），可以帮助你定位问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt; --previous
</span></span></code></pre></div><ul><li><code>--previous</code>：查看 <strong>上一个容器</strong> 的日志（如果容器已经崩溃）。</li></ul><h3 id=2-暂时设置重启策略为>2. <strong>暂时设置重启策略为 <code>Never</code></strong>
<a class=anchor href=#2-%e6%9a%82%e6%97%b6%e8%ae%be%e7%bd%ae%e9%87%8d%e5%90%af%e7%ad%96%e7%95%a5%e4%b8%ba>#</a></h3><p>为了阻止 Pod 一直重启，你可以暂时将重启策略设置为 <code>Never</code>，然后手动删除 Pod，防止它在你排查时继续重启。</p><h4 id=修改-pod-配置>修改 Pod 配置：
<a class=anchor href=#%e4%bf%ae%e6%94%b9-pod-%e9%85%8d%e7%bd%ae>#</a></h4><ol><li><p>编辑 Pod 或 Deployment（如果是通过控制器管理的 Pod）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit deployment &lt;deployment-name&gt;
</span></span></code></pre></div></li><li><p>在编辑界面中，修改 <code>restartPolicy</code> 为 <code>Never</code>，或者如果你是直接管理 Pod，修改其 YAML 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</span></span></code></pre></div><p>然后保存更改。</p></li><li><p>在这个修改之后，你可以手动删除当前 Pod 并重建它，然后再尝试 <code>kubectl exec</code> 进入容器进行调试。</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete pod &lt;pod-name&gt;
</span></span></code></pre></div><ol><li>如果 Pod 还需要被重建，可以使用 <code>kubectl apply</code> 重新应用 Deployment 等资源。</li></ol><h3 id=3-增加容器启动延迟>3. <strong>增加容器启动延迟</strong>
<a class=anchor href=#3-%e5%a2%9e%e5%8a%a0%e5%ae%b9%e5%99%a8%e5%90%af%e5%8a%a8%e5%bb%b6%e8%bf%9f>#</a></h3><p>如果容器重启太快，你可以在容器启动时添加一些延迟，使其在启动后有足够的时间来调试。</p><p>例如，你可以在容器的启动命令中添加一个 <code>sleep</code> 命令来延迟启动过程。修改你的容器配置文件（<code>Dockerfile</code> 或 Pod 配置）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;/bin/sh&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>, <span style=color:#e6db74>&#34;sleep 60 &amp;&amp; &lt;your-command&gt;&#34;</span>]
</span></span></code></pre></div><p>这里的 <code>sleep 60</code> 会让容器在启动后停顿 60 秒，这样你就可以使用 <code>kubectl exec</code> 进入容器进行调试。</p><h3 id=4-修改容器的启动命令为调试模式>4. <strong>修改容器的启动命令为调试模式</strong>
<a class=anchor href=#4-%e4%bf%ae%e6%94%b9%e5%ae%b9%e5%99%a8%e7%9a%84%e5%90%af%e5%8a%a8%e5%91%bd%e4%bb%a4%e4%b8%ba%e8%b0%83%e8%af%95%e6%a8%a1%e5%bc%8f>#</a></h3><p>你还可以修改容器的启动命令，使其进入调试模式或者以交互模式启动容器。例如，直接启动一个 shell 会话，而不是运行主程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;/bin/sh&#34;</span>]
</span></span></code></pre></div><p>这样，容器就会启动一个交互式 shell，你可以通过 <code>kubectl exec</code> 进入容器并查看环境、依赖、配置等。</p><h3 id=5-使用>5. <strong>使用 <code>kubectl run</code> 创建临时 Pod 进行调试</strong>
<a class=anchor href=#5-%e4%bd%bf%e7%94%a8>#</a></h3><p>如果无法进入原 Pod，可以创建一个临时的 Pod 来进行调试。通过 <code>kubectl run</code> 创建一个类似的容器，并进入该容器进行调试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl run -it --rm --image<span style=color:#f92672>=</span>&lt;image-name&gt; --restart<span style=color:#f92672>=</span>Never &lt;temporary-pod-name&gt; -- /bin/sh
</span></span></code></pre></div><p>这个命令会创建一个临时 Pod，在容器启动后直接进入 shell，调试完毕后会自动删除 Pod。</p><h3 id=6-查看-pod-状态和事件>6. <strong>查看 Pod 状态和事件</strong>
<a class=anchor href=#6-%e6%9f%a5%e7%9c%8b-pod-%e7%8a%b6%e6%80%81%e5%92%8c%e4%ba%8b%e4%bb%b6>#</a></h3><p>如果你想了解更多关于 Pod 崩溃的信息，可以使用 <code>kubectl describe pod</code> 来查看事件和容器的退出状态码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>在 <strong>Events</strong> 部分，通常会记录容器崩溃的原因。例如，OOM（Out Of Memory）或者其他启动错误。</p><h3 id=7-通过>7. <strong>通过 <code>kubectl debug</code> 创建调试容器</strong>
<a class=anchor href=#7-%e9%80%9a%e8%bf%87>#</a></h3><p>Kubernetes 提供了 <code>kubectl debug</code> 命令来在现有 Pod 上启动一个调试容器（比如基于相同的镜像或者不同的镜像），让你进行调试。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl debug -it &lt;pod-name&gt; --image<span style=color:#f92672>=</span>busybox --target<span style=color:#f92672>=</span>&lt;container-name&gt;
</span></span></code></pre></div><p>这个命令会启动一个新容器，与目标容器共享网络和挂载的卷，从而可以进入容器并进行进一步的调试。</p><h3 id=总结-13>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-13>#</a></h3><p>如果 Pod 处于 <code>CrashBackOff</code> 状态，直接使用 <code>kubectl exec</code> 可能会遇到困难，因为容器会不断重启。你可以通过以下方法调试：</p><ul><li>查看日志（<code>kubectl logs</code>）。</li><li>临时修改 <code>restartPolicy</code> 为 <code>Never</code>，避免 Pod 继续重启。</li><li>增加启动延迟或修改容器启动命令为调试模式。</li><li>使用 <code>kubectl run</code> 或 <code>kubectl debug</code> 创建临时调试 Pod。</li></ul><p>通过这些方法，你可以更方便地排查和调试容器的启动问题。</p><h2 id=默认日志存在宿主机那个位置>默认日志存在宿主机那个位置？
<a class=anchor href=#%e9%bb%98%e8%ae%a4%e6%97%a5%e5%bf%97%e5%ad%98%e5%9c%a8%e5%ae%bf%e4%b8%bb%e6%9c%ba%e9%82%a3%e4%b8%aa%e4%bd%8d%e7%bd%ae>#</a></h2><p>Kubernetes 中的容器日志默认保存在宿主机的 <strong><code>/var/log/containers/</code></strong> 目录下。具体来说，容器的日志文件存储位置取决于宿主机的容器运行时（例如 Docker 或 containerd），但通常会有以下几个路径和结构：</p><h3 id=1-docker-容器日志默认路径>1. <strong>Docker 容器日志默认路径</strong>
<a class=anchor href=#1-docker-%e5%ae%b9%e5%99%a8%e6%97%a5%e5%bf%97%e9%bb%98%e8%ae%a4%e8%b7%af%e5%be%84>#</a></h3><p>如果你的 Kubernetes 节点使用 Docker 作为容器运行时，容器的日志默认会存储在宿主机的 <code>/var/lib/docker/containers/&lt;container-id>/</code> 目录下，具体路径是：</p><pre tabindex=0><code>/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log
</code></pre><ul><li><strong><code>&lt;container-id></code></strong>：是每个容器的唯一 ID。你可以通过 <code>docker ps</code> 命令查看正在运行的容器及其 ID。</li><li><strong><code>-json.log</code></strong>：这个文件记录了容器的标准输出和标准错误输出（stdout 和 stderr）。</li></ul><p>例如，如果你要查看某个容器的日志，可以找到对应的 <code>&lt;container-id>-json.log</code> 文件，然后使用 <code>cat</code> 或 <code>tail</code> 命令查看日志内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -f /var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log
</span></span></code></pre></div><h3 id=2-containerd-容器日志默认路径>2. <strong>containerd 容器日志默认路径</strong>
<a class=anchor href=#2-containerd-%e5%ae%b9%e5%99%a8%e6%97%a5%e5%bf%97%e9%bb%98%e8%ae%a4%e8%b7%af%e5%be%84>#</a></h3><p>如果 Kubernetes 使用 <strong>containerd</strong> 作为容器运行时（在许多现代 Kubernetes 集群中使用），容器日志会保存在类似的路径中：</p><pre tabindex=0><code>/var/log/containers/&lt;pod-name&gt;_&lt;namespace&gt;_&lt;container-name&gt;-&lt;container-id&gt;.log
</code></pre><p>这些日志文件也是容器的标准输出和标准错误输出，通常是以 <code>JSON</code> 格式存储。</p><h3 id=3-kubernetes-节点日志varlogcontainers>3. <strong>Kubernetes 节点日志（/var/log/containers）</strong>
<a class=anchor href=#3-kubernetes-%e8%8a%82%e7%82%b9%e6%97%a5%e5%bf%97varlogcontainers>#</a></h3><p>在 Kubernetes 集群中，无论使用 Docker 还是 containerd，容器的标准输出日志文件一般都会存放在 <strong><code>/var/log/containers/</code></strong> 目录下。日志文件的命名格式通常是：</p><pre tabindex=0><code>/var/log/containers/&lt;pod-name&gt;_&lt;namespace&gt;_&lt;container-name&gt;-&lt;container-id&gt;.log
</code></pre><p>例如，一个 Pod 中的 <code>nginx</code> 容器的日志文件路径可能是：</p><pre tabindex=0><code>/var/log/containers/nginx_default_nginx-12345abcde67890.log
</code></pre><p>你可以使用 <code>tail</code> 或 <code>cat</code> 命令查看日志内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -f /var/log/containers/&lt;pod-name&gt;_&lt;namespace&gt;_&lt;container-name&gt;-&lt;container-id&gt;.log
</span></span></code></pre></div><h3 id=4-查看日志的其它方式>4. <strong>查看日志的其它方式</strong>
<a class=anchor href=#4-%e6%9f%a5%e7%9c%8b%e6%97%a5%e5%bf%97%e7%9a%84%e5%85%b6%e5%ae%83%e6%96%b9%e5%bc%8f>#</a></h3><p>除了直接访问宿主机上的日志文件外，你也可以使用 <code>kubectl</code> 命令查看容器日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt; -n &lt;namespace&gt;
</span></span></code></pre></div><p>如果 Pod 中有多个容器，可以指定容器名称。</p><h3 id=总结-14>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-14>#</a></h3><ul><li><strong>Docker 环境</strong>：日志存储在 <code>/var/lib/docker/containers/&lt;container-id>/&lt;container-id>-json.log</code>。</li><li><strong>containerd 环境</strong>：日志存储在 <code>/var/log/containers/&lt;pod-name>_&lt;namespace>_&lt;container-name>-&lt;container-id>.log</code>。</li><li>在大多数 Kubernetes 环境中，日志可以通过宿主机上的 <code>/var/log/containers/</code> 目录找到，并且可以通过 <code>kubectl logs</code> 命令查看容器日志。</li></ul><h2 id=docker的网络模式有哪些>docker的网络模式有哪些
<a class=anchor href=#docker%e7%9a%84%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h2><p>Docker提供了几种不同的网络模式，用来满足不同的容器通信需求。常见的网络模式包括：</p><ol><li><strong>bridge (桥接模式)</strong>
这是Docker的默认网络模式。容器会连接到Docker主机的虚拟桥接网络，通过桥接网络，容器之间可以相互通信，同时容器也能访问宿主机和外部网络。</li><li><strong>host (主机模式)</strong>
容器直接使用宿主机的网络栈，不会进行网络隔离。容器内的网络配置与宿主机相同，容器的端口映射到宿主机上，适用于需要高性能网络通信的场景。</li><li><strong>none (无网络模式)</strong>
容器没有网络连接。容器内的网络接口会被禁用，容器不能访问宿主机或其他容器，也不能接入任何外部网络。</li><li><strong>container (容器模式)</strong>
容器共享另一个容器的网络栈。网络设置与被共享容器相同，容器之间可以通过localhost进行通信。这种模式下，多个容器会共享IP地址和端口空间。</li><li><strong>host-gateway (主机网关模式)</strong>
这是一个相对较新的网络模式，用来实现容器与宿主机间的直接网络通信。容器能够通过指定的网关与宿主机互通。</li><li><strong>overlay (覆盖网络模式)</strong>
适用于跨多个Docker主机的容器之间的网络通信。Docker Swarm或Kubernetes等集群管理工具常使用overlay网络。在不同主机上的容器可以像在同一个主机上那样直接通信。</li><li><strong>macvlan (MAC虚拟局域网模式)</strong>
容器会被赋予一个唯一的MAC地址，容器可以直接连接到物理网络中，类似于独立的物理主机。这种模式可以让容器直接被其他物理设备识别，适合需要容器表现为物理设备的场景。</li><li><strong>ipvlan (IP虚拟局域网模式)</strong>
类似于macvlan，但它基于IP地址而非MAC地址进行网络隔离。适用于对性能要求较高、需要容器直接访问物理网络的场景。</li></ol><p>不同的网络模式适合不同的场景，选择合适的网络模式能提升应用的网络性能或满足安全需求。</p><h2 id=nginx的location的proxy的地址后面加和不加的区别>nginx的location的proxy的地址后面加/和不加/的区别
<a class=anchor href=#nginx%e7%9a%84location%e7%9a%84proxy%e7%9a%84%e5%9c%b0%e5%9d%80%e5%90%8e%e9%9d%a2%e5%8a%a0%e5%92%8c%e4%b8%8d%e5%8a%a0%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h2><p>在Nginx的<code>location</code>配置中，使用<code>proxy_pass</code>指令时，地址后面加 <code>/</code> 和不加 <code>/</code> 确实有区别，主要体现在请求路径如何传递给上游服务器。</p><h3 id=1-加>1. <strong>加 <code>/</code>：</strong>
<a class=anchor href=#1-%e5%8a%a0>#</a></h3><p>如果在 <code>proxy_pass</code> 后面加上 <code>/</code>，Nginx 会将客户端请求的路径的剩余部分追加到上游服务器的地址后面。</p><ul><li><p><strong>例子：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/api/</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://backend/</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>假设有请求 <code>http://nginx-server/api/user</code>，Nginx 会将请求转发到 <code>http://backend/user</code>。也就是说，<code>/api/</code> 部分会被去掉，只保留 <code>/user</code>。</p></li></ul><p><strong>总结</strong>：加 <code>/</code> 会去掉原请求路径中的匹配部分，直接将剩余路径传递给上游服务器。</p><h3 id=2-不加>2. <strong>不加 <code>/</code>：</strong>
<a class=anchor href=#2-%e4%b8%8d%e5%8a%a0>#</a></h3><p>如果在 <code>proxy_pass</code> 后面不加 <code>/</code>，Nginx 会将客户端请求的路径的剩余部分直接追加到上游服务器的地址后面，并保留匹配到的部分。</p><ul><li><p><strong>例子：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/api/</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://backend</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>假设有请求 <code>http://nginx-server/api/user</code>，Nginx 会将请求转发到 <code>http://backend/api/user</code>。这时，<code>/api/</code> 部分会被保留下来。</p></li></ul><p><strong>总结</strong>：不加 <code>/</code> 时，Nginx 会保留匹配的部分，并将剩余的路径传递给上游服务器。</p><h3 id=小结>小结：
<a class=anchor href=#%e5%b0%8f%e7%bb%93>#</a></h3><ul><li><strong>加 <code>/</code></strong>：会将匹配路径去掉，剩余的路径传递给后端。</li><li><strong>不加 <code>/</code></strong>：会保留匹配的路径部分，直接传递给后端。</li></ul><p>选择加或不加 <code>/</code> 取决于你希望如何将请求路径传递到上游服务器。</p><h2 id=k8s的dns的影响clusterfist-还有哪些>k8s的dns的影响clusterfist 还有哪些
<a class=anchor href=#k8s%e7%9a%84dns%e7%9a%84%e5%bd%b1%e5%93%8dclusterfist-%e8%bf%98%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h2><p>Kubernetes的DNS在集群内部通信中起着至关重要的作用，尤其是在服务发现和通信方面。Kubernetes的DNS服务通常是通过<code>kube-dns</code>或<code>CoreDNS</code>来实现的，它会为集群中的所有Pod和服务提供DNS解析。</p><p>在Kubernetes集群中，DNS配置有时会受到多种因素的影响，尤其是在集群初始化时的配置和网络环境的设置。以下是几种可能影响Kubernetes DNS的因素：</p><h3 id=1-clusterfirst-和-clusterfirstwithhostnet>1. <strong>ClusterFirst 和 ClusterFirstWithHostNet</strong>
<a class=anchor href=#1-clusterfirst-%e5%92%8c-clusterfirstwithhostnet>#</a></h3><p>在Kubernetes中，<code>DNSPolicy</code>配置项允许你指定DNS解析策略，影响Pod如何访问DNS解析。</p><ul><li><p><strong>ClusterFirst</strong>： 这是默认的DNS策略。Pod的DNS解析请求首先会被路由到集群内部的DNS服务（通常是<code>CoreDNS</code>）。如果请求是集群内的域名（如<code>service-name.namespace.svc.cluster.local</code>），则会被解析为集群内的IP地址。如果请求的是外部域名，DNS请求会被转发到外部DNS服务器。</p><p><strong>适用场景</strong>：大多数情况下都使用此模式，尤其是Pod之间需要访问服务时。</p></li><li><p><strong>ClusterFirstWithHostNet</strong>： 当Pod使用<code>hostNetwork: true</code>时，Pod将共享宿主机的网络栈。此时，如果你指定<code>ClusterFirstWithHostNet</code>，Pod会尝试通过集群的DNS服务解析内网域名（比如<code>service-name.namespace.svc.cluster.local</code>），但对于外部域名，它会使用宿主机的DNS配置，而不是集群内部的DNS。</p><p><strong>适用场景</strong>：适用于需要共享宿主机网络的场景（例如，网络性能要求很高的Pod，或者某些特殊的网络配置）。</p></li></ul><h3 id=2-dns解析的依赖性>2. <strong>DNS解析的依赖性</strong>
<a class=anchor href=#2-dns%e8%a7%a3%e6%9e%90%e7%9a%84%e4%be%9d%e8%b5%96%e6%80%a7>#</a></h3><p>Kubernetes集群中的DNS服务是高度集成的，很多集群功能依赖DNS：</p><ul><li><strong>Service Discovery</strong>：通过DNS解析服务名称来获取对应的IP地址。</li><li><strong>Pod之间的通信</strong>：Pod可以通过DNS服务来相互发现和通信。</li><li><strong>Ingress Controller</strong>：使用DNS解析来访问Ingress资源。</li></ul><p>如果DNS服务出现问题，整个集群内的服务发现和通信将受到影响。</p><h3 id=3-dns配置中的>3. <strong>DNS配置中的<code>search</code>和<code>resolve</code></strong>
<a class=anchor href=#3-dns%e9%85%8d%e7%bd%ae%e4%b8%ad%e7%9a%84>#</a></h3><p>Kubernetes中的DNS解析还可能受到Pod的<code>/etc/resolv.conf</code>配置的影响。例如，在Pod启动时，Kubernetes会自动设置DNS解析的配置，包括<code>search</code>（搜索域名）和<code>nameserver</code>（DNS服务器）。这个配置通常是由集群中的DNS服务（例如<code>CoreDNS</code>）提供的。</p><ul><li><strong><code>search</code>字段</strong>：指定域名后缀，允许不完整的域名被自动补全为完全合格的域名（FQDN）。</li><li><strong><code>nameserver</code>字段</strong>：指定DNS服务器的地址，通常是集群内的DNS服务的IP地址。</li></ul><h3 id=4-networkpolicy的影响>4. <strong>NetworkPolicy的影响</strong>
<a class=anchor href=#4-networkpolicy%e7%9a%84%e5%bd%b1%e5%93%8d>#</a></h3><p>如果在集群中启用了<code>NetworkPolicy</code>，它可能会影响Pod与DNS服务器（如<code>CoreDNS</code>）之间的通信。某些<code>NetworkPolicy</code>可能阻止Pod访问DNS服务，导致DNS解析失败。</p><p><strong>解决方法</strong>：确保所有Pod能够访问DNS服务端点（通常是<code>kube-dns</code>或<code>CoreDNS</code>服务）。</p><h3 id=5-coredns和>5. <strong>CoreDNS和<code>kube-dns</code></strong>
<a class=anchor href=#5-coredns%e5%92%8c>#</a></h3><p>Kubernetes使用<code>CoreDNS</code>（或<code>kube-dns</code>，具体取决于Kubernetes版本）作为DNS解析服务。CoreDNS通常与Kubernetes集群的API服务器、etcd和网络插件紧密集成。如果<code>CoreDNS</code>出现问题，集群内的DNS解析会中断。</p><ul><li><strong>DNS Server</strong>：<code>CoreDNS</code>负责提供DNS解析功能。</li><li><strong>Cache</strong>：<code>CoreDNS</code>通常会缓存DNS查询结果，以减少DNS查询的延迟。</li><li><strong>插件</strong>：CoreDNS支持多种插件，例如<code>forward</code>插件可以将查询转发到外部DNS服务器，<code>kubedns</code>插件可以解析集群内的服务名称。</li></ul><h3 id=6-集群网络插件cni>6. <strong>集群网络插件（CNI）</strong>
<a class=anchor href=#6-%e9%9b%86%e7%be%a4%e7%bd%91%e7%bb%9c%e6%8f%92%e4%bb%b6cni>#</a></h3><p>Kubernetes的CNI插件（例如Flannel、Calico、Weave等）在集群网络的配置中扮演着重要角色。某些网络插件可能会影响DNS的路由和解析，特别是如果网络插件配置不当或与DNS服务不兼容时。</p><ul><li><strong>Pod网络隔离</strong>：一些网络插件可能会导致DNS服务无法从某些Pod或命名空间中访问，尤其是在Pod被网络策略（NetworkPolicy）隔离的情况下。</li><li><strong>DNS流量路由</strong>：有些网络插件可能会通过不同的路由策略影响DNS流量的传输，导致DNS解析超时或失败。</li></ul><h3 id=7-dns-pod和service的高可用性>7. <strong>DNS Pod和Service的高可用性</strong>
<a class=anchor href=#7-dns-pod%e5%92%8cservice%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7>#</a></h3><p>Kubernetes的DNS服务（如<code>CoreDNS</code>）通常会以Deployment形式运行，具备一定的高可用性，但在一些配置下，DNS服务可能成为集群的单点故障。如果<code>CoreDNS</code>或<code>kube-dns</code> Pod出现故障，DNS解析就会失败，影响集群内所有Pod的通信。</p><ul><li><strong>Pod副本数</strong>：为了确保高可用性，<code>CoreDNS</code>通常至少有两个副本（Replica）。</li><li><strong>资源限制</strong>：如果<code>CoreDNS</code>的资源配置不足，可能导致解析延迟或失败。</li></ul><h3 id=8-externaldns>8. <strong>ExternalDNS</strong>
<a class=anchor href=#8-externaldns>#</a></h3><p>Kubernetes中的<code>ExternalDNS</code>可以帮助你将集群中的服务自动注册到外部DNS服务（如Route 53，Google Cloud DNS等）。这种方式将影响集群外部的DNS解析，但不会直接影响内部的DNS解析。</p><h3 id=小结-1>小结：
<a class=anchor href=#%e5%b0%8f%e7%bb%93-1>#</a></h3><p>Kubernetes中的DNS服务对集群的稳定性和服务发现至关重要。<code>ClusterFirst</code>和<code>ClusterFirstWithHostNet</code>是最常用的DNS策略，其他因素如网络策略、CNI插件、DNS服务的高可用性等都会影响DNS解析的正常工作。确保集群的DNS配置正确，并定期监控DNS服务的状态，对于保证集群的健康至关重要。</p><h2 id=calico和flannel有什么区别>calico和flannel有什么区别
<a class=anchor href=#calico%e5%92%8cflannel%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab>#</a></h2><p><strong>Calico</strong> 和 <strong>Flannel</strong> 都是 Kubernetes 中常用的网络插件（CNI，容器网络接口），用于实现容器之间的网络通信。它们在设计理念、功能、性能等方面有一些显著的区别。下面是它们的主要差异：</p><h3 id=1-设计理念>1. <strong>设计理念</strong>
<a class=anchor href=#1-%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5>#</a></h3><ul><li><strong>Flannel</strong>： Flannel 是一个比较简单的网络插件，设计上侧重于简化 Kubernetes 网络的配置和管理。它主要提供一个基础的网络层，确保不同节点上的 Pod 可以相互通信。Flannel 创建一个覆盖网络（overlay network），并为每个节点分配一个独立的子网。</li><li><strong>Calico</strong>： Calico 提供更强大的网络功能，包括网络策略（Network Policy）和安全性控制。它不仅支持 overlay 网络，还可以支持基于路由的网络（即基于BGP的网络）。Calico 可以为每个 Pod 分配一个 IP 地址，并提供集成的网络策略功能，可以实现更细粒度的流量控制和安全管理。</li></ul><h3 id=2-网络模式>2. <strong>网络模式</strong>
<a class=anchor href=#2-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8f>#</a></h3><ul><li><strong>Flannel</strong>： 默认情况下，Flannel 使用 overlay 网络模式，这意味着它会在现有的网络上建立一个虚拟的、独立的网络层。Flannel 为每个节点分配一个子网，并通过 VXLAN 或其他技术（如UDP）在节点间传输数据。<ul><li><strong>Overlay模式</strong>：Flannel 在集群各节点间建立一个虚拟网络，所有容器/Pod的流量都通过这个虚拟网络进行转发。</li><li><strong>简单配置</strong>：Flannel 比较容易部署，适合对网络性能要求不高的集群。</li></ul></li><li><strong>Calico</strong>： Calico 可以支持两种网络模式：<ul><li><strong>Overlay模式</strong>：与 Flannel 类似，Calico 也可以使用 overlay 网络，但它更灵活，可以根据需求选择。</li><li><strong>BGP模式</strong>：Calico 更加核心的特点是它可以使用 BGP（边界网关协议）来进行网络路由。每个节点都会参与路由决策，Pod之间的数据包会基于路由表进行直接传递。与 Flannel 的 overlay 网络相比，Calico 的这种方式性能更高，延迟更低，因为它不需要额外的封装层。</li></ul></li></ul><h3 id=3-网络策略network-policy>3. <strong>网络策略（Network Policy）</strong>
<a class=anchor href=#3-%e7%bd%91%e7%bb%9c%e7%ad%96%e7%95%a5network-policy>#</a></h3><ul><li><p><strong>Flannel</strong>： Flannel 本身并不提供网络策略功能。如果要使用网络策略，通常需要与其他网络插件（如 Calico 或 Cilium）结合使用。</p></li><li><p><strong>Calico</strong>： Calico 的一个显著特点是它内建了强大的 <strong>网络策略</strong> 功能。通过 Calico，你可以非常灵活地定义 Pod 间、Pod 和外部之间的流量规则。这使得 Calico 成为一种理想的选择，特别是在需要细粒度安全控制和流量隔离的环境中。</p><ul><li><p>示例功能</p><p>：</p><ul><li>控制哪些 Pod 可以与其他 Pod 通信。</li><li>基于标签、命名空间或端口号进行访问控制。</li><li>支持加密流量（IPsec、WireGuard 等）。</li></ul></li></ul></li></ul><h3 id=4-性能>4. <strong>性能</strong>
<a class=anchor href=#4-%e6%80%a7%e8%83%bd>#</a></h3><ul><li><strong>Flannel</strong>： 由于 Flannel 默认使用 Overlay 网络，它的性能可能不如 Calico。特别是在 VXLAN 模式下，数据包会进行多次封装，可能导致一定的性能开销。对于性能要求较高的场景，Flannel 可能不如 Calico。</li><li><strong>Calico</strong>： Calico 在性能方面通常表现更好，尤其是在使用 BGP 模式时。Calico 允许 Pod 直接通过底层网络进行通信，无需额外的封装层，因此能够减少延迟和提高吞吐量。</li></ul><h3 id=5-可扩展性>5. <strong>可扩展性</strong>
<a class=anchor href=#5-%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7>#</a></h3><ul><li><strong>Flannel</strong>： Flannel 适合小到中等规模的集群。由于它是一个简单的 Overlay 网络，它在大规模集群中的表现可能会受到一些限制，特别是当节点数量较多时，VXLAN 的性能可能成为瓶颈。</li><li><strong>Calico</strong>： Calico 支持更大的集群规模，特别是在需要更高吞吐量和低延迟的场景下。它的 BGP 路由模式使得它能够更加高效地处理大规模集群中的网络流量，避免了 Overlay 网络的性能瓶颈。</li></ul><h3 id=6-安装与配置>6. <strong>安装与配置</strong>
<a class=anchor href=#6-%e5%ae%89%e8%a3%85%e4%b8%8e%e9%85%8d%e7%bd%ae>#</a></h3><ul><li><strong>Flannel</strong>： Flannel 相对简单易用，适合快速部署和简单的用例。它的配置也比 Calico 简单，不需要太多额外的配置选项。</li><li><strong>Calico</strong>： Calico 比 Flannel 更复杂一些，尤其是在启用 BGP 路由时，可能需要一些额外的配置。不过，Calico 也提供了很多功能和灵活性，因此在需要更多自定义网络控制的场景中，它是一个很好的选择。</li></ul><h3 id=7-社区支持与生态>7. <strong>社区支持与生态</strong>
<a class=anchor href=#7-%e7%a4%be%e5%8c%ba%e6%94%af%e6%8c%81%e4%b8%8e%e7%94%9f%e6%80%81>#</a></h3><ul><li><strong>Flannel</strong>： Flannel 是 Kubernetes 早期的网络插件之一，社区支持相对较好，但它的功能比较简单，通常适用于对功能要求不高的环境。</li><li><strong>Calico</strong>： Calico 作为一个更强大的网络插件，它不仅有 Kubernetes 社区的支持，还被许多企业用于生产环境中，尤其是在对安全性和网络策略有较高要求的环境中。Calico 是一个活跃的开源项目，拥有广泛的用户和贡献者。</li></ul><h3 id=8-支持的功能>8. <strong>支持的功能</strong>
<a class=anchor href=#8-%e6%94%af%e6%8c%81%e7%9a%84%e5%8a%9f%e8%83%bd>#</a></h3><ul><li><strong>Flannel</strong>：<ul><li>简单的 Pod 网络连接。</li><li>支持 VXLAN、UDP 和其他简单的网络模式。</li><li>不自带网络策略功能（需要与其他插件结合使用）。</li></ul></li><li><strong>Calico</strong>：<ul><li>先进的网络策略功能，支持细粒度流量控制。</li><li>支持 BGP 和传统的 Overlay 网络。</li><li>支持高性能和低延迟的网络架构。</li><li>内建支持多租户和容器级别的隔离。</li><li>支持加密和 IPsec、WireGuard 等网络安全特性。</li></ul></li></ul><h3 id=总结-15>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-15>#</a></h3><table><thead><tr><th>特性</th><th><strong>Flannel</strong></th><th><strong>Calico</strong></th></tr></thead><tbody><tr><td><strong>网络模式</strong></td><td>主要使用 Overlay（VXLAN等）模式</td><td>支持 Overlay 和 BGP 路由模式</td></tr><tr><td><strong>性能</strong></td><td>较低，尤其在使用 VXLAN 时会有性能瓶颈</td><td>高性能，特别是在 BGP 模式下</td></tr><tr><td><strong>网络策略</strong></td><td>不支持（需要与其他插件结合使用）</td><td>内建支持强大的网络策略功能</td></tr><tr><td><strong>可扩展性</strong></td><td>适合小到中等规模集群</td><td>支持大规模集群，特别是在需要高性能的场景下</td></tr><tr><td><strong>安装与配置</strong></td><td>简单，易于安装和配置</td><td>配置稍复杂，但功能强大</td></tr><tr><td><strong>社区支持</strong></td><td>广泛支持，较为成熟</td><td>社区活跃，尤其在大规模企业级应用中更为常见</td></tr><tr><td><strong>适用场景</strong></td><td>小规模、性能要求不高的集群</td><td>需要高安全性、流量控制、网络策略的企业级集群</td></tr></tbody></table><p>总的来说，<strong>Flannel</strong> 更适合快速部署、简单的网络场景，而 <strong>Calico</strong> 则适合需要更复杂网络控制、安全策略和大规模集群的环境。</p><h6><a class=anchor href=#>#</a></h6><h2 id=efk-elasticsearch-fluentd-kibana-怎么用-干嘛的-怎么收集pod日志-存储展示>efk elasticsearch fluentd kibana 怎么用 干嘛的 怎么收集pod日志 存储展示
<a class=anchor href=#efk-elasticsearch-fluentd-kibana-%e6%80%8e%e4%b9%88%e7%94%a8-%e5%b9%b2%e5%98%9b%e7%9a%84-%e6%80%8e%e4%b9%88%e6%94%b6%e9%9b%86pod%e6%97%a5%e5%bf%97-%e5%ad%98%e5%82%a8%e5%b1%95%e7%a4%ba>#</a></h2><p>EFK 是 Elasticsearch、Fluentd 和 Kibana 的组合，它们一起构成了一个日志收集、存储和展示的解决方案。在 Kubernetes 环境中，EFK 被广泛用于集中式日志管理，帮助开发者和运维人员收集、存储和查看应用程序和系统的日志。</p><p>以下是关于 EFK 组合各组件的功能及如何使用它们收集 Pod 日志、存储日志并展示日志的介绍：</p><hr><h3 id=1-efk-组件介绍>1. <strong>EFK 组件介绍</strong>
<a class=anchor href=#1-efk-%e7%bb%84%e4%bb%b6%e4%bb%8b%e7%bb%8d>#</a></h3><ul><li><strong>Elasticsearch</strong>： Elasticsearch 是一个开源的分布式搜索引擎，主要用于存储、搜索和分析大规模的数据。它能够高效地存储日志并支持复杂的查询和分析。</li><li><strong>Fluentd</strong>： Fluentd 是一个开源的日志收集工具，用于收集、处理和转发日志数据。它能够从多个来源收集日志，并将日志数据流转到其他服务（如 Elasticsearch）进行存储和分析。</li><li><strong>Kibana</strong>： Kibana 是一个数据可视化工具，专门用来展示存储在 Elasticsearch 中的数据。你可以使用 Kibana 创建仪表盘、查询日志并进行分析，帮助用户快速找到日志中的问题。</li></ul><hr><h3 id=2-efk-体系架构>2. <strong>EFK 体系架构</strong>
<a class=anchor href=#2-efk-%e4%bd%93%e7%b3%bb%e6%9e%b6%e6%9e%84>#</a></h3><p>EFK 体系架构基本上是一个流数据处理链条，具体流程如下：</p><ol><li><strong>Fluentd</strong> 收集 Kubernetes 中各个 Pod 的日志（或通过日志收集代理如 Filebeat）。</li><li>Fluentd 对日志进行处理和格式化后，将其发送到 <strong>Elasticsearch</strong> 进行存储。</li><li><strong>Elasticsearch</strong> 存储日志数据，并支持快速搜索、索引和分析。</li><li><strong>Kibana</strong> 通过与 Elasticsearch 集成，提供强大的界面，帮助用户实时查看和分析日志。</li></ol><hr><h3 id=3-efk-的用途>3. <strong>EFK 的用途</strong>
<a class=anchor href=#3-efk-%e7%9a%84%e7%94%a8%e9%80%94>#</a></h3><p>EFK 解决方案通常用于以下用途：</p><ul><li><strong>日志集中化</strong>：将多个 Pod 和应用的日志集中存储在一个地方，便于管理。</li><li><strong>实时日志分析</strong>：支持对日志数据进行实时分析，能够快速发现问题。</li><li><strong>日志搜索</strong>：Kibana 提供强大的搜索和过滤功能，可以轻松检索和分析日志。</li><li><strong>监控和可视化</strong>：Kibana 可以通过仪表盘可视化日志数据，帮助开发者和运维人员快速理解集群和应用的健康状况。</li></ul><hr><h3 id=4-如何配置-efk-以收集-kubernetes-pod-日志>4. <strong>如何配置 EFK 以收集 Kubernetes Pod 日志</strong>
<a class=anchor href=#4-%e5%a6%82%e4%bd%95%e9%85%8d%e7%bd%ae-efk-%e4%bb%a5%e6%94%b6%e9%9b%86-kubernetes-pod-%e6%97%a5%e5%bf%97>#</a></h3><h4 id=步骤-1部署-elasticsearch><strong>步骤 1：部署 Elasticsearch</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-1%e9%83%a8%e7%bd%b2-elasticsearch>#</a></h4><p>首先，你需要部署 Elasticsearch 来存储日志。可以使用 Kubernetes 的部署方式，或者使用官方的 Elasticsearch Helm Chart 进行部署。</p><p>使用 Helm 部署 Elasticsearch 的命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install elasticsearch elastic/elasticsearch
</span></span></code></pre></div><p>配置 Elasticsearch：</p><ul><li>为 Elasticsearch 设置适当的资源限制和存储。</li><li>确保其能够对 Kubernetes 集群中的日志流量进行水平扩展。</li></ul><h4 id=步骤-2部署-fluentd><strong>步骤 2：部署 Fluentd</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-2%e9%83%a8%e7%bd%b2-fluentd>#</a></h4><p>Fluentd 用于从 Kubernetes 集群中的各个节点和 Pod 收集日志。Fluentd 收集的日志将发送到 Elasticsearch 存储。</p><p>你可以通过部署 Fluentd DaemonSet 来在每个节点上运行 Fluentd 收集日志：</p><ol><li><p>创建 Fluentd 配置文件 <code>fluentd.conf</code>，配置日志收集规则和数据传输到 Elasticsearch 的方式。</p></li><li><p>部署 Fluentd：</p><p>使用 Helm 安装 Fluentd：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install fluentd stable/fluentd
</span></span></code></pre></div></li><li><p>配置 Fluentd 输出到 Elasticsearch： 在 Fluentd 配置中，设置 <code>elasticsearch</code> 输出插件，确保日志被发送到 Elasticsearch。</p><p>配置示例（在 Fluentd 配置文件中）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>&lt;match **&gt;</span>
</span></span><span style=display:flex><span>  @<span style=color:#ae81ff>type elasticsearch</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>host elasticsearch.default.svc.cluster.local</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>port 9200</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>logstash_format true</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>logstash_prefix kubernetes-logs</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>flush_interval 5s</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>&lt;/match&gt;</span>
</span></span></code></pre></div></li></ol><h4 id=步骤-3部署-kibana><strong>步骤 3：部署 Kibana</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-3%e9%83%a8%e7%bd%b2-kibana>#</a></h4><p>Kibana 提供了一个 Web 界面来查看存储在 Elasticsearch 中的日志。你可以使用 Helm 或者手动部署 Kibana。</p><ol><li><p>使用 Helm 部署 Kibana：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install kibana elastic/kibana
</span></span></code></pre></div></li><li><p>配置 Kibana： 确保 Kibana 能够连接到 Elasticsearch，设置 Kibana 的 <code>elasticsearch.hosts</code> 配置项。</p></li></ol><h4 id=步骤-4验证日志收集><strong>步骤 4：验证日志收集</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-4%e9%aa%8c%e8%af%81%e6%97%a5%e5%bf%97%e6%94%b6%e9%9b%86>#</a></h4><ol><li><p><strong>查看 Fluentd 是否正常收集日志</strong>： 使用 <code>kubectl logs</code> 查看 Fluentd Pod 的日志，确认它是否正在收集和发送日志到 Elasticsearch。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs -l app<span style=color:#f92672>=</span>fluentd
</span></span></code></pre></div></li><li><p><strong>查看 Kibana 是否显示日志</strong>： 登录到 Kibana Web 界面，通常可以通过端口映射访问 Kibana，默认端口是 <code>5601</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl port-forward svc/kibana 5601:5601
</span></span></code></pre></div><p>访问 <code>http://localhost:5601</code>，进入 Kibana 仪表盘，查看是否能够查询和可视化日志。</p></li></ol><hr><h3 id=5-查看和分析日志>5. <strong>查看和分析日志</strong>
<a class=anchor href=#5-%e6%9f%a5%e7%9c%8b%e5%92%8c%e5%88%86%e6%9e%90%e6%97%a5%e5%bf%97>#</a></h3><ul><li>在 <strong>Kibana</strong> 中，使用 <strong>Discover</strong> 选项来搜索日志。你可以通过定义查询条件（如日志级别、时间范围等）来查找特定的日志信息。</li><li>在 <strong>Dashboard</strong> 中，你可以创建实时仪表盘，将关键日志指标可视化，方便监控。</li><li>Kibana 还支持各种高级功能，如日志聚合、过滤、和告警。</li></ul><hr><h3 id=6-日志存储和展示的最佳实践>6. <strong>日志存储和展示的最佳实践</strong>
<a class=anchor href=#6-%e6%97%a5%e5%bf%97%e5%ad%98%e5%82%a8%e5%92%8c%e5%b1%95%e7%a4%ba%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5>#</a></h3><ul><li><strong>日志清理和保留策略</strong>：Elasticsearch 存储日志时可能会占用大量磁盘空间。你可以设置日志的生命周期管理（例如：使用 ILM（Index Lifecycle Management）自动删除旧日志或将其归档）。</li><li><strong>标签和元数据</strong>：在 Fluentd 配置中，可以确保每个日志条目附带 Kubernetes 的元数据（如 Pod 名称、命名空间、容器名等），这样在 Kibana 中可以更方便地搜索和分析。</li><li><strong>资源限制</strong>：部署 EFK 堆栈时，要为 Elasticsearch、Fluentd 和 Kibana 设置适当的资源限制，防止因日志量过大而导致集群性能下降。</li></ul><hr><h3 id=总结-16>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-16>#</a></h3><ul><li><strong>Fluentd</strong> 负责收集 Kubernetes Pod 和容器的日志。</li><li><strong>Elasticsearch</strong> 负责存储日志，并支持强大的搜索和分析。</li><li><strong>Kibana</strong> 提供一个友好的 Web 界面，用于展示和分析存储在 Elasticsearch 中的日志。</li></ul><p>EFK 体系提供了一个功能强大且易于扩展的日志收集和展示解决方案，广泛应用于 Kubernetes 环境中，帮助团队快速发现问题并进行故障排除。</p><h6><a class=anchor href=#>#</a></h6><h6><a class=anchor href=#>#</a></h6></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#delete-pvc时-设置什么字段可以保证pv不被删除>delete pvc时 设置什么字段可以保证pv不被删除</a><ul><li><a href=#步骤>步骤</a></li><li><a href=#总结>总结：</a></li></ul></li><li><a href=#重新绑定到一个新的-pvc-数据还在吗>重新绑定到一个新的 PVC 数据还在吗</a><ul><li><a href=#如何运作>如何运作：</a></li><li><a href=#例子>例子：</a></li><li><a href=#注意事项>注意事项：</a></li><li><a href=#总结-1>总结：</a></li></ul></li><li><a href=#临时存储的字段是啥>临时存储的字段是啥</a><ul><li><a href=#1-emptydir>1. <strong>emptyDir</strong></a></li><li><a href=#2-ephemeral>2. <strong>ephemeral</strong></a></li><li><a href=#3-hostpath>3. <strong>hostPath</strong></a></li><li><a href=#4-临时存储请求>4. <strong>临时存储请求（<code>ephemeral-storage</code>）</strong></a></li><li><a href=#总结-2>总结</a></li></ul></li><li><a href=#metric-server-干啥的>metric-server 干啥的</a><ul><li><a href=#metric-server-的功能>Metric Server 的功能</a></li><li><a href=#metric-server-的工作原理>Metric Server 的工作原理</a></li><li><a href=#安装与配置>安装与配置</a></li><li><a href=#常见问题>常见问题</a></li><li><a href=#总结-3>总结</a></li><li><a href=#更深入的工作原理>更深入的工作原理</a></li><li><a href=#数据流动示例>数据流动示例</a></li><li><a href=#cadvisor-和-metric-server-的协作>cAdvisor 和 Metric Server 的协作</a></li><li><a href=#为什么-cadvisor-和-metric-server-配合使用>为什么 cAdvisor 和 Metric Server 配合使用？</a></li><li><a href=#其他相关工具>其他相关工具</a></li><li><a href=#总结-4>总结</a></li></ul></li><li><a href=#deploy里面定义secrect的字段是啥>deploy里面定义secrect的字段是啥</a><ul><li><a href=#1-通过环境变量传递-secret>1. 通过环境变量传递 Secret</a></li><li><a href=#2-通过卷挂载-secret>2. 通过卷挂载 Secret</a></li><li><a href=#总结-5>总结</a></li></ul></li><li><a href=#pod被调度的方式有哪些>pod被调度的方式有哪些</a><ul><li><a href=#1-默认调度>1. <strong>默认调度</strong></a></li><li><a href=#2-node-affinity节点亲和性>2. <strong>Node Affinity（节点亲和性）</strong></a></li><li><a href=#3-pod-affinity-和-pod-anti-affinity>3. <strong>Pod Affinity 和 Pod Anti-Affinity</strong></a></li><li><a href=#4-taints-和-tolerations污点和容忍>4. <strong>Taints 和 Tolerations（污点和容忍）</strong></a></li><li><a href=#5-资源请求和限制resource-requests-and-limits>5. <strong>资源请求和限制（Resource Requests and Limits）</strong></a></li><li><a href=#6-priority-class优先级类>6. <strong>Priority Class（优先级类）</strong></a></li><li><a href=#7-topology-spread-constraints拓扑分布约束>7. <strong>Topology Spread Constraints（拓扑分布约束）</strong></a></li><li><a href=#总结-6>总结</a></li></ul></li><li><a href=#daemonset-忽略污点-使其可以调度到所有节点>daemonset 忽略污点 使其可以调度到所有节点</a><ul><li><a href=#1-理解污点和容忍>1. <strong>理解污点和容忍</strong></a></li><li><a href=#2-修改-daemonset-的配置>2. <strong>修改 DaemonSet 的配置</strong></a></li><li><a href=#3-解释上述配置>3. <strong>解释上述配置</strong></a></li><li><a href=#4-使其可以调度到所有节点>4. <strong>使其可以调度到所有节点</strong></a></li><li><a href=#5-应用配置>5. <strong>应用配置</strong></a></li><li><a href=#总结-7>总结</a></li></ul></li><li><a href=#pod的状态有哪些>pod的状态有哪些？</a><ul><li><a href=#1-pending等待中>1. <strong>Pending（等待中）</strong></a></li><li><a href=#2-running运行中>2. <strong>Running（运行中）</strong></a></li><li><a href=#3-succeeded成功>3. <strong>Succeeded（成功）</strong></a></li><li><a href=#4-failed失败>4. <strong>Failed（失败）</strong></a></li><li><a href=#5-unknown未知>5. <strong>Unknown（未知）</strong></a></li><li><a href=#pod-状态的详细说明>Pod 状态的详细说明</a></li><li><a href=#pod-状态的细化字段容器级>Pod 状态的细化字段（容器级）</a></li><li><a href=#容器状态示例>容器状态示例：</a></li><li><a href=#总结-8>总结</a></li></ul></li><li><a href=#evicted呢>evicted呢？</a><ul><li><a href=#evicted-状态的原因><strong>Evicted</strong> 状态的原因</a></li><li><a href=#evicted-状态的标志><strong>Evicted</strong> 状态的标志</a></li><li><a href=#evicted-的后续处理><strong>Evicted</strong> 的后续处理</a></li><li><a href=#总结-9>总结</a></li></ul></li><li><a href=#如果同一个pod-出现几十几百次的evicted-是啥原因>如果同一个pod 出现几十几百次的evicted 是啥原因？</a><ul><li></li><li><a href=#1-资源不足-memorypressure--diskpressure>1. <strong>资源不足 (MemoryPressure / DiskPressure)</strong></a></li><li><a href=#2-pod-配置问题>2. <strong>Pod 配置问题</strong></a></li><li><a href=#3-pod-驱逐策略taints-和-tolerations>3. <strong>Pod 驱逐策略（Taints 和 Tolerations）</strong></a></li><li><a href=#4-调度和优先级问题>4. <strong>调度和优先级问题</strong></a></li><li><a href=#5-poddisruptionbudget-pdb>5. <strong>PodDisruptionBudget (PDB)</strong></a></li><li><a href=#6-集群健康和调度器问题>6. <strong>集群健康和调度器问题</strong></a></li><li><a href=#如何解决>如何解决？</a></li><li><a href=#总结-10>总结</a></li></ul></li><li><a href=#如果pod超出资源限制被杀死那他时重启-重建还是什么呢>如果pod超出资源限制被杀死，那他时重启 重建还是什么呢？</a><ul><li><a href=#1-容器被杀死时的行为>1. <strong>容器被杀死时的行为</strong></a></li><li><a href=#2-容器的重启行为>2. <strong>容器的重启行为</strong></a></li><li><a href=#3-由控制器管理的行为>3. <strong>由控制器管理的行为</strong></a></li><li><a href=#4-oom-kill-与重启的细节>4. <strong>OOM Kill 与重启的细节</strong></a></li><li><a href=#5-pod-状态变化>5. <strong>Pod 状态变化</strong></a></li><li><a href=#6-如何避免-pod-被-oom-杀死>6. <strong>如何避免 Pod 被 OOM 杀死</strong></a></li><li><a href=#总结-11>总结</a></li></ul></li><li><a href=#如果-pod-配置了-restartpolicy-always这是-deploymentreplicaset-等控制器的默认重启策略即使容器被-oom-杀死或因其他原因退出kubernetes-会自动重新启动容器-控制器行为如果是由-deployment-或-replicaset-管理的-pod当容器因资源超限而被杀死时kubernetes-会自动重新调度一个新的容器实例以确保-pod-的副本数不变-自相矛盾了吧>如果 Pod 配置了 restartPolicy: Always（这是 Deployment、ReplicaSet 等控制器的默认重启策略），即使容器被 OOM 杀死或因其他原因退出，Kubernetes 会自动重新启动容器。 控制器行为：如果是由 Deployment 或 ReplicaSet 管理的 Pod，当容器因资源超限而被杀死时，Kubernetes 会自动重新调度一个新的容器实例，以确保 Pod 的副本数不变。 自相矛盾了吧</a><ul><li></li><li><a href=#restartpolicy-always-和-控制器行为><code>restartPolicy: Always</code> 和 控制器行为</a></li><li><a href=#控制器的行为>控制器的行为：</a></li><li><a href=#细节容器的重启-vs-pod-重建>细节：容器的重启 vs Pod 重建</a></li></ul></li><li><a href=#debug容器调试老是crashbackof的pod>debug容器调试老是crashbackof的pod？</a><ul><li><a href=#crashbackoff-产生的常见原因><strong>CrashBackOff</strong> 产生的常见原因</a></li><li><a href=#调试-crashbackoff-的步骤><strong>调试 CrashBackOff 的步骤</strong></a></li><li><a href=#示例查看容器日志><strong>示例</strong>：查看容器日志</a></li><li><a href=#常见的-crashbackoff-问题和解决方案><strong>常见的 CrashBackOff 问题和解决方案</strong></a></li><li><a href=#总结-12>总结</a></li></ul></li><li><a href=#kubectl-exec-进不去因为-会一直重启>kubectl exec 进不去因为 会一直重启</a><ul><li><a href=#1-使用>1. <strong>使用 <code>kubectl logs</code> 查看日志</strong></a></li><li><a href=#2-暂时设置重启策略为>2. <strong>暂时设置重启策略为 <code>Never</code></strong></a></li><li><a href=#3-增加容器启动延迟>3. <strong>增加容器启动延迟</strong></a></li><li><a href=#4-修改容器的启动命令为调试模式>4. <strong>修改容器的启动命令为调试模式</strong></a></li><li><a href=#5-使用>5. <strong>使用 <code>kubectl run</code> 创建临时 Pod 进行调试</strong></a></li><li><a href=#6-查看-pod-状态和事件>6. <strong>查看 Pod 状态和事件</strong></a></li><li><a href=#7-通过>7. <strong>通过 <code>kubectl debug</code> 创建调试容器</strong></a></li><li><a href=#总结-13>总结</a></li></ul></li><li><a href=#默认日志存在宿主机那个位置>默认日志存在宿主机那个位置？</a><ul><li><a href=#1-docker-容器日志默认路径>1. <strong>Docker 容器日志默认路径</strong></a></li><li><a href=#2-containerd-容器日志默认路径>2. <strong>containerd 容器日志默认路径</strong></a></li><li><a href=#3-kubernetes-节点日志varlogcontainers>3. <strong>Kubernetes 节点日志（/var/log/containers）</strong></a></li><li><a href=#4-查看日志的其它方式>4. <strong>查看日志的其它方式</strong></a></li><li><a href=#总结-14>总结</a></li></ul></li><li><a href=#docker的网络模式有哪些>docker的网络模式有哪些</a></li><li><a href=#nginx的location的proxy的地址后面加和不加的区别>nginx的location的proxy的地址后面加/和不加/的区别</a><ul><li><a href=#1-加>1. <strong>加 <code>/</code>：</strong></a></li><li><a href=#2-不加>2. <strong>不加 <code>/</code>：</strong></a></li><li><a href=#小结>小结：</a></li></ul></li><li><a href=#k8s的dns的影响clusterfist-还有哪些>k8s的dns的影响clusterfist 还有哪些</a><ul><li><a href=#1-clusterfirst-和-clusterfirstwithhostnet>1. <strong>ClusterFirst 和 ClusterFirstWithHostNet</strong></a></li><li><a href=#2-dns解析的依赖性>2. <strong>DNS解析的依赖性</strong></a></li><li><a href=#3-dns配置中的>3. <strong>DNS配置中的<code>search</code>和<code>resolve</code></strong></a></li><li><a href=#4-networkpolicy的影响>4. <strong>NetworkPolicy的影响</strong></a></li><li><a href=#5-coredns和>5. <strong>CoreDNS和<code>kube-dns</code></strong></a></li><li><a href=#6-集群网络插件cni>6. <strong>集群网络插件（CNI）</strong></a></li><li><a href=#7-dns-pod和service的高可用性>7. <strong>DNS Pod和Service的高可用性</strong></a></li><li><a href=#8-externaldns>8. <strong>ExternalDNS</strong></a></li><li><a href=#小结-1>小结：</a></li></ul></li><li><a href=#calico和flannel有什么区别>calico和flannel有什么区别</a><ul><li><a href=#1-设计理念>1. <strong>设计理念</strong></a></li><li><a href=#2-网络模式>2. <strong>网络模式</strong></a></li><li><a href=#3-网络策略network-policy>3. <strong>网络策略（Network Policy）</strong></a></li><li><a href=#4-性能>4. <strong>性能</strong></a></li><li><a href=#5-可扩展性>5. <strong>可扩展性</strong></a></li><li><a href=#6-安装与配置>6. <strong>安装与配置</strong></a></li><li><a href=#7-社区支持与生态>7. <strong>社区支持与生态</strong></a></li><li><a href=#8-支持的功能>8. <strong>支持的功能</strong></a></li><li><a href=#总结-15>总结</a></li></ul></li><li><a href=#efk-elasticsearch-fluentd-kibana-怎么用-干嘛的-怎么收集pod日志-存储展示>efk elasticsearch fluentd kibana 怎么用 干嘛的 怎么收集pod日志 存储展示</a><ul><li><a href=#1-efk-组件介绍>1. <strong>EFK 组件介绍</strong></a></li><li><a href=#2-efk-体系架构>2. <strong>EFK 体系架构</strong></a></li><li><a href=#3-efk-的用途>3. <strong>EFK 的用途</strong></a></li><li><a href=#4-如何配置-efk-以收集-kubernetes-pod-日志>4. <strong>如何配置 EFK 以收集 Kubernetes Pod 日志</strong></a></li><li><a href=#5-查看和分析日志>5. <strong>查看和分析日志</strong></a></li><li><a href=#6-日志存储和展示的最佳实践>6. <strong>日志存储和展示的最佳实践</strong></a></li><li><a href=#总结-16>总结</a></li></ul></li></ul></nav></div></aside></main></body></html>