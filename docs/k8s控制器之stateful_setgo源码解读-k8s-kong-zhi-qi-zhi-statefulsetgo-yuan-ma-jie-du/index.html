<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package statefulset

import (
	"context"
	"fmt"
	"reflect"
	"time"

	apps "k8s.io/api/apps/v1"
	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/apimachinery/pkg/util/wait"
	appsinformers "k8s.io/client-go/informers/apps/v1"
	coreinformers "k8s.io/client-go/informers/core/v1"
	clientset "k8s.io/client-go/kubernetes"
	"k8s.io/client-go/kubernetes/scheme"
	v1core "k8s.io/client-go/kubernetes/typed/core/v1"
	appslisters "k8s.io/client-go/listers/apps/v1"
	corelisters "k8s.io/client-go/listers/core/v1"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/tools/record"
	"k8s.io/client-go/util/workqueue"
	podutil "k8s.io/kubernetes/pkg/api/v1/pod"
	"k8s.io/kubernetes/pkg/controller"
	"k8s.io/kubernetes/pkg/controller/history"
)

// controllerKind contains the schema.GroupVersionKind for this controller type.
var controllerKind = apps.SchemeGroupVersion.WithKind("StatefulSet")

// StatefulSetController controls statefulsets.
type StatefulSetController struct {
	// client interface
	kubeClient clientset.Interface
	// control returns an interface capable of syncing a stateful set.
	// Abstracted out for testing.
	control StatefulSetControlInterface
	// podControl is used for patching pods.
	podControl controller.PodControlInterface
	// podLister is able to list/get pods from a shared informer&#39;s store
	podLister corelisters.PodLister
	// podListerSynced returns true if the pod shared informer has synced at least once
	podListerSynced cache.InformerSynced
	// setLister is able to list/get stateful sets from a shared informer&#39;s store
	setLister appslisters.StatefulSetLister
	// setListerSynced returns true if the stateful set shared informer has synced at least once
	setListerSynced cache.InformerSynced
	// pvcListerSynced returns true if the pvc shared informer has synced at least once
	pvcListerSynced cache.InformerSynced
	// revListerSynced returns true if the rev shared informer has synced at least once
	revListerSynced cache.InformerSynced
	// StatefulSets that need to be synced.
	queue workqueue.RateLimitingInterface
	// eventBroadcaster is the core of event processing pipeline.
	eventBroadcaster record.EventBroadcaster
}

// 这段Go代码定义了一个名为StatefulSetController的结构体，用于控制StatefulSets。
// 它包含了一系列的成员变量，包括client接口、控制StatefulSet同步的接口、用于patching pods的接口、以及一系列的Lister和Synced函数，
// 用于从共享informer的存储中获取Pods、StatefulSets、PVCs等信息。
// 此外，它还定义了一个工作队列和一个事件广播器。这个结构体主要用于管理和同步Kubernetes中的StatefulSets。
// NewStatefulSetController creates a new statefulset controller.
func NewStatefulSetController(
	ctx context.Context,
	podInformer coreinformers.PodInformer,
	setInformer appsinformers.StatefulSetInformer,
	pvcInformer coreinformers.PersistentVolumeClaimInformer,
	revInformer appsinformers.ControllerRevisionInformer,
	kubeClient clientset.Interface,
) *StatefulSetController {
	logger := klog.FromContext(ctx)
	eventBroadcaster := record.NewBroadcaster(record.WithContext(ctx))
	recorder := eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: "statefulset-controller"})
	ssc := &amp;StatefulSetController{
		kubeClient: kubeClient,
		control: NewDefaultStatefulSetControl(
			NewStatefulPodControl(
				kubeClient,
				podInformer.Lister(),
				pvcInformer.Lister(),
				recorder),
			NewRealStatefulSetStatusUpdater(kubeClient, setInformer.Lister()),
			history.NewHistory(kubeClient, revInformer.Lister()),
			recorder,
		),
		pvcListerSynced: pvcInformer.Informer().HasSynced,
		revListerSynced: revInformer.Informer().HasSynced,
		queue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "statefulset"),
		podControl:      controller.RealPodControl{KubeClient: kubeClient, Recorder: recorder},

		eventBroadcaster: eventBroadcaster,
	}
	//该函数用于创建一个新的StatefulSet控制器。它接收多个参数，包括上下文、各种Informer、客户端接口等。
	//函数内部通过调用NewDefaultStatefulSetControl函数和其他函数，初始化了StatefulSetController结构体的各个字段，
	//并返回一个指向StatefulSetController结构体的指针。
	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
		// lookup the statefulset and enqueue
		AddFunc: func(obj interface{}) {
			ssc.addPod(logger, obj)
		},
		// lookup current and old statefulset if labels changed
		UpdateFunc: func(oldObj, newObj interface{}) {
			ssc.updatePod(logger, oldObj, newObj)
		},
		// lookup statefulset accounting for deletion tombstones
		DeleteFunc: func(obj interface{}) {
			ssc.deletePod(logger, obj)
		},
	})
	//这段代码定义了一个Go函数，它为podInformer的Informer添加了一个事件处理程序。
	//该事件处理程序使用cache.ResourceEventHandlerFuncs结构体中的AddFunc、UpdateFunc和DeleteFunc来处理资源的添加、更新和删除事件。
	//- AddFunc函数在资源添加时调用ssc.addPod(logger, obj)来添加Pod。
	//- UpdateFunc函数在资源更新时调用ssc.updatePod(logger, oldObj, newObj)来更新Pod。
	//- DeleteFunc函数在资源删除时调用ssc.deletePod(logger, obj)来删除Pod。
	//这些函数通过传入的logger和相应的资源对象来执行具体的操作。
	ssc.podLister = podInformer.Lister()
	ssc.podListerSynced = podInformer.Informer().HasSynced

	setInformer.Informer().AddEventHandler(
		cache.ResourceEventHandlerFuncs{
			AddFunc: ssc.enqueueStatefulSet,
			UpdateFunc: func(old, cur interface{}) {
				oldPS := old.(*apps.StatefulSet)
				curPS := cur.(*apps.StatefulSet)
				if oldPS.Status.Replicas != curPS.Status.Replicas {
					logger.V(4).Info("Observed updated replica count for StatefulSet", "statefulSet", klog.KObj(curPS), "oldReplicas", oldPS.Status.Replicas, "newReplicas", curPS.Status.Replicas)
				}
				ssc.enqueueStatefulSet(cur)
			},
			DeleteFunc: ssc.enqueueStatefulSet,
		},
	)
	//这段代码主要涉及到了Kubernetes Informer机制的使用，用于监听StatefulSet资源的变化，并对变化事件进行处理。
	//1. 首先，ssc.podLister = podInformer.Lister()和ssc.podListerSynced = podInformer.Informer().HasSynced
	//两行代码是将pod的Lister和是否同步完成的函数赋值给ssc对象的对应字段。Lister是用来从Informer的cache中获取资源列表和单个资源的，
	//HasSynced则是用来判断Informer是否已经完成初始的资源同步。
	//2. 接下来，setInformer.Informer().AddEventHandler(...)这行代码是给setInformer添加了一个事件处理函数。
	//其中，cache.ResourceEventHandlerFuncs是一个包含了资源添加、更新和删除事件处理函数的结构体。
	//- AddFunc: ssc.enqueueStatefulSet表示当有StatefulSet资源被添加时，调用ssc.enqueueStatefulSet函数来处理该事件。
	//- UpdateFunc表示当有StatefulSet资源被更新时，会先判断其副本数是否发生了变化，如果有变化则打印日志并调用ssc.enqueueStatefulSet函数来处理该事件。
	//- DeleteFunc: ssc.enqueueStatefulSet表示当有StatefulSet资源被删除时，调用ssc.enqueueStatefulSet函数来处理该事件。
	//综上所述，这段代码通过使用Kubernetes Informer机制监听StatefulSet资源的变化，并调用ssc.enqueueStatefulSet函数来处理这些变化事件。
	ssc.setLister = setInformer.Lister()
	ssc.setListerSynced = setInformer.Informer().HasSynced

	// TODO: Watch volumes
	return ssc
}

// 这个Go函数主要设置了ssc对象的setLister和setListerSynced属性。
// setLister是通过setInformer.Lister()方法设置的，它用于从存储中获取设置列表。setListerSynced是通过setInformer.Informer().HasSynced方法设置的，
// 它用于检查设置的同步状态。最后，该函数返回ssc对象。
// Run runs the statefulset controller.
func (ssc *StatefulSetController) Run(ctx context.Context, workers int) {
	defer utilruntime.HandleCrash()

	// Start events processing pipeline.
	ssc.eventBroadcaster.StartStructuredLogging(3)
	ssc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: ssc.kubeClient.CoreV1().Events("")})
	defer ssc.eventBroadcaster.Shutdown()

	defer ssc.queue.ShutDown()

	logger := klog.FromContext(ctx)
	logger.Info("Starting stateful set controller")
	defer logger.Info("Shutting down statefulset controller")
	//该函数是StatefulSetController类型的Run方法，用于启动statefulset控制器。
	//函数首先处理崩溃情况，然后开启事件处理管道，记录事件并将其发送到事件接收器。
	//之后，函数通过调用queue的ShutDown方法来关闭队列。函数在启动和关闭控制器时分别记录日志信息。
	if !cache.WaitForNamedCacheSync("stateful set", ctx.Done(), ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) {
		return
	}

	for i := 0; i < workers; i++ {
		go wait.UntilWithContext(ctx, ssc.worker, time.Second)
	}

	<-ctx.Done()
}

// 这段Go代码主要实现了以下功能：
// - 等待多个缓存同步完成：通过调用cache.WaitForNamedCacheSync方法，
// 等待podListerSynced、setListerSynced、pvcListerSynced和revListerSynced四个缓存同步完成。
// 如果在指定的上下文ctx被取消或超时之前，所有缓存都已同步，则继续执行后续代码；否则直接返回。
// - 启动多个工作协程：使用for循环和go关键字，启动workers个工作协程，并在每个协程中定期执行ssc.worker函数，其间隔时间为1秒。
// 这些工作协程会一直运行，直到上下文ctx被取消或超时。
// - 等待上下文取消或超时：通过读取ctx.Done()通道，阻塞当前协程，等待上下文ctx被取消或超时。
// 一旦上下文被取消或超时，整个函数执行结束。  这段代码通常用于在启动时等待多个缓存同步完成，并启动多个工作协程来处理后续任务。
// 通过上下文ctx来控制整个函数的运行时长，并能够在缓存同步或工作协程运行过程中随时取消操作。
// addPod adds the statefulset for the pod to the sync queue
func (ssc *StatefulSetController) addPod(logger klog.Logger, obj interface{}) {
	pod := obj.(*v1.Pod)

	if pod.DeletionTimestamp != nil {
		// on a restart of the controller manager, it&#39;s possible a new pod shows up in a state that
		// is already pending deletion. Prevent the pod from being a creation observation.
		ssc.deletePod(logger, pod)
		return
	}

	// If it has a ControllerRef, that&#39;s all that matters.
	if controllerRef := metav1.GetControllerOf(pod); controllerRef != nil {
		set := ssc.resolveControllerRef(pod.Namespace, controllerRef)
		if set == nil {
			return
		}
		logger.V(4).Info("Pod created with labels", "pod", klog.KObj(pod), "labels", pod.Labels)
		ssc.enqueueStatefulSet(set)
		return
	}
	//该函数是StatefulSetController类型的一个方法，用于将Pod的状态添加到同步队列中。
	//首先，它检查Pod是否已被标记为删除，如果是，则调用deletePod方法删除Pod，并返回。
	//然后，它检查Pod是否有ControllerRef，如果有，则通过resolveControllerRef方法解析ControllerRef，
	//并将解析结果传递给enqueueStatefulSet方法，以将StatefulSet添加到同步队列中。
	// Otherwise, it&#39;s an orphan. Get a list of all matching controllers and sync
	// them to see if anyone wants to adopt it.
	sets := ssc.getStatefulSetsForPod(pod)
	if len(sets) == 0 {
		return
	}
	logger.V(4).Info("Orphan Pod created with labels", "pod", klog.KObj(pod), "labels", pod.Labels)
	for _, set := range sets {
		ssc.enqueueStatefulSet(set)
	}
}

// 该函数用于处理一个无归属的Pod（孤儿Pod），通过获取与该Pod匹配的所有StatefulSet控制器，并将它们同步，以查看是否有控制器愿意“收养”这个Pod。
// 首先，函数会调用ssc.getStatefulSetsForPod(pod)方法来获取与Pod匹配的所有StatefulSet集合。
// 如果这个集合的长度为0，说明没有找到匹配的控制器，那么函数直接返回。
// 否则，函数会使用logger记录一条日志信息，以4级日志级别记录“创建了一个孤儿Pod，并列出了Pod的标签”。
// 然后，函数会遍历这个匹配的StatefulSet集合，对每个集合调用ssc.enqueueStatefulSet(set)方法，将其加入到同步队列中，以便后续进行同步处理。
// updatePod adds the statefulset for the current and old pods to the sync queue.
func (ssc *StatefulSetController) updatePod(logger klog.Logger, old, cur interface{}) {
	curPod := cur.(*v1.Pod)
	oldPod := old.(*v1.Pod)
	if curPod.ResourceVersion == oldPod.ResourceVersion {
		// In the event of a re-list we may receive update events for all known pods.
		// Two different versions of the same pod will always have different RVs.
		return
	}

	labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels)

	curControllerRef := metav1.GetControllerOf(curPod)
	oldControllerRef := metav1.GetControllerOf(oldPod)
	controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)
	if controllerRefChanged && oldControllerRef != nil {
		// The ControllerRef was changed. Sync the old controller, if any.
		if set := ssc.resolveControllerRef(oldPod.Namespace, oldControllerRef); set != nil {
			ssc.enqueueStatefulSet(set)
		}
	}
	//该函数用于将当前和旧的Pod的状态fulset添加到同步队列中。
	//函数首先将传入的old和cur参数转换为v1.Pod类型，并检查它们的ResourceVersion是否相同。
	//如果相同，则表示这是由于重新列表而导致的更新事件，函数将直接返回。
	//然后，函数会检查Pod的标签是否发生变化，并检查ControllerRef是否发生变化。
	//如果ControllerRef发生变化且旧的ControllerRef不为空，则函数将解析旧的ControllerRef，并将对应的StatefulSet添加到同步队列中。
	// If it has a ControllerRef, that&#39;s all that matters.
	if curControllerRef != nil {
		set := ssc.resolveControllerRef(curPod.Namespace, curControllerRef)
		if set == nil {
			return
		}
		logger.V(4).Info("Pod objectMeta updated", "pod", klog.KObj(curPod), "oldObjectMeta", oldPod.ObjectMeta, "newObjectMeta", curPod.ObjectMeta)
		ssc.enqueueStatefulSet(set)
		// TODO: MinReadySeconds in the Pod will generate an Available condition to be added in
		// the Pod status which in turn will trigger a requeue of the owning replica set thus
		// having its status updated with the newly available replica.
		if !podutil.IsPodReady(oldPod) && podutil.IsPodReady(curPod) && set.Spec.MinReadySeconds > 0 {
			logger.V(2).Info("StatefulSet will be enqueued after minReadySeconds for availability check", "statefulSet", klog.KObj(set), "minReadySeconds", set.Spec.MinReadySeconds)
			// Add a second to avoid milliseconds skew in AddAfter.
			// See https://github.com/kubernetes/kubernetes/issues/39785#issuecomment-279959133 for more info.
			ssc.enqueueSSAfter(set, (time.Duration(set.Spec.MinReadySeconds)*time.Second)+time.Second)
		}
		return
	}
	//该Go函数是一个处理Pod对象元数据更新的函数。
	//它首先检查当前Pod是否有ControllerRef，如果有，则通过resolveControllerRef方法解析其引用的Controller，并将其加入到队列中以进行后续处理。
	//如果Pod满足特定条件（例如，从不可用状态变为可用状态，并且其所属的StatefulSet的MinReadySeconds大于0），
	//则会将StatefulSet加入到队列中， 以便在MinReadySeconds秒后进行可用性检查。
	// Otherwise, it&#39;s an orphan. If anything changed, sync matching controllers
	// to see if anyone wants to adopt it now.
	if labelChanged || controllerRefChanged {
		sets := ssc.getStatefulSetsForPod(curPod)
		if len(sets) == 0 {
			return
		}
		logger.V(4).Info("Orphan Pod objectMeta updated", "pod", klog.KObj(curPod), "oldObjectMeta", oldPod.ObjectMeta, "newObjectMeta", curPod.ObjectMeta)
		for _, set := range sets {
			ssc.enqueueStatefulSet(set)
		}
	}
}

// 这段Go代码是处理Pod对象的元数据更新的逻辑。
// 如果Pod的标签或控制器引用发生了变化，它会检查是否有StatefulSet控制器可以“收养”这个Pod。
// 如果有，则将这个StatefulSet控制器加入到队列中，以便进一步处理。
// deletePod enqueues the statefulset for the pod accounting for deletion tombstones.
func (ssc *StatefulSetController) deletePod(logger klog.Logger, obj interface{}) {
	pod, ok := obj.(*v1.Pod)

	// When a delete is dropped, the relist will notice a pod in the store not
	// in the list, leading to the insertion of a tombstone object which contains
	// the deleted key/value. Note that this value might be stale.
	if !ok {
		tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
		if !ok {
			utilruntime.HandleError(fmt.Errorf("couldn&#39;t get object from tombstone %+v", obj))
			return
		}
		pod, ok = tombstone.Obj.(*v1.Pod)
		if !ok {
			utilruntime.HandleError(fmt.Errorf("tombstone contained object that is not a pod %+v", obj))
			return
		}
	}
	//该函数是一个Go语言函数，名为deletePod，它属于StatefulSetController类型。
	//该函数的功能是将删除操作对应的状态fulset加入到队列中，并考虑到删除标记（tombstones）。
	//函数参数： - logger：klog.Logger类型，用于记录日志。
	//- obj：interface{}类型，表示要删除的Pod对象。
	//函数流程： 1. 尝试将obj对象转换为*v1.Pod类型。
	//2. 如果转换失败，则尝试将obj对象转换为cache.DeletedFinalStateUnknown类型。
	//3. 如果转换成功，则从tombstone对象中获取被删除的Pod对象。
	//4. 如果获取失败，则记录错误信息并返回。
	//5. 如果成功获取到Pod对象，则将其加入到队列中，以供后续处理。
	//该函数主要处理了两种情况：直接删除Pod对象和通过tombstone对象删除Pod。
	//在处理过程中，函数会进行类型断言来确保对象类型正确，并在出现异常时记录错误信息。
	controllerRef := metav1.GetControllerOf(pod)
	if controllerRef == nil {
		// No controller should care about orphans being deleted.
		return
	}
	set := ssc.resolveControllerRef(pod.Namespace, controllerRef)
	if set == nil {
		return
	}
	logger.V(4).Info("Pod deleted.", "pod", klog.KObj(pod), "caller", utilruntime.GetCaller())
	ssc.enqueueStatefulSet(set)
}

// 该函数是一个Go语言函数，名为deletePod，它属于StatefulSetController类型。
// 该函数的功能是在删除Pod时，检查是否有对应的控制器（StatefulSet）对该Pod有管理关系，
// 如果有，则将该StatefulSet加入到队列中，以触发相应的更新操作。
// 函数流程：
// 1. 通过metav1.GetControllerOf函数获取Pod的控制器引用（controllerRef）。
// 2. 如果controllerRef为nil，表示该Pod没有对应的控制器，则直接返回。
// 3. 调用ssc.resolveControllerRef函数解析controllerRef，获取对应的StatefulSet对象（set）。
// 4. 如果set为nil，表示无法解析到对应的StatefulSet，则直接返回。
// 5. 记录日志信息，表示Pod已被删除。
// 6. 将set加入到队列中，以触发StatefulSet的更新操作。
// 该函数主要通过controllerRef来确定Pod所属的StatefulSet，并在删除Pod时，通知对应的StatefulSet进行相应的更新操作。
// 如果无法确定Pod的控制器或者无法解析到对应的StatefulSet，则函数直接返回，不做任何处理。
// getPodsForStatefulSet returns the Pods that a given StatefulSet should manage.
// It also reconciles ControllerRef by adopting/orphaning.
//
// NOTE: Returned Pods are pointers to objects from the cache.
// If you need to modify one, you need to copy it first.
func (ssc *StatefulSetController) getPodsForStatefulSet(ctx context.Context, set *apps.StatefulSet, selector labels.Selector) ([]*v1.Pod, error) {
	// List all pods to include the pods that don&#39;t match the selector anymore but
	// has a ControllerRef pointing to this StatefulSet.
	pods, err := ssc.podLister.Pods(set.Namespace).List(labels.Everything())
	if err != nil {
		return nil, err
	}

	filter := func(pod *v1.Pod) bool {
		// Only claim if it matches our StatefulSet name. Otherwise release/ignore.
		return isMemberOf(set, pod)
	}

	cm := controller.NewPodControllerRefManager(ssc.podControl, set, selector, controllerKind, ssc.canAdoptFunc(ctx, set))
	return cm.ClaimPods(ctx, pods, filter)
}

// 该函数用于获取指定StatefulSet应该管理的Pods，并通过adopting/orphaning来协调ControllerRef。
// 函数首先从缓存中列出所有Pods，包括不再匹配选择器但具有指向该StatefulSet的ControllerRef的Pods。
// 然后通过isMemberOf函数筛选出属于该StatefulSet的Pods。
// 最后，使用PodControllerRefManager的ClaimPods方法来处理ControllerRef的采用/孤儿化，并返回属于该StatefulSet的Pods的指针。
// 注意：返回的Pods是来自缓存的对象指针，如果需要修改，则需要先复制。
// If any adoptions are attempted, we should first recheck for deletion with
// an uncached quorum read sometime after listing Pods/ControllerRevisions (see #42639).
func (ssc *StatefulSetController) canAdoptFunc(ctx context.Context, set *apps.StatefulSet) func(ctx2 context.Context) error {
	return controller.RecheckDeletionTimestamp(func(ctx context.Context) (metav1.Object, error) {
		fresh, err := ssc.kubeClient.AppsV1().StatefulSets(set.Namespace).Get(ctx, set.Name, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		if fresh.UID != set.UID {
			return nil, fmt.Errorf("original StatefulSet %v/%v is gone: got uid %v, wanted %v", set.Namespace, set.Name, fresh.UID, set.UID)
		}
		return fresh, nil
	})
}

// 该函数是一个生成函数，返回一个函数，用于检查是否有资格收养（adopt）某个StatefulSet。
// 收养的条件是：在尝试收养之后，需要再次使用未缓存的多数读取（uncached quorum read）检查该StatefulSet是否已被删除。
// 函数内部通过调用ssc.kubeClient.AppsV1().StatefulSets(set.Namespace).Get()来获取最新的StatefulSet信息，并与原有信息进行对比，
// 如果UID一致，则返回最新的StatefulSet对象；否则返回错误信息。
// adoptOrphanRevisions adopts any orphaned ControllerRevisions matched by set&#39;s Selector.
func (ssc *StatefulSetController) adoptOrphanRevisions(ctx context.Context, set *apps.StatefulSet) error {
	revisions, err := ssc.control.ListRevisions(set)
	if err != nil {
		return err
	}
	orphanRevisions := make([]*apps.ControllerRevision, 0)
	for i := range revisions {
		if metav1.GetControllerOf(revisions[i]) == nil {
			orphanRevisions = append(orphanRevisions, revisions[i])
		}
	}
	if len(orphanRevisions) > 0 {
		canAdoptErr := ssc.canAdoptFunc(ctx, set)(ctx)
		if canAdoptErr != nil {
			return fmt.Errorf("can&#39;t adopt ControllerRevisions: %v", canAdoptErr)
		}
		return ssc.control.AdoptOrphanRevisions(set, orphanRevisions)
	}
	return nil
}

// 该函数用于收养被控制器创建但没有被任何StatefulSet认领的ControllerRevision对象。具体流程如下：
// 1. 调用ssc.control.ListRevisions(set)获取与给定StatefulSet相关联的所有ControllerRevision对象。
// 2. 遍历所有ControllerRevision对象，如果其metav1.GetControllerOf字段为空，则将其加入orphanRevisions列表。
// 3. 如果orphanRevisions列表非空，则调用ssc.canAdoptFunc(ctx, set)(ctx)判断是否可以收养这些孤儿Revision。
// 4. 如果可以收养，则调用ssc.control.AdoptOrphanRevisions(set, orphanRevisions)进行收养操作。
// 5. 如果收养过程中出现错误，则返回错误信息；否则返回nil表示成功。
// getStatefulSetsForPod returns a list of StatefulSets that potentially match
// a given pod.
func (ssc *StatefulSetController) getStatefulSetsForPod(pod *v1.Pod) []*apps.StatefulSet {
	sets, err := ssc.setLister.GetPodStatefulSets(pod)
	if err != nil {
		return nil
	}
	// More than one set is selecting the same Pod
	if len(sets) > 1 {
		// ControllerRef will ensure we don&#39;t do anything crazy, but more than one
		// item in this list nevertheless constitutes user error.
		setNames := []string{}
		for _, s := range sets {
			setNames = append(setNames, s.Name)
		}
		utilruntime.HandleError(
			fmt.Errorf(
				"user error: more than one StatefulSet is selecting pods with labels: %+v. Sets: %v",
				pod.Labels, setNames))
	}
	return sets
}

// 该函数用于获取与给定Pod相匹配的所有StatefulSet列表。
// - 首先，函数通过调用ssc.setLister.GetPodStatefulSets(pod)方法获取选择该Pod的所有StatefulSet。
// - 如果获取过程中出现错误，则直接返回nil。
// - 如果存在多个StatefulSet选择同一个Pod（即sets长度大于1），则将其视为用户错误。
// 函数会记录错误信息，并返回所有匹配的StatefulSet列表。
// 注意：在存在多个StatefulSet选择同一个Pod时，通过ControllerRef可以确保不会发生疯狂的行为。
// 但是多个StatefulSet出现在列表中仍然被认为是用户错误。
// resolveControllerRef returns the controller referenced by a ControllerRef,
// or nil if the ControllerRef could not be resolved to a matching controller
// of the correct Kind.
func (ssc *StatefulSetController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *apps.StatefulSet {
	// We can&#39;t look up by UID, so look up by Name and then verify UID.
	// Don&#39;t even try to look up by Name if it&#39;s the wrong Kind.
	if controllerRef.Kind != controllerKind.Kind {
		return nil
	}
	set, err := ssc.setLister.StatefulSets(namespace).Get(controllerRef.Name)
	if err != nil {
		return nil
	}
	if set.UID != controllerRef.UID {
		// The controller we found with this Name is not the same one that the
		// ControllerRef points to.
		return nil
	}
	return set
}

// 该函数用于解析ControllerRef引用的控制器，如果引用无法解析为正确的类型，则返回nil。
// 具体步骤如下： 1. 检查controllerRef的类型是否与期望的类型相匹配，如果不匹配则直接返回nil。
// 2. 通过名称查找StatefulSet控制器，如果查找失败则返回nil。
// 3. 验证找到的StatefulSet控制器的UID是否与controllerRef的UID相同，如果不同则返回nil。
// 4. 如果以上验证都通过，则返回找到的StatefulSet控制器。
// enqueueStatefulSet enqueues the given statefulset in the work queue.
func (ssc *StatefulSetController) enqueueStatefulSet(obj interface{}) {
	key, err := controller.KeyFunc(obj)
	if err != nil {
		utilruntime.HandleError(fmt.Errorf("couldn&#39;t get key for object %+v: %v", obj, err))
		return
	}
	ssc.queue.Add(key)
}

// 该函数用于将给定的状态fulset对象加入工作队列中。
// 函数首先通过controller.KeyFunc方法获取对象的键值，如果获取失败，则通过utilruntime.HandleError方法记录错误信息并返回。
// 最后，将获取到的键值加入到ssc.queue队列中。
// enqueueStatefulSet enqueues the given statefulset in the work queue after given time
func (ssc *StatefulSetController) enqueueSSAfter(ss *apps.StatefulSet, duration time.Duration) {
	key, err := controller.KeyFunc(ss)
	if err != nil {
		utilruntime.HandleError(fmt.Errorf("couldn&#39;t get key for object %#v: %v", ss, err))
		return
	}
	ssc.queue.AddAfter(key, duration)
}

// 该函数将给定的状态集（StatefulSet）在指定时间后加入到工作队列中。
// 首先，函数通过调用controller.KeyFunc(ss)方法获取状态集的键值。
// 如果获取键值时出现错误，则使用utilruntime.HandleError()方法处理错误并返回。
// 最后，将键值和指定时间间隔添加到ssc.queue队列中，以便后续处理。
// processNextWorkItem dequeues items, processes them, and marks them done. It enforces that the syncHandler is never
// invoked concurrently with the same key.
func (ssc *StatefulSetController) processNextWorkItem(ctx context.Context) bool {
	key, quit := ssc.queue.Get()
	if quit {
		return false
	}
	defer ssc.queue.Done(key)
	if err := ssc.sync(ctx, key.(string)); err != nil {
		utilruntime.HandleError(fmt.Errorf("error syncing StatefulSet %v, requeuing: %v", key.(string), err))
		ssc.queue.AddRateLimited(key)
	} else {
		ssc.queue.Forget(key)
	}
	return true
}

// 该函数是一个处理工作项的函数，它从队列中获取工作项，处理它，并将其标记为完成。
// 它确保同步处理程序永远不会使用相同的键并发执行。
// 函数返回一个布尔值，表示是否继续处理下一个工作项。
// worker runs a worker goroutine that invokes processNextWorkItem until the controller&#39;s queue is closed
func (ssc *StatefulSetController) worker(ctx context.Context) {
	for ssc.processNextWorkItem(ctx) {
	}
}

// 该函数是一个goroutine，用于不断调用processNextWorkItem处理工作项，直到控制器的队列关闭。
// sync syncs the given statefulset.
func (ssc *StatefulSetController) sync(ctx context.Context, key string) error {
	startTime := time.Now()
	logger := klog.FromContext(ctx)
	defer func() {
		logger.V(4).Info("Finished syncing statefulset", "key", key, "time", time.Since(startTime))
	}()

	namespace, name, err := cache.SplitMetaNamespaceKey(key)
	//该函数是一个Go语言函数，它定义在名为StatefulSetController的结构体中，使用sync作为函数名。
	//该函数接收两个参数：ctx context.Context和key string，并返回一个error类型的值。
	//函数主要功能如下：
	//1. 记录开始时间：在函数开始处，通过调用time.Now()记录当前时间，用于后续计算函数执行时间。
	//2. 获取日志记录器：通过从传入的ctx参数中获取日志记录器，用于记录函数执行的日志信息。
	//3. 延迟执行日志记录：使用defer关键字定义延迟执行的函数，该函数会在函数返回前执行。
	//延迟函数主要记录函数执行结束时间，并通过日志记录器记录函数执行时间及关键参数信息。
	//4. 分解键值：通过调用cache.SplitMetaNamespaceKey(key)函数，将传入的键值key分解为命名空间namespace和名称name两个部分。
	//整体而言，该函数的主要作用是同步处理某个键值对应的StatefulSet对象，具体处理逻辑在该函数的后续代码中实现。
	//该函数通过记录函数执行时间、获取日志记录器以及分解键值等操作，为后续处理提供了必要信息。
	if err != nil {
		return err
	}
	set, err := ssc.setLister.StatefulSets(namespace).Get(name)
	//该函数主要执行以下操作：
	//1. 检查err是否为nil，如果不为nil，则直接返回错误。
	//2. 调用ssc.setLister.StatefulSets(namespace).Get(name)获取指定命名空间中的状态集，并将其赋值给set变量。
	//3. 返回set和err，其中set为获取的状态集，err为执行过程中可能出现的错误。
	if errors.IsNotFound(err) {
		logger.Info("StatefulSet has been deleted", "key", key)
		return nil
	}
	//这段Go代码主要进行错误判断和日志记录。具体功能如下：
	//- 首先，它检查错误变量err是否为NotFound错误（即该错误表示某个资源未找到）。
	//- 如果是NotFound错误，它会通过logger.Info方法记录一条日志信息，指示某个StatefulSet已被删除，同时在日志中包含key参数的值。
	//- 最后，函数返回nil，表示处理完成且无需进一步处理。
	//这段代码的作用是在遇到特定类型的错误时，记录一条相关日志信息，并终止进一步的错误处理流程。
	if err != nil {
		utilruntime.HandleError(fmt.Errorf("unable to retrieve StatefulSet %v from store: %v", key, err))
		return err
	}
	//这段Go代码是一个错误处理的示例。
	//如果变量err不为nil，则会使用utilruntime.HandleError()函数处理错误，
	//该函数会将一个格式化后的错误信息打印出来。然后函数会返回err。这段代码的作用是在发生错误时记录错误信息并返回错误。
	selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)
	if err != nil {
		utilruntime.HandleError(fmt.Errorf("error converting StatefulSet %v selector: %v", key, err))
		// This is a non-transient error, so don&#39;t retry.
		return nil
	}
	//这段Go代码主要实现了将StatefulSet的标签选择器转换为Selector的功能。
	//具体来说，它首先通过metav1.LabelSelectorAsSelector函数将set.Spec.Selector转换为Selector类型，
	//如果转换过程中出现错误，则通过utilruntime.HandleError函数记录错误信息，并返回nil。
	//需要注意的是，这里的错误被认为是非瞬时错误，因此不会进行重试。
	if err := ssc.adoptOrphanRevisions(ctx, set); err != nil {
		return err
	}
	//这个函数调用了ssc.adoptOrphanRevisions方法，该方法的作用是在给定的上下文ctx中采用孤儿修订版本。如果方法执行出错，则会返回错误信息err。
	pods, err := ssc.getPodsForStatefulSet(ctx, set, selector)
	if err != nil {
		return err
	}
	//该函数尝试通过调用ssc.getPodsForStatefulSet方法获取与指定StatefulSet和选择器相关联的Pods。如果获取过程中出现错误，则将错误返回。
	return ssc.syncStatefulSet(ctx, set, pods)
	//该函数是Go语言编写的，用于同步更新StatefulSet（有状态副本集）的状态。
	//- ctx是一个上下文对象，用于控制函数执行的生命周期。
	//- set是一个StatefulSet对象，表示要更新的有状态副本集。
	//- pods是一个Pod对象的列表，表示有状态副本集中的Pods。
	//函数内部会根据传入的有状态副本集和Pods对象，进行一系列操作来更新副本集的状态，使其与实际的Pods状态保持一致。具体操作细节可以根据函数实现来确定。
}

// syncStatefulSet syncs a tuple of (statefulset, []*v1.Pod).
func (ssc *StatefulSetController) syncStatefulSet(ctx context.Context, set *apps.StatefulSet, pods []*v1.Pod) error {
	logger := klog.FromContext(ctx)
	logger.V(4).Info("Syncing StatefulSet with pods", "statefulSet", klog.KObj(set), "pods", len(pods))
	var status *apps.StatefulSetStatus
	var err error
	status, err = ssc.control.UpdateStatefulSet(ctx, set, pods)
	if err != nil {
		return err
	}
	logger.V(4).Info("Successfully synced StatefulSet", "statefulSet", klog.KObj(set))
	// One more sync to handle the clock skew. This is also helping in requeuing right after status update
	if set.Spec.MinReadySeconds > 0 && status != nil && status.AvailableReplicas != *set.Spec.Replicas {
		ssc.enqueueSSAfter(set, time.Duration(set.Spec.MinReadySeconds)*time.Second)
	}

	return nil
}

//该函数是一个用于同步StatefulSet和其关联Pods的函数。
//它通过调用ssc.control.UpdateStatefulSet方法来更新StatefulSet的状态，
//并在更新完成后进行额外的同步操作来处理时钟偏移。
//如果StatefulSet的MinReadySeconds大于0，并且更新后的状态的AvailableReplicas与Spec.Replicas不相等，则会重新排队等待处理。
'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2024-04-10 K8S控制器之stateful_set.go源码解读"><meta property="og:description" content='/* Copyright 2016 The Kubernetes Authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ package statefulset import ( "context" "fmt" "reflect" "time" apps "k8s.io/api/apps/v1" v1 "k8s.io/api/core/v1" "k8s.io/apimachinery/pkg/api/errors" metav1 "k8s.io/apimachinery/pkg/apis/meta/v1" "k8s.io/apimachinery/pkg/labels" utilruntime "k8s.io/apimachinery/pkg/util/runtime" "k8s.io/apimachinery/pkg/util/wait" appsinformers "k8s.io/client-go/informers/apps/v1" coreinformers "k8s.io/client-go/informers/core/v1" clientset "k8s.io/client-go/kubernetes" "k8s.io/client-go/kubernetes/scheme" v1core "k8s.io/client-go/kubernetes/typed/core/v1" appslisters "k8s.io/client-go/listers/apps/v1" corelisters "k8s.io/client-go/listers/core/v1" "k8s.io/client-go/tools/cache" "k8s.io/client-go/tools/record" "k8s.io/client-go/util/workqueue" podutil "k8s.io/kubernetes/pkg/api/v1/pod" "k8s.io/kubernetes/pkg/controller" "k8s.io/kubernetes/pkg/controller/history" ) // controllerKind contains the schema.GroupVersionKind for this controller type. var controllerKind = apps.SchemeGroupVersion.WithKind("StatefulSet") // StatefulSetController controls statefulsets. type StatefulSetController struct { // client interface kubeClient clientset.Interface // control returns an interface capable of syncing a stateful set. // Abstracted out for testing. control StatefulSetControlInterface // podControl is used for patching pods. podControl controller.PodControlInterface // podLister is able to list/get pods from a shared informer&#39;s store podLister corelisters.PodLister // podListerSynced returns true if the pod shared informer has synced at least once podListerSynced cache.InformerSynced // setLister is able to list/get stateful sets from a shared informer&#39;s store setLister appslisters.StatefulSetLister // setListerSynced returns true if the stateful set shared informer has synced at least once setListerSynced cache.InformerSynced // pvcListerSynced returns true if the pvc shared informer has synced at least once pvcListerSynced cache.InformerSynced // revListerSynced returns true if the rev shared informer has synced at least once revListerSynced cache.InformerSynced // StatefulSets that need to be synced. queue workqueue.RateLimitingInterface // eventBroadcaster is the core of event processing pipeline. eventBroadcaster record.EventBroadcaster } // 这段Go代码定义了一个名为StatefulSetController的结构体，用于控制StatefulSets。 // 它包含了一系列的成员变量，包括client接口、控制StatefulSet同步的接口、用于patching pods的接口、以及一系列的Lister和Synced函数， // 用于从共享informer的存储中获取Pods、StatefulSets、PVCs等信息。 // 此外，它还定义了一个工作队列和一个事件广播器。这个结构体主要用于管理和同步Kubernetes中的StatefulSets。 // NewStatefulSetController creates a new statefulset controller. func NewStatefulSetController( ctx context.Context, podInformer coreinformers.PodInformer, setInformer appsinformers.StatefulSetInformer, pvcInformer coreinformers.PersistentVolumeClaimInformer, revInformer appsinformers.ControllerRevisionInformer, kubeClient clientset.Interface, ) *StatefulSetController { logger := klog.FromContext(ctx) eventBroadcaster := record.NewBroadcaster(record.WithContext(ctx)) recorder := eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: "statefulset-controller"}) ssc := &amp;StatefulSetController{ kubeClient: kubeClient, control: NewDefaultStatefulSetControl( NewStatefulPodControl( kubeClient, podInformer.Lister(), pvcInformer.Lister(), recorder), NewRealStatefulSetStatusUpdater(kubeClient, setInformer.Lister()), history.NewHistory(kubeClient, revInformer.Lister()), recorder, ), pvcListerSynced: pvcInformer.Informer().HasSynced, revListerSynced: revInformer.Informer().HasSynced, queue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "statefulset"), podControl: controller.RealPodControl{KubeClient: kubeClient, Recorder: recorder}, eventBroadcaster: eventBroadcaster, } //该函数用于创建一个新的StatefulSet控制器。它接收多个参数，包括上下文、各种Informer、客户端接口等。 //函数内部通过调用NewDefaultStatefulSetControl函数和其他函数，初始化了StatefulSetController结构体的各个字段， //并返回一个指向StatefulSetController结构体的指针。 podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{ // lookup the statefulset and enqueue AddFunc: func(obj interface{}) { ssc.addPod(logger, obj) }, // lookup current and old statefulset if labels changed UpdateFunc: func(oldObj, newObj interface{}) { ssc.updatePod(logger, oldObj, newObj) }, // lookup statefulset accounting for deletion tombstones DeleteFunc: func(obj interface{}) { ssc.deletePod(logger, obj) }, }) //这段代码定义了一个Go函数，它为podInformer的Informer添加了一个事件处理程序。 //该事件处理程序使用cache.ResourceEventHandlerFuncs结构体中的AddFunc、UpdateFunc和DeleteFunc来处理资源的添加、更新和删除事件。 //- AddFunc函数在资源添加时调用ssc.addPod(logger, obj)来添加Pod。 //- UpdateFunc函数在资源更新时调用ssc.updatePod(logger, oldObj, newObj)来更新Pod。 //- DeleteFunc函数在资源删除时调用ssc.deletePod(logger, obj)来删除Pod。 //这些函数通过传入的logger和相应的资源对象来执行具体的操作。 ssc.podLister = podInformer.Lister() ssc.podListerSynced = podInformer.Informer().HasSynced setInformer.Informer().AddEventHandler( cache.ResourceEventHandlerFuncs{ AddFunc: ssc.enqueueStatefulSet, UpdateFunc: func(old, cur interface{}) { oldPS := old.(*apps.StatefulSet) curPS := cur.(*apps.StatefulSet) if oldPS.Status.Replicas != curPS.Status.Replicas { logger.V(4).Info("Observed updated replica count for StatefulSet", "statefulSet", klog.KObj(curPS), "oldReplicas", oldPS.Status.Replicas, "newReplicas", curPS.Status.Replicas) } ssc.enqueueStatefulSet(cur) }, DeleteFunc: ssc.enqueueStatefulSet, }, ) //这段代码主要涉及到了Kubernetes Informer机制的使用，用于监听StatefulSet资源的变化，并对变化事件进行处理。 //1. 首先，ssc.podLister = podInformer.Lister()和ssc.podListerSynced = podInformer.Informer().HasSynced //两行代码是将pod的Lister和是否同步完成的函数赋值给ssc对象的对应字段。Lister是用来从Informer的cache中获取资源列表和单个资源的， //HasSynced则是用来判断Informer是否已经完成初始的资源同步。 //2. 接下来，setInformer.Informer().AddEventHandler(...)这行代码是给setInformer添加了一个事件处理函数。 //其中，cache.ResourceEventHandlerFuncs是一个包含了资源添加、更新和删除事件处理函数的结构体。 //- AddFunc: ssc.enqueueStatefulSet表示当有StatefulSet资源被添加时，调用ssc.enqueueStatefulSet函数来处理该事件。 //- UpdateFunc表示当有StatefulSet资源被更新时，会先判断其副本数是否发生了变化，如果有变化则打印日志并调用ssc.enqueueStatefulSet函数来处理该事件。 //- DeleteFunc: ssc.enqueueStatefulSet表示当有StatefulSet资源被删除时，调用ssc.enqueueStatefulSet函数来处理该事件。 //综上所述，这段代码通过使用Kubernetes Informer机制监听StatefulSet资源的变化，并调用ssc.enqueueStatefulSet函数来处理这些变化事件。 ssc.setLister = setInformer.Lister() ssc.setListerSynced = setInformer.Informer().HasSynced // TODO: Watch volumes return ssc } // 这个Go函数主要设置了ssc对象的setLister和setListerSynced属性。 // setLister是通过setInformer.Lister()方法设置的，它用于从存储中获取设置列表。setListerSynced是通过setInformer.Informer().HasSynced方法设置的， // 它用于检查设置的同步状态。最后，该函数返回ssc对象。 // Run runs the statefulset controller. func (ssc *StatefulSetController) Run(ctx context.Context, workers int) { defer utilruntime.HandleCrash() // Start events processing pipeline. ssc.eventBroadcaster.StartStructuredLogging(3) ssc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: ssc.kubeClient.CoreV1().Events("")}) defer ssc.eventBroadcaster.Shutdown() defer ssc.queue.ShutDown() logger := klog.FromContext(ctx) logger.Info("Starting stateful set controller") defer logger.Info("Shutting down statefulset controller") //该函数是StatefulSetController类型的Run方法，用于启动statefulset控制器。 //函数首先处理崩溃情况，然后开启事件处理管道，记录事件并将其发送到事件接收器。 //之后，函数通过调用queue的ShutDown方法来关闭队列。函数在启动和关闭控制器时分别记录日志信息。 if !cache.WaitForNamedCacheSync("stateful set", ctx.Done(), ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) { return } for i := 0; i < workers; i++ { go wait.UntilWithContext(ctx, ssc.worker, time.Second) } <-ctx.Done() } // 这段Go代码主要实现了以下功能： // - 等待多个缓存同步完成：通过调用cache.WaitForNamedCacheSync方法， // 等待podListerSynced、setListerSynced、pvcListerSynced和revListerSynced四个缓存同步完成。 // 如果在指定的上下文ctx被取消或超时之前，所有缓存都已同步，则继续执行后续代码；否则直接返回。 // - 启动多个工作协程：使用for循环和go关键字，启动workers个工作协程，并在每个协程中定期执行ssc.worker函数，其间隔时间为1秒。 // 这些工作协程会一直运行，直到上下文ctx被取消或超时。 // - 等待上下文取消或超时：通过读取ctx.Done()通道，阻塞当前协程，等待上下文ctx被取消或超时。 // 一旦上下文被取消或超时，整个函数执行结束。 这段代码通常用于在启动时等待多个缓存同步完成，并启动多个工作协程来处理后续任务。 // 通过上下文ctx来控制整个函数的运行时长，并能够在缓存同步或工作协程运行过程中随时取消操作。 // addPod adds the statefulset for the pod to the sync queue func (ssc *StatefulSetController) addPod(logger klog.Logger, obj interface{}) { pod := obj.(*v1.Pod) if pod.DeletionTimestamp != nil { // on a restart of the controller manager, it&#39;s possible a new pod shows up in a state that // is already pending deletion. Prevent the pod from being a creation observation. ssc.deletePod(logger, pod) return } // If it has a ControllerRef, that&#39;s all that matters. if controllerRef := metav1.GetControllerOf(pod); controllerRef != nil { set := ssc.resolveControllerRef(pod.Namespace, controllerRef) if set == nil { return } logger.V(4).Info("Pod created with labels", "pod", klog.KObj(pod), "labels", pod.Labels) ssc.enqueueStatefulSet(set) return } //该函数是StatefulSetController类型的一个方法，用于将Pod的状态添加到同步队列中。 //首先，它检查Pod是否已被标记为删除，如果是，则调用deletePod方法删除Pod，并返回。 //然后，它检查Pod是否有ControllerRef，如果有，则通过resolveControllerRef方法解析ControllerRef， //并将解析结果传递给enqueueStatefulSet方法，以将StatefulSet添加到同步队列中。 // Otherwise, it&#39;s an orphan. Get a list of all matching controllers and sync // them to see if anyone wants to adopt it. sets := ssc.getStatefulSetsForPod(pod) if len(sets) == 0 { return } logger.V(4).Info("Orphan Pod created with labels", "pod", klog.KObj(pod), "labels", pod.Labels) for _, set := range sets { ssc.enqueueStatefulSet(set) } } // 该函数用于处理一个无归属的Pod（孤儿Pod），通过获取与该Pod匹配的所有StatefulSet控制器，并将它们同步，以查看是否有控制器愿意“收养”这个Pod。 // 首先，函数会调用ssc.getStatefulSetsForPod(pod)方法来获取与Pod匹配的所有StatefulSet集合。 // 如果这个集合的长度为0，说明没有找到匹配的控制器，那么函数直接返回。 // 否则，函数会使用logger记录一条日志信息，以4级日志级别记录“创建了一个孤儿Pod，并列出了Pod的标签”。 // 然后，函数会遍历这个匹配的StatefulSet集合，对每个集合调用ssc.enqueueStatefulSet(set)方法，将其加入到同步队列中，以便后续进行同步处理。 // updatePod adds the statefulset for the current and old pods to the sync queue. func (ssc *StatefulSetController) updatePod(logger klog.Logger, old, cur interface{}) { curPod := cur.(*v1.Pod) oldPod := old.(*v1.Pod) if curPod.ResourceVersion == oldPod.ResourceVersion { // In the event of a re-list we may receive update events for all known pods. // Two different versions of the same pod will always have different RVs. return } labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels) curControllerRef := metav1.GetControllerOf(curPod) oldControllerRef := metav1.GetControllerOf(oldPod) controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef) if controllerRefChanged && oldControllerRef != nil { // The ControllerRef was changed. Sync the old controller, if any. if set := ssc.resolveControllerRef(oldPod.Namespace, oldControllerRef); set != nil { ssc.enqueueStatefulSet(set) } } //该函数用于将当前和旧的Pod的状态fulset添加到同步队列中。 //函数首先将传入的old和cur参数转换为v1.Pod类型，并检查它们的ResourceVersion是否相同。 //如果相同，则表示这是由于重新列表而导致的更新事件，函数将直接返回。 //然后，函数会检查Pod的标签是否发生变化，并检查ControllerRef是否发生变化。 //如果ControllerRef发生变化且旧的ControllerRef不为空，则函数将解析旧的ControllerRef，并将对应的StatefulSet添加到同步队列中。 // If it has a ControllerRef, that&#39;s all that matters. if curControllerRef != nil { set := ssc.resolveControllerRef(curPod.Namespace, curControllerRef) if set == nil { return } logger.V(4).Info("Pod objectMeta updated", "pod", klog.KObj(curPod), "oldObjectMeta", oldPod.ObjectMeta, "newObjectMeta", curPod.ObjectMeta) ssc.enqueueStatefulSet(set) // TODO: MinReadySeconds in the Pod will generate an Available condition to be added in // the Pod status which in turn will trigger a requeue of the owning replica set thus // having its status updated with the newly available replica. if !podutil.IsPodReady(oldPod) && podutil.IsPodReady(curPod) && set.Spec.MinReadySeconds > 0 { logger.V(2).Info("StatefulSet will be enqueued after minReadySeconds for availability check", "statefulSet", klog.KObj(set), "minReadySeconds", set.Spec.MinReadySeconds) // Add a second to avoid milliseconds skew in AddAfter. // See https://github.com/kubernetes/kubernetes/issues/39785#issuecomment-279959133 for more info. ssc.enqueueSSAfter(set, (time.Duration(set.Spec.MinReadySeconds)*time.Second)+time.Second) } return } //该Go函数是一个处理Pod对象元数据更新的函数。 //它首先检查当前Pod是否有ControllerRef，如果有，则通过resolveControllerRef方法解析其引用的Controller，并将其加入到队列中以进行后续处理。 //如果Pod满足特定条件（例如，从不可用状态变为可用状态，并且其所属的StatefulSet的MinReadySeconds大于0）， //则会将StatefulSet加入到队列中， 以便在MinReadySeconds秒后进行可用性检查。 // Otherwise, it&#39;s an orphan. If anything changed, sync matching controllers // to see if anyone wants to adopt it now. if labelChanged || controllerRefChanged { sets := ssc.getStatefulSetsForPod(curPod) if len(sets) == 0 { return } logger.V(4).Info("Orphan Pod objectMeta updated", "pod", klog.KObj(curPod), "oldObjectMeta", oldPod.ObjectMeta, "newObjectMeta", curPod.ObjectMeta) for _, set := range sets { ssc.enqueueStatefulSet(set) } } } // 这段Go代码是处理Pod对象的元数据更新的逻辑。 // 如果Pod的标签或控制器引用发生了变化，它会检查是否有StatefulSet控制器可以“收养”这个Pod。 // 如果有，则将这个StatefulSet控制器加入到队列中，以便进一步处理。 // deletePod enqueues the statefulset for the pod accounting for deletion tombstones. func (ssc *StatefulSetController) deletePod(logger klog.Logger, obj interface{}) { pod, ok := obj.(*v1.Pod) // When a delete is dropped, the relist will notice a pod in the store not // in the list, leading to the insertion of a tombstone object which contains // the deleted key/value. Note that this value might be stale. if !ok { tombstone, ok := obj.(cache.DeletedFinalStateUnknown) if !ok { utilruntime.HandleError(fmt.Errorf("couldn&#39;t get object from tombstone %+v", obj)) return } pod, ok = tombstone.Obj.(*v1.Pod) if !ok { utilruntime.HandleError(fmt.Errorf("tombstone contained object that is not a pod %+v", obj)) return } } //该函数是一个Go语言函数，名为deletePod，它属于StatefulSetController类型。 //该函数的功能是将删除操作对应的状态fulset加入到队列中，并考虑到删除标记（tombstones）。 //函数参数： - logger：klog.Logger类型，用于记录日志。 //- obj：interface{}类型，表示要删除的Pod对象。 //函数流程： 1. 尝试将obj对象转换为*v1.Pod类型。 //2. 如果转换失败，则尝试将obj对象转换为cache.DeletedFinalStateUnknown类型。 //3. 如果转换成功，则从tombstone对象中获取被删除的Pod对象。 //4. 如果获取失败，则记录错误信息并返回。 //5. 如果成功获取到Pod对象，则将其加入到队列中，以供后续处理。 //该函数主要处理了两种情况：直接删除Pod对象和通过tombstone对象删除Pod。 //在处理过程中，函数会进行类型断言来确保对象类型正确，并在出现异常时记录错误信息。 controllerRef := metav1.GetControllerOf(pod) if controllerRef == nil { // No controller should care about orphans being deleted. return } set := ssc.resolveControllerRef(pod.Namespace, controllerRef) if set == nil { return } logger.V(4).Info("Pod deleted.", "pod", klog.KObj(pod), "caller", utilruntime.GetCaller()) ssc.enqueueStatefulSet(set) } // 该函数是一个Go语言函数，名为deletePod，它属于StatefulSetController类型。 // 该函数的功能是在删除Pod时，检查是否有对应的控制器（StatefulSet）对该Pod有管理关系， // 如果有，则将该StatefulSet加入到队列中，以触发相应的更新操作。 // 函数流程： // 1. 通过metav1.GetControllerOf函数获取Pod的控制器引用（controllerRef）。 // 2. 如果controllerRef为nil，表示该Pod没有对应的控制器，则直接返回。 // 3. 调用ssc.resolveControllerRef函数解析controllerRef，获取对应的StatefulSet对象（set）。 // 4. 如果set为nil，表示无法解析到对应的StatefulSet，则直接返回。 // 5. 记录日志信息，表示Pod已被删除。 // 6. 将set加入到队列中，以触发StatefulSet的更新操作。 // 该函数主要通过controllerRef来确定Pod所属的StatefulSet，并在删除Pod时，通知对应的StatefulSet进行相应的更新操作。 // 如果无法确定Pod的控制器或者无法解析到对应的StatefulSet，则函数直接返回，不做任何处理。 // getPodsForStatefulSet returns the Pods that a given StatefulSet should manage. // It also reconciles ControllerRef by adopting/orphaning. // // NOTE: Returned Pods are pointers to objects from the cache. // If you need to modify one, you need to copy it first. func (ssc *StatefulSetController) getPodsForStatefulSet(ctx context.Context, set *apps.StatefulSet, selector labels.Selector) ([]*v1.Pod, error) { // List all pods to include the pods that don&#39;t match the selector anymore but // has a ControllerRef pointing to this StatefulSet. pods, err := ssc.podLister.Pods(set.Namespace).List(labels.Everything()) if err != nil { return nil, err } filter := func(pod *v1.Pod) bool { // Only claim if it matches our StatefulSet name. Otherwise release/ignore. return isMemberOf(set, pod) } cm := controller.NewPodControllerRefManager(ssc.podControl, set, selector, controllerKind, ssc.canAdoptFunc(ctx, set)) return cm.ClaimPods(ctx, pods, filter) } // 该函数用于获取指定StatefulSet应该管理的Pods，并通过adopting/orphaning来协调ControllerRef。 // 函数首先从缓存中列出所有Pods，包括不再匹配选择器但具有指向该StatefulSet的ControllerRef的Pods。 // 然后通过isMemberOf函数筛选出属于该StatefulSet的Pods。 // 最后，使用PodControllerRefManager的ClaimPods方法来处理ControllerRef的采用/孤儿化，并返回属于该StatefulSet的Pods的指针。 // 注意：返回的Pods是来自缓存的对象指针，如果需要修改，则需要先复制。 // If any adoptions are attempted, we should first recheck for deletion with // an uncached quorum read sometime after listing Pods/ControllerRevisions (see #42639). func (ssc *StatefulSetController) canAdoptFunc(ctx context.Context, set *apps.StatefulSet) func(ctx2 context.Context) error { return controller.RecheckDeletionTimestamp(func(ctx context.Context) (metav1.Object, error) { fresh, err := ssc.kubeClient.AppsV1().StatefulSets(set.Namespace).Get(ctx, set.Name, metav1.GetOptions{}) if err != nil { return nil, err } if fresh.UID != set.UID { return nil, fmt.Errorf("original StatefulSet %v/%v is gone: got uid %v, wanted %v", set.Namespace, set.Name, fresh.UID, set.UID) } return fresh, nil }) } // 该函数是一个生成函数，返回一个函数，用于检查是否有资格收养（adopt）某个StatefulSet。 // 收养的条件是：在尝试收养之后，需要再次使用未缓存的多数读取（uncached quorum read）检查该StatefulSet是否已被删除。 // 函数内部通过调用ssc.kubeClient.AppsV1().StatefulSets(set.Namespace).Get()来获取最新的StatefulSet信息，并与原有信息进行对比， // 如果UID一致，则返回最新的StatefulSet对象；否则返回错误信息。 // adoptOrphanRevisions adopts any orphaned ControllerRevisions matched by set&#39;s Selector. func (ssc *StatefulSetController) adoptOrphanRevisions(ctx context.Context, set *apps.StatefulSet) error { revisions, err := ssc.control.ListRevisions(set) if err != nil { return err } orphanRevisions := make([]*apps.ControllerRevision, 0) for i := range revisions { if metav1.GetControllerOf(revisions[i]) == nil { orphanRevisions = append(orphanRevisions, revisions[i]) } } if len(orphanRevisions) > 0 { canAdoptErr := ssc.canAdoptFunc(ctx, set)(ctx) if canAdoptErr != nil { return fmt.Errorf("can&#39;t adopt ControllerRevisions: %v", canAdoptErr) } return ssc.control.AdoptOrphanRevisions(set, orphanRevisions) } return nil } // 该函数用于收养被控制器创建但没有被任何StatefulSet认领的ControllerRevision对象。具体流程如下： // 1. 调用ssc.control.ListRevisions(set)获取与给定StatefulSet相关联的所有ControllerRevision对象。 // 2. 遍历所有ControllerRevision对象，如果其metav1.GetControllerOf字段为空，则将其加入orphanRevisions列表。 // 3. 如果orphanRevisions列表非空，则调用ssc.canAdoptFunc(ctx, set)(ctx)判断是否可以收养这些孤儿Revision。 // 4. 如果可以收养，则调用ssc.control.AdoptOrphanRevisions(set, orphanRevisions)进行收养操作。 // 5. 如果收养过程中出现错误，则返回错误信息；否则返回nil表示成功。 // getStatefulSetsForPod returns a list of StatefulSets that potentially match // a given pod. func (ssc *StatefulSetController) getStatefulSetsForPod(pod *v1.Pod) []*apps.StatefulSet { sets, err := ssc.setLister.GetPodStatefulSets(pod) if err != nil { return nil } // More than one set is selecting the same Pod if len(sets) > 1 { // ControllerRef will ensure we don&#39;t do anything crazy, but more than one // item in this list nevertheless constitutes user error. setNames := []string{} for _, s := range sets { setNames = append(setNames, s.Name) } utilruntime.HandleError( fmt.Errorf( "user error: more than one StatefulSet is selecting pods with labels: %+v. Sets: %v", pod.Labels, setNames)) } return sets } // 该函数用于获取与给定Pod相匹配的所有StatefulSet列表。 // - 首先，函数通过调用ssc.setLister.GetPodStatefulSets(pod)方法获取选择该Pod的所有StatefulSet。 // - 如果获取过程中出现错误，则直接返回nil。 // - 如果存在多个StatefulSet选择同一个Pod（即sets长度大于1），则将其视为用户错误。 // 函数会记录错误信息，并返回所有匹配的StatefulSet列表。 // 注意：在存在多个StatefulSet选择同一个Pod时，通过ControllerRef可以确保不会发生疯狂的行为。 // 但是多个StatefulSet出现在列表中仍然被认为是用户错误。 // resolveControllerRef returns the controller referenced by a ControllerRef, // or nil if the ControllerRef could not be resolved to a matching controller // of the correct Kind. func (ssc *StatefulSetController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *apps.StatefulSet { // We can&#39;t look up by UID, so look up by Name and then verify UID. // Don&#39;t even try to look up by Name if it&#39;s the wrong Kind. if controllerRef.Kind != controllerKind.Kind { return nil } set, err := ssc.setLister.StatefulSets(namespace).Get(controllerRef.Name) if err != nil { return nil } if set.UID != controllerRef.UID { // The controller we found with this Name is not the same one that the // ControllerRef points to. return nil } return set } // 该函数用于解析ControllerRef引用的控制器，如果引用无法解析为正确的类型，则返回nil。 // 具体步骤如下： 1. 检查controllerRef的类型是否与期望的类型相匹配，如果不匹配则直接返回nil。 // 2. 通过名称查找StatefulSet控制器，如果查找失败则返回nil。 // 3. 验证找到的StatefulSet控制器的UID是否与controllerRef的UID相同，如果不同则返回nil。 // 4. 如果以上验证都通过，则返回找到的StatefulSet控制器。 // enqueueStatefulSet enqueues the given statefulset in the work queue. func (ssc *StatefulSetController) enqueueStatefulSet(obj interface{}) { key, err := controller.KeyFunc(obj) if err != nil { utilruntime.HandleError(fmt.Errorf("couldn&#39;t get key for object %+v: %v", obj, err)) return } ssc.queue.Add(key) } // 该函数用于将给定的状态fulset对象加入工作队列中。 // 函数首先通过controller.KeyFunc方法获取对象的键值，如果获取失败，则通过utilruntime.HandleError方法记录错误信息并返回。 // 最后，将获取到的键值加入到ssc.queue队列中。 // enqueueStatefulSet enqueues the given statefulset in the work queue after given time func (ssc *StatefulSetController) enqueueSSAfter(ss *apps.StatefulSet, duration time.Duration) { key, err := controller.KeyFunc(ss) if err != nil { utilruntime.HandleError(fmt.Errorf("couldn&#39;t get key for object %#v: %v", ss, err)) return } ssc.queue.AddAfter(key, duration) } // 该函数将给定的状态集（StatefulSet）在指定时间后加入到工作队列中。 // 首先，函数通过调用controller.KeyFunc(ss)方法获取状态集的键值。 // 如果获取键值时出现错误，则使用utilruntime.HandleError()方法处理错误并返回。 // 最后，将键值和指定时间间隔添加到ssc.queue队列中，以便后续处理。 // processNextWorkItem dequeues items, processes them, and marks them done. It enforces that the syncHandler is never // invoked concurrently with the same key. func (ssc *StatefulSetController) processNextWorkItem(ctx context.Context) bool { key, quit := ssc.queue.Get() if quit { return false } defer ssc.queue.Done(key) if err := ssc.sync(ctx, key.(string)); err != nil { utilruntime.HandleError(fmt.Errorf("error syncing StatefulSet %v, requeuing: %v", key.(string), err)) ssc.queue.AddRateLimited(key) } else { ssc.queue.Forget(key) } return true } // 该函数是一个处理工作项的函数，它从队列中获取工作项，处理它，并将其标记为完成。 // 它确保同步处理程序永远不会使用相同的键并发执行。 // 函数返回一个布尔值，表示是否继续处理下一个工作项。 // worker runs a worker goroutine that invokes processNextWorkItem until the controller&#39;s queue is closed func (ssc *StatefulSetController) worker(ctx context.Context) { for ssc.processNextWorkItem(ctx) { } } // 该函数是一个goroutine，用于不断调用processNextWorkItem处理工作项，直到控制器的队列关闭。 // sync syncs the given statefulset. func (ssc *StatefulSetController) sync(ctx context.Context, key string) error { startTime := time.Now() logger := klog.FromContext(ctx) defer func() { logger.V(4).Info("Finished syncing statefulset", "key", key, "time", time.Since(startTime)) }() namespace, name, err := cache.SplitMetaNamespaceKey(key) //该函数是一个Go语言函数，它定义在名为StatefulSetController的结构体中，使用sync作为函数名。 //该函数接收两个参数：ctx context.Context和key string，并返回一个error类型的值。 //函数主要功能如下： //1. 记录开始时间：在函数开始处，通过调用time.Now()记录当前时间，用于后续计算函数执行时间。 //2. 获取日志记录器：通过从传入的ctx参数中获取日志记录器，用于记录函数执行的日志信息。 //3. 延迟执行日志记录：使用defer关键字定义延迟执行的函数，该函数会在函数返回前执行。 //延迟函数主要记录函数执行结束时间，并通过日志记录器记录函数执行时间及关键参数信息。 //4. 分解键值：通过调用cache.SplitMetaNamespaceKey(key)函数，将传入的键值key分解为命名空间namespace和名称name两个部分。 //整体而言，该函数的主要作用是同步处理某个键值对应的StatefulSet对象，具体处理逻辑在该函数的后续代码中实现。 //该函数通过记录函数执行时间、获取日志记录器以及分解键值等操作，为后续处理提供了必要信息。 if err != nil { return err } set, err := ssc.setLister.StatefulSets(namespace).Get(name) //该函数主要执行以下操作： //1. 检查err是否为nil，如果不为nil，则直接返回错误。 //2. 调用ssc.setLister.StatefulSets(namespace).Get(name)获取指定命名空间中的状态集，并将其赋值给set变量。 //3. 返回set和err，其中set为获取的状态集，err为执行过程中可能出现的错误。 if errors.IsNotFound(err) { logger.Info("StatefulSet has been deleted", "key", key) return nil } //这段Go代码主要进行错误判断和日志记录。具体功能如下： //- 首先，它检查错误变量err是否为NotFound错误（即该错误表示某个资源未找到）。 //- 如果是NotFound错误，它会通过logger.Info方法记录一条日志信息，指示某个StatefulSet已被删除，同时在日志中包含key参数的值。 //- 最后，函数返回nil，表示处理完成且无需进一步处理。 //这段代码的作用是在遇到特定类型的错误时，记录一条相关日志信息，并终止进一步的错误处理流程。 if err != nil { utilruntime.HandleError(fmt.Errorf("unable to retrieve StatefulSet %v from store: %v", key, err)) return err } //这段Go代码是一个错误处理的示例。 //如果变量err不为nil，则会使用utilruntime.HandleError()函数处理错误， //该函数会将一个格式化后的错误信息打印出来。然后函数会返回err。这段代码的作用是在发生错误时记录错误信息并返回错误。 selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector) if err != nil { utilruntime.HandleError(fmt.Errorf("error converting StatefulSet %v selector: %v", key, err)) // This is a non-transient error, so don&#39;t retry. return nil } //这段Go代码主要实现了将StatefulSet的标签选择器转换为Selector的功能。 //具体来说，它首先通过metav1.LabelSelectorAsSelector函数将set.Spec.Selector转换为Selector类型， //如果转换过程中出现错误，则通过utilruntime.HandleError函数记录错误信息，并返回nil。 //需要注意的是，这里的错误被认为是非瞬时错误，因此不会进行重试。 if err := ssc.adoptOrphanRevisions(ctx, set); err != nil { return err } //这个函数调用了ssc.adoptOrphanRevisions方法，该方法的作用是在给定的上下文ctx中采用孤儿修订版本。如果方法执行出错，则会返回错误信息err。 pods, err := ssc.getPodsForStatefulSet(ctx, set, selector) if err != nil { return err } //该函数尝试通过调用ssc.getPodsForStatefulSet方法获取与指定StatefulSet和选择器相关联的Pods。如果获取过程中出现错误，则将错误返回。 return ssc.syncStatefulSet(ctx, set, pods) //该函数是Go语言编写的，用于同步更新StatefulSet（有状态副本集）的状态。 //- ctx是一个上下文对象，用于控制函数执行的生命周期。 //- set是一个StatefulSet对象，表示要更新的有状态副本集。 //- pods是一个Pod对象的列表，表示有状态副本集中的Pods。 //函数内部会根据传入的有状态副本集和Pods对象，进行一系列操作来更新副本集的状态，使其与实际的Pods状态保持一致。具体操作细节可以根据函数实现来确定。 } // syncStatefulSet syncs a tuple of (statefulset, []*v1.Pod). func (ssc *StatefulSetController) syncStatefulSet(ctx context.Context, set *apps.StatefulSet, pods []*v1.Pod) error { logger := klog.FromContext(ctx) logger.V(4).Info("Syncing StatefulSet with pods", "statefulSet", klog.KObj(set), "pods", len(pods)) var status *apps.StatefulSetStatus var err error status, err = ssc.control.UpdateStatefulSet(ctx, set, pods) if err != nil { return err } logger.V(4).Info("Successfully synced StatefulSet", "statefulSet", klog.KObj(set)) // One more sync to handle the clock skew. This is also helping in requeuing right after status update if set.Spec.MinReadySeconds > 0 && status != nil && status.AvailableReplicas != *set.Spec.Replicas { ssc.enqueueSSAfter(set, time.Duration(set.Spec.MinReadySeconds)*time.Second) } return nil } //该函数是一个用于同步StatefulSet和其关联Pods的函数。 //它通过调用ssc.control.UpdateStatefulSet方法来更新StatefulSet的状态， //并在更新完成后进行额外的同步操作来处理时钟偏移。 //如果StatefulSet的MinReadySeconds大于0，并且更新后的状态的AvailableReplicas与Spec.Replicas不相等，则会重新排队等待处理。'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2024-04-10 K8S控制器之stateful_set.go源码解读 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.3cb8e8434778f0c84796163dce5e3366067ef3c81eec3be98a8322df81d6631a.js integrity="sha256-PLjoQ0d48MhHlhY9zl4zZgZ+88ge7DvpioMi34HWYxo=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2025-1-16 k8s流量链路剖析</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2025-1-16 CSI剖析演进</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-8-1 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 k8s面试题</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-5-1 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-4-17 面试总结</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-3-8 面试</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-3-4 CNI剖析演进</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-3-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-2-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-2-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-2-22 k8s架构师面试大全</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/ class=active>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2024-04-10 K8S控制器之stateful_set.go源码解读</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><pre tabindex=0><code>/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package statefulset

import (
	&#34;context&#34;
	&#34;fmt&#34;
	&#34;reflect&#34;
	&#34;time&#34;

	apps &#34;k8s.io/api/apps/v1&#34;
	v1 &#34;k8s.io/api/core/v1&#34;
	&#34;k8s.io/apimachinery/pkg/api/errors&#34;
	metav1 &#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;
	&#34;k8s.io/apimachinery/pkg/labels&#34;
	utilruntime &#34;k8s.io/apimachinery/pkg/util/runtime&#34;
	&#34;k8s.io/apimachinery/pkg/util/wait&#34;
	appsinformers &#34;k8s.io/client-go/informers/apps/v1&#34;
	coreinformers &#34;k8s.io/client-go/informers/core/v1&#34;
	clientset &#34;k8s.io/client-go/kubernetes&#34;
	&#34;k8s.io/client-go/kubernetes/scheme&#34;
	v1core &#34;k8s.io/client-go/kubernetes/typed/core/v1&#34;
	appslisters &#34;k8s.io/client-go/listers/apps/v1&#34;
	corelisters &#34;k8s.io/client-go/listers/core/v1&#34;
	&#34;k8s.io/client-go/tools/cache&#34;
	&#34;k8s.io/client-go/tools/record&#34;
	&#34;k8s.io/client-go/util/workqueue&#34;
	podutil &#34;k8s.io/kubernetes/pkg/api/v1/pod&#34;
	&#34;k8s.io/kubernetes/pkg/controller&#34;
	&#34;k8s.io/kubernetes/pkg/controller/history&#34;
)

// controllerKind contains the schema.GroupVersionKind for this controller type.
var controllerKind = apps.SchemeGroupVersion.WithKind(&#34;StatefulSet&#34;)

// StatefulSetController controls statefulsets.
type StatefulSetController struct {
	// client interface
	kubeClient clientset.Interface
	// control returns an interface capable of syncing a stateful set.
	// Abstracted out for testing.
	control StatefulSetControlInterface
	// podControl is used for patching pods.
	podControl controller.PodControlInterface
	// podLister is able to list/get pods from a shared informer&#39;s store
	podLister corelisters.PodLister
	// podListerSynced returns true if the pod shared informer has synced at least once
	podListerSynced cache.InformerSynced
	// setLister is able to list/get stateful sets from a shared informer&#39;s store
	setLister appslisters.StatefulSetLister
	// setListerSynced returns true if the stateful set shared informer has synced at least once
	setListerSynced cache.InformerSynced
	// pvcListerSynced returns true if the pvc shared informer has synced at least once
	pvcListerSynced cache.InformerSynced
	// revListerSynced returns true if the rev shared informer has synced at least once
	revListerSynced cache.InformerSynced
	// StatefulSets that need to be synced.
	queue workqueue.RateLimitingInterface
	// eventBroadcaster is the core of event processing pipeline.
	eventBroadcaster record.EventBroadcaster
}

// 这段Go代码定义了一个名为StatefulSetController的结构体，用于控制StatefulSets。
// 它包含了一系列的成员变量，包括client接口、控制StatefulSet同步的接口、用于patching pods的接口、以及一系列的Lister和Synced函数，
// 用于从共享informer的存储中获取Pods、StatefulSets、PVCs等信息。
// 此外，它还定义了一个工作队列和一个事件广播器。这个结构体主要用于管理和同步Kubernetes中的StatefulSets。
// NewStatefulSetController creates a new statefulset controller.
func NewStatefulSetController(
	ctx context.Context,
	podInformer coreinformers.PodInformer,
	setInformer appsinformers.StatefulSetInformer,
	pvcInformer coreinformers.PersistentVolumeClaimInformer,
	revInformer appsinformers.ControllerRevisionInformer,
	kubeClient clientset.Interface,
) *StatefulSetController {
	logger := klog.FromContext(ctx)
	eventBroadcaster := record.NewBroadcaster(record.WithContext(ctx))
	recorder := eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: &#34;statefulset-controller&#34;})
	ssc := &amp;StatefulSetController{
		kubeClient: kubeClient,
		control: NewDefaultStatefulSetControl(
			NewStatefulPodControl(
				kubeClient,
				podInformer.Lister(),
				pvcInformer.Lister(),
				recorder),
			NewRealStatefulSetStatusUpdater(kubeClient, setInformer.Lister()),
			history.NewHistory(kubeClient, revInformer.Lister()),
			recorder,
		),
		pvcListerSynced: pvcInformer.Informer().HasSynced,
		revListerSynced: revInformer.Informer().HasSynced,
		queue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), &#34;statefulset&#34;),
		podControl:      controller.RealPodControl{KubeClient: kubeClient, Recorder: recorder},

		eventBroadcaster: eventBroadcaster,
	}
	//该函数用于创建一个新的StatefulSet控制器。它接收多个参数，包括上下文、各种Informer、客户端接口等。
	//函数内部通过调用NewDefaultStatefulSetControl函数和其他函数，初始化了StatefulSetController结构体的各个字段，
	//并返回一个指向StatefulSetController结构体的指针。
	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
		// lookup the statefulset and enqueue
		AddFunc: func(obj interface{}) {
			ssc.addPod(logger, obj)
		},
		// lookup current and old statefulset if labels changed
		UpdateFunc: func(oldObj, newObj interface{}) {
			ssc.updatePod(logger, oldObj, newObj)
		},
		// lookup statefulset accounting for deletion tombstones
		DeleteFunc: func(obj interface{}) {
			ssc.deletePod(logger, obj)
		},
	})
	//这段代码定义了一个Go函数，它为podInformer的Informer添加了一个事件处理程序。
	//该事件处理程序使用cache.ResourceEventHandlerFuncs结构体中的AddFunc、UpdateFunc和DeleteFunc来处理资源的添加、更新和删除事件。
	//- AddFunc函数在资源添加时调用ssc.addPod(logger, obj)来添加Pod。
	//- UpdateFunc函数在资源更新时调用ssc.updatePod(logger, oldObj, newObj)来更新Pod。
	//- DeleteFunc函数在资源删除时调用ssc.deletePod(logger, obj)来删除Pod。
	//这些函数通过传入的logger和相应的资源对象来执行具体的操作。
	ssc.podLister = podInformer.Lister()
	ssc.podListerSynced = podInformer.Informer().HasSynced

	setInformer.Informer().AddEventHandler(
		cache.ResourceEventHandlerFuncs{
			AddFunc: ssc.enqueueStatefulSet,
			UpdateFunc: func(old, cur interface{}) {
				oldPS := old.(*apps.StatefulSet)
				curPS := cur.(*apps.StatefulSet)
				if oldPS.Status.Replicas != curPS.Status.Replicas {
					logger.V(4).Info(&#34;Observed updated replica count for StatefulSet&#34;, &#34;statefulSet&#34;, klog.KObj(curPS), &#34;oldReplicas&#34;, oldPS.Status.Replicas, &#34;newReplicas&#34;, curPS.Status.Replicas)
				}
				ssc.enqueueStatefulSet(cur)
			},
			DeleteFunc: ssc.enqueueStatefulSet,
		},
	)
	//这段代码主要涉及到了Kubernetes Informer机制的使用，用于监听StatefulSet资源的变化，并对变化事件进行处理。
	//1. 首先，ssc.podLister = podInformer.Lister()和ssc.podListerSynced = podInformer.Informer().HasSynced
	//两行代码是将pod的Lister和是否同步完成的函数赋值给ssc对象的对应字段。Lister是用来从Informer的cache中获取资源列表和单个资源的，
	//HasSynced则是用来判断Informer是否已经完成初始的资源同步。
	//2. 接下来，setInformer.Informer().AddEventHandler(...)这行代码是给setInformer添加了一个事件处理函数。
	//其中，cache.ResourceEventHandlerFuncs是一个包含了资源添加、更新和删除事件处理函数的结构体。
	//- AddFunc: ssc.enqueueStatefulSet表示当有StatefulSet资源被添加时，调用ssc.enqueueStatefulSet函数来处理该事件。
	//- UpdateFunc表示当有StatefulSet资源被更新时，会先判断其副本数是否发生了变化，如果有变化则打印日志并调用ssc.enqueueStatefulSet函数来处理该事件。
	//- DeleteFunc: ssc.enqueueStatefulSet表示当有StatefulSet资源被删除时，调用ssc.enqueueStatefulSet函数来处理该事件。
	//综上所述，这段代码通过使用Kubernetes Informer机制监听StatefulSet资源的变化，并调用ssc.enqueueStatefulSet函数来处理这些变化事件。
	ssc.setLister = setInformer.Lister()
	ssc.setListerSynced = setInformer.Informer().HasSynced

	// TODO: Watch volumes
	return ssc
}

// 这个Go函数主要设置了ssc对象的setLister和setListerSynced属性。
// setLister是通过setInformer.Lister()方法设置的，它用于从存储中获取设置列表。setListerSynced是通过setInformer.Informer().HasSynced方法设置的，
// 它用于检查设置的同步状态。最后，该函数返回ssc对象。
// Run runs the statefulset controller.
func (ssc *StatefulSetController) Run(ctx context.Context, workers int) {
	defer utilruntime.HandleCrash()

	// Start events processing pipeline.
	ssc.eventBroadcaster.StartStructuredLogging(3)
	ssc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: ssc.kubeClient.CoreV1().Events(&#34;&#34;)})
	defer ssc.eventBroadcaster.Shutdown()

	defer ssc.queue.ShutDown()

	logger := klog.FromContext(ctx)
	logger.Info(&#34;Starting stateful set controller&#34;)
	defer logger.Info(&#34;Shutting down statefulset controller&#34;)
	//该函数是StatefulSetController类型的Run方法，用于启动statefulset控制器。
	//函数首先处理崩溃情况，然后开启事件处理管道，记录事件并将其发送到事件接收器。
	//之后，函数通过调用queue的ShutDown方法来关闭队列。函数在启动和关闭控制器时分别记录日志信息。
	if !cache.WaitForNamedCacheSync(&#34;stateful set&#34;, ctx.Done(), ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) {
		return
	}

	for i := 0; i &lt; workers; i++ {
		go wait.UntilWithContext(ctx, ssc.worker, time.Second)
	}

	&lt;-ctx.Done()
}

// 这段Go代码主要实现了以下功能：
// - 等待多个缓存同步完成：通过调用cache.WaitForNamedCacheSync方法，
// 等待podListerSynced、setListerSynced、pvcListerSynced和revListerSynced四个缓存同步完成。
// 如果在指定的上下文ctx被取消或超时之前，所有缓存都已同步，则继续执行后续代码；否则直接返回。
// - 启动多个工作协程：使用for循环和go关键字，启动workers个工作协程，并在每个协程中定期执行ssc.worker函数，其间隔时间为1秒。
// 这些工作协程会一直运行，直到上下文ctx被取消或超时。
// - 等待上下文取消或超时：通过读取ctx.Done()通道，阻塞当前协程，等待上下文ctx被取消或超时。
// 一旦上下文被取消或超时，整个函数执行结束。  这段代码通常用于在启动时等待多个缓存同步完成，并启动多个工作协程来处理后续任务。
// 通过上下文ctx来控制整个函数的运行时长，并能够在缓存同步或工作协程运行过程中随时取消操作。
// addPod adds the statefulset for the pod to the sync queue
func (ssc *StatefulSetController) addPod(logger klog.Logger, obj interface{}) {
	pod := obj.(*v1.Pod)

	if pod.DeletionTimestamp != nil {
		// on a restart of the controller manager, it&#39;s possible a new pod shows up in a state that
		// is already pending deletion. Prevent the pod from being a creation observation.
		ssc.deletePod(logger, pod)
		return
	}

	// If it has a ControllerRef, that&#39;s all that matters.
	if controllerRef := metav1.GetControllerOf(pod); controllerRef != nil {
		set := ssc.resolveControllerRef(pod.Namespace, controllerRef)
		if set == nil {
			return
		}
		logger.V(4).Info(&#34;Pod created with labels&#34;, &#34;pod&#34;, klog.KObj(pod), &#34;labels&#34;, pod.Labels)
		ssc.enqueueStatefulSet(set)
		return
	}
	//该函数是StatefulSetController类型的一个方法，用于将Pod的状态添加到同步队列中。
	//首先，它检查Pod是否已被标记为删除，如果是，则调用deletePod方法删除Pod，并返回。
	//然后，它检查Pod是否有ControllerRef，如果有，则通过resolveControllerRef方法解析ControllerRef，
	//并将解析结果传递给enqueueStatefulSet方法，以将StatefulSet添加到同步队列中。
	// Otherwise, it&#39;s an orphan. Get a list of all matching controllers and sync
	// them to see if anyone wants to adopt it.
	sets := ssc.getStatefulSetsForPod(pod)
	if len(sets) == 0 {
		return
	}
	logger.V(4).Info(&#34;Orphan Pod created with labels&#34;, &#34;pod&#34;, klog.KObj(pod), &#34;labels&#34;, pod.Labels)
	for _, set := range sets {
		ssc.enqueueStatefulSet(set)
	}
}

// 该函数用于处理一个无归属的Pod（孤儿Pod），通过获取与该Pod匹配的所有StatefulSet控制器，并将它们同步，以查看是否有控制器愿意“收养”这个Pod。
// 首先，函数会调用ssc.getStatefulSetsForPod(pod)方法来获取与Pod匹配的所有StatefulSet集合。
// 如果这个集合的长度为0，说明没有找到匹配的控制器，那么函数直接返回。
// 否则，函数会使用logger记录一条日志信息，以4级日志级别记录“创建了一个孤儿Pod，并列出了Pod的标签”。
// 然后，函数会遍历这个匹配的StatefulSet集合，对每个集合调用ssc.enqueueStatefulSet(set)方法，将其加入到同步队列中，以便后续进行同步处理。
// updatePod adds the statefulset for the current and old pods to the sync queue.
func (ssc *StatefulSetController) updatePod(logger klog.Logger, old, cur interface{}) {
	curPod := cur.(*v1.Pod)
	oldPod := old.(*v1.Pod)
	if curPod.ResourceVersion == oldPod.ResourceVersion {
		// In the event of a re-list we may receive update events for all known pods.
		// Two different versions of the same pod will always have different RVs.
		return
	}

	labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels)

	curControllerRef := metav1.GetControllerOf(curPod)
	oldControllerRef := metav1.GetControllerOf(oldPod)
	controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)
	if controllerRefChanged &amp;&amp; oldControllerRef != nil {
		// The ControllerRef was changed. Sync the old controller, if any.
		if set := ssc.resolveControllerRef(oldPod.Namespace, oldControllerRef); set != nil {
			ssc.enqueueStatefulSet(set)
		}
	}
	//该函数用于将当前和旧的Pod的状态fulset添加到同步队列中。
	//函数首先将传入的old和cur参数转换为v1.Pod类型，并检查它们的ResourceVersion是否相同。
	//如果相同，则表示这是由于重新列表而导致的更新事件，函数将直接返回。
	//然后，函数会检查Pod的标签是否发生变化，并检查ControllerRef是否发生变化。
	//如果ControllerRef发生变化且旧的ControllerRef不为空，则函数将解析旧的ControllerRef，并将对应的StatefulSet添加到同步队列中。
	// If it has a ControllerRef, that&#39;s all that matters.
	if curControllerRef != nil {
		set := ssc.resolveControllerRef(curPod.Namespace, curControllerRef)
		if set == nil {
			return
		}
		logger.V(4).Info(&#34;Pod objectMeta updated&#34;, &#34;pod&#34;, klog.KObj(curPod), &#34;oldObjectMeta&#34;, oldPod.ObjectMeta, &#34;newObjectMeta&#34;, curPod.ObjectMeta)
		ssc.enqueueStatefulSet(set)
		// TODO: MinReadySeconds in the Pod will generate an Available condition to be added in
		// the Pod status which in turn will trigger a requeue of the owning replica set thus
		// having its status updated with the newly available replica.
		if !podutil.IsPodReady(oldPod) &amp;&amp; podutil.IsPodReady(curPod) &amp;&amp; set.Spec.MinReadySeconds &gt; 0 {
			logger.V(2).Info(&#34;StatefulSet will be enqueued after minReadySeconds for availability check&#34;, &#34;statefulSet&#34;, klog.KObj(set), &#34;minReadySeconds&#34;, set.Spec.MinReadySeconds)
			// Add a second to avoid milliseconds skew in AddAfter.
			// See https://github.com/kubernetes/kubernetes/issues/39785#issuecomment-279959133 for more info.
			ssc.enqueueSSAfter(set, (time.Duration(set.Spec.MinReadySeconds)*time.Second)+time.Second)
		}
		return
	}
	//该Go函数是一个处理Pod对象元数据更新的函数。
	//它首先检查当前Pod是否有ControllerRef，如果有，则通过resolveControllerRef方法解析其引用的Controller，并将其加入到队列中以进行后续处理。
	//如果Pod满足特定条件（例如，从不可用状态变为可用状态，并且其所属的StatefulSet的MinReadySeconds大于0），
	//则会将StatefulSet加入到队列中， 以便在MinReadySeconds秒后进行可用性检查。
	// Otherwise, it&#39;s an orphan. If anything changed, sync matching controllers
	// to see if anyone wants to adopt it now.
	if labelChanged || controllerRefChanged {
		sets := ssc.getStatefulSetsForPod(curPod)
		if len(sets) == 0 {
			return
		}
		logger.V(4).Info(&#34;Orphan Pod objectMeta updated&#34;, &#34;pod&#34;, klog.KObj(curPod), &#34;oldObjectMeta&#34;, oldPod.ObjectMeta, &#34;newObjectMeta&#34;, curPod.ObjectMeta)
		for _, set := range sets {
			ssc.enqueueStatefulSet(set)
		}
	}
}

// 这段Go代码是处理Pod对象的元数据更新的逻辑。
// 如果Pod的标签或控制器引用发生了变化，它会检查是否有StatefulSet控制器可以“收养”这个Pod。
// 如果有，则将这个StatefulSet控制器加入到队列中，以便进一步处理。
// deletePod enqueues the statefulset for the pod accounting for deletion tombstones.
func (ssc *StatefulSetController) deletePod(logger klog.Logger, obj interface{}) {
	pod, ok := obj.(*v1.Pod)

	// When a delete is dropped, the relist will notice a pod in the store not
	// in the list, leading to the insertion of a tombstone object which contains
	// the deleted key/value. Note that this value might be stale.
	if !ok {
		tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
		if !ok {
			utilruntime.HandleError(fmt.Errorf(&#34;couldn&#39;t get object from tombstone %+v&#34;, obj))
			return
		}
		pod, ok = tombstone.Obj.(*v1.Pod)
		if !ok {
			utilruntime.HandleError(fmt.Errorf(&#34;tombstone contained object that is not a pod %+v&#34;, obj))
			return
		}
	}
	//该函数是一个Go语言函数，名为deletePod，它属于StatefulSetController类型。
	//该函数的功能是将删除操作对应的状态fulset加入到队列中，并考虑到删除标记（tombstones）。
	//函数参数： - logger：klog.Logger类型，用于记录日志。
	//- obj：interface{}类型，表示要删除的Pod对象。
	//函数流程： 1. 尝试将obj对象转换为*v1.Pod类型。
	//2. 如果转换失败，则尝试将obj对象转换为cache.DeletedFinalStateUnknown类型。
	//3. 如果转换成功，则从tombstone对象中获取被删除的Pod对象。
	//4. 如果获取失败，则记录错误信息并返回。
	//5. 如果成功获取到Pod对象，则将其加入到队列中，以供后续处理。
	//该函数主要处理了两种情况：直接删除Pod对象和通过tombstone对象删除Pod。
	//在处理过程中，函数会进行类型断言来确保对象类型正确，并在出现异常时记录错误信息。
	controllerRef := metav1.GetControllerOf(pod)
	if controllerRef == nil {
		// No controller should care about orphans being deleted.
		return
	}
	set := ssc.resolveControllerRef(pod.Namespace, controllerRef)
	if set == nil {
		return
	}
	logger.V(4).Info(&#34;Pod deleted.&#34;, &#34;pod&#34;, klog.KObj(pod), &#34;caller&#34;, utilruntime.GetCaller())
	ssc.enqueueStatefulSet(set)
}

// 该函数是一个Go语言函数，名为deletePod，它属于StatefulSetController类型。
// 该函数的功能是在删除Pod时，检查是否有对应的控制器（StatefulSet）对该Pod有管理关系，
// 如果有，则将该StatefulSet加入到队列中，以触发相应的更新操作。
// 函数流程：
// 1. 通过metav1.GetControllerOf函数获取Pod的控制器引用（controllerRef）。
// 2. 如果controllerRef为nil，表示该Pod没有对应的控制器，则直接返回。
// 3. 调用ssc.resolveControllerRef函数解析controllerRef，获取对应的StatefulSet对象（set）。
// 4. 如果set为nil，表示无法解析到对应的StatefulSet，则直接返回。
// 5. 记录日志信息，表示Pod已被删除。
// 6. 将set加入到队列中，以触发StatefulSet的更新操作。
// 该函数主要通过controllerRef来确定Pod所属的StatefulSet，并在删除Pod时，通知对应的StatefulSet进行相应的更新操作。
// 如果无法确定Pod的控制器或者无法解析到对应的StatefulSet，则函数直接返回，不做任何处理。
// getPodsForStatefulSet returns the Pods that a given StatefulSet should manage.
// It also reconciles ControllerRef by adopting/orphaning.
//
// NOTE: Returned Pods are pointers to objects from the cache.
// If you need to modify one, you need to copy it first.
func (ssc *StatefulSetController) getPodsForStatefulSet(ctx context.Context, set *apps.StatefulSet, selector labels.Selector) ([]*v1.Pod, error) {
	// List all pods to include the pods that don&#39;t match the selector anymore but
	// has a ControllerRef pointing to this StatefulSet.
	pods, err := ssc.podLister.Pods(set.Namespace).List(labels.Everything())
	if err != nil {
		return nil, err
	}

	filter := func(pod *v1.Pod) bool {
		// Only claim if it matches our StatefulSet name. Otherwise release/ignore.
		return isMemberOf(set, pod)
	}

	cm := controller.NewPodControllerRefManager(ssc.podControl, set, selector, controllerKind, ssc.canAdoptFunc(ctx, set))
	return cm.ClaimPods(ctx, pods, filter)
}

// 该函数用于获取指定StatefulSet应该管理的Pods，并通过adopting/orphaning来协调ControllerRef。
// 函数首先从缓存中列出所有Pods，包括不再匹配选择器但具有指向该StatefulSet的ControllerRef的Pods。
// 然后通过isMemberOf函数筛选出属于该StatefulSet的Pods。
// 最后，使用PodControllerRefManager的ClaimPods方法来处理ControllerRef的采用/孤儿化，并返回属于该StatefulSet的Pods的指针。
// 注意：返回的Pods是来自缓存的对象指针，如果需要修改，则需要先复制。
// If any adoptions are attempted, we should first recheck for deletion with
// an uncached quorum read sometime after listing Pods/ControllerRevisions (see #42639).
func (ssc *StatefulSetController) canAdoptFunc(ctx context.Context, set *apps.StatefulSet) func(ctx2 context.Context) error {
	return controller.RecheckDeletionTimestamp(func(ctx context.Context) (metav1.Object, error) {
		fresh, err := ssc.kubeClient.AppsV1().StatefulSets(set.Namespace).Get(ctx, set.Name, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		if fresh.UID != set.UID {
			return nil, fmt.Errorf(&#34;original StatefulSet %v/%v is gone: got uid %v, wanted %v&#34;, set.Namespace, set.Name, fresh.UID, set.UID)
		}
		return fresh, nil
	})
}

// 该函数是一个生成函数，返回一个函数，用于检查是否有资格收养（adopt）某个StatefulSet。
// 收养的条件是：在尝试收养之后，需要再次使用未缓存的多数读取（uncached quorum read）检查该StatefulSet是否已被删除。
// 函数内部通过调用ssc.kubeClient.AppsV1().StatefulSets(set.Namespace).Get()来获取最新的StatefulSet信息，并与原有信息进行对比，
// 如果UID一致，则返回最新的StatefulSet对象；否则返回错误信息。
// adoptOrphanRevisions adopts any orphaned ControllerRevisions matched by set&#39;s Selector.
func (ssc *StatefulSetController) adoptOrphanRevisions(ctx context.Context, set *apps.StatefulSet) error {
	revisions, err := ssc.control.ListRevisions(set)
	if err != nil {
		return err
	}
	orphanRevisions := make([]*apps.ControllerRevision, 0)
	for i := range revisions {
		if metav1.GetControllerOf(revisions[i]) == nil {
			orphanRevisions = append(orphanRevisions, revisions[i])
		}
	}
	if len(orphanRevisions) &gt; 0 {
		canAdoptErr := ssc.canAdoptFunc(ctx, set)(ctx)
		if canAdoptErr != nil {
			return fmt.Errorf(&#34;can&#39;t adopt ControllerRevisions: %v&#34;, canAdoptErr)
		}
		return ssc.control.AdoptOrphanRevisions(set, orphanRevisions)
	}
	return nil
}

// 该函数用于收养被控制器创建但没有被任何StatefulSet认领的ControllerRevision对象。具体流程如下：
// 1. 调用ssc.control.ListRevisions(set)获取与给定StatefulSet相关联的所有ControllerRevision对象。
// 2. 遍历所有ControllerRevision对象，如果其metav1.GetControllerOf字段为空，则将其加入orphanRevisions列表。
// 3. 如果orphanRevisions列表非空，则调用ssc.canAdoptFunc(ctx, set)(ctx)判断是否可以收养这些孤儿Revision。
// 4. 如果可以收养，则调用ssc.control.AdoptOrphanRevisions(set, orphanRevisions)进行收养操作。
// 5. 如果收养过程中出现错误，则返回错误信息；否则返回nil表示成功。
// getStatefulSetsForPod returns a list of StatefulSets that potentially match
// a given pod.
func (ssc *StatefulSetController) getStatefulSetsForPod(pod *v1.Pod) []*apps.StatefulSet {
	sets, err := ssc.setLister.GetPodStatefulSets(pod)
	if err != nil {
		return nil
	}
	// More than one set is selecting the same Pod
	if len(sets) &gt; 1 {
		// ControllerRef will ensure we don&#39;t do anything crazy, but more than one
		// item in this list nevertheless constitutes user error.
		setNames := []string{}
		for _, s := range sets {
			setNames = append(setNames, s.Name)
		}
		utilruntime.HandleError(
			fmt.Errorf(
				&#34;user error: more than one StatefulSet is selecting pods with labels: %+v. Sets: %v&#34;,
				pod.Labels, setNames))
	}
	return sets
}

// 该函数用于获取与给定Pod相匹配的所有StatefulSet列表。
// - 首先，函数通过调用ssc.setLister.GetPodStatefulSets(pod)方法获取选择该Pod的所有StatefulSet。
// - 如果获取过程中出现错误，则直接返回nil。
// - 如果存在多个StatefulSet选择同一个Pod（即sets长度大于1），则将其视为用户错误。
// 函数会记录错误信息，并返回所有匹配的StatefulSet列表。
// 注意：在存在多个StatefulSet选择同一个Pod时，通过ControllerRef可以确保不会发生疯狂的行为。
// 但是多个StatefulSet出现在列表中仍然被认为是用户错误。
// resolveControllerRef returns the controller referenced by a ControllerRef,
// or nil if the ControllerRef could not be resolved to a matching controller
// of the correct Kind.
func (ssc *StatefulSetController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *apps.StatefulSet {
	// We can&#39;t look up by UID, so look up by Name and then verify UID.
	// Don&#39;t even try to look up by Name if it&#39;s the wrong Kind.
	if controllerRef.Kind != controllerKind.Kind {
		return nil
	}
	set, err := ssc.setLister.StatefulSets(namespace).Get(controllerRef.Name)
	if err != nil {
		return nil
	}
	if set.UID != controllerRef.UID {
		// The controller we found with this Name is not the same one that the
		// ControllerRef points to.
		return nil
	}
	return set
}

// 该函数用于解析ControllerRef引用的控制器，如果引用无法解析为正确的类型，则返回nil。
// 具体步骤如下： 1. 检查controllerRef的类型是否与期望的类型相匹配，如果不匹配则直接返回nil。
// 2. 通过名称查找StatefulSet控制器，如果查找失败则返回nil。
// 3. 验证找到的StatefulSet控制器的UID是否与controllerRef的UID相同，如果不同则返回nil。
// 4. 如果以上验证都通过，则返回找到的StatefulSet控制器。
// enqueueStatefulSet enqueues the given statefulset in the work queue.
func (ssc *StatefulSetController) enqueueStatefulSet(obj interface{}) {
	key, err := controller.KeyFunc(obj)
	if err != nil {
		utilruntime.HandleError(fmt.Errorf(&#34;couldn&#39;t get key for object %+v: %v&#34;, obj, err))
		return
	}
	ssc.queue.Add(key)
}

// 该函数用于将给定的状态fulset对象加入工作队列中。
// 函数首先通过controller.KeyFunc方法获取对象的键值，如果获取失败，则通过utilruntime.HandleError方法记录错误信息并返回。
// 最后，将获取到的键值加入到ssc.queue队列中。
// enqueueStatefulSet enqueues the given statefulset in the work queue after given time
func (ssc *StatefulSetController) enqueueSSAfter(ss *apps.StatefulSet, duration time.Duration) {
	key, err := controller.KeyFunc(ss)
	if err != nil {
		utilruntime.HandleError(fmt.Errorf(&#34;couldn&#39;t get key for object %#v: %v&#34;, ss, err))
		return
	}
	ssc.queue.AddAfter(key, duration)
}

// 该函数将给定的状态集（StatefulSet）在指定时间后加入到工作队列中。
// 首先，函数通过调用controller.KeyFunc(ss)方法获取状态集的键值。
// 如果获取键值时出现错误，则使用utilruntime.HandleError()方法处理错误并返回。
// 最后，将键值和指定时间间隔添加到ssc.queue队列中，以便后续处理。
// processNextWorkItem dequeues items, processes them, and marks them done. It enforces that the syncHandler is never
// invoked concurrently with the same key.
func (ssc *StatefulSetController) processNextWorkItem(ctx context.Context) bool {
	key, quit := ssc.queue.Get()
	if quit {
		return false
	}
	defer ssc.queue.Done(key)
	if err := ssc.sync(ctx, key.(string)); err != nil {
		utilruntime.HandleError(fmt.Errorf(&#34;error syncing StatefulSet %v, requeuing: %v&#34;, key.(string), err))
		ssc.queue.AddRateLimited(key)
	} else {
		ssc.queue.Forget(key)
	}
	return true
}

// 该函数是一个处理工作项的函数，它从队列中获取工作项，处理它，并将其标记为完成。
// 它确保同步处理程序永远不会使用相同的键并发执行。
// 函数返回一个布尔值，表示是否继续处理下一个工作项。
// worker runs a worker goroutine that invokes processNextWorkItem until the controller&#39;s queue is closed
func (ssc *StatefulSetController) worker(ctx context.Context) {
	for ssc.processNextWorkItem(ctx) {
	}
}

// 该函数是一个goroutine，用于不断调用processNextWorkItem处理工作项，直到控制器的队列关闭。
// sync syncs the given statefulset.
func (ssc *StatefulSetController) sync(ctx context.Context, key string) error {
	startTime := time.Now()
	logger := klog.FromContext(ctx)
	defer func() {
		logger.V(4).Info(&#34;Finished syncing statefulset&#34;, &#34;key&#34;, key, &#34;time&#34;, time.Since(startTime))
	}()

	namespace, name, err := cache.SplitMetaNamespaceKey(key)
	//该函数是一个Go语言函数，它定义在名为StatefulSetController的结构体中，使用sync作为函数名。
	//该函数接收两个参数：ctx context.Context和key string，并返回一个error类型的值。
	//函数主要功能如下：
	//1. 记录开始时间：在函数开始处，通过调用time.Now()记录当前时间，用于后续计算函数执行时间。
	//2. 获取日志记录器：通过从传入的ctx参数中获取日志记录器，用于记录函数执行的日志信息。
	//3. 延迟执行日志记录：使用defer关键字定义延迟执行的函数，该函数会在函数返回前执行。
	//延迟函数主要记录函数执行结束时间，并通过日志记录器记录函数执行时间及关键参数信息。
	//4. 分解键值：通过调用cache.SplitMetaNamespaceKey(key)函数，将传入的键值key分解为命名空间namespace和名称name两个部分。
	//整体而言，该函数的主要作用是同步处理某个键值对应的StatefulSet对象，具体处理逻辑在该函数的后续代码中实现。
	//该函数通过记录函数执行时间、获取日志记录器以及分解键值等操作，为后续处理提供了必要信息。
	if err != nil {
		return err
	}
	set, err := ssc.setLister.StatefulSets(namespace).Get(name)
	//该函数主要执行以下操作：
	//1. 检查err是否为nil，如果不为nil，则直接返回错误。
	//2. 调用ssc.setLister.StatefulSets(namespace).Get(name)获取指定命名空间中的状态集，并将其赋值给set变量。
	//3. 返回set和err，其中set为获取的状态集，err为执行过程中可能出现的错误。
	if errors.IsNotFound(err) {
		logger.Info(&#34;StatefulSet has been deleted&#34;, &#34;key&#34;, key)
		return nil
	}
	//这段Go代码主要进行错误判断和日志记录。具体功能如下：
	//- 首先，它检查错误变量err是否为NotFound错误（即该错误表示某个资源未找到）。
	//- 如果是NotFound错误，它会通过logger.Info方法记录一条日志信息，指示某个StatefulSet已被删除，同时在日志中包含key参数的值。
	//- 最后，函数返回nil，表示处理完成且无需进一步处理。
	//这段代码的作用是在遇到特定类型的错误时，记录一条相关日志信息，并终止进一步的错误处理流程。
	if err != nil {
		utilruntime.HandleError(fmt.Errorf(&#34;unable to retrieve StatefulSet %v from store: %v&#34;, key, err))
		return err
	}
	//这段Go代码是一个错误处理的示例。
	//如果变量err不为nil，则会使用utilruntime.HandleError()函数处理错误，
	//该函数会将一个格式化后的错误信息打印出来。然后函数会返回err。这段代码的作用是在发生错误时记录错误信息并返回错误。
	selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)
	if err != nil {
		utilruntime.HandleError(fmt.Errorf(&#34;error converting StatefulSet %v selector: %v&#34;, key, err))
		// This is a non-transient error, so don&#39;t retry.
		return nil
	}
	//这段Go代码主要实现了将StatefulSet的标签选择器转换为Selector的功能。
	//具体来说，它首先通过metav1.LabelSelectorAsSelector函数将set.Spec.Selector转换为Selector类型，
	//如果转换过程中出现错误，则通过utilruntime.HandleError函数记录错误信息，并返回nil。
	//需要注意的是，这里的错误被认为是非瞬时错误，因此不会进行重试。
	if err := ssc.adoptOrphanRevisions(ctx, set); err != nil {
		return err
	}
	//这个函数调用了ssc.adoptOrphanRevisions方法，该方法的作用是在给定的上下文ctx中采用孤儿修订版本。如果方法执行出错，则会返回错误信息err。
	pods, err := ssc.getPodsForStatefulSet(ctx, set, selector)
	if err != nil {
		return err
	}
	//该函数尝试通过调用ssc.getPodsForStatefulSet方法获取与指定StatefulSet和选择器相关联的Pods。如果获取过程中出现错误，则将错误返回。
	return ssc.syncStatefulSet(ctx, set, pods)
	//该函数是Go语言编写的，用于同步更新StatefulSet（有状态副本集）的状态。
	//- ctx是一个上下文对象，用于控制函数执行的生命周期。
	//- set是一个StatefulSet对象，表示要更新的有状态副本集。
	//- pods是一个Pod对象的列表，表示有状态副本集中的Pods。
	//函数内部会根据传入的有状态副本集和Pods对象，进行一系列操作来更新副本集的状态，使其与实际的Pods状态保持一致。具体操作细节可以根据函数实现来确定。
}

// syncStatefulSet syncs a tuple of (statefulset, []*v1.Pod).
func (ssc *StatefulSetController) syncStatefulSet(ctx context.Context, set *apps.StatefulSet, pods []*v1.Pod) error {
	logger := klog.FromContext(ctx)
	logger.V(4).Info(&#34;Syncing StatefulSet with pods&#34;, &#34;statefulSet&#34;, klog.KObj(set), &#34;pods&#34;, len(pods))
	var status *apps.StatefulSetStatus
	var err error
	status, err = ssc.control.UpdateStatefulSet(ctx, set, pods)
	if err != nil {
		return err
	}
	logger.V(4).Info(&#34;Successfully synced StatefulSet&#34;, &#34;statefulSet&#34;, klog.KObj(set))
	// One more sync to handle the clock skew. This is also helping in requeuing right after status update
	if set.Spec.MinReadySeconds &gt; 0 &amp;&amp; status != nil &amp;&amp; status.AvailableReplicas != *set.Spec.Replicas {
		ssc.enqueueSSAfter(set, time.Duration(set.Spec.MinReadySeconds)*time.Second)
	}

	return nil
}

//该函数是一个用于同步StatefulSet和其关联Pods的函数。
//它通过调用ssc.control.UpdateStatefulSet方法来更新StatefulSet的状态，
//并在更新完成后进行额外的同步操作来处理时钟偏移。
//如果StatefulSet的MinReadySeconds大于0，并且更新后的状态的AvailableReplicas与Spec.Replicas不相等，则会重新排队等待处理。
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>