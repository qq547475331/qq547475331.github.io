<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  上海外包太平洋保险
  #


  有完成过ansible比较复杂的role task的编写吗？
  #

是的，基于你的需求描述，我可以帮你了解和完成一些复杂的 Ansible Role 和 Task 编写。以下是一些示例场景：

  1. 完整的 Kubernetes 集群节点加入 Role 编写
  #

假设你需要使用 Ansible 创建一个完整的 Kubernetes 节点加入过程，包含以下内容：

创建目录结构和配置文件
二进制文件下载和分发
systemd 服务文件创建和启用
配置文件模板化（kubelet，kube-proxy，CNI 插件等）
节点标签和调度禁用操作
kubelet、kube-proxy 等服务的启动管理


  2. Ansible Role 示例
  #

一个复杂的 Role 可能包含以下几个部分：

  tasks/main.yml
  #

---
# 安装并配置 Kubernetes 组件（如 kubelet 和 kube-proxy）

- name: 创建 Kubernetes 相关目录
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: "0755"
  with_items:
    - /var/lib/kubelet
    - /var/lib/kube-proxy
    - /etc/cni/net.d
    - /opt/cni/bin

- name: 分发 kubelet 和 kube-proxy 二进制文件
  copy:
    src: "{{ base_dir }}/bin/{{ item }}"
    dest: "{{ bin_dir }}/{{ item }}"
    mode: "0755"
  with_items:
    - kubectl
    - kubelet
    - kube-proxy

- name: 分发 CNI 插件
  copy:
    src: "{{ item }}"
    dest: /opt/cni/bin/
    mode: "0755"
  with_fileglob:
    - "{{ base_dir }}/bin/cni-bin/*"

# 创建 kubelet 和 kube-proxy 配置文件
- name: 创建 kubelet 配置文件
  template:
    src: kubelet-config.yaml.j2
    dest: /var/lib/kubelet/config.yaml
  tags: configure_kubelet

- name: 创建 kube-proxy 配置文件
  template:
    src: kube-proxy-config.yaml.j2
    dest: /var/lib/kube-proxy/kube-proxy-config.yaml
  tags: configure_kubeproxy

# 创建 kubelet 和 kube-proxy 的 systemd 服务
- name: 创建 kubelet systemd 服务文件
  template:
    src: kubelet.service.j2
    dest: /etc/systemd/system/kubelet.service
  tags: manage_services

- name: 创建 kube-proxy systemd 服务文件
  template:
    src: kube-proxy.service.j2
    dest: /etc/systemd/system/kube-proxy.service
  tags: manage_services

# 启用并启动服务
- name: 启用 kubelet 服务
  systemd:
    name: kubelet
    enabled: yes
    state: started
  tags: manage_services

- name: 启用 kube-proxy 服务
  systemd:
    name: kube-proxy
    enabled: yes
    state: started
  tags: manage_services

# 节点加入 Kubernetes 集群并设置角色标签
- name: 设置 Kubernetes 节点角色标签
  shell: "{{ kubectl_bin }} label node {{ inventory_hostname }} kubernetes.io/role={{ node_role }} --overwrite"
  tags: configure_node_role

- name: 节点调度控制
  shell: "{{ kubectl_bin }} cordon {{ inventory_hostname }}"
  when: node_role == "master"
  tags: configure_node_role

  templates/kubelet-config.yaml.j2
  #

apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
address: 0.0.0.0
port: 10250
readOnlyPort: 10255
clusterDNS:
  - {{ cluster_dns }}
clusterDomain: {{ cluster_domain }}
resolvConf: /run/systemd/resolve/resolv.conf
...

  templates/kube-proxy-config.yaml.j2
  #

apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
mode: iptables
clusterCIDR: {{ cluster_cidr }}
...

  templates/kubelet.service.j2
  #

[Unit]
Description=Kubernetes Kubelet
Documentation=https://kubernetes.io/docs/home/
After=network.target
Requires=docker.service

[Service]
ExecStart={{ bin_dir }}/kubelet \
  --config={{ config_dir }}/kubelet/config.yaml \
  --kubeconfig={{ kubeconfig_path }}
Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target

  templates/kube-proxy.service.j2
  #

[Unit]
Description=Kubernetes Kube Proxy
After=network.target

[Service]
ExecStart={{ bin_dir }}/kube-proxy \
  --config={{ config_dir }}/kube-proxy/kube-proxy-config.yaml \
  --kubeconfig={{ kubeconfig_path }}
Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target

  3. Role 的配置文件结构
  #

可以在 Role 中定义一个清晰的目录结构，包括以下文件：'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2025-2-25 面试0225"><meta property="og:description" content='上海外包太平洋保险 # 有完成过ansible比较复杂的role task的编写吗？ # 是的，基于你的需求描述，我可以帮你了解和完成一些复杂的 Ansible Role 和 Task 编写。以下是一些示例场景：
1. 完整的 Kubernetes 集群节点加入 Role 编写 # 假设你需要使用 Ansible 创建一个完整的 Kubernetes 节点加入过程，包含以下内容：
创建目录结构和配置文件 二进制文件下载和分发 systemd 服务文件创建和启用 配置文件模板化（kubelet，kube-proxy，CNI 插件等） 节点标签和调度禁用操作 kubelet、kube-proxy 等服务的启动管理 2. Ansible Role 示例 # 一个复杂的 Role 可能包含以下几个部分：
tasks/main.yml # --- # 安装并配置 Kubernetes 组件（如 kubelet 和 kube-proxy） - name: 创建 Kubernetes 相关目录 file: path: "{{ item }}" state: directory owner: root group: root mode: "0755" with_items: - /var/lib/kubelet - /var/lib/kube-proxy - /etc/cni/net.d - /opt/cni/bin - name: 分发 kubelet 和 kube-proxy 二进制文件 copy: src: "{{ base_dir }}/bin/{{ item }}" dest: "{{ bin_dir }}/{{ item }}" mode: "0755" with_items: - kubectl - kubelet - kube-proxy - name: 分发 CNI 插件 copy: src: "{{ item }}" dest: /opt/cni/bin/ mode: "0755" with_fileglob: - "{{ base_dir }}/bin/cni-bin/*" # 创建 kubelet 和 kube-proxy 配置文件 - name: 创建 kubelet 配置文件 template: src: kubelet-config.yaml.j2 dest: /var/lib/kubelet/config.yaml tags: configure_kubelet - name: 创建 kube-proxy 配置文件 template: src: kube-proxy-config.yaml.j2 dest: /var/lib/kube-proxy/kube-proxy-config.yaml tags: configure_kubeproxy # 创建 kubelet 和 kube-proxy 的 systemd 服务 - name: 创建 kubelet systemd 服务文件 template: src: kubelet.service.j2 dest: /etc/systemd/system/kubelet.service tags: manage_services - name: 创建 kube-proxy systemd 服务文件 template: src: kube-proxy.service.j2 dest: /etc/systemd/system/kube-proxy.service tags: manage_services # 启用并启动服务 - name: 启用 kubelet 服务 systemd: name: kubelet enabled: yes state: started tags: manage_services - name: 启用 kube-proxy 服务 systemd: name: kube-proxy enabled: yes state: started tags: manage_services # 节点加入 Kubernetes 集群并设置角色标签 - name: 设置 Kubernetes 节点角色标签 shell: "{{ kubectl_bin }} label node {{ inventory_hostname }} kubernetes.io/role={{ node_role }} --overwrite" tags: configure_node_role - name: 节点调度控制 shell: "{{ kubectl_bin }} cordon {{ inventory_hostname }}" when: node_role == "master" tags: configure_node_role templates/kubelet-config.yaml.j2 # apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration address: 0.0.0.0 port: 10250 readOnlyPort: 10255 clusterDNS: - {{ cluster_dns }} clusterDomain: {{ cluster_domain }} resolvConf: /run/systemd/resolve/resolv.conf ... templates/kube-proxy-config.yaml.j2 # apiVersion: kubeproxy.config.k8s.io/v1alpha1 kind: KubeProxyConfiguration mode: iptables clusterCIDR: {{ cluster_cidr }} ... templates/kubelet.service.j2 # [Unit] Description=Kubernetes Kubelet Documentation=https://kubernetes.io/docs/home/ After=network.target Requires=docker.service [Service] ExecStart={{ bin_dir }}/kubelet \ --config={{ config_dir }}/kubelet/config.yaml \ --kubeconfig={{ kubeconfig_path }} Restart=always RestartSec=10s [Install] WantedBy=multi-user.target templates/kube-proxy.service.j2 # [Unit] Description=Kubernetes Kube Proxy After=network.target [Service] ExecStart={{ bin_dir }}/kube-proxy \ --config={{ config_dir }}/kube-proxy/kube-proxy-config.yaml \ --kubeconfig={{ kubeconfig_path }} Restart=always RestartSec=10s [Install] WantedBy=multi-user.target 3. Role 的配置文件结构 # 可以在 Role 中定义一个清晰的目录结构，包括以下文件：'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2025-2-25 面试0225 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.7f32d7f32854c58e9d609afa823b9ac3f779ee2a51b25a601df51a0597543f29.js integrity="sha256-fzLX8yhUxY6dYJr6gjuaw/d57ipRslpgHfUaBZdUPyk=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus/>2025-2-28 prometheus 面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/ class=active>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2025-1-16 k8s流量链路剖析</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2025-1-16 CSI剖析演进</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-8-1 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 k8s面试题</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-5-1 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-4-17 面试总结</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-3-8 面试</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-3-4 CNI剖析演进</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-3-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-2-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-2-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-2-22 k8s架构师面试大全</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-2-25 面试0225</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#上海外包太平洋保险>上海外包太平洋保险</a></li><li><a href=#有完成过ansible比较复杂的role-task的编写吗>有完成过ansible比较复杂的role task的编写吗？</a><ul><li><a href=#1-完整的-kubernetes-集群节点加入-role-编写><strong>1. 完整的 Kubernetes 集群节点加入 Role 编写</strong></a></li><li><a href=#2-ansible-role-示例><strong>2. Ansible Role 示例</strong></a></li><li><a href=#3-role-的配置文件结构><strong>3. Role 的配置文件结构</strong></a></li><li><a href=#4-执行过程><strong>4. 执行过程</strong></a></li><li><a href=#总结><strong>总结</strong></a></li></ul></li><li><a href=#defaultsmainyml定义该-role-的默认变量可以为所有的任务设置默认值-varsmainyml可以为该-role-提供更具体的变量设置-谁的优先级更高>defaults/main.yml：定义该 Role 的默认变量，可以为所有的任务设置默认值。 vars/main.yml：可以为该 Role 提供更具体的变量设置。 谁的优先级更高</a><ul><li><a href=#优先级><strong>优先级</strong></a></li><li><a href=#优先级顺序><strong>优先级顺序：</strong></a></li><li><a href=#例子><strong>例子</strong></a></li><li><a href=#总结-1><strong>总结</strong></a></li></ul></li><li><a href=#集群多少规模多大用ansible部署>集群多少？规模多大？用ansible部署。</a></li><li><a href=#ansible变量的优先级变量的优先级怎么去设置同一变量可能出现在playbook的多个地方>ansible变量的优先级？变量的优先级怎么去设置，同一变量可能出现在playbook的多个地方</a></li><li><a href=#你是如何用优先级去控制变量的正确性>你是如何用优先级去控制变量的正确性？</a><ul><li><a href=#ansible-变量的优先级从低到高><strong>Ansible 变量的优先级（从低到高）</strong></a></li><li><a href=#优先级的示意图><strong>优先级的示意图：</strong></a></li><li><a href=#优先级控制变量正确性的方法><strong>优先级控制变量正确性的方法：</strong></a></li><li><a href=#优先级应用场景><strong>优先级应用场景：</strong></a></li><li><a href=#如何控制变量的正确性><strong>如何控制变量的正确性</strong></a></li></ul></li><li><a href=#playbook的role存在多个子的role那么如何让控制好他的执行顺序>playbook的role存在多个子的role，那么如何让控制好他的执行顺序？</a><ul><li><a href=#1-role-执行顺序role-顺序是基于-playbook-中的定义顺序来决定的>1. <strong>Role 执行顺序：Role 顺序是基于 Playbook 中的定义顺序来决定的</strong></a></li><li><a href=#2-使用>2. <strong>使用 <code>dependencies</code> 控制 Role 的执行顺序</strong></a></li><li><a href=#3-在-playbook-中使用>3. <strong>在 Playbook 中使用 <code>pre_tasks</code> 和 <code>post_tasks</code> 控制执行顺序</strong></a></li><li><a href=#4-利用>4. <strong>利用 <code>tags</code> 控制 Role 的执行顺序</strong></a></li><li><a href=#5-条件判断来控制执行顺序>5. <strong>条件判断来控制执行顺序</strong></a></li><li><a href=#6-使用>6. <strong>使用 <code>block</code> 来组合多个 Role</strong></a></li><li><a href=#7-使用>7. <strong>使用 <code>serial</code> 来控制并发执行</strong></a></li><li><a href=#总结-2><strong>总结</strong></a></li></ul></li><li><a href=#meta用过吗role-task里面main里面第一个yaml还有个meta-在执行主的yaml前去调用这个的预先的执行meta的外部扩展的子>meta用过吗？role task里面main里面第一个yaml，还有个meta 在执行主的yaml前去调用这个的预先的，执行meta的外部扩展的子</a><ul><li><a href=#metamainyml-的常见用途><code>meta/main.yml</code> 的常见用途：</a></li><li><a href=#1-role-依赖配置>1. <strong>Role 依赖配置</strong></a></li><li><a href=#2-meta>2. <strong><code>meta</code> 在 Role 中的执行</strong></a></li><li><a href=#3-如何调用>3. <strong>如何调用 <code>meta</code> 里的内容</strong></a></li><li><a href=#注意事项><strong>注意事项</strong>：</a></li><li><a href=#4-metamainyml>4. <strong><code>meta/main.yml</code> 示例</strong></a></li><li><a href=#总结-3><strong>总结</strong>：</a></li></ul></li><li><a href=#除了用ansible部署k8s外上层的软件如何部署其他类似云原生的应用会部署哪些>除了用ansible部署k8s外上层的软件如何部署，其他类似云原生的应用会部署哪些？</a><ul><li><a href=#1-云原生应用部署>1. <strong>云原生应用部署</strong></a></li><li><a href=#2-多集群管理>2. <strong>多集群管理</strong></a></li><li><a href=#3-容器编排与调度>3. <strong>容器编排与调度</strong></a></li><li><a href=#4-安全管理与身份认证>4. <strong>安全管理与身份认证</strong></a></li><li><a href=#5-自动化运维和弹性伸缩>5. <strong>自动化运维和弹性伸缩</strong></a></li><li><a href=#总结-4>总结</a></li></ul></li><li><a href=#helm用吗成品helm部署的模版有个人去完成过吗>helm用吗？成品helm部署的模版有个人去完成过吗？</a><ul><li><a href=#helm-charts-的使用>Helm Charts 的使用</a></li><li><a href=#helm-的优势>Helm 的优势</a></li></ul></li><li><a href=#内部的调优后期运维工作体现在哪>内部的调优，后期运维工作体现在哪？</a><ul><li><a href=#1-性能优化>1. <strong>性能优化</strong></a></li><li><a href=#2-高可用性和容错性设计>2. <strong>高可用性和容错性设计</strong></a></li><li><a href=#3-自动化运维>3. <strong>自动化运维</strong></a></li><li><a href=#4-安全性加强>4. <strong>安全性加强</strong></a></li><li><a href=#5-问题排查与故障处理>5. <strong>问题排查与故障处理</strong></a></li><li><a href=#6-版本升级与迁移>6. <strong>版本升级与迁移</strong></a></li><li><a href=#7-成本优化>7. <strong>成本优化</strong></a></li><li><a href=#总结-5>总结：</a></li></ul></li><li><a href=#k8s的集群的驱逐怎么做的被动驱逐为了不要被驱逐可能主机上已有应用被驱逐不让他被驱逐解决不要被驱逐的问题>k8s的集群的驱逐怎么做的？被动驱逐，为了不要被驱逐，可能主机上已有应用被驱逐，不让他被驱逐，解决不要被驱逐的问题，</a></li><li><a href=#提前扩容做一些考量>提前扩容，做一些考量，</a><ul><li><a href=#1-kubernetes-驱逐机制>1. <strong>Kubernetes 驱逐机制</strong></a></li><li><a href=#2-防止-pod-被驱逐>2. <strong>防止 Pod 被驱逐</strong></a></li><li><a href=#3-如何避免主机应用被驱逐>3. <strong>如何避免主机应用被驱逐</strong></a></li><li><a href=#总结-6>总结：</a></li></ul></li><li><a href=#kafka-zk脑裂怎么解决>kafka ，zk，脑裂怎么解决？</a><ul><li><a href=#1-kafka-中的脑裂问题及解决方法>1. <strong>Kafka 中的脑裂问题及解决方法</strong></a></li><li><a href=#2-zookeeper-中的脑裂问题及解决方法>2. <strong>Zookeeper 中的脑裂问题及解决方法</strong></a></li><li><a href=#3-总结kafka-与-zookeeper-的脑裂问题解决>3. <strong>总结：Kafka 与 Zookeeper 的脑裂问题解决</strong></a></li><li><a href=#网络分区的表现>网络分区的表现：</a></li><li><a href=#在-zookeeper-中的影响>在 Zookeeper 中的影响：</a></li><li><a href=#网络分区的解决方法>网络分区的解决方法：</a></li></ul></li><li><a href=#开发能力有没有flask的前端页面怎么做>开发能力有没有？flask的，前端页面怎么做？</a><ul><li><a href=#前端vuejs-和-flask-配合>前端：Vue.js 和 Flask 配合</a></li><li><a href=#结构概览>结构概览：</a></li><li><a href=#部署>部署：</a></li><li><a href=#1-主机管理和配置管理>1. <strong>主机管理和配置管理</strong>：</a></li><li><a href=#2-ssh-远程登录管理>2. <strong>SSH 远程登录管理</strong>：</a></li><li><a href=#3-日志管理与集中式日志分析>3. <strong>日志管理与集中式日志分析</strong>：</a></li><li><a href=#4-主机监控与报警>4. <strong>主机监控与报警</strong>：</a></li><li><a href=#5-自动化运维任务管理>5. <strong>自动化运维任务管理</strong>：</a></li><li><a href=#具体实现思路>具体实现思路：</a></li><li><a href=#示例架构>示例架构：</a></li><li><a href=#总结-7>总结：</a></li></ul></li><li><a href=#k8s的cni用的啥网络扁平网络跨层跨墙>k8s的cni用的啥，网络，扁平网络，跨层，跨墙，</a></li><li><a href=#子网可能a类-b类跨墙的这种怎么解决>子网可能A类 B类，跨墙的这种，怎么解决</a></li><li><a href=#换工作的原因>换工作的原因</a></li><li><a href=#自我介绍离职原因有无offer多久到岗>自我介绍，离职原因，有无offer，多久到岗。</a></li><li><a href=#印象比较深的中间件排障的经验>印象比较深的中间件排障的经验？</a><ul><li><a href=#1-kafka-集群的脑裂问题>1. <strong>Kafka 集群的脑裂问题</strong></a></li><li><a href=#2-redis-主从复制延迟问题>2. <strong>Redis 主从复制延迟问题</strong></a></li><li><a href=#3-nginx-高并发下的资源耗尽>3. <strong>Nginx 高并发下的资源耗尽</strong></a></li><li><a href=#4-zookeeper-的节点丢失>4. <strong>Zookeeper 的节点丢失</strong></a></li><li><a href=#总结-8>总结</a></li><li><a href=#故障转移后应用连接问题的原因>故障转移后应用连接问题的原因</a></li><li><a href=#解决方案与恢复步骤>解决方案与恢复步骤</a></li><li><a href=#总结-9>总结</a></li></ul></li><li><a href=#编程语言熟悉哪个实现最复杂的功能>编程语言熟悉哪个？实现最复杂的功能？</a><ul><li><a href=#1-flask-项目>1. <strong>Flask 项目：</strong></a></li><li><a href=#2-django-项目>2. <strong>Django 项目：</strong></a></li><li><a href=#总结-10>总结：</a></li></ul></li><li><a href=#k8s的operator用过吗helm用过吗>k8s的operator用过吗？helm用过吗？</a><ul><li><a href=#创建-helm-chart>创建 Helm Chart</a></li><li><a href=#步骤-5-部署-flask-应用>步骤 5: 部署 Flask 应用</a></li><li><a href=#步骤-6-检查部署状态>步骤 6: 检查部署状态</a></li></ul></li><li><a href=#故障复盘怎么做的>故障复盘怎么做的</a><ul><li><a href=#1-准备工作>1. <strong>准备工作</strong></a></li><li><a href=#2-回顾故障事件>2. <strong>回顾故障事件</strong></a></li><li><a href=#3-确定故障原因>3. <strong>确定故障原因</strong></a></li><li><a href=#4-评估响应过程>4. <strong>评估响应过程</strong></a></li><li><a href=#5-总结问题及其影响>5. <strong>总结问题及其影响</strong></a></li><li><a href=#6-制定改进计划>6. <strong>制定改进计划</strong></a></li><li><a href=#7-改进措施的执行>7. <strong>改进措施的执行</strong></a></li><li><a href=#8-撰写故障复盘报告>8. <strong>撰写故障复盘报告</strong></a></li><li><a href=#9-后续跟进>9. <strong>后续跟进</strong></a></li><li><a href=#总结-11>总结</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=上海外包太平洋保险>上海外包太平洋保险
<a class=anchor href=#%e4%b8%8a%e6%b5%b7%e5%a4%96%e5%8c%85%e5%a4%aa%e5%b9%b3%e6%b4%8b%e4%bf%9d%e9%99%a9>#</a></h2><h2 id=有完成过ansible比较复杂的role-task的编写吗>有完成过ansible比较复杂的role task的编写吗？
<a class=anchor href=#%e6%9c%89%e5%ae%8c%e6%88%90%e8%bf%87ansible%e6%af%94%e8%be%83%e5%a4%8d%e6%9d%82%e7%9a%84role-task%e7%9a%84%e7%bc%96%e5%86%99%e5%90%97>#</a></h2><p>是的，基于你的需求描述，我可以帮你了解和完成一些复杂的 Ansible Role 和 Task 编写。以下是一些示例场景：</p><h3 id=1-完整的-kubernetes-集群节点加入-role-编写><strong>1. 完整的 Kubernetes 集群节点加入 Role 编写</strong>
<a class=anchor href=#1-%e5%ae%8c%e6%95%b4%e7%9a%84-kubernetes-%e9%9b%86%e7%be%a4%e8%8a%82%e7%82%b9%e5%8a%a0%e5%85%a5-role-%e7%bc%96%e5%86%99>#</a></h3><p>假设你需要使用 Ansible 创建一个完整的 Kubernetes 节点加入过程，包含以下内容：</p><ul><li><strong>创建目录结构和配置文件</strong></li><li><strong>二进制文件下载和分发</strong></li><li><strong><code>systemd</code> 服务文件创建和启用</strong></li><li><strong>配置文件模板化（<code>kubelet</code>，<code>kube-proxy</code>，<code>CNI</code> 插件等）</strong></li><li><strong>节点标签和调度禁用操作</strong></li><li><strong><code>kubelet</code>、<code>kube-proxy</code> 等服务的启动管理</strong></li></ul><h3 id=2-ansible-role-示例><strong>2. Ansible Role 示例</strong>
<a class=anchor href=#2-ansible-role-%e7%a4%ba%e4%be%8b>#</a></h3><p>一个复杂的 Role 可能包含以下几个部分：</p><h4 id=tasksmainyml><strong><code>tasks/main.yml</code></strong>
<a class=anchor href=#tasksmainyml>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#75715e># 安装并配置 Kubernetes 组件（如 kubelet 和 kube-proxy）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建 Kubernetes 相关目录</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>file</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: <span style=color:#e6db74>&#34;{{ item }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>directory</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>owner</span>: <span style=color:#ae81ff>root</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>group</span>: <span style=color:#ae81ff>root</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;0755&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with_items</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>/var/lib/kubelet</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>/var/lib/kube-proxy</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>/etc/cni/net.d</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>/opt/cni/bin</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>分发 kubelet 和 kube-proxy 二进制文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;{{ base_dir }}/bin/{{ item }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#e6db74>&#34;{{ bin_dir }}/{{ item }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;0755&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with_items</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>kubectl</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>kubelet</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>kube-proxy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>分发 CNI 插件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>copy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#e6db74>&#34;{{ item }}&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#ae81ff>/opt/cni/bin/</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;0755&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with_fileglob</span>:
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#34;{{ base_dir }}/bin/cni-bin/*&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建 kubelet 和 kube-proxy 配置文件</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建 kubelet 配置文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#ae81ff>kubelet-config.yaml.j2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#ae81ff>/var/lib/kubelet/config.yaml</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>configure_kubelet</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建 kube-proxy 配置文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#ae81ff>kube-proxy-config.yaml.j2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#ae81ff>/var/lib/kube-proxy/kube-proxy-config.yaml</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>configure_kubeproxy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建 kubelet 和 kube-proxy 的 systemd 服务</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建 kubelet systemd 服务文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#ae81ff>kubelet.service.j2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#ae81ff>/etc/systemd/system/kubelet.service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>manage_services</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>创建 kube-proxy systemd 服务文件</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>src</span>: <span style=color:#ae81ff>kube-proxy.service.j2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>dest</span>: <span style=color:#ae81ff>/etc/systemd/system/kube-proxy.service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>manage_services</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启用并启动服务</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>启用 kubelet 服务</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>systemd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kubelet</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>yes</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>started</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>manage_services</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>启用 kube-proxy 服务</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>systemd</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kube-proxy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>yes</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>state</span>: <span style=color:#ae81ff>started</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>manage_services</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 节点加入 Kubernetes 集群并设置角色标签</span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>设置 Kubernetes 节点角色标签</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#e6db74>&#34;{{ kubectl_bin }} label node {{ inventory_hostname }} kubernetes.io/role={{ node_role }} --overwrite&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>configure_node_role</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>节点调度控制</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>shell</span>: <span style=color:#e6db74>&#34;{{ kubectl_bin }} cordon {{ inventory_hostname }}&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>node_role == &#34;master&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tags</span>: <span style=color:#ae81ff>configure_node_role</span>
</span></span></code></pre></div><h4 id=templateskubelet-configyamlj2><strong><code>templates/kubelet-config.yaml.j2</code></strong>
<a class=anchor href=#templateskubelet-configyamlj2>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kubelet.config.k8s.io/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>KubeletConfiguration</span>
</span></span><span style=display:flex><span><span style=color:#f92672>address</span>: <span style=color:#ae81ff>0.0.0.0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>port</span>: <span style=color:#ae81ff>10250</span>
</span></span><span style=display:flex><span><span style=color:#f92672>readOnlyPort</span>: <span style=color:#ae81ff>10255</span>
</span></span><span style=display:flex><span><span style=color:#f92672>clusterDNS</span>:
</span></span><span style=display:flex><span>  - {{ <span style=color:#ae81ff>cluster_dns }}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>clusterDomain</span>: {{ <span style=color:#ae81ff>cluster_domain }}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>resolvConf</span>: <span style=color:#ae81ff>/run/systemd/resolve/resolv.conf</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h4 id=templateskube-proxy-configyamlj2><strong><code>templates/kube-proxy-config.yaml.j2</code></strong>
<a class=anchor href=#templateskube-proxy-configyamlj2>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kubeproxy.config.k8s.io/v1alpha1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>KubeProxyConfiguration</span>
</span></span><span style=display:flex><span><span style=color:#f92672>mode</span>: <span style=color:#ae81ff>iptables</span>
</span></span><span style=display:flex><span><span style=color:#f92672>clusterCIDR</span>: {{ <span style=color:#ae81ff>cluster_cidr }}</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h4 id=templateskubeletservicej2><strong><code>templates/kubelet.service.j2</code></strong>
<a class=anchor href=#templateskubeletservicej2>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Kubernetes Kubelet</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Documentation</span><span style=color:#f92672>=</span><span style=color:#e6db74>https://kubernetes.io/docs/home/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Requires</span><span style=color:#f92672>=</span><span style=color:#e6db74>docker.service</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>{{ bin_dir }}/kubelet \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  --config={{ config_dir }}/kubelet/config.yaml \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  --kubeconfig={{ kubeconfig_path }}</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>always</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>RestartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>10s</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><h4 id=templateskube-proxyservicej2><strong><code>templates/kube-proxy.service.j2</code></strong>
<a class=anchor href=#templateskube-proxyservicej2>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Kubernetes Kube Proxy</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>After</span><span style=color:#f92672>=</span><span style=color:#e6db74>network.target</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>{{ bin_dir }}/kube-proxy \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  --config={{ config_dir }}/kube-proxy/kube-proxy-config.yaml \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  --kubeconfig={{ kubeconfig_path }}</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Restart</span><span style=color:#f92672>=</span><span style=color:#e6db74>always</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>RestartSec</span><span style=color:#f92672>=</span><span style=color:#e6db74>10s</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><h3 id=3-role-的配置文件结构><strong>3. Role 的配置文件结构</strong>
<a class=anchor href=#3-role-%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84>#</a></h3><p>可以在 Role 中定义一个清晰的目录结构，包括以下文件：</p><ul><li><code>tasks/main.yml</code>：定义了整个 Role 的执行任务。</li><li><code>defaults/main.yml</code>：定义该 Role 的默认变量，可以为所有的任务设置默认值。</li><li><code>vars/main.yml</code>：可以为该 Role 提供更具体的变量设置。</li><li><code>files/</code>：存放需要分发的静态文件。</li><li><code>templates/</code>：存放 Jinja2 模板文件，用于生成动态的配置文件。</li><li><code>handlers/main.yml</code>：包含一些事件触发时要执行的任务，例如服务重启。</li></ul><h3 id=4-执行过程><strong>4. 执行过程</strong>
<a class=anchor href=#4-%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b>#</a></h3><p>当你执行这个 Role 时，Ansible 会：</p><ol><li>确保目标节点上所有的目录和文件已正确创建。</li><li>下载并分发 <code>kubelet</code>, <code>kube-proxy</code> 和 <code>kubectl</code> 等二进制文件。</li><li>配置节点所需的配置文件（包括 <code>kubelet</code>, <code>kube-proxy</code> 配置和 <code>systemd</code> 服务）。</li><li>启动并管理服务（<code>kubelet</code>, <code>kube-proxy</code>），确保它们在系统启动时自动启动。</li><li>在 Kubernetes 集群中为节点添加正确的标签，确保节点能够被正确调度。</li></ol><h3 id=总结><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><p>这种方式的优点是，Role 和 Task 的模块化设计使得你可以非常清晰地管理 Kubernetes 节点的加入过程，且能够重复使用和扩展。如果有多个节点加入集群，只需要在 <code>inventory</code> 中配置好节点信息，运行相同的 Role 即可。</p><p>你可以根据自己的需求，修改模板文件和任务，进行个性化的配置和优化。如果你有任何更复杂的需求，或者需要具体实现某个部分，可以继续讨论和调整。</p><h2 id=defaultsmainyml定义该-role-的默认变量可以为所有的任务设置默认值-varsmainyml可以为该-role-提供更具体的变量设置-谁的优先级更高>defaults/main.yml：定义该 Role 的默认变量，可以为所有的任务设置默认值。 vars/main.yml：可以为该 Role 提供更具体的变量设置。 谁的优先级更高
<a class=anchor href=#defaultsmainyml%e5%ae%9a%e4%b9%89%e8%af%a5-role-%e7%9a%84%e9%bb%98%e8%ae%a4%e5%8f%98%e9%87%8f%e5%8f%af%e4%bb%a5%e4%b8%ba%e6%89%80%e6%9c%89%e7%9a%84%e4%bb%bb%e5%8a%a1%e8%ae%be%e7%bd%ae%e9%bb%98%e8%ae%a4%e5%80%bc-varsmainyml%e5%8f%af%e4%bb%a5%e4%b8%ba%e8%af%a5-role-%e6%8f%90%e4%be%9b%e6%9b%b4%e5%85%b7%e4%bd%93%e7%9a%84%e5%8f%98%e9%87%8f%e8%ae%be%e7%bd%ae-%e8%b0%81%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7%e6%9b%b4%e9%ab%98>#</a></h2><p>在 Ansible 中，<code>defaults/main.yml</code> 和 <code>vars/main.yml</code> 都是用来存储变量的文件，但它们的优先级不同：</p><h3 id=优先级><strong>优先级</strong>
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7>#</a></h3><ul><li><strong><code>defaults/main.yml</code></strong>：这是定义变量的默认值文件。它的优先级最低，意味着如果在其他地方（如 playbook、命令行、<code>vars/main.yml</code>）定义了同样的变量，<code>defaults</code> 中的值会被覆盖。</li><li><strong><code>vars/main.yml</code></strong>：这是一个更具体的变量定义文件，优先级高于 <code>defaults</code>。如果变量在 <code>vars/main.yml</code> 中定义，那么 <code>defaults</code> 中的值会被覆盖。</li></ul><h3 id=优先级顺序><strong>优先级顺序：</strong>
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e9%a1%ba%e5%ba%8f>#</a></h3><p>Ansible 中变量的优先级从低到高为：</p><ol><li><strong><code>defaults</code> 中的变量</strong>（优先级最低）</li><li><strong><code>vars</code> 中的变量</strong></li><li><strong>playbook 中定义的变量</strong></li><li><strong>命令行参数定义的变量</strong>（<code>-e</code>）</li></ol><h3 id=例子><strong>例子</strong>
<a class=anchor href=#%e4%be%8b%e5%ad%90>#</a></h3><p>假设你有以下两个文件：</p><h4 id=defaultsmainyml><code>defaults/main.yml</code>
<a class=anchor href=#defaultsmainyml>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># defaults/main.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>my_variable</span>: <span style=color:#e6db74>&#34;default_value&#34;</span>
</span></span></code></pre></div><h4 id=varsmainyml><code>vars/main.yml</code>
<a class=anchor href=#varsmainyml>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># vars/main.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>my_variable</span>: <span style=color:#e6db74>&#34;vars_value&#34;</span>
</span></span></code></pre></div><h4 id=使用时>使用时
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e6%97%b6>#</a></h4><ul><li><strong>如果只包含 <code>vars/main.yml</code></strong>，则 <code>my_variable</code> 会是 <code>"vars_value"</code>。</li><li><strong>如果在 playbook 中覆盖变量</strong>，例如：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>vars</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>my_variable</span>: <span style=color:#e6db74>&#34;playbook_value&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>my_role</span>
</span></span></code></pre></div><p>此时，<code>my_variable</code> 将会是 <code>"playbook_value"</code>。</p><h3 id=总结-1><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-1>#</a></h3><ul><li><code>vars/main.yml</code> 的优先级高于 <code>defaults/main.yml</code>，因此它会覆盖 <code>defaults</code> 中定义的变量值。</li><li><code>defaults/main.yml</code> 主要用于定义最基础的默认值，而 <code>vars/main.yml</code> 用于为该 Role 提供具体或自定义的变量值。</li></ul><h2 id=集群多少规模多大用ansible部署>集群多少？规模多大？用ansible部署。
<a class=anchor href=#%e9%9b%86%e7%be%a4%e5%a4%9a%e5%b0%91%e8%a7%84%e6%a8%a1%e5%a4%9a%e5%a4%a7%e7%94%a8ansible%e9%83%a8%e7%bd%b2>#</a></h2><h2 id=ansible变量的优先级变量的优先级怎么去设置同一变量可能出现在playbook的多个地方>ansible变量的优先级？变量的优先级怎么去设置，同一变量可能出现在playbook的多个地方
<a class=anchor href=#ansible%e5%8f%98%e9%87%8f%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7%e5%8f%98%e9%87%8f%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7%e6%80%8e%e4%b9%88%e5%8e%bb%e8%ae%be%e7%bd%ae%e5%90%8c%e4%b8%80%e5%8f%98%e9%87%8f%e5%8f%af%e8%83%bd%e5%87%ba%e7%8e%b0%e5%9c%a8playbook%e7%9a%84%e5%a4%9a%e4%b8%aa%e5%9c%b0%e6%96%b9>#</a></h2><h2 id=你是如何用优先级去控制变量的正确性>你是如何用优先级去控制变量的正确性？
<a class=anchor href=#%e4%bd%a0%e6%98%af%e5%a6%82%e4%bd%95%e7%94%a8%e4%bc%98%e5%85%88%e7%ba%a7%e5%8e%bb%e6%8e%a7%e5%88%b6%e5%8f%98%e9%87%8f%e7%9a%84%e6%ad%a3%e7%a1%ae%e6%80%a7>#</a></h2><p>在 Ansible 中，变量的优先级是根据特定的加载顺序来决定的。理解这些优先级非常重要，因为同一个变量可能出现在多个地方，优先级决定了最终使用哪个值。</p><h3 id=ansible-变量的优先级从低到高><strong>Ansible 变量的优先级（从低到高）</strong>
<a class=anchor href=#ansible-%e5%8f%98%e9%87%8f%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7%e4%bb%8e%e4%bd%8e%e5%88%b0%e9%ab%98>#</a></h3><p>Ansible 变量的优先级按照以下顺序排列，低优先级的会被高优先级的变量覆盖：</p><ol><li><strong>Role 的 <code>defaults/main.yml</code> 文件</strong>
这是为 Role 设置的默认值，优先级最低。如果没有其他地方定义变量，默认值将被使用。</li><li><strong>Role 的 <code>vars/main.yml</code> 文件</strong>
该文件优先级高于 <code>defaults</code>，但是低于 <code>playbook</code> 和命令行中的变量。</li><li><strong>Inventory 文件中的变量</strong>
在 Ansible 的 inventory 文件（包括 <code>host_vars</code> 和 <code>group_vars</code>）中设置的变量，优先级高于 <code>defaults</code> 和 <code>vars</code> 文件，但低于 playbook 中的变量和命令行参数。</li><li><strong>Playbook 中定义的变量</strong>
在 <code>playbook</code> 中直接定义的变量，优先级高于 <code>defaults</code>、<code>vars</code>、以及 <code>inventory</code> 中的变量。</li><li><strong>命令行定义的变量（<code>-e</code> 或 <code>--extra-vars</code>）</strong>
使用 <code>-e</code> 或 <code>--extra-vars</code> 参数时在命令行上定义的变量，优先级最高，会覆盖所有其他来源的变量。</li><li><strong>Facts</strong>
通过 <code>setup</code> 模块或 <code>ansible_facts</code> 获取的系统信息，也会以变量的形式传递，通常优先级较低，但依然可以影响变量的值，除非它在更高优先级的地方被覆盖。</li></ol><h3 id=优先级的示意图><strong>优先级的示意图：</strong>
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e7%9a%84%e7%a4%ba%e6%84%8f%e5%9b%be>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>    [Defaults]
</span></span><span style=display:flex><span>        ↓
</span></span><span style=display:flex><span>    [Vars (role)]
</span></span><span style=display:flex><span>        ↓
</span></span><span style=display:flex><span>    [Inventory (group_vars/host_vars)]
</span></span><span style=display:flex><span>        ↓
</span></span><span style=display:flex><span>    [Playbook]
</span></span><span style=display:flex><span>        ↓
</span></span><span style=display:flex><span>    [Command-line (-e)]
</span></span><span style=display:flex><span>        ↓
</span></span><span style=display:flex><span>    [Facts]
</span></span></code></pre></div><h3 id=优先级控制变量正确性的方法><strong>优先级控制变量正确性的方法：</strong>
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e6%8e%a7%e5%88%b6%e5%8f%98%e9%87%8f%e6%ad%a3%e7%a1%ae%e6%80%a7%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h3><h4 id=1-适当使用默认值><strong>1. 适当使用默认值</strong>
<a class=anchor href=#1-%e9%80%82%e5%bd%93%e4%bd%bf%e7%94%a8%e9%bb%98%e8%ae%a4%e5%80%bc>#</a></h4><p>在 <code>defaults/main.yml</code> 中设置变量的默认值，确保如果没有提供变量时，系统会使用合理的默认值。这是保持变量正确性的一种方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># defaults/main.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>my_var</span>: <span style=color:#e6db74>&#34;default_value&#34;</span>
</span></span></code></pre></div><h4 id=2-覆盖默认值><strong>2. 覆盖默认值</strong>
<a class=anchor href=#2-%e8%a6%86%e7%9b%96%e9%bb%98%e8%ae%a4%e5%80%bc>#</a></h4><p>可以在 <code>vars/main.yml</code> 中根据实际需要调整变量，覆盖默认值。使用 <code>vars/main.yml</code> 可以为某个 Role 提供具体的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># vars/main.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>my_var</span>: <span style=color:#e6db74>&#34;role_specific_value&#34;</span>
</span></span></code></pre></div><h4 id=3-playbook-中定义变量><strong>3. Playbook 中定义变量</strong>
<a class=anchor href=#3-playbook-%e4%b8%ad%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f>#</a></h4><p>在 Playbook 中可以根据具体的主机、组、或任务来定义变量，这样可以灵活调整每个节点的配置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>vars</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>my_var</span>: <span style=color:#e6db74>&#34;playbook_specific_value&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>my_role</span>
</span></span></code></pre></div><h4 id=4-使用命令行变量><strong>4. 使用命令行变量</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%98%e9%87%8f>#</a></h4><p>如果你希望在运行 Playbook 时指定变量的值，可以使用 <code>-e</code> 参数来定义，这样可以覆盖其他所有地方的定义。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ansible-playbook -e <span style=color:#e6db74>&#34;my_var=command_line_value&#34;</span> playbook.yml
</span></span></code></pre></div><h4 id=5-结合条件判断><strong>5. 结合条件判断</strong>
<a class=anchor href=#5-%e7%bb%93%e5%90%88%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad>#</a></h4><p>通过 <code>when</code> 判断来控制变量的赋值，以此来确保在某些条件下使用特定的变量值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Set value based on condition</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>set_fact</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>my_var</span>: <span style=color:#e6db74>&#34;specific_value&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>when</span>: <span style=color:#ae81ff>ansible_facts[&#39;os_family&#39;] == &#34;Debian&#34;</span>
</span></span></code></pre></div><h4 id=6-优先级的注意事项><strong>6. 优先级的注意事项</strong>
<a class=anchor href=#6-%e4%bc%98%e5%85%88%e7%ba%a7%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h4><ul><li><strong>避免混乱</strong>：如果多个地方都设置了同一个变量，要清楚地知道哪个地方会最终生效。可以通过 <code>-v</code> 或 <code>-vvv</code> 来查看变量的实际值。</li><li><strong>严格管理 <code>vars</code> 和 <code>defaults</code></strong>：一般来说，<code>defaults</code> 是用来设置默认值的，而 <code>vars</code> 用于更具体的配置。如果在 <code>vars</code> 中设置的值依赖于 <code>defaults</code> 中的值，确保 <code>vars</code> 中不会覆盖 <code>defaults</code> 中设置的合理值。</li></ul><h3 id=优先级应用场景><strong>优先级应用场景：</strong>
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><ol><li><strong>跨主机的变量管理</strong>：通过 <code>inventory</code> 和 <code>group_vars</code> 配置变量，可以确保某个组的所有主机使用同一套配置，而不同组的主机配置可以有不同的值。</li><li><strong>Role 内的变量控制</strong>：Role 的 <code>defaults</code> 和 <code>vars</code> 用于区分默认值和具体配置。当同一变量在多个地方设置时，优先级顺序可以帮助你控制最终的值。</li><li><strong>灵活覆盖变量</strong>：在执行 Playbook 时，可以使用命令行中的 <code>-e</code> 参数来动态覆盖变量值，这对于一些临时的配置变更非常有用。</li></ol><h3 id=如何控制变量的正确性><strong>如何控制变量的正确性</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e6%8e%a7%e5%88%b6%e5%8f%98%e9%87%8f%e7%9a%84%e6%ad%a3%e7%a1%ae%e6%80%a7>#</a></h3><ul><li><strong>文档化变量</strong>：确保所有的变量都有明确的文档说明，并且告诉团队成员如何覆盖默认值，避免不必要的覆盖。</li><li><strong>合理使用 <code>defaults</code> 和 <code>vars</code></strong>：不要随便在 <code>playbook</code> 中覆盖变量，尽量使用 <code>defaults</code> 和 <code>vars</code> 来管理变量，这样可以保证统一性。</li><li><strong>调试和检查变量</strong>：使用 <code>debug</code> 模块输出变量的值，特别是在复杂的 Role 和 Playbook 中，可以帮助你调试和验证变量的正确性。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Print the value of my_var</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>debug</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>var</span>: <span style=color:#ae81ff>my_var</span>
</span></span></code></pre></div><ul><li><strong>避免冗余变量定义</strong>：同一变量不应该出现在多个地方，否则容易混淆。确保变量的定义在合适的位置。</li></ul><p>通过合理的管理和优先级控制，你可以有效避免变量值混乱的问题，确保 Playbook 的可预测性和正确性。</p><h2 id=playbook的role存在多个子的role那么如何让控制好他的执行顺序>playbook的role存在多个子的role，那么如何让控制好他的执行顺序？
<a class=anchor href=#playbook%e7%9a%84role%e5%ad%98%e5%9c%a8%e5%a4%9a%e4%b8%aa%e5%ad%90%e7%9a%84role%e9%82%a3%e4%b9%88%e5%a6%82%e4%bd%95%e8%ae%a9%e6%8e%a7%e5%88%b6%e5%a5%bd%e4%bb%96%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f>#</a></h2><p>在 Ansible 中，如果一个 Playbook 包含多个子 Role，可以通过以下几种方式控制它们的执行顺序：</p><h3 id=1-role-执行顺序role-顺序是基于-playbook-中的定义顺序来决定的>1. <strong>Role 执行顺序：Role 顺序是基于 Playbook 中的定义顺序来决定的</strong>
<a class=anchor href=#1-role-%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8frole-%e9%a1%ba%e5%ba%8f%e6%98%af%e5%9f%ba%e4%ba%8e-playbook-%e4%b8%ad%e7%9a%84%e5%ae%9a%e4%b9%89%e9%a1%ba%e5%ba%8f%e6%9d%a5%e5%86%b3%e5%ae%9a%e7%9a%84>#</a></h3><p>Playbook 中 Role 的执行顺序是按照它们在 <code>roles</code> 部分的出现顺序来执行的，Ansible 会按顺序逐个执行各个 Role。如果你有多个子 Role，Ansible 会依次执行这些 Role，直到所有的 Role 执行完成。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_A</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_B</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_C</span>
</span></span></code></pre></div><p>在这个例子中，Role <code>role_A</code> 会首先执行，然后是 <code>role_B</code> 和 <code>role_C</code>。Ansible 会按照顺序执行它们。</p><h3 id=2-使用>2. <strong>使用 <code>dependencies</code> 控制 Role 的执行顺序</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8>#</a></h3><p>如果一个 Role 依赖于另一个 Role，Ansible 提供了 <code>dependencies</code> 字段，可以在 Role 中明确指定依赖关系。通过这种方式，你可以控制 Role 的执行顺序，确保某些 Role 在其他 Role 之前执行。</p><p><strong>示例：</strong> 假设 <code>role_B</code> 依赖 <code>role_A</code>，可以在 <code>role_B</code> 中通过 <code>meta/main.yml</code> 文件指定依赖。</p><p><code>role_B/meta/main.yml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>dependencies</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_A</span>
</span></span></code></pre></div><p>这样，Ansible 会首先执行 <code>role_A</code>，然后执行 <code>role_B</code>。</p><h3 id=3-在-playbook-中使用>3. <strong>在 Playbook 中使用 <code>pre_tasks</code> 和 <code>post_tasks</code> 控制执行顺序</strong>
<a class=anchor href=#3-%e5%9c%a8-playbook-%e4%b8%ad%e4%bd%bf%e7%94%a8>#</a></h3><p><code>pre_tasks</code> 和 <code>post_tasks</code> 可以让你在 Role 执行之前或之后执行任务，从而间接控制 Role 的执行顺序。</p><ul><li><strong><code>pre_tasks</code></strong>：在 Role 执行之前执行任务。</li><li><strong><code>post_tasks</code></strong>：在 Role 执行之后执行任务。</li></ul><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>pre_tasks</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Run some task before roles</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>echo &#34;This runs before the roles&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>role_A</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>role_B</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f92672>post_tasks</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>Run some task after roles</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>echo &#34;This runs after the roles&#34;</span>
</span></span></code></pre></div><p>在这个示例中，<code>pre_tasks</code> 在 Role 执行之前执行，<code>post_tasks</code> 在所有 Role 执行之后执行。</p><h3 id=4-利用>4. <strong>利用 <code>tags</code> 控制 Role 的执行顺序</strong>
<a class=anchor href=#4-%e5%88%a9%e7%94%a8>#</a></h3><p>如果你想选择性地运行某些 Role，可以通过 <code>tags</code> 来控制。你可以在 Playbook 中为不同的 Role 或任务设置不同的标签，并在命令行运行时指定要运行的标签。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_A</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>tags</span>: [<span style=color:#ae81ff>role_A]</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_B</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>tags</span>: [<span style=color:#ae81ff>role_B]</span>
</span></span></code></pre></div><p>在执行时，你可以指定只运行某些 Role：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ansible-playbook playbook.yml --tags <span style=color:#e6db74>&#34;role_A&#34;</span>
</span></span></code></pre></div><p><strong>注意</strong>：这个方法并不能控制 Role 执行的顺序，主要用于选择性地执行特定的 Role。</p><h3 id=5-条件判断来控制执行顺序>5. <strong>条件判断来控制执行顺序</strong>
<a class=anchor href=#5-%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad%e6%9d%a5%e6%8e%a7%e5%88%b6%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f>#</a></h3><p>有时你希望根据某些条件来决定 Role 是否执行，可以使用 <code>when</code> 语句在 Playbook 中对 Role 进行条件控制。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_A</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>when</span>: <span style=color:#ae81ff>ansible_facts[&#39;os_family&#39;] == &#39;Debian&#39;</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_B</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>when</span>: <span style=color:#ae81ff>ansible_facts[&#39;os_family&#39;] == &#39;RedHat&#39;</span>
</span></span></code></pre></div><p>通过这种方式，某个 Role 只有在符合特定条件时才会执行。</p><h3 id=6-使用>6. <strong>使用 <code>block</code> 来组合多个 Role</strong>
<a class=anchor href=#6-%e4%bd%bf%e7%94%a8>#</a></h3><p>你还可以使用 <code>block</code> 将多个 Role 分组，并通过控制块内的顺序来间接控制 Role 执行的顺序。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tasks</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>block</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_A</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_B</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>when</span>: <span style=color:#ae81ff>ansible_facts[&#39;os_family&#39;] == &#39;Debian&#39;</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>block</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_C</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_D</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>when</span>: <span style=color:#ae81ff>ansible_facts[&#39;os_family&#39;] == &#39;RedHat&#39;</span>
</span></span></code></pre></div><p>这样，你可以根据条件执行不同的 Role 顺序。</p><h3 id=7-使用>7. <strong>使用 <code>serial</code> 来控制并发执行</strong>
<a class=anchor href=#7-%e4%bd%bf%e7%94%a8>#</a></h3><p>如果你在多台主机上执行 Playbook，可以通过 <code>serial</code> 控制每次执行的主机数，进而间接控制每个主机上 Role 的执行顺序。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:#f92672>hosts</span>: <span style=color:#ae81ff>all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>serial</span>: <span style=color:#ae81ff>1</span>  <span style=color:#75715e># 每次只在一个主机上执行</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>roles</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>role_A</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>role_B</span>
</span></span></code></pre></div><h3 id=总结-2><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-2>#</a></h3><ul><li><strong>默认顺序</strong>：Role 的执行顺序由 Playbook 中的定义顺序决定。</li><li><strong><code>dependencies</code></strong>：通过 Role 内的 <code>meta/main.yml</code> 来控制 Role 之间的依赖关系。</li><li><strong><code>pre_tasks</code> 和 <code>post_tasks</code></strong>：在执行 Role 前后插入任务。</li><li><strong><code>tags</code></strong>：控制 Role 的选择性执行，适用于调试或特定环境。</li><li><strong>条件控制（<code>when</code>）</strong>：根据条件控制 Role 的执行。</li><li><strong><code>block</code></strong>：将多个 Role 组合在一起，控制执行顺序。</li><li><strong><code>serial</code></strong>：控制并发执行的主机数，可以间接控制执行顺序。</li></ul><p>通过上述方法，你可以灵活地控制 Ansible 中多个 Role 的执行顺序，从而确保配置和部署的正确性。</p><h2 id=meta用过吗role-task里面main里面第一个yaml还有个meta-在执行主的yaml前去调用这个的预先的执行meta的外部扩展的子>meta用过吗？role task里面main里面第一个yaml，还有个meta 在执行主的yaml前去调用这个的预先的，执行meta的外部扩展的子
<a class=anchor href=#meta%e7%94%a8%e8%bf%87%e5%90%97role-task%e9%87%8c%e9%9d%a2main%e9%87%8c%e9%9d%a2%e7%ac%ac%e4%b8%80%e4%b8%aayaml%e8%bf%98%e6%9c%89%e4%b8%aameta-%e5%9c%a8%e6%89%a7%e8%a1%8c%e4%b8%bb%e7%9a%84yaml%e5%89%8d%e5%8e%bb%e8%b0%83%e7%94%a8%e8%bf%99%e4%b8%aa%e7%9a%84%e9%a2%84%e5%85%88%e7%9a%84%e6%89%a7%e8%a1%8cmeta%e7%9a%84%e5%a4%96%e9%83%a8%e6%89%a9%e5%b1%95%e7%9a%84%e5%ad%90>#</a></h2><p>是的，<code>meta/main.yml</code> 文件在 Ansible Role 中的作用是用来定义 Role 的元数据，并且通常用于在 Role 中管理依赖关系（即 Role 之间的依赖），以及一些其他的角色级别的配置。</p><h3 id=metamainyml-的常见用途><code>meta/main.yml</code> 的常见用途：
<a class=anchor href=#metamainyml-%e7%9a%84%e5%b8%b8%e8%a7%81%e7%94%a8%e9%80%94>#</a></h3><ol><li><strong>管理 Role 的依赖</strong>：最常见的用途是定义 Role 之间的依赖关系。在 <code>meta/main.yml</code> 中通过 <code>dependencies</code> 字段，可以指定当前 Role 依赖的其他 Role。这样，Ansible 会在执行当前 Role 之前自动执行这些依赖的 Role。</li><li><strong>执行其他任务</strong>：你可以通过 <code>meta</code> 来指定一些任务，在 Role 执行之前或之后执行。<code>meta</code> 文件中的内容会被自动调用，但它本身并不是一个任务文件。</li></ol><h3 id=1-role-依赖配置>1. <strong>Role 依赖配置</strong>
<a class=anchor href=#1-role-%e4%be%9d%e8%b5%96%e9%85%8d%e7%bd%ae>#</a></h3><p>通过 <code>meta/main.yml</code> 文件中的 <code>dependencies</code> 字段，可以指定当前 Role 依赖其他的 Role。这些依赖的 Role 会在当前 Role 执行之前被执行。</p><p><strong>示例：</strong> 假设 <code>role_A</code> 依赖 <code>role_B</code>，那么你可以在 <code>role_A</code> 中通过 <code>meta/main.yml</code> 来指定 <code>role_B</code> 作为依赖。</p><p><code>role_A/meta/main.yml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>dependencies</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_B</span>
</span></span></code></pre></div><p>在这种情况下，当你在 Playbook 中调用 <code>role_A</code> 时，Ansible 会先执行 <code>role_B</code>，然后再执行 <code>role_A</code>。</p><h3 id=2-meta>2. <strong><code>meta</code> 在 Role 中的执行</strong>
<a class=anchor href=#2-meta>#</a></h3><p><code>meta/main.yml</code> 中的内容不会直接被作为 Playbook 中的任务执行。它的作用是用于 Role 的元数据定义，特别是依赖关系的定义，或者在特殊情况下用于调整 Role 执行的方式。例如，你可以用它来指定当 Role 执行失败时是否停止执行。</p><p><strong>示例：</strong> <code>role_A/meta/main.yml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>dependencies</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>role_B</span>
</span></span></code></pre></div><p>在上面的例子中，<code>role_A</code> 会先依赖 <code>role_B</code>，然后再执行它自己的任务。</p><h3 id=3-如何调用>3. <strong>如何调用 <code>meta</code> 里的内容</strong>
<a class=anchor href=#3-%e5%a6%82%e4%bd%95%e8%b0%83%e7%94%a8>#</a></h3><p><code>meta</code> 文件通常不需要在 Playbook 中直接调用。它是 Ansible 在执行 Role 时自动读取并执行的部分。通常，你不会在 Playbook 中手动调用 <code>meta/main.yml</code>，但会通过定义 Role 的依赖关系等，间接影响 Role 的执行顺序。</p><h3 id=注意事项><strong>注意事项</strong>：
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h3><ul><li><code>meta/main.yml</code> 中定义的 <code>dependencies</code> 会在执行当前 Role 之前自动执行，因此你无需手动指定执行顺序。</li><li><code>meta</code> 文件中的内容主要用来进行 Role 之间的依赖管理，确保在执行某些任务之前，其他必要的任务（比如依赖的 Role）已经完成。</li></ul><h3 id=4-metamainyml>4. <strong><code>meta/main.yml</code> 示例</strong>
<a class=anchor href=#4-metamainyml>#</a></h3><p>一个典型的 <code>meta/main.yml</code> 文件看起来可能是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>dependencies</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>common</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>apache</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>role</span>: <span style=color:#ae81ff>mysql</span>
</span></span></code></pre></div><p>在这个例子中，<code>meta/main.yml</code> 定义了当前 Role 需要依赖三个其他的 Role：<code>common</code>、<code>apache</code> 和 <code>mysql</code>，这些依赖的 Role 会在当前 Role 执行之前自动被执行。</p><h3 id=总结-3><strong>总结</strong>：
<a class=anchor href=#%e6%80%bb%e7%bb%93-3>#</a></h3><ul><li><strong><code>meta/main.yml</code></strong> 主要用于管理 Role 之间的依赖关系。</li><li>你不能在 Playbook 中直接调用 <code>meta/main.yml</code>，它是自动调用的，用来处理 Role 的执行顺序、依赖关系等。</li><li><code>dependencies</code> 字段是 <code>meta/main.yml</code> 中的核心功能，它会确保依赖的 Role 在当前 Role 执行前被执行。</li></ul><p>通过正确地使用 <code>meta</code>，你可以使多个 Role 之间的依赖关系变得更加明确，确保它们按顺序和正确的方式执行。</p><h2 id=除了用ansible部署k8s外上层的软件如何部署其他类似云原生的应用会部署哪些>除了用ansible部署k8s外上层的软件如何部署，其他类似云原生的应用会部署哪些？
<a class=anchor href=#%e9%99%a4%e4%ba%86%e7%94%a8ansible%e9%83%a8%e7%bd%b2k8s%e5%a4%96%e4%b8%8a%e5%b1%82%e7%9a%84%e8%bd%af%e4%bb%b6%e5%a6%82%e4%bd%95%e9%83%a8%e7%bd%b2%e5%85%b6%e4%bb%96%e7%b1%bb%e4%bc%bc%e4%ba%91%e5%8e%9f%e7%94%9f%e7%9a%84%e5%ba%94%e7%94%a8%e4%bc%9a%e9%83%a8%e7%bd%b2%e5%93%aa%e4%ba%9b>#</a></h2><p>除了使用 Ansible 部署 Kubernetes（K8s）外，上层的软件部署通常涉及云原生应用及相关的工具和服务。云原生应用通常具有容器化、微服务架构、持续集成与交付等特点，因此在 Kubernetes 上的部署会包括以下几类软件和工具：</p><h3 id=1-云原生应用部署>1. <strong>云原生应用部署</strong>
<a class=anchor href=#1-%e4%ba%91%e5%8e%9f%e7%94%9f%e5%ba%94%e7%94%a8%e9%83%a8%e7%bd%b2>#</a></h3><p>云原生应用通常是基于微服务架构构建的，部署时往往会用到容器化技术（Docker）和容器编排平台（Kubernetes）。除了 Kubernetes，常见的云原生应用和工具有：</p><h4 id=11-微服务应用>1.1 <strong>微服务应用</strong>
<a class=anchor href=#11-%e5%be%ae%e6%9c%8d%e5%8a%a1%e5%ba%94%e7%94%a8>#</a></h4><ul><li><p>Spring Boot</p><p>、</p><p>Node.js</p><p>、</p><p>Go</p><p>等常见框架的微服务应用。</p><ul><li>使用 Docker 容器化，将服务打包成容器镜像。</li><li>通过 Helm charts 或直接部署到 Kubernetes 上，管理其生命周期（部署、扩容、升级等）。</li></ul></li></ul><h4 id=12-服务网格-service-mesh>1.2 <strong>服务网格 (Service Mesh)</strong>
<a class=anchor href=#12-%e6%9c%8d%e5%8a%a1%e7%bd%91%e6%a0%bc-service-mesh>#</a></h4><ul><li><p>Istio</p><p>、</p><p>Linkerd</p><p>、</p><p>Consul</p><p>等服务网格可以在 Kubernetes 上帮助实现服务之间的管理和通信、流量控制、安全加密、故障恢复等功能。</p><ul><li>它们提供了微服务之间的服务发现、负载均衡、路由、限流、熔断等功能。</li><li>部署时，通常是通过 Helm charts 安装，或者直接在 Kubernetes 中创建相关的资源定义。</li></ul></li></ul><h4 id=13-cicd-工具链>1.3 <strong>CI/CD 工具链</strong>
<a class=anchor href=#13-cicd-%e5%b7%a5%e5%85%b7%e9%93%be>#</a></h4><ul><li><p>Jenkins</p><p>、</p><p>GitLab CI</p><p>、</p><p>ArgoCD</p><p>等工具用于自动化构建、测试、部署应用。</p><ul><li>Jenkins 可以通过 Kubernetes 插件直接与 Kubernetes 集群交互，动态创建 Pod 执行构建任务。</li><li>ArgoCD 用于 GitOps 模式下的持续交付，可以自动将 Git 仓库中的 YAML 文件同步到 Kubernetes 中。</li></ul></li></ul><h4 id=14-监控与日志>1.4 <strong>监控与日志</strong>
<a class=anchor href=#14-%e7%9b%91%e6%8e%a7%e4%b8%8e%e6%97%a5%e5%bf%97>#</a></h4><ul><li><p>Prometheus</p><p>、</p><p>Grafana</p><p>：用于监控和可视化 Kubernetes 集群及应用的性能。</p><ul><li>Prometheus 收集监控指标，Grafana 用来展示这些指标。</li></ul></li><li><p>Elasticsearch</p><p>、</p><p>Logstash</p><p>、</p><p>Kibana (ELK Stack)</p><p>：用于日志收集、存储、分析和可视化。</p><ul><li>将应用和 Kubernetes 中的日志集中到 ELK Stack，便于查看和分析。</li></ul></li></ul><h4 id=15-消息队列与流处理>1.5 <strong>消息队列与流处理</strong>
<a class=anchor href=#15-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%b8%8e%e6%b5%81%e5%a4%84%e7%90%86>#</a></h4><ul><li><p>Kafka</p><p>、</p><p>RabbitMQ</p><p>、</p><p>NATS</p><p>等消息队列系统，适用于微服务之间的异步通信。</p><ul><li>Kafka 经常与 Kubernetes 配合使用，在容器化环境下作为事件驱动架构的核心组件。</li></ul></li><li><p><strong>Apache Flink</strong>、<strong>Apache Pulsar</strong>：用于大数据流处理，能够处理来自多源的数据流，适合实时分析。</p></li></ul><h4 id=16-数据库与缓存>1.6 <strong>数据库与缓存</strong>
<a class=anchor href=#16-%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%8e%e7%bc%93%e5%ad%98>#</a></h4><ul><li><p><strong>MySQL</strong>、<strong>PostgreSQL</strong>、<strong>MariaDB</strong> 等传统关系型数据库。</p></li><li><p><strong>Redis</strong>、<strong>Memcached</strong>：用于缓存，提升数据访问速度。</p></li><li><p>Cassandra</p><p>、</p><p>MongoDB</p><p>、</p><p>ClickHouse</p><p>等 NoSQL 数据库。</p><ul><li>这些数据库系统可以通过 StatefulSets 或 Helm charts 部署到 Kubernetes 中，并配置高可用和备份策略。</li></ul></li></ul><h4 id=17-api-网关>1.7 <strong>API 网关</strong>
<a class=anchor href=#17-api-%e7%bd%91%e5%85%b3>#</a></h4><ul><li><p>Kong</p><p>、</p><p>Traefik</p><p>、</p><p>NGINX</p><p>等 API 网关，通常用于处理微服务之间的流量管理、身份验证、限流、负载均衡等功能。</p><ul><li>在 Kubernetes 上，通常将这些 API 网关部署为 Ingress 控制器，负责外部流量到集群内部服务的路由。</li></ul></li></ul><h4 id=18-存储与卷管理>1.8 <strong>存储与卷管理</strong>
<a class=anchor href=#18-%e5%ad%98%e5%82%a8%e4%b8%8e%e5%8d%b7%e7%ae%a1%e7%90%86>#</a></h4><ul><li><p>Ceph</p><p>、</p><p>GlusterFS</p><p>、</p><p>Rook</p><p>等分布式存储解决方案，能够为 Kubernetes 提供持久存储卷（Persistent Volumes）。</p><ul><li>Rook 通过在 Kubernetes 集群中运行 Ceph 或其他存储系统，简化了存储的部署和管理。</li></ul></li></ul><h4 id=19-容器注册中心>1.9 <strong>容器注册中心</strong>
<a class=anchor href=#19-%e5%ae%b9%e5%99%a8%e6%b3%a8%e5%86%8c%e4%b8%ad%e5%bf%83>#</a></h4><ul><li><p>Harbor</p><p>、</p><p>Docker Registry</p><p>：用于存储和管理容器镜像。</p><ul><li>Harbor 提供了企业级的镜像管理，支持身份认证、访问控制和审计日志。</li></ul></li></ul><h4 id=110-web-应用和服务>1.10 <strong>Web 应用和服务</strong>
<a class=anchor href=#110-web-%e5%ba%94%e7%94%a8%e5%92%8c%e6%9c%8d%e5%8a%a1>#</a></h4><ul><li><p>WordPress</p><p>、</p><p>Jenkins</p><p>、</p><p>Nextcloud</p><p>等 Web 应用通常也部署在 Kubernetes 上，利用 Helm charts 或直接使用 Kubernetes 配置文件（YAML）进行管理。</p><ul><li>Kubernetes 可以为这些 Web 应用提供高可用性、扩容、自动恢复等特性。</li></ul></li></ul><h3 id=2-多集群管理>2. <strong>多集群管理</strong>
<a class=anchor href=#2-%e5%a4%9a%e9%9b%86%e7%be%a4%e7%ae%a1%e7%90%86>#</a></h3><p>随着企业的云基础设施复杂化，通常需要管理多个 Kubernetes 集群。为了简化管理，可以部署一些跨集群的工具：</p><ul><li><strong>Rancher</strong>：提供多集群的管理，支持跨数据中心、跨云环境的 Kubernetes 集群统一管理。</li><li><strong>Federation</strong>：Kubernetes 的原生工具，允许跨多个集群的资源同步和共享。</li></ul><h3 id=3-容器编排与调度>3. <strong>容器编排与调度</strong>
<a class=anchor href=#3-%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e4%b8%8e%e8%b0%83%e5%ba%a6>#</a></h3><ul><li><strong>Kubernetes Operator</strong>：用于管理和自动化应用的生命周期管理。Operator 通过自定义控制器和 CRD（Custom Resource Definition）扩展 Kubernetes API，用于自动化管理特定应用（如数据库、消息队列等）的状态和操作。</li></ul><h3 id=4-安全管理与身份认证>4. <strong>安全管理与身份认证</strong>
<a class=anchor href=#4-%e5%ae%89%e5%85%a8%e7%ae%a1%e7%90%86%e4%b8%8e%e8%ba%ab%e4%bb%bd%e8%ae%a4%e8%af%81>#</a></h3><ul><li><p>HashiCorp Vault</p><p>：用于管理敏感数据，如数据库密码、API 密钥等。</p><ul><li>Kubernetes 可以与 Vault 集成，用于提供动态的密钥和凭证管理。</li></ul></li><li><p><strong>OPA (Open Policy Agent)</strong>：用于执行策略管理，例如权限管理、安全控制等。</p></li></ul><h3 id=5-自动化运维和弹性伸缩>5. <strong>自动化运维和弹性伸缩</strong>
<a class=anchor href=#5-%e8%87%aa%e5%8a%a8%e5%8c%96%e8%bf%90%e7%bb%b4%e5%92%8c%e5%bc%b9%e6%80%a7%e4%bc%b8%e7%bc%a9>#</a></h3><ul><li><strong>Helm</strong>：Kubernetes 的包管理工具，类似于 Linux 的 <code>apt</code> 或 <code>yum</code>，Helm 提供了一个标准化的方式来打包和管理 Kubernetes 应用。</li><li><strong>Keda</strong>：用于基于事件的自动伸缩，它通过事件驱动的方式来动态扩展 Kubernetes 上的应用。</li><li><strong>Argo Workflows</strong>：可以在 Kubernetes 上运行复杂的工作流和任务调度。</li></ul><h3 id=总结-4>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-4>#</a></h3><p>除了 K8s 作为容器编排平台，还涉及许多其他云原生应用和工具的部署，包括服务网格、CI/CD 工具、消息队列、监控系统、API 网关等。这些工具通常都需要部署在 Kubernetes 上，利用 Kubernetes 的容器化、自动化、扩展能力来提高应用的可管理性、可伸缩性、可靠性和安全性。</p><p>通过使用 Ansible 或其他自动化工具，我们可以将这些应用部署到 Kubernetes 集群中，并通过定义相关的配置文件（如 Helm charts、YAML 文件等）来实现集群内的服务部署、管理和调度。</p><h2 id=helm用吗成品helm部署的模版有个人去完成过吗>helm用吗？成品helm部署的模版有个人去完成过吗？
<a class=anchor href=#helm%e7%94%a8%e5%90%97%e6%88%90%e5%93%81helm%e9%83%a8%e7%bd%b2%e7%9a%84%e6%a8%a1%e7%89%88%e6%9c%89%e4%b8%aa%e4%ba%ba%e5%8e%bb%e5%ae%8c%e6%88%90%e8%bf%87%e5%90%97>#</a></h2><p>是的，Helm 是 Kubernetes 的一个非常常用的包管理工具，类似于 Linux 的 <code>apt</code> 或 <code>yum</code>，用于简化应用的安装和管理。通过 Helm，用户可以使用现成的 Helm charts 来快速部署应用，或者根据需求创建自定义的 Helm charts 来进行部署。</p><h3 id=helm-charts-的使用>Helm Charts 的使用
<a class=anchor href=#helm-charts-%e7%9a%84%e4%bd%bf%e7%94%a8>#</a></h3><ol><li><p><strong>成品 Helm Charts</strong>：</p><ul><li>很多常见的云原生应用（如 Redis、Nginx、Prometheus、Grafana 等）都已经有成品的 Helm charts，可以直接使用这些现成的 charts 来快速部署应用。</li><li>这些 charts 通常已经由社区或厂商进行了优化，并提供了很多可以配置的参数，能够支持不同环境下的需求。</li></ul></li><li><p><strong>自定义 Helm Charts</strong>：</p><ul><li>如果有更复杂的应用需求，可以自己编写 Helm charts。</li><li>Helm charts 包含了 <code>values.yaml</code>、<code>templates/</code> 等文件，可以定义 Kubernetes 资源的创建逻辑、应用配置、环境变量等。</li><li>用户可以根据自己的需求自定义模板文件，结合配置文件对应用进行精细化部署。</li></ul></li><li><p><strong>创建和管理 Helm Charts</strong>：</p><ul><li>创建 Helm charts 包含以下几个步骤：<ol><li>使用 <code>helm create</code> 命令生成基本的 Helm chart 结构。</li><li>编辑 <code>values.yaml</code> 文件，定义应用的配置项。</li><li>编辑 <code>templates/</code> 文件夹中的 Kubernetes YAML 模板，包含 Deployment、Service、Ingress 等资源定义。</li><li>使用 <code>helm install</code> 部署应用，使用 <code>helm upgrade</code> 进行更新。</li><li>可通过 <code>helm repo</code> 命令管理 Helm chart 仓库，方便下载和发布 charts。</li></ol></li></ul><p>这些步骤可以通过自动化工具（如 Ansible）来完成，尤其是在多环境、多集群部署时，Helm charts 配合 CI/CD 工具能够帮助高效管理。</p></li></ol><h3 id=helm-的优势>Helm 的优势
<a class=anchor href=#helm-%e7%9a%84%e4%bc%98%e5%8a%bf>#</a></h3><ul><li><strong>简化部署</strong>：Helm 将复杂的 Kubernetes 部署转化为简单的命令和配置，避免了手动编写大量 YAML 文件。</li><li><strong>版本管理</strong>：Helm charts 版本化，使得应用的升级和回滚变得更加简单。</li><li><strong>扩展性</strong>：通过 <code>values.yaml</code> 文件，Helm 可以支持根据不同的配置进行灵活的调整，支持多种部署场景。</li></ul><p>如果你有使用过 Helm 或想要尝试编写和管理 Helm charts，通常会用它来管理生产环境中容器化的应用，尤其是涉及到微服务架构的应用。</p><h2 id=内部的调优后期运维工作体现在哪>内部的调优，后期运维工作体现在哪？
<a class=anchor href=#%e5%86%85%e9%83%a8%e7%9a%84%e8%b0%83%e4%bc%98%e5%90%8e%e6%9c%9f%e8%bf%90%e7%bb%b4%e5%b7%a5%e4%bd%9c%e4%bd%93%e7%8e%b0%e5%9c%a8%e5%93%aa>#</a></h2><p>在内部的调优和后期运维中，主要的工作体现通常可以分为以下几个方面：</p><h3 id=1-性能优化>1. <strong>性能优化</strong>
<a class=anchor href=#1-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96>#</a></h3><ul><li><strong>资源调度和管理</strong>：根据应用的需求和系统的承载能力，合理分配 CPU、内存、存储等资源。比如在 Kubernetes 中，可以调整 Pod 的 <code>requests</code> 和 <code>limits</code>，设置合理的资源配额。</li><li><strong>网络优化</strong>：确保网络延迟和带宽充足，避免由于网络瓶颈造成的性能问题。这可能涉及负载均衡的配置优化（如调整 Nginx 或 HAProxy 的配置）、CNI 插件的优化等。</li><li><strong>存储优化</strong>：如果使用了分布式存储（如 Ceph 或 GlusterFS），需要对存储的 I/O 性能进行调优，确保存储层不会成为瓶颈。</li><li><strong>数据库优化</strong>：对数据库进行索引优化、查询优化、缓存策略调整等工作。对 MySQL、PostgreSQL、Redis 等数据库进行性能调优，确保它们能够高效运行。</li></ul><h3 id=2-高可用性和容错性设计>2. <strong>高可用性和容错性设计</strong>
<a class=anchor href=#2-%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7%e5%92%8c%e5%ae%b9%e9%94%99%e6%80%a7%e8%ae%be%e8%ae%a1>#</a></h3><ul><li><strong>监控与告警</strong>：通过工具如 Prometheus 和 Grafana，进行系统和应用的监控，确保能够实时了解系统的健康状况。设置合理的告警规则，及时响应故障。</li><li><strong>高可用架构</strong>：确保系统的高可用性，例如 Kubernetes 中配置 Pod 的副本数、使用自动故障转移机制（如 <code>PodDisruptionBudgets</code> 和 <code>Affinity</code> 策略）、确保服务在单点故障下不影响整体系统。</li><li><strong>容灾与备份</strong>：定期备份重要数据，确保在灾难恢复时可以快速恢复。例如，定期备份 etcd 数据，并确保备份的存储位置和频率合理。</li></ul><h3 id=3-自动化运维>3. <strong>自动化运维</strong>
<a class=anchor href=#3-%e8%87%aa%e5%8a%a8%e5%8c%96%e8%bf%90%e7%bb%b4>#</a></h3><ul><li><strong>自动化部署与管理</strong>：使用 Ansible、Helm 等工具进行应用和基础设施的自动化管理。通过 CI/CD 流水线（如 Jenkins、GitLab CI、ArgoCD 等）实现应用的自动化部署和更新。</li><li><strong>自动化修复</strong>：配置 Kubernetes 中的自愈机制，如 Pod 重启策略、自动扩缩容等，确保在节点或服务出现故障时，系统能够自动进行恢复。</li><li><strong>日志集中化与分析</strong>：部署 ELK Stack（Elasticsearch、Logstash、Kibana）或 Fluentd 等日志收集系统，集中管理和分析日志，提前发现系统异常。</li></ul><h3 id=4-安全性加强>4. <strong>安全性加强</strong>
<a class=anchor href=#4-%e5%ae%89%e5%85%a8%e6%80%a7%e5%8a%a0%e5%bc%ba>#</a></h3><ul><li><strong>身份和访问控制</strong>：确保系统的访问控制策略合理，如通过 Kubernetes RBAC（角色访问控制）控制对集群资源的访问权限，配置合适的用户权限。</li><li><strong>安全补丁管理</strong>：及时更新操作系统、容器引擎、Kubernetes、应用程序等的安全补丁，减少被攻击的风险。可以通过定期的 CVE 漏洞扫描和更新机制来确保安全性。</li><li><strong>加密和审计</strong>：对敏感数据进行加密存储，启用通信加密（如使用 TLS 加密客户端与服务端之间的通信），并通过 Kubernetes 审计日志功能，记录和监控访问行为。</li></ul><h3 id=5-问题排查与故障处理>5. <strong>问题排查与故障处理</strong>
<a class=anchor href=#5-%e9%97%ae%e9%a2%98%e6%8e%92%e6%9f%a5%e4%b8%8e%e6%95%85%e9%9a%9c%e5%a4%84%e7%90%86>#</a></h3><ul><li><strong>日志分析</strong>：通过日志分析工具（如 ELK、Fluentd 等），快速定位问题并采取措施。比如，系统出现异常时，可以通过日志查询和分析，找到根本原因并修复。</li><li><strong>性能瓶颈排查</strong>：利用工具如 <code>top</code>、<code>iotop</code>、<code>netstat</code>、<code>vmstat</code> 等诊断系统的性能瓶颈。Kubernetes 中可以使用 <code>kubectl top</code> 来查看 Pod 和节点的资源使用情况，找出资源使用过高的服务或 Pod。</li><li><strong>故障恢复</strong>：当出现故障时，运维人员需要快速响应，找到故障源并及时恢复。比如，在 Kubernetes 集群中，可以使用 <code>kubectl describe pod &lt;pod-name></code> 查找 Pod 的详细信息，查看是否是资源不足、节点故障等问题。</li></ul><h3 id=6-版本升级与迁移>6. <strong>版本升级与迁移</strong>
<a class=anchor href=#6-%e7%89%88%e6%9c%ac%e5%8d%87%e7%ba%a7%e4%b8%8e%e8%bf%81%e7%a7%bb>#</a></h3><ul><li><strong>Kubernetes 升级</strong>：随着 Kubernetes 的版本更新，需要定期对集群进行升级。运维人员需要确保升级过程顺利，避免中断业务，通常包括对 K8s 控制平面、工作节点及应用的逐步升级。</li><li><strong>应用版本控制与升级</strong>：对于应用的升级，运维需要确保平滑迁移，避免停机。可以通过 Helm 部署的应用管理版本和更新，确保应用在升级过程中高可用。</li></ul><h3 id=7-成本优化>7. <strong>成本优化</strong>
<a class=anchor href=#7-%e6%88%90%e6%9c%ac%e4%bc%98%e5%8c%96>#</a></h3><ul><li><strong>资源利用率监控</strong>：通过监控和分析资源的使用情况，找到资源浪费和瓶颈。例如，查看哪些 Pod 的资源使用率过低，哪些资源过度消耗，进而优化资源分配。</li><li><strong>弹性伸缩</strong>：使用 Kubernetes 的 HPA（Horizontal Pod Autoscaler）或 VPA（Vertical Pod Autoscaler）来根据负载动态扩展或缩减服务实例数量，减少不必要的资源浪费。</li></ul><h3 id=总结-5>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-5>#</a></h3><p>运维的工作不仅仅是对系统的监控和管理，更多的是从各个方面（性能、可用性、安全性、成本等）不断优化系统，确保它在高效、安全的情况下稳定运行。通过合理的架构设计、自动化工具、监控报警等手段，可以提前发现和解决问题，确保服务的持续可用性和稳定性。</p><h2 id=k8s的集群的驱逐怎么做的被动驱逐为了不要被驱逐可能主机上已有应用被驱逐不让他被驱逐解决不要被驱逐的问题>k8s的集群的驱逐怎么做的？被动驱逐，为了不要被驱逐，可能主机上已有应用被驱逐，不让他被驱逐，解决不要被驱逐的问题，
<a class=anchor href=#k8s%e7%9a%84%e9%9b%86%e7%be%a4%e7%9a%84%e9%a9%b1%e9%80%90%e6%80%8e%e4%b9%88%e5%81%9a%e7%9a%84%e8%a2%ab%e5%8a%a8%e9%a9%b1%e9%80%90%e4%b8%ba%e4%ba%86%e4%b8%8d%e8%a6%81%e8%a2%ab%e9%a9%b1%e9%80%90%e5%8f%af%e8%83%bd%e4%b8%bb%e6%9c%ba%e4%b8%8a%e5%b7%b2%e6%9c%89%e5%ba%94%e7%94%a8%e8%a2%ab%e9%a9%b1%e9%80%90%e4%b8%8d%e8%ae%a9%e4%bb%96%e8%a2%ab%e9%a9%b1%e9%80%90%e8%a7%a3%e5%86%b3%e4%b8%8d%e8%a6%81%e8%a2%ab%e9%a9%b1%e9%80%90%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h2><h2 id=提前扩容做一些考量>提前扩容，做一些考量，
<a class=anchor href=#%e6%8f%90%e5%89%8d%e6%89%a9%e5%ae%b9%e5%81%9a%e4%b8%80%e4%ba%9b%e8%80%83%e9%87%8f>#</a></h2><p>Kubernetes 的驱逐（Eviction）机制主要是针对 <strong>资源短缺</strong> 的情况，目的是保证集群能够在资源紧张的情况下，保持关键服务的可用性。下面我会详细讲解 Kubernetes 驱逐的工作原理、被动驱逐的发生情况，以及如何防止某些 Pod 被驱逐。</p><h3 id=1-kubernetes-驱逐机制>1. <strong>Kubernetes 驱逐机制</strong>
<a class=anchor href=#1-kubernetes-%e9%a9%b1%e9%80%90%e6%9c%ba%e5%88%b6>#</a></h3><p>Kubernetes 中的 <strong>驱逐</strong> 是指当节点的资源（如 CPU、内存、磁盘空间）紧张时，系统会尝试停止某些非关键性的 Pod，以释放资源，从而确保更重要的 Pod 能继续运行。</p><h4 id=驱逐的触发条件>驱逐的触发条件：
<a class=anchor href=#%e9%a9%b1%e9%80%90%e7%9a%84%e8%a7%a6%e5%8f%91%e6%9d%a1%e4%bb%b6>#</a></h4><ul><li><p><strong>节点资源不足</strong>：如节点的内存、CPU 或磁盘空间不足，Kubernetes 会自动进行驱逐。</p></li><li><p>Pod 优先级和 QoS (Quality of Service) 分类</p><p>：Kubernetes 根据 Pod 的优先级和 QoS 分类来决定哪些 Pod 会被驱逐。Pod 被分为 3 个 QoS 等级：</p><ol><li><strong>Guaranteed</strong>：如果 Pod 为 Guaranteed 类型，Kubernetes 会尽量避免驱逐它，因为它的资源请求和限制是固定的。</li><li><strong>Burstable</strong>：对于这种类型的 Pod，Kubernetes 会尝试驱逐那些资源消耗不合适的实例。</li><li><strong>BestEffort</strong>：资源请求和限制都未定义，这些 Pod 是最容易被驱逐的。</li></ol></li></ul><h4 id=被动驱逐>被动驱逐：
<a class=anchor href=#%e8%a2%ab%e5%8a%a8%e9%a9%b1%e9%80%90>#</a></h4><ul><li><strong>Memory Pressure</strong>：当节点的内存占用过高时，Kubernetes 会根据 Pod 的 QoS 等级进行驱逐。</li><li><strong>Disk Pressure</strong>：当磁盘空间不足时，Kubernetes 会驱逐那些磁盘占用量较大的 Pod。</li><li><strong>PID Pressure</strong>：当进程数量过多时，系统可能会驱逐部分 Pod。</li></ul><p>Kubernetes 通过 <strong><code>kubelet</code></strong> 监听和监控节点上的资源情况，遇到资源不足时，会根据驱逐策略，选择符合条件的 Pod 进行驱逐。</p><h3 id=2-防止-pod-被驱逐>2. <strong>防止 Pod 被驱逐</strong>
<a class=anchor href=#2-%e9%98%b2%e6%ad%a2-pod-%e8%a2%ab%e9%a9%b1%e9%80%90>#</a></h3><p>如果你不希望某些 Pod 被驱逐，可以通过以下几种方式来确保它们的优先级更高，或者让它们具备更高的容忍能力：</p><h4 id=1-pod-优先级和抢占>(1) <strong>Pod 优先级和抢占</strong>
<a class=anchor href=#1-pod-%e4%bc%98%e5%85%88%e7%ba%a7%e5%92%8c%e6%8a%a2%e5%8d%a0>#</a></h4><p>Kubernetes 提供了 <strong>Pod 优先级</strong> 和 <strong>抢占</strong> 的机制，允许用户设置某些 Pod 的优先级。高优先级的 Pod 在资源紧张时会抢占低优先级 Pod 的资源。</p><ul><li><p><strong>设置 Pod 优先级</strong>：可以通过 <code>PriorityClass</code> 来为 Pod 设置优先级。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>scheduling.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PriorityClass</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>high-priority</span>
</span></span><span style=display:flex><span><span style=color:#f92672>value</span>: <span style=color:#ae81ff>1000000</span>
</span></span><span style=display:flex><span><span style=color:#f92672>globalDefault</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#f92672>description</span>: <span style=color:#e6db74>&#34;High priority pods&#34;</span>
</span></span></code></pre></div><p>然后在 Pod 配置中引用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>priorityClassName</span>: <span style=color:#ae81ff>high-priority</span>
</span></span></code></pre></div></li><li><p><strong>抢占机制</strong>：如果一个高优先级的 Pod 需要资源而资源不足时，它会自动驱逐低优先级的 Pod 来争取资源。</p></li></ul><h4 id=2-资源请求与限制requests-and-limits>(2) <strong>资源请求与限制（Requests and Limits）</strong>
<a class=anchor href=#2-%e8%b5%84%e6%ba%90%e8%af%b7%e6%b1%82%e4%b8%8e%e9%99%90%e5%88%b6requests-and-limits>#</a></h4><p>Kubernetes 中的 <strong>资源请求</strong>（<code>requests</code>）和 <strong>资源限制</strong>（<code>limits</code>）非常重要。如果 Pod 没有设置适当的资源请求和限制，可能会被 Kubernetes 判定为 <strong>BestEffort</strong> 类型，优先被驱逐。</p><p>通过设置合理的资源请求和限制，可以避免 Pod 被驱逐：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;256Mi&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;500m&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;512Mi&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;1000m&#34;</span>
</span></span></code></pre></div><ul><li><strong><code>requests</code></strong>：表示容器启动时所需的最低资源。</li><li><strong><code>limits</code></strong>：表示容器使用资源的最大限制。</li></ul><h4 id=3-node-affinity-与-taintstolerations>(3) <strong>Node Affinity 与 Taints/Tolerations</strong>
<a class=anchor href=#3-node-affinity-%e4%b8%8e-taintstolerations>#</a></h4><ul><li><p><strong>Node Affinity</strong>：通过节点亲和性（Node Affinity），你可以让 Pod 只调度到特定的节点上，从而避免某些节点资源紧张时对特定 Pod 的影响。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>affinity</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nodeAffinity</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>requiredDuringSchedulingIgnoredDuringExecution</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>nodeSelectorTerms</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>matchExpressions</span>:
</span></span><span style=display:flex><span>              - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;disktype&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>operator</span>: <span style=color:#ae81ff>In</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>values</span>:
</span></span><span style=display:flex><span>                  - <span style=color:#e6db74>&#34;ssd&#34;</span>
</span></span></code></pre></div></li><li><p><strong>Taints/Tolerations</strong>：节点可以通过 <code>taints</code> 来标记，表示该节点资源紧张或某些原因不适合调度某些 Pod。Pod 可以通过 <code>tolerations</code> 来容忍节点的 Taints，避免驱逐。</p><ul><li><p>给节点打上 taint：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl taint nodes &lt;node-name&gt; key<span style=color:#f92672>=</span>value:NoSchedule
</span></span></code></pre></div></li><li><p>给 Pod 配置 toleration，允许调度到有 taint 的节点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>tolerations</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>key</span>: <span style=color:#e6db74>&#34;key&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>operator</span>: <span style=color:#e6db74>&#34;Equal&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;value&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>effect</span>: <span style=color:#e6db74>&#34;NoSchedule&#34;</span>
</span></span></code></pre></div></li></ul></li></ul><h4 id=4-poddisruptionbudgets-pdb>(4) <strong>PodDisruptionBudgets (PDB)</strong>
<a class=anchor href=#4-poddisruptionbudgets-pdb>#</a></h4><p>如果你不希望某些 Pod 被驱逐（尤其是在进行计划的维护操作时），可以使用 <strong>PodDisruptionBudget</strong> 来定义在驱逐发生时必须保留的 Pod 最小数量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>policy/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PodDisruptionBudget</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app-pdb</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>minAvailable</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span></code></pre></div><p>这个配置确保在进行计划性的驱逐时，至少会保留一个副本运行，避免服务不可用。</p><h3 id=3-如何避免主机应用被驱逐>3. <strong>如何避免主机应用被驱逐</strong>
<a class=anchor href=#3-%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e4%b8%bb%e6%9c%ba%e5%ba%94%e7%94%a8%e8%a2%ab%e9%a9%b1%e9%80%90>#</a></h3><p>如果主机上已经有关键应用运行，而你希望避免这些应用被驱逐，可以通过以下方式保障它们的稳定性：</p><ol><li><strong>为关键应用设置高优先级</strong>：如前所述，可以设置 <code>PriorityClass</code> 来确保关键应用具有较高优先级，避免在资源不足时被驱逐。</li><li><strong>合理设置资源请求和限制</strong>：确保应用的资源请求和限制合理，避免 Pod 被判定为 <code>BestEffort</code> 类型而被驱逐。</li><li><strong>使用 <code>PodDisruptionBudget</code></strong>：确保关键服务能够在驱逐操作中得到保障，避免在进行节点维护或其他操作时应用出现中断。</li><li><strong>节点和 Pod 的调度策略</strong>：通过 Node Affinity、Taints/Tolerations 等手段，确保关键服务调度到适当的节点，避免节点资源压力过大导致驱逐。</li></ol><h3 id=总结-6>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-6>#</a></h3><p>Kubernetes 的驱逐机制主要是在节点资源紧张时，通过释放一些 Pod 来保证关键应用的稳定性。通过合理配置资源请求和限制、Pod 优先级、Taints/Tolerations 等手段，可以确保关键应用在资源紧张时不会被驱逐，从而保证集群的稳定运行。</p><h2 id=kafka-zk脑裂怎么解决>kafka ，zk，脑裂怎么解决？
<a class=anchor href=#kafka-zk%e8%84%91%e8%a3%82%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3>#</a></h2><p>Kafka 和 Zookeeper 都是分布式系统中的重要组件，分别负责消息队列和集群协调。<strong>脑裂</strong>（Split Brain）指的是在分布式系统中，因网络分区或其他原因，多个节点之间无法正常通信，导致集群中的不同部分各自认为自己是主集群，出现不一致性问题。</p><p>在 Kafka 和 Zookeeper 中，脑裂问题可能会导致集群不可用或数据不一致。解决脑裂的关键是确保系统中的各个节点在网络异常时能够正确地判断和处理。下面我们分别讨论 Kafka 和 Zookeeper 中的脑裂问题及其解决方法。</p><h3 id=1-kafka-中的脑裂问题及解决方法>1. <strong>Kafka 中的脑裂问题及解决方法</strong>
<a class=anchor href=#1-kafka-%e4%b8%ad%e7%9a%84%e8%84%91%e8%a3%82%e9%97%ae%e9%a2%98%e5%8f%8a%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95>#</a></h3><p>在 Kafka 中，脑裂问题主要表现为 <strong>Leader 选举</strong>和 <strong>副本同步</strong> 问题。Kafka 中的每个分区都有一个 Leader 和多个 Follower，当分区的 Leader 所在节点和 Follower 所在节点之间出现网络分区时，会发生脑裂。</p><h4 id=kafka-中脑裂的表现>Kafka 中脑裂的表现：
<a class=anchor href=#kafka-%e4%b8%ad%e8%84%91%e8%a3%82%e7%9a%84%e8%a1%a8%e7%8e%b0>#</a></h4><ul><li><strong>Leader 副本失联</strong>：某些 Broker 节点无法连接到 Leader 副本，导致它们认为自己是 Leader，或者 Follower 没法同步数据。</li><li><strong>数据丢失</strong>：当 Follower 节点无法及时同步 Leader 节点的数据时，可能会出现数据丢失。</li><li><strong>不可用的分区</strong>：一些分区的副本可能无法获得一致的数据，导致这些分区的消费者和生产者无法正常工作。</li></ul><h4 id=kafka-的脑裂防范和解决>Kafka 的脑裂防范和解决：
<a class=anchor href=#kafka-%e7%9a%84%e8%84%91%e8%a3%82%e9%98%b2%e8%8c%83%e5%92%8c%e8%a7%a3%e5%86%b3>#</a></h4><ol><li><p><strong>确保 Zookeeper 的稳定性</strong>： Kafka 集群的元数据存储在 Zookeeper 中，Zookeeper 用于管理 Kafka 中的 Broker 节点、分区的 Leader、副本等。Zookeeper 的稳定性至关重要，<strong>Zookeeper 需要有奇数个节点</strong>，并且推荐至少使用 3 个节点来保证一致性和容错能力。</p></li><li><p><strong>配置 <code>min.insync.replicas</code> 参数</strong>： 在 Kafka 中，<code>min.insync.replicas</code> 参数用于保证分区的数据副本数量。在脑裂的情况下，若 <code>min.insync.replicas</code> 设置为较大的值，即使部分副本失联，Kafka 也不会允许写入，从而避免数据丢失。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#a6e22e>min.insync.replicas</span><span style=color:#f92672>=</span><span style=color:#e6db74>2</span>
</span></span></code></pre></div></li><li><p><strong><code>unclean.leader.election.enable</code> 配置</strong>： 默认情况下，Kafka 在发生脑裂时会禁用“不干净的 Leader 选举”，即禁止在某些副本可能尚未同步的情况下，选举新的 Leader。这可以避免在网络恢复后，由于旧的 Leader 丢失了一部分数据而导致数据不一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#a6e22e>unclean.leader.election.enable</span><span style=color:#f92672>=</span><span style=color:#e6db74>false</span>
</span></span></code></pre></div></li><li><p><strong>配置合理的 <code>acks</code> 参数</strong>： Kafka 提供了 <code>acks</code> 参数来控制生产者确认消息写入的行为：</p><ul><li><code>acks=1</code>：Leader 接收到消息后就返回确认。</li><li><code>acks=all</code> 或 <code>acks=-1</code>：所有副本都收到消息后才返回确认，这样可以保证数据的一致性，即使部分节点失联也能保证消息不会丢失。</li></ul></li><li><p><strong>通过 Kafka 自动恢复机制</strong>： Kafka 集群在发生网络分区后，会自动进行 Leader 选举，确保分区能够继续处理消息。但为了减少脑裂发生的概率，应该确保 Kafka 集群的网络稳定性和 Zookeeper 节点的健康性。</p></li></ol><h3 id=2-zookeeper-中的脑裂问题及解决方法>2. <strong>Zookeeper 中的脑裂问题及解决方法</strong>
<a class=anchor href=#2-zookeeper-%e4%b8%ad%e7%9a%84%e8%84%91%e8%a3%82%e9%97%ae%e9%a2%98%e5%8f%8a%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95>#</a></h3><p>Zookeeper 是一个分布式协调服务，用于 Kafka 集群的管理。Zookeeper 本身也可能出现脑裂问题，尤其是在网络分区的情况下。</p><h4 id=zookeeper-中脑裂的表现>Zookeeper 中脑裂的表现：
<a class=anchor href=#zookeeper-%e4%b8%ad%e8%84%91%e8%a3%82%e7%9a%84%e8%a1%a8%e7%8e%b0>#</a></h4><ul><li><strong>多个 Zookeeper 节点选举为 Leader</strong>：当 Zookeeper 集群出现网络分区时，可能会导致某些 Zookeeper 节点认为自己是集群的 Leader，从而引发不一致的操作。</li><li><strong>数据不一致</strong>：网络分区会导致 Zookeeper 中的数据同步不及时，造成不同 Zookeeper 节点上的数据不一致。</li></ul><h4 id=zookeeper-的脑裂防范和解决>Zookeeper 的脑裂防范和解决：
<a class=anchor href=#zookeeper-%e7%9a%84%e8%84%91%e8%a3%82%e9%98%b2%e8%8c%83%e5%92%8c%e8%a7%a3%e5%86%b3>#</a></h4><ol><li><strong>保证 Zookeeper 集群节点的数量为奇数</strong>： Zookeeper 集群必须配置为奇数个节点（通常是 3 或 5 个节点）。这可以确保在集群出现网络分区时，至少有一部分节点可以形成“多数派”来选举出 Leader，避免脑裂的情况。</li><li><strong><code>quorum</code> 配置</strong>： Zookeeper 通过配置 <code>quorum</code> 参数来控制哪些节点可以参与选举。如果网络出现分区，只有在至少半数以上节点可用的情况下，才会选举出 Leader。</li><li><strong><code>initLimit</code> 和 <code>syncLimit</code> 配置</strong>： 这些配置项用于控制 Zookeeper 集群节点之间的心跳检测：<ul><li><code>initLimit</code>：指定 Zookeeper 集群启动过程中，Follower 节点与 Leader 节点之间初始化连接所允许的最大时间。</li><li><code>syncLimit</code>：指定 Zookeeper 集群在正常工作过程中，Follower 节点与 Leader 节点之间通信的最大延迟。 通过调整这些参数，可以减少网络延迟和分区带来的影响。</li></ul></li><li><strong><code>zk.tickTime</code> 配置</strong>： <code>tickTime</code> 用于指定 Zookeeper 中的一个基本时间单位。通过调整 <code>tickTime</code> 和 <code>maxClientCnxns</code> 等参数，可以增强 Zookeeper 对网络分区的容忍度。</li><li><strong>使用合适的 Zookeeper 版本</strong>： 新版本的 Zookeeper 修复了许多网络分区时的稳定性问题，因此推荐使用较新的 Zookeeper 版本，以确保在发生脑裂的情况下，能够尽可能地减少不一致性和数据丢失。</li></ol><h3 id=3-总结kafka-与-zookeeper-的脑裂问题解决>3. <strong>总结：Kafka 与 Zookeeper 的脑裂问题解决</strong>
<a class=anchor href=#3-%e6%80%bb%e7%bb%93kafka-%e4%b8%8e-zookeeper-%e7%9a%84%e8%84%91%e8%a3%82%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3>#</a></h3><ul><li><strong>Kafka</strong>：<ul><li>配置合理的 <code>min.insync.replicas</code>、<code>acks</code> 和 <code>unclean.leader.election.enable</code> 参数，避免在脑裂时出现数据丢失。</li><li>确保 Kafka 集群中的网络稳定性，以及与 Zookeeper 的连接健康。</li><li>Kafka 会自动进行 Leader 选举，但应确保 Zookeeper 的稳定性以避免 Kafka 出现故障。</li></ul></li><li><strong>Zookeeper</strong>：<ul><li>使用奇数个 Zookeeper 节点，确保在发生网络分区时能够选举出 Leader。</li><li>配置合理的 <code>quorum</code>、<code>initLimit</code> 和 <code>syncLimit</code> 等参数，提高集群的容错能力。</li><li>使用新版本的 Zookeeper，以修复旧版本中存在的一些脑裂问题。</li></ul></li></ul><p>最终，避免脑裂的关键是设计高可用的集群架构，确保网络稳定性，并且为 Kafka 和 Zookeeper 配置合理的容错机制和参数。</p><p><strong>网络分区</strong>（Network Partition）是指分布式系统中的一部分节点无法与其他节点通信，通常是由于网络故障、路由器问题、硬件故障或其他原因导致的。网络分区会导致集群中的节点无法与其他部分的节点进行正常的通信，进而影响集群的一致性和可靠性。</p><h3 id=网络分区的表现>网络分区的表现：
<a class=anchor href=#%e7%bd%91%e7%bb%9c%e5%88%86%e5%8c%ba%e7%9a%84%e8%a1%a8%e7%8e%b0>#</a></h3><ol><li><strong>节点不可达</strong>：部分节点由于网络问题无法与其他节点进行通信。这些节点可能会认为自己仍然是集群的一部分，但实际上，它们无法和其他节点同步数据或协调操作。</li><li><strong>分割的集群</strong>：网络分区可能会将集群划分为多个子集（即“脑裂”情况），每个子集内的节点认为自己是完整集群的一部分，无法与其他子集的节点协作或同步。</li></ol><h3 id=在-zookeeper-中的影响>在 Zookeeper 中的影响：
<a class=anchor href=#%e5%9c%a8-zookeeper-%e4%b8%ad%e7%9a%84%e5%bd%b1%e5%93%8d>#</a></h3><p>Zookeeper 是一个分布式协调服务，它依赖一个主从架构来保证集群的一致性。在网络分区的情况下，Zookeeper 的集群可能会发生如下问题：</p><ol><li><strong>Leader 节点丧失联系</strong>：Zookeeper 集群中只有一个 Leader 节点，负责处理所有的写请求和一些管理任务。在网络分区的情况下，一部分 Zookeeper 节点与 Leader 失去联系，无法得知当前 Leader 的状态，这可能导致这些节点认为它们自己可以选举出新的 Leader。</li><li><strong>脑裂（Split Brain）</strong>：如果网络分区导致集群被分成多个子集，其中某些子集选举出自己的 Leader，这就会导致脑裂问题。在这种情况下，集群的各个部分可能认为自己是集群的唯一 Leader，并且无法与其他部分同步数据，最终导致数据不一致。</li><li><strong>写操作不可达</strong>：由于 Leader 无法与大多数节点通信，部分客户端的写请求可能会被丢失或者无法正确处理，因为 Leader 需要与多数节点确认写入操作的有效性。</li></ol><h3 id=网络分区的解决方法>网络分区的解决方法：
<a class=anchor href=#%e7%bd%91%e7%bb%9c%e5%88%86%e5%8c%ba%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95>#</a></h3><p>为了防止 Zookeeper 集群在网络分区时出现数据不一致和脑裂问题，通常采取以下策略：</p><ol><li><strong>使用奇数个节点</strong>：Zookeeper 集群的节点数必须是奇数，通常建议使用 3、5 或 7 个节点。这样可以确保在网络分区时，至少有一个子集能够选举出 Leader，并且大多数节点可以达成一致。</li><li><strong>选举协议</strong>：Zookeeper 使用 <strong>Zab 协议</strong>（Zookeeper Atomic Broadcast）来保证集群内的一致性。在网络分区的情况下，Zookeeper 会确保只有一个 Leader 被选举出来，避免出现多个 Leader。</li><li><strong><code>quorum</code> 配置</strong>：Zookeeper 会根据节点的多数（即大于半数的节点）来做出决策，确保集群的正确性。例如，在网络分区时，Zookeeper 只会接受来自能与大多数节点通信的节点的写入请求。</li><li><strong>网络监控与修复</strong>：为了降低网络分区的风险，需要定期检查集群的网络状况，确保节点间的通信稳定，及时修复可能导致网络分区的问题。</li><li><strong>调整 <code>initLimit</code> 和 <code>syncLimit</code></strong>：这些配置项可以帮助 Zookeeper 调节在网络不稳定时的容错能力，通过设置合理的超时时间，可以增加 Zookeeper 集群在网络分区时的稳定性。</li></ol><p>总的来说，网络分区是指分布式系统中的部分节点因网络问题无法正常通信，这会导致集群的一致性出现问题，特别是在 Zookeeper 中，可能导致脑裂现象和不一致的操作。在 Zookeeper 中，通过保证节点数为奇数、使用适当的协议和配置、监控网络健康等手段，可以有效减少网络分区的风险。</p><h2 id=开发能力有没有flask的前端页面怎么做>开发能力有没有？flask的，前端页面怎么做？
<a class=anchor href=#%e5%bc%80%e5%8f%91%e8%83%bd%e5%8a%9b%e6%9c%89%e6%b2%a1%e6%9c%89flask%e7%9a%84%e5%89%8d%e7%ab%af%e9%a1%b5%e9%9d%a2%e6%80%8e%e4%b9%88%e5%81%9a>#</a></h2><p>使用 <strong>Vue.js</strong> 作为前端框架配合 <strong>Flask</strong> 后端开发应用是一个很常见的组合。Vue.js 主要负责渲染和交互，而 Flask 负责数据处理和 API 提供。</p><h3 id=前端vuejs-和-flask-配合>前端：Vue.js 和 Flask 配合
<a class=anchor href=#%e5%89%8d%e7%ab%afvuejs-%e5%92%8c-flask-%e9%85%8d%e5%90%88>#</a></h3><ol><li><p><strong>安装 Vue.js</strong>： 首先，确保你的机器上已经安装了 Node.js 和 npm。然后使用 Vue CLI 创建一个新的 Vue 项目：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npm install -g @vue/cli
</span></span><span style=display:flex><span>vue create my-vue-app
</span></span><span style=display:flex><span>cd my-vue-app
</span></span><span style=display:flex><span>npm run serve
</span></span></code></pre></div></li><li><p><strong>设置 Vue.js 与 Flask 交互</strong>： 在 Vue 中，可以通过 <strong>Axios</strong> 库来发送 HTTP 请求并从 Flask 后端获取数据。首先安装 Axios：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npm install axios
</span></span></code></pre></div></li><li><p><strong>修改 Vue 组件来请求 Flask API</strong>： 在 <code>src/components/HelloWorld.vue</code> 文件中，修改为如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vue data-lang=vue><span style=display:flex><span>&lt;<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>h1</span>&gt;<span style=color:#a6e22e>Welcome</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>Vue</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>Flask</span><span style=color:#f92672>!</span>&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>button</span> <span style=color:#f92672>@click</span><span style=color:#e6db74>=&#34;fetchData&#34;</span>&gt;<span style=color:#a6e22e>Get</span> <span style=color:#a6e22e>Data</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>p</span>&gt;{{ <span style=color:#a6e22e>message</span> }}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>axios</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;axios&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>methods</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fetchData</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>axios</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#39;http://localhost:5000/api/data&#39;</span>)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>response</span> =&gt; {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>message</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>message</span>;
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>error</span> =&gt; {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div></li><li><p><strong>Flask 后端设置</strong>： 在 Flask 中，创建一个简单的 API 端点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> flask <span style=color:#f92672>import</span> Flask, jsonify
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/api/data&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_data</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> jsonify(message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Data from Flask API!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>run(debug<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div></li><li><p><strong>解决跨域问题（CORS）</strong>： Flask 后端和 Vue 前端通常是运行在不同的端口上，因此会涉及 <strong>跨域请求</strong>（CORS）。为了解决这个问题，可以使用 Flask-CORS 扩展：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install flask-cors
</span></span></code></pre></div><p>然后在 Flask 后端中启用 CORS：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> flask <span style=color:#f92672>import</span> Flask, jsonify
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> flask_cors <span style=color:#f92672>import</span> CORS
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>CORS(app)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/api/data&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_data</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> jsonify(message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Data from Flask API!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>run(debug<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div></li><li><p><strong>运行应用</strong>：</p><ul><li><p>启动 Flask 后端：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python app.py
</span></span></code></pre></div></li><li><p>启动 Vue 前端：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npm run serve
</span></span></code></pre></div></li></ul></li></ol><h3 id=结构概览>结构概览：
<a class=anchor href=#%e7%bb%93%e6%9e%84%e6%a6%82%e8%a7%88>#</a></h3><ul><li><strong>Flask</strong>：后端提供数据 API。</li><li><strong>Vue.js</strong>：前端通过 Axios 向 Flask 发送请求并渲染数据。</li></ul><h3 id=部署>部署：
<a class=anchor href=#%e9%83%a8%e7%bd%b2>#</a></h3><p>在部署时，通常会将 Vue 构建为静态资源，通过 Flask 提供给前端。例如，使用 Vue CLI 构建生产版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npm run build
</span></span></code></pre></div><p>然后将构建后的 <code>dist</code> 文件夹内容放到 Flask 静态目录下，Flask 会直接提供静态文件。</p><p>你有具体的项目或者遇到的难点吗？我可以帮你进一步细化。</p><p>是的，<strong>Flask</strong> 和 <strong>Vue.js</strong> 可以用来实现上面提到的主机管理、SSH远程登录、日志管理和主机监控功能。下面是一个大致的实现思路，结合 Flask 和 Vue.js 来构建一个完整的运维平台：</p><h3 id=1-主机管理和配置管理>1. <strong>主机管理和配置管理</strong>：
<a class=anchor href=#1-%e4%b8%bb%e6%9c%ba%e7%ae%a1%e7%90%86%e5%92%8c%e9%85%8d%e7%bd%ae%e7%ae%a1%e7%90%86>#</a></h3><ul><li><p>Flask 后端</p><p>：</p><ul><li><strong>Flask</strong> 可以用来提供一个 <strong>REST API</strong> 来管理主机的配置，包括添加、删除主机，配置 SSH 登录信息等。通过 <code>Flask-SocketIO</code> 等工具，可以提供实时的更新和监控。</li><li>可以结合 <strong>Ansible</strong> 或 <strong>SaltStack</strong> 的 Python API 来进行自动化任务执行（例如批量配置和更新）。</li></ul></li><li><p>Vue.js 前端</p><p>：</p><ul><li><strong>Vue.js</strong> 负责构建一个用户界面，用于展示当前主机的状态，主机的配置管理界面，或者执行批量操作。</li><li>通过 Vue.js 发起 API 请求与 Flask 后端进行通信，例如获取主机列表、查看主机详情、执行特定的操作（如重启、配置更新等）。</li><li>使用 <strong>Vuex</strong> 管理前端状态，确保 UI 在数据变动时同步更新。</li></ul></li></ul><h3 id=2-ssh-远程登录管理>2. <strong>SSH 远程登录管理</strong>：
<a class=anchor href=#2-ssh-%e8%bf%9c%e7%a8%8b%e7%99%bb%e5%bd%95%e7%ae%a1%e7%90%86>#</a></h3><ul><li><p>Flask 后端</p><p>：</p><ul><li>Flask 可以提供 API 接口来管理 SSH 登录，比如存储 SSH 密钥和配置，或者通过 Flask 后端提供 API 来执行 SSH 登录。</li><li>使用 <strong>paramiko</strong> 这样的 Python 库来通过 SSH 协议与远程主机进行交互，支持执行远程命令、文件传输等。</li></ul></li><li><p>Vue.js 前端</p><p>：</p><ul><li>在前端，可以使用 <strong>WebSocket</strong> 或 <strong>Socket.IO</strong> 来进行实时的 SSH 会话管理。例如，可以为每个主机提供一个实时控制台，用户可以直接在浏览器中执行命令，获得实时反馈。</li></ul></li></ul><h3 id=3-日志管理与集中式日志分析>3. <strong>日志管理与集中式日志分析</strong>：
<a class=anchor href=#3-%e6%97%a5%e5%bf%97%e7%ae%a1%e7%90%86%e4%b8%8e%e9%9b%86%e4%b8%ad%e5%bc%8f%e6%97%a5%e5%bf%97%e5%88%86%e6%9e%90>#</a></h3><ul><li><p>Flask 后端</p><p>：</p><ul><li>Flask 后端可以整合日志管理功能，将主机的日志通过 API 接口传输到后端进行存储和分析。</li><li>使用 <strong>ELK Stack</strong> 或 <strong>Fluentd</strong> 进行日志的收集和分析，Flask 后端提供接口将这些日志显示到前端界面。</li><li>可以使用 Python 中的 <code>logging</code> 模块来生成和管理日志信息，也可以集成第三方工具（如 <strong>Logstash</strong>）来收集日志数据。</li></ul></li><li><p>Vue.js 前端</p><p>：</p><ul><li>前端部分，Vue.js 可以提供日志查看的界面，展示系统日志、应用日志等，支持多维度的日志筛选和查询。</li><li>可以集成 <strong>Kibana</strong>（如果使用 ELK Stack），通过与其 API 通信展示日志数据。</li></ul></li></ul><h3 id=4-主机监控与报警>4. <strong>主机监控与报警</strong>：
<a class=anchor href=#4-%e4%b8%bb%e6%9c%ba%e7%9b%91%e6%8e%a7%e4%b8%8e%e6%8a%a5%e8%ad%a6>#</a></h3><ul><li><p>Flask 后端</p><p>：</p><ul><li>后端可以通过 <strong>Prometheus</strong> 或 <strong>Zabbix</strong> 提供的 API 来收集主机监控数据，如 CPU、内存、磁盘使用情况等。</li><li>可以通过 Flask 提供 API 接口，将监控数据传递给前端进行展示。</li><li>使用 <strong>Flask-SocketIO</strong> 实现实时监控更新，比如 CPU 使用率超过阈值时，Flask 后端通过 WebSocket 向前端推送警告消息。</li></ul></li><li><p>Vue.js 前端</p><p>：</p><ul><li>Vue.js 前端可以展示实时的监控图表，使用 <strong>Chart.js</strong>、<strong>ECharts</strong> 或 <strong>Grafana</strong>（如果与 Grafana 集成）来渲染监控数据。</li><li>通过与后端的 API 通信，获取实时的监控数据并展示。例如，可以展示 CPU 使用率图表、内存使用情况等。</li><li>当监控数据超过阈值时，前端可以展示警报信息。</li></ul></li></ul><h3 id=5-自动化运维任务管理>5. <strong>自动化运维任务管理</strong>：
<a class=anchor href=#5-%e8%87%aa%e5%8a%a8%e5%8c%96%e8%bf%90%e7%bb%b4%e4%bb%bb%e5%8a%a1%e7%ae%a1%e7%90%86>#</a></h3><ul><li><p>Flask 后端</p><p>：</p><ul><li>提供任务调度和执行的功能，后端可以使用 <strong>Celery</strong> 来异步执行耗时的运维任务，如批量软件安装、配置更新等。</li><li>后端可以集成 <strong>Ansible</strong> 或 <strong>SaltStack</strong> 等自动化工具，允许通过 API 执行任务，并返回执行结果。</li></ul></li><li><p>Vue.js 前端</p><p>：</p><ul><li>提供用户界面来创建、监控和管理运维任务。用户可以通过前端界面发起任务，查看任务执行进度，获取结果。</li><li>使用 <strong>Vue Router</strong> 跳转到任务的详情页面，实时更新任务执行状态。</li></ul></li></ul><h3 id=具体实现思路>具体实现思路：
<a class=anchor href=#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af>#</a></h3><ol><li><strong>后端部分（Flask）</strong>：<ul><li>提供 API 接口，用于管理主机、执行 SSH 命令、日志收集与展示、监控数据收集与展示。</li><li>通过 Flask 集成自动化工具（如 Ansible），允许通过 Web 前端执行配置和运维任务。</li><li>使用 Celery 执行长时间的运维任务，并提供任务状态和结果接口。</li></ul></li><li><strong>前端部分（Vue.js）</strong>：<ul><li>构建现代化的 Web 界面，展示主机状态、日志、监控数据等。</li><li>通过 Vue.js 与 Flask 后端进行数据交互，使用 <strong>Axios</strong> 来请求 API，使用 <strong>Vuex</strong> 管理全局状态。</li><li>实现实时日志查看、监控图表、任务执行状态更新等功能。</li></ul></li></ol><h3 id=示例架构>示例架构：
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e6%9e%b6%e6%9e%84>#</a></h3><ul><li><strong>Flask 后端</strong>：提供 RESTful API，用于处理主机管理、SSH 登录、日志展示、监控数据等。后端也负责与自动化工具（如 Ansible）进行交互，执行运维任务。</li><li><strong>Vue.js 前端</strong>：展示系统信息，监控数据，日志数据，以及操作界面。前端通过 API 与 Flask 后端交互，提供用户友好的操作界面。</li></ul><h3 id=总结-7>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-7>#</a></h3><p>通过 <strong>Flask</strong> 和 <strong>Vue.js</strong>，你可以实现一个完整的运维管理平台，处理从主机管理、日志分析、远程 SSH 登录到监控和自动化任务等多个运维任务。Flask 作为后端处理业务逻辑，Vue.js 作为前端展示和交互，两者通过 API 通信，提供完整的用户体验和管理功能。</p><h2 id=k8s的cni用的啥网络扁平网络跨层跨墙>k8s的cni用的啥，网络，扁平网络，跨层，跨墙，
<a class=anchor href=#k8s%e7%9a%84cni%e7%94%a8%e7%9a%84%e5%95%a5%e7%bd%91%e7%bb%9c%e6%89%81%e5%b9%b3%e7%bd%91%e7%bb%9c%e8%b7%a8%e5%b1%82%e8%b7%a8%e5%a2%99>#</a></h2><h2 id=子网可能a类-b类跨墙的这种怎么解决>子网可能A类 B类，跨墙的这种，怎么解决
<a class=anchor href=#%e5%ad%90%e7%bd%91%e5%8f%af%e8%83%bda%e7%b1%bb-b%e7%b1%bb%e8%b7%a8%e5%a2%99%e7%9a%84%e8%bf%99%e7%a7%8d%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3>#</a></h2><p>内部开墙，放行端口，要求能够互相访问，也可以自定义你vxlan 的udp 4789 端口号在flexconfiguration 修改vxlan port为14789也行</p><h2 id=换工作的原因>换工作的原因
<a class=anchor href=#%e6%8d%a2%e5%b7%a5%e4%bd%9c%e7%9a%84%e5%8e%9f%e5%9b%a0>#</a></h2><p>家庭原因</p><p>南京网易外包</p><h2 id=自我介绍离职原因有无offer多久到岗>自我介绍，离职原因，有无offer，多久到岗。
<a class=anchor href=#%e8%87%aa%e6%88%91%e4%bb%8b%e7%bb%8d%e7%a6%bb%e8%81%8c%e5%8e%9f%e5%9b%a0%e6%9c%89%e6%97%a0offer%e5%a4%9a%e4%b9%85%e5%88%b0%e5%b2%97>#</a></h2><h2 id=印象比较深的中间件排障的经验>印象比较深的中间件排障的经验？
<a class=anchor href=#%e5%8d%b0%e8%b1%a1%e6%af%94%e8%be%83%e6%b7%b1%e7%9a%84%e4%b8%ad%e9%97%b4%e4%bb%b6%e6%8e%92%e9%9a%9c%e7%9a%84%e7%bb%8f%e9%aa%8c>#</a></h2><p>在我的运维经验中，排查中间件问题是非常常见的场景，尤其是在 Kubernetes 环境下，涉及到的中间件有 Kafka、Zookeeper、Redis、Nginx 等。以下是一些印象比较深的排障经验：</p><h3 id=1-kafka-集群的脑裂问题>1. <strong>Kafka 集群的脑裂问题</strong>
<a class=anchor href=#1-kafka-%e9%9b%86%e7%be%a4%e7%9a%84%e8%84%91%e8%a3%82%e9%97%ae%e9%a2%98>#</a></h3><p>Kafka 集群的脑裂问题可能导致集群内的部分节点误以为自己是 leader，从而影响数据的正确性和一致性。一次，我们的 Kafka 集群出现了数据不一致的问题，部分消费者无法消费消息。</p><h4 id=排查步骤>排查步骤：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%ad%a5%e9%aa%a4>#</a></h4><ul><li><strong>检查 Zookeeper 状态</strong>：Kafka 依赖 Zookeeper 来管理集群的元数据。通过查看 Zookeeper 的日志，发现有一个 Zookeeper 节点因网络问题无法与其他节点通信，导致 Zookeeper 集群出现了网络分区。</li><li><strong>分析 Kafka 节点日志</strong>：Kafka 节点的日志显示有多个 leader 选举失败，部分节点进入了 <code>LEADER_NOT_AVAILABLE</code> 状态。</li><li><strong>恢复 Zookeeper 集群一致性</strong>：通过手动修复 Zookeeper 集群的分区问题，确保集群的一致性，并强制重新选举 leader。</li><li><strong>检查 Kafka 配置</strong>：检查了 Kafka 的 <code>zookeeper.connection.timeout.ms</code> 和 <code>replica.lag.time.max.ms</code> 等参数，确保集群能够快速处理节点失联后的恢复。</li><li><strong>验证结果</strong>：恢复网络后，Kafka 集群重新稳定，所有消费者可以正常消费消息。</li></ul><h3 id=2-redis-主从复制延迟问题>2. <strong>Redis 主从复制延迟问题</strong>
<a class=anchor href=#2-redis-%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e5%bb%b6%e8%bf%9f%e9%97%ae%e9%a2%98>#</a></h3><p>在一次生产环境中，Redis 主从复制出现了严重的延迟，主节点与从节点之间的数据同步滞后，导致读取的数据不一致。</p><h4 id=排查步骤-1>排查步骤：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%ad%a5%e9%aa%a4-1>#</a></h4><ul><li><p><strong>查看 Redis 监控指标</strong>：通过 Prometheus 和 Grafana 监控 Redis 集群，发现主节点的写入延迟急剧增加，从节点的同步延迟也非常高。</p></li><li><p><strong>分析 Redis 日志</strong>：通过 <code>INFO replication</code> 命令查看 Redis 的复制状态，发现从节点的 <code>connected_slaves</code> 数量是正常的，但是同步速度非常慢。</p></li><li><p><strong>查看网络带宽</strong>：检查了主节点和从节点之间的网络带宽，发现网络带宽已经达到瓶颈。Redis 复制是通过 AOF（Append-Only File）进行的，数据量较大时会对网络造成很大的压力。</p></li><li><p>优化方案</p><p>：</p><ul><li>降低 <code>repl-backlog-size</code> 和 <code>repl-timeout</code>，加快从节点同步。</li><li>增加网络带宽，并将 Redis 配置为 RDB（快照）同步模式，以减少复制负担。</li><li>增加 Redis 从节点数量，分担主节点的复制压力。</li></ul></li><li><p><strong>验证结果</strong>：优化后，Redis 主从复制的延迟大幅下降，系统恢复正常。</p></li></ul><h3 id=3-nginx-高并发下的资源耗尽>3. <strong>Nginx 高并发下的资源耗尽</strong>
<a class=anchor href=#3-nginx-%e9%ab%98%e5%b9%b6%e5%8f%91%e4%b8%8b%e7%9a%84%e8%b5%84%e6%ba%90%e8%80%97%e5%b0%bd>#</a></h3><p>在处理高并发请求时，我们的 Nginx 服务器出现了 CPU 占用率过高，导致请求超时和部分服务不可用。</p><h4 id=排查步骤-2>排查步骤：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%ad%a5%e9%aa%a4-2>#</a></h4><ul><li><strong>查看 Nginx 错误日志</strong>：Nginx 错误日志显示了大量的 <code>worker process</code> 启动失败，进程数达到上限，导致无法处理新的请求。</li><li><strong>查看系统资源</strong>：使用 <code>top</code> 命令查看服务器的 CPU 和内存占用，发现 Nginx 的 worker 进程消耗了大量的 CPU 资源。</li><li><strong>分析 Nginx 配置</strong>：检查 Nginx 的 <code>worker_processes</code> 和 <code>worker_connections</code> 配置，发现 <code>worker_processes</code> 配置为 2，导致高并发时无法充分利用服务器的 CPU 核心。</li><li><strong>调整配置</strong>：根据机器的 CPU 核心数，将 <code>worker_processes</code> 设置为 <code>auto</code>，并根据负载调整 <code>worker_connections</code> 数量。</li><li><strong>优化系统配置</strong>：增加了文件句柄限制，调整了操作系统的 <code>ulimit</code> 参数，确保 Nginx 可以处理更多的并发连接。</li><li><strong>验证结果</strong>：修改配置后，Nginx 的性能得到了显著提升，服务器负载得以均衡，处理高并发请求时不再出现资源耗尽的问题。</li></ul><h3 id=4-zookeeper-的节点丢失>4. <strong>Zookeeper 的节点丢失</strong>
<a class=anchor href=#4-zookeeper-%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%a2%e5%a4%b1>#</a></h3><p>在一次 Zookeeper 集群的升级过程中，由于配置问题，集群的部分节点丢失，导致集群不可用。</p><h4 id=排查步骤-3>排查步骤：
<a class=anchor href=#%e6%8e%92%e6%9f%a5%e6%ad%a5%e9%aa%a4-3>#</a></h4><ul><li><strong>查看 Zookeeper 节点日志</strong>：通过查看丢失节点的日志，发现 Zookeeper 的 <code>dataDir</code> 配置错误，导致节点无法正常启动。</li><li><strong>检查 Zookeeper 配置</strong>：验证了 <code>zoo.cfg</code> 中的 <code>dataDir</code> 路径和 <code>myid</code> 配置，发现路径配置错误，导致该节点无法在集群中正确识别。</li><li><strong>修复配置</strong>：纠正了路径和 ID 配置，重新启动了 Zookeeper 节点，确保该节点能够加入集群。</li><li><strong>验证结果</strong>：重新启动节点后，Zookeeper 集群恢复正常，所有节点都恢复了数据同步，集群可用性恢复。</li></ul><h3 id=总结-8>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-8>#</a></h3><p>这些中间件的排障经历中，最重要的几个步骤通常是：</p><ul><li><strong>分析日志</strong>：深入分析相关中间件的日志文件，找到错误的根本原因。</li><li><strong>监控指标</strong>：使用 Prometheus、Grafana 等监控工具收集指标，提前发现性能瓶颈或潜在问题。</li><li><strong>配置优化</strong>：根据问题的原因，调整中间件和系统的配置，解决性能或资源瓶颈问题。</li><li><strong>网络排查</strong>：尤其在分布式系统中，网络问题可能会导致严重的故障，需要重点排查网络连通性和带宽。</li></ul><p>这些经验帮助我在工作中能更快地定位和解决中间件的问题，确保系统的高可用性和稳定性。</p><p>在 <strong>Sentinel</strong>（通常指 Redis Sentinel）配置中，如果你使用了 1 主 2 从 3 哨兵的架构，当主节点故障转移（failover）后，应用可能会出现连接问题，因为在故障转移发生时，Redis 的主节点会发生变化。哨兵会选举一个新的主节点，并通知客户端更新连接的信息。此时，如果应用没有及时响应或配置不当，就会导致连接到错误的 Redis 节点，导致连接问题。</p><h3 id=故障转移后应用连接问题的原因>故障转移后应用连接问题的原因
<a class=anchor href=#%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb%e5%90%8e%e5%ba%94%e7%94%a8%e8%bf%9e%e6%8e%a5%e9%97%ae%e9%a2%98%e7%9a%84%e5%8e%9f%e5%9b%a0>#</a></h3><ul><li><strong>客户端未更新主节点地址</strong>：应用程序未能及时获取新的主节点 IP 地址，因此继续连接到旧的主节点或从节点。</li><li><strong>客户端未配置 Redis Sentinel</strong>：如果客户端没有配置 Redis Sentinel 来自动发现新的主节点，在故障转移发生后，客户端将无法自动切换到新的主节点。</li><li><strong>Sentinel 配置问题</strong>：如果 Redis Sentinel 没有正确配置，或者故障转移没有成功完成，应用可能会连接到一个不健康的节点。</li></ul><h3 id=解决方案与恢复步骤>解决方案与恢复步骤
<a class=anchor href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e4%b8%8e%e6%81%a2%e5%a4%8d%e6%ad%a5%e9%aa%a4>#</a></h3><h4 id=1-确保应用客户端支持-redis-sentinel>1. <strong>确保应用客户端支持 Redis Sentinel</strong>
<a class=anchor href=#1-%e7%a1%ae%e4%bf%9d%e5%ba%94%e7%94%a8%e5%ae%a2%e6%88%b7%e7%ab%af%e6%94%af%e6%8c%81-redis-sentinel>#</a></h4><p>应用程序需要能够与 Redis Sentinel 通信，从而在故障转移后自动重新连接到新的主节点。Redis 客户端（例如 <code>redis-py</code>、<code>Jedis</code> 等）通常提供与 Sentinel 的集成。</p><ul><li><p><strong>更新客户端配置</strong>：确保客户端配置了 Redis Sentinel 的地址列表，而不是单个 Redis 实例的地址。客户端会向 Sentinel 查询当前的主节点信息，并根据查询结果连接到新的主节点。</p><p>例如，使用 <code>redis-py</code> 客户端时，可以这样配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> redis.sentinel <span style=color:#f92672>import</span> Sentinel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sentinel <span style=color:#f92672>=</span> Sentinel([(<span style=color:#e6db74>&#39;sentinel_host1&#39;</span>, <span style=color:#ae81ff>26379</span>), (<span style=color:#e6db74>&#39;sentinel_host2&#39;</span>, <span style=color:#ae81ff>26379</span>), (<span style=color:#e6db74>&#39;sentinel_host3&#39;</span>, <span style=color:#ae81ff>26379</span>)])
</span></span><span style=display:flex><span>master <span style=color:#f92672>=</span> sentinel<span style=color:#f92672>.</span>master_for(<span style=color:#e6db74>&#39;mymaster&#39;</span>, socket_timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>)
</span></span></code></pre></div><p>这样，当故障转移发生时，<code>master_for</code> 方法会自动获取新的主节点地址。</p></li></ul><h4 id=2-检查-sentinel-的状态>2. <strong>检查 Sentinel 的状态</strong>
<a class=anchor href=#2-%e6%a3%80%e6%9f%a5-sentinel-%e7%9a%84%e7%8a%b6%e6%80%81>#</a></h4><p>确保 Sentinel 已经成功地进行故障转移并且选举了新的主节点。你可以使用以下命令检查 Sentinel 的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>redis-cli -h sentinel_host -p sentinel_port SENTINEL failover mymaster
</span></span></code></pre></div><p>确认新的主节点已经选举出来并且状态为 <code>master</code>。</p><h4 id=3-验证新的主节点和从节点>3. <strong>验证新的主节点和从节点</strong>
<a class=anchor href=#3-%e9%aa%8c%e8%af%81%e6%96%b0%e7%9a%84%e4%b8%bb%e8%8a%82%e7%82%b9%e5%92%8c%e4%bb%8e%e8%8a%82%e7%82%b9>#</a></h4><p>使用 Sentinel 命令查看新的主节点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>redis-cli -h sentinel_host -p sentinel_port SENTINEL get-master-addr-by-name mymaster
</span></span></code></pre></div><p>该命令返回新的主节点的 IP 和端口，确保应用连接到正确的主节点。</p><p>同时，检查从节点状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>redis-cli -h sentinel_host -p sentinel_port SENTINEL slaves mymaster
</span></span></code></pre></div><p>确保从节点正常同步新的主节点。</p><h4 id=4-确认-redis-哨兵配置>4. <strong>确认 Redis 哨兵配置</strong>
<a class=anchor href=#4-%e7%a1%ae%e8%ae%a4-redis-%e5%93%a8%e5%85%b5%e9%85%8d%e7%bd%ae>#</a></h4><p>检查 Redis Sentinel 配置文件，确保以下配置项正确：</p><ul><li><code>sentinel monitor mymaster &lt;master_ip> &lt;master_port> &lt;quorum></code>：确保监视主节点的配置正确。</li><li><code>sentinel down-after-milliseconds mymaster &lt;time_in_ms></code>：确保哨兵检测到主节点不可用的时间足够短。</li><li><code>sentinel failover-timeout mymaster &lt;time_in_ms></code>：确保故障转移的超时时间足够合理。</li></ul><h4 id=5-应用重试机制>5. <strong>应用重试机制</strong>
<a class=anchor href=#5-%e5%ba%94%e7%94%a8%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6>#</a></h4><p>为了避免在故障转移期间应用出现长时间无法连接的问题，可以在应用中增加连接重试机制，确保在主节点切换期间应用能够自动重新连接。</p><p>例如，在客户端连接时，设置一定的重试次数和超时时间。</p><h4 id=6-应用重新启动如果需要>6. <strong>应用重新启动（如果需要）</strong>
<a class=anchor href=#6-%e5%ba%94%e7%94%a8%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8%e5%a6%82%e6%9e%9c%e9%9c%80%e8%a6%81>#</a></h4><p>如果应用没有及时获取到新的主节点信息，重启应用程序可以强制它重新与 Redis Sentinel 进行通信，从而获取正确的主节点地址。</p><h3 id=总结-9>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-9>#</a></h3><ul><li><strong>配置 Redis Sentinel 支持</strong>：确保应用支持通过 Redis Sentinel 自动发现主节点。</li><li><strong>检查 Sentinel 和 Redis 节点状态</strong>：通过 Redis CLI 检查 Sentinel 和 Redis 节点的状态，确认故障转移完成。</li><li><strong>重试机制</strong>：在应用中增加连接重试机制，防止连接失败。</li><li><strong>配置优化</strong>：优化 Redis Sentinel 配置，确保故障转移高效、可靠。</li></ul><p>通过上述步骤，应该能够恢复应用连接问题，确保 Redis 高可用性架构稳定运行。</p><h2 id=编程语言熟悉哪个实现最复杂的功能>编程语言熟悉哪个？实现最复杂的功能？
<a class=anchor href=#%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e7%86%9f%e6%82%89%e5%93%aa%e4%b8%aa%e5%ae%9e%e7%8e%b0%e6%9c%80%e5%a4%8d%e6%9d%82%e7%9a%84%e5%8a%9f%e8%83%bd>#</a></h2><p>我熟悉多种编程语言，并能够实现复杂的功能。以下是我熟悉的一些语言和我曾实现过的复杂功能的例子：</p><ol><li><strong>Python</strong>：<ul><li><strong>复杂功能</strong>：开发过多个全栈项目，包括使用 Flask 和 Django 搭建的 web 应用，编写过大量的自动化脚本和运维工具（例如：自动化部署工具、CI/CD 流程等）。</li><li><strong>功能实现</strong>：编写过批量处理大数据的 ETL 系统，进行大规模日志分析，并通过机器学习模型进行预测分析。</li></ul></li><li><strong>Go</strong>：<ul><li><strong>复杂功能</strong>：实现过高并发、高性能的网络应用，主要用于云原生应用和容器管理工具的开发。</li><li><strong>功能实现</strong>：例如在 Kubernetes 环境中，使用 Go 开发过监控和日志收集系统，支持高并发的日志数据处理。</li></ul></li><li><strong>JavaScript (Vue.js 和 Node.js)</strong>：<ul><li><strong>复杂功能</strong>：实现过全栈应用，使用 Vue.js 实现前端交互，Node.js 实现后端服务，主要应用于企业级平台开发。</li><li><strong>功能实现</strong>：设计并实现了前端数据可视化界面，结合 WebSocket 实现实时数据展示，后端使用 RESTful API 与数据库交互。</li></ul></li><li><strong>Shell 脚本</strong>：<ul><li><strong>复杂功能</strong>：编写过复杂的运维自动化脚本，涵盖系统监控、日志收集、数据备份、故障诊断等任务。</li><li><strong>功能实现</strong>：例如通过 Shell 脚本实现自动化的系统巡检，定期进行应用的备份、日志清理和数据压缩等操作。</li></ul></li><li><strong>SQL</strong>：<ul><li><strong>复杂功能</strong>：在数据库中实现复杂的查询，进行数据分析和优化。</li><li><strong>功能实现</strong>：编写复杂的 SQL 查询语句和存储过程，处理数据迁移、清洗、合并等工作。</li></ul></li><li><strong>Ansible</strong>：<ul><li><strong>复杂功能</strong>：开发过复杂的自动化运维流程，包括 Kubernetes 集群的自动化部署、配置管理、应用发布等。</li><li><strong>功能实现</strong>：通过 Ansible Playbook 实现大规模系统的批量配置、软件安装、环境搭建等自动化任务。</li></ul></li></ol><p>我在这些领域的经验使我能够快速解决技术难题，并根据需求实现高效、可维护的解决方案。如果你有具体的编程需求或技术问题，欢迎提出，我可以帮助你实现！</p><p>在使用 Flask 和 Django 搭建的 Web 应用中，我曾经实现过一些具有挑战性和功能丰富的应用。以下是我在这两个框架下实现过的一些具体功能：</p><h3 id=1-flask-项目>1. <strong>Flask 项目：</strong>
<a class=anchor href=#1-flask-%e9%a1%b9%e7%9b%ae>#</a></h3><h4 id=运维自动化管理平台><strong>运维自动化管理平台</strong>：
<a class=anchor href=#%e8%bf%90%e7%bb%b4%e8%87%aa%e5%8a%a8%e5%8c%96%e7%ae%a1%e7%90%86%e5%b9%b3%e5%8f%b0>#</a></h4><ul><li><p>功能</p><p>：</p><ul><li><strong>用户认证与权限管理</strong>：通过 Flask-Login 和 Flask-Principal 实现用户的登录、注册、权限控制等功能，支持基于角色的访问控制 (RBAC)。</li><li><strong>多服务器管理</strong>：通过 Flask 和 Celery 实现对多台主机的远程 SSH 执行命令，进行批量操作，如批量安装软件、更新配置、重启服务等。</li><li><strong>任务调度与监控</strong>：使用 Celery 实现任务调度，用户可以查看任务的执行状态（成功/失败），同时支持任务重试机制。</li><li><strong>日志管理</strong>：集成日志收集系统，通过 Flask-WTF 设计表单，允许用户查看、过滤和下载日志文件。</li></ul></li></ul><h4 id=数据分析与可视化平台><strong>数据分析与可视化平台</strong>：
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%88%86%e6%9e%90%e4%b8%8e%e5%8f%af%e8%a7%86%e5%8c%96%e5%b9%b3%e5%8f%b0>#</a></h4><ul><li><p>功能</p><p>：</p><ul><li><strong>数据上传与管理</strong>：提供用户上传各种格式（如 CSV、Excel 等）数据的功能，并对数据进行存储和管理。</li><li><strong>数据清洗和处理</strong>：利用 Pandas 库对上传的数据进行清洗和预处理，例如填补缺失值、数据去重、异常值处理等。</li><li><strong>数据可视化</strong>：集成 Plotly 或 Matplotlib 库，动态展示数据图表，包括柱状图、折线图、饼图等，支持用户根据不同条件选择查看数据。</li><li><strong>报表生成与导出</strong>：用户可以自定义报表模板，生成 PDF 或 Excel 格式的报表，并进行导出。</li></ul></li></ul><h3 id=2-django-项目>2. <strong>Django 项目：</strong>
<a class=anchor href=#2-django-%e9%a1%b9%e7%9b%ae>#</a></h3><h4 id=企业级管理平台><strong>企业级管理平台</strong>：
<a class=anchor href=#%e4%bc%81%e4%b8%9a%e7%ba%a7%e7%ae%a1%e7%90%86%e5%b9%b3%e5%8f%b0>#</a></h4><ul><li><p>功能</p><p>：</p><ul><li><strong>后台管理界面</strong>：使用 Django Admin 自带的管理后台快速生成用户管理、权限管理、商品管理、订单管理等功能。</li><li><strong>API 接口</strong>：通过 Django REST Framework 实现 RESTful API，用于与前端 Vue.js 或 React 进行数据交互。</li><li><strong>搜索与过滤</strong>：集成 Haystack 或 Django-filter 实现内容搜索和筛选功能，支持模糊查询和多条件筛选。</li><li><strong>消息推送</strong>：通过 Django Channels 实现 WebSocket 通信，实时推送系统通知和消息。</li><li><strong>报告生成</strong>：为用户提供生成自定义报表的功能，可以导出 PDF 或 Excel 格式的文件。</li></ul></li></ul><h4 id=电商平台><strong>电商平台</strong>：
<a class=anchor href=#%e7%94%b5%e5%95%86%e5%b9%b3%e5%8f%b0>#</a></h4><ul><li><p>功能</p><p>：</p><ul><li><strong>商品管理</strong>：实现商品的增、删、改、查功能，支持商品分类、品牌筛选、价格排序等。</li><li><strong>用户订单管理</strong>：用户下单、支付、查看订单状态等功能，同时后台管理员可以管理订单、发货等。</li><li><strong>支付接口集成</strong>：集成第三方支付接口（如支付宝、微信支付），处理支付过程中的回调、通知等。</li><li><strong>购物车与结算</strong>：用户可以将商品添加到购物车，并进行结算，支持使用优惠券、积分等促销手段。</li></ul></li></ul><h4 id=社交平台><strong>社交平台</strong>：
<a class=anchor href=#%e7%a4%be%e4%ba%a4%e5%b9%b3%e5%8f%b0>#</a></h4><ul><li><p>功能</p><p>：</p><ul><li><strong>用户动态</strong>：用户可以发布文本、图片、视频等动态，其他用户可以评论和点赞。</li><li><strong>关注与粉丝</strong>：用户可以关注其他用户，查看其动态，并获取相关通知。</li><li><strong>私信系统</strong>：通过 Django Channels 实现实时私信，用户可以互相发送和接收消息。</li><li><strong>搜索与推荐</strong>：集成 Elasticsearch 或 Haystack 实现全站内容搜索和智能推荐功能。</li></ul></li></ul><h4 id=项目管理与协作平台><strong>项目管理与协作平台</strong>：
<a class=anchor href=#%e9%a1%b9%e7%9b%ae%e7%ae%a1%e7%90%86%e4%b8%8e%e5%8d%8f%e4%bd%9c%e5%b9%b3%e5%8f%b0>#</a></h4><ul><li><p>功能</p><p>：</p><ul><li><strong>任务管理</strong>：支持创建、分配和跟踪任务，任务支持优先级、截止日期、负责人等字段。</li><li><strong>团队协作</strong>：用户可以组建团队，协作处理任务，支持多级权限控制。</li><li><strong>时间追踪</strong>：记录每个任务的工作时间，生成工作报告，支持按项目或团队查看统计数据。</li><li><strong>项目进度</strong>：可视化展示项目进度，通过甘特图或看板查看任务的完成情况。</li></ul></li></ul><h3 id=总结-10>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-10>#</a></h3><p>在这些 Web 应用中，我主要通过 Flask 和 Django 实现了以下核心功能：</p><ul><li>用户管理和认证；</li><li>数据管理与分析；</li><li>后台管理系统；</li><li>消息推送和实时通信；</li><li>支付和订单管理；</li><li>搜索和报表生成。</li></ul><p>这些项目展示了我在不同领域的开发能力，无论是前端、后端、数据库，还是与第三方服务集成、实时通信等，都有涉及。如果你有类似的需求或想要讨论如何实现某些功能，可以详细说明，我很乐意提供帮助！</p><h2 id=k8s的operator用过吗helm用过吗>k8s的operator用过吗？helm用过吗？
<a class=anchor href=#k8s%e7%9a%84operator%e7%94%a8%e8%bf%87%e5%90%97helm%e7%94%a8%e8%bf%87%e5%90%97>#</a></h2><h3 id=创建-helm-chart>创建 Helm Chart
<a class=anchor href=#%e5%88%9b%e5%bb%ba-helm-chart>#</a></h3><p>接下来，使用 Helm 创建一个 Chart 来部署 Flask 应用。假设你已经安装了 Helm。</p><ol><li><strong>创建一个新的 Helm Chart：</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm create flask-app
</span></span></code></pre></div><p>这将创建一个名为 <code>flask-app</code> 的文件夹，并且包含了一些 Helm 默认的文件和模板。</p><ol><li><strong>编辑 Helm Chart 配置：</strong></li></ol><p>打开 <code>flask-app/values.yaml</code>，并修改以下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 修改镜像的名称和标签</span>
</span></span><span style=display:flex><span><span style=color:#f92672>image</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>repository</span>: <span style=color:#ae81ff>your-dockerhub-username/flask-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>tag</span>: <span style=color:#ae81ff>latest</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>pullPolicy</span>: <span style=color:#ae81ff>IfNotPresent</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 修改服务端口</span>
</span></span><span style=display:flex><span><span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><ol><li><strong>修改 <code>flask-app/templates/deployment.yaml</code>：</strong></li></ol><p>确保 <code>deployment.yaml</code> 中的容器端口与 Flask 应用的端口匹配（Flask 默认是 5000），但因为我们通常希望将它暴露在 80 端口上，记得在服务的配置中进行修改。</p><p>编辑 <code>flask-app/templates/deployment.yaml</code> 中的 <code>containerPort</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>5000</span>
</span></span></code></pre></div><h3 id=步骤-5-部署-flask-应用>步骤 5: 部署 Flask 应用
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-5-%e9%83%a8%e7%bd%b2-flask-%e5%ba%94%e7%94%a8>#</a></h3><p>使用以下命令安装 Helm Chart：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install flask-app ./flask-app
</span></span></code></pre></div><p>这将使用你刚刚创建的 Helm Chart 部署 Flask 应用。</p><h3 id=步骤-6-检查部署状态>步骤 6: 检查部署状态
<a class=anchor href=#%e6%ad%a5%e9%aa%a4-6-%e6%a3%80%e6%9f%a5%e9%83%a8%e7%bd%b2%e7%8a%b6%e6%80%81>#</a></h3><p>你可以使用以下命令检查部署的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>查看服务的暴露方式，确保你可以通过外部访问到 Flask 应用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get svc
</span></span></code></pre></div><p>你应该能够看到一个服务正在监听 HTTP 流量，并且你的 Flask 应用已经成功部署在 Kubernetes 集群中。</p><hr><p>这样，你就通过 Helm 部署了一个简单的 Flask 应用。如果你有其他特定的需求或者遇到问题，欢迎继续询问！</p><p>有什么问题问我？项目上的事情做好就行？</p><p>生产变更多吗？晚上做？一月一次</p><p>十来个人 每个人有各自的项目</p><h2 id=故障复盘怎么做的>故障复盘怎么做的
<a class=anchor href=#%e6%95%85%e9%9a%9c%e5%a4%8d%e7%9b%98%e6%80%8e%e4%b9%88%e5%81%9a%e7%9a%84>#</a></h2><p><strong>故障复盘</strong>（Post-mortem analysis）是对故障发生后进行的详细分析过程，目的是找出问题的根本原因，评估响应过程，提出改进措施，以防止类似问题的再次发生。以下是一个完整的故障复盘过程，包含从问题发生到总结和改进的各个步骤：</p><h3 id=1-准备工作>1. <strong>准备工作</strong>
<a class=anchor href=#1-%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c>#</a></h3><p>在复盘开始之前，确保以下几个条件：</p><ul><li><strong>故障发生时间和日志</strong>：收集并准备故障发生时的日志、监控数据、报警信息等。</li><li><strong>相关人员</strong>：确保相关的技术人员、管理人员以及其他参与故障处理的人都能参与复盘。</li><li><strong>时间和地点</strong>：安排一个合适的时间和地点进行复盘，避免赶时间和干扰。</li></ul><h3 id=2-回顾故障事件>2. <strong>回顾故障事件</strong>
<a class=anchor href=#2-%e5%9b%9e%e9%a1%be%e6%95%85%e9%9a%9c%e4%ba%8b%e4%bb%b6>#</a></h3><p>通过收集到的资料，详细回顾故障事件：</p><ul><li><strong>故障时间点</strong>：什么时候故障开始发生，什么时候恢复正常。</li><li><strong>影响范围</strong>：哪些业务或服务受到影响，故障影响了多少用户。</li><li><strong>报警信息</strong>：监控报警和日志的异常信息，确认系统是如何检测到故障的。</li></ul><p>这一步骤的目的是建立故障发生的时间线，尽量重现整个故障的过程，确保每个细节都被回顾。</p><h3 id=3-确定故障原因>3. <strong>确定故障原因</strong>
<a class=anchor href=#3-%e7%a1%ae%e5%ae%9a%e6%95%85%e9%9a%9c%e5%8e%9f%e5%9b%a0>#</a></h3><p>通过以下方式逐步排查，找出故障的根本原因：</p><ul><li><strong>系统日志</strong>：分析系统日志、应用日志、数据库日志等，查看是否有明显的错误或异常。</li><li><strong>监控数据</strong>：查看监控平台（例如 Prometheus + Grafana、Zabbix 等）的数据，确认是否存在系统负载、内存、CPU 或磁盘等资源的瓶颈。</li><li><strong>配置变更</strong>：检查是否有最近的配置更改，或者新部署的服务引发了故障。</li><li><strong>网络问题</strong>：如果故障涉及到分布式架构，检查网络连接是否正常，是否存在延迟或丢包。</li><li><strong>外部因素</strong>：是否存在外部依赖问题（如第三方服务故障）。</li></ul><p>在此过程中，可以使用<strong>5个为什么</strong>（5 Whys）分析方法，逐步深入到根本原因。例如，故障的表象可能是服务器宕机，但深入分析可能发现是由于磁盘空间不足导致的，而磁盘空间不足是因为日志文件未被清理。</p><h3 id=4-评估响应过程>4. <strong>评估响应过程</strong>
<a class=anchor href=#4-%e8%af%84%e4%bc%b0%e5%93%8d%e5%ba%94%e8%bf%87%e7%a8%8b>#</a></h3><p>评估团队和个人在故障发生时的响应：</p><ul><li><strong>故障检测和报警</strong>：是否能够及时发现问题，报警机制是否合理？是否有足够的报警规则覆盖到关键指标？</li><li><strong>应急响应</strong>：在故障发生后，是否有清晰的应急预案？团队是否按照预案快速响应？响应人员是否到位？</li><li><strong>恢复过程</strong>：故障恢复是否及时？恢复过程中的沟通是否顺畅？是否存在人为操作失误？</li><li><strong>故障追踪</strong>：是否有良好的故障追踪和记录，以便后续分析？</li></ul><p>这一部分帮助团队了解响应中的优点与不足，为今后优化故障响应流程提供依据。</p><h3 id=5-总结问题及其影响>5. <strong>总结问题及其影响</strong>
<a class=anchor href=#5-%e6%80%bb%e7%bb%93%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e5%bd%b1%e5%93%8d>#</a></h3><p>根据问题发生的原因和影响，做出总结：</p><ul><li><strong>问题根本原因</strong>：明确指出故障的根本原因，避免只停留在表面症状的层面。</li><li><strong>故障的影响</strong>：估算故障带来的经济损失、用户影响、品牌影响等。可以通过一些量化指标来说明影响范围，例如停机时长、用户投诉数、服务级别协议（SLA）违约等。</li></ul><h3 id=6-制定改进计划>6. <strong>制定改进计划</strong>
<a class=anchor href=#6-%e5%88%b6%e5%ae%9a%e6%94%b9%e8%bf%9b%e8%ae%a1%e5%88%92>#</a></h3><p>基于故障复盘的结果，制定详细的改进计划，防止类似问题的发生。可能的改进措施包括：</p><ul><li><p>基础设施方面</p><p>：</p><ul><li>增强硬件资源或虚拟资源，避免单点故障。</li><li>优化网络、存储和数据库架构。</li><li>引入冗余备份和自动化容错机制（例如，使用高可用、负载均衡、自动伸缩等）。</li></ul></li><li><p>流程方面</p><p>：</p><ul><li>改进故障检测机制，调整报警阈值，避免报警过多或漏报。</li><li>制定和完善应急响应流程和操作手册。</li><li>定期进行灾备演练，确保应急预案可行。</li></ul></li><li><p>自动化方面</p><p>：</p><ul><li>增加自动化运维工具，如自动化部署、自动化恢复等，减少人工干预。</li><li>增加健康检查和自动修复功能，提升系统自愈能力。</li></ul></li><li><p>团队方面</p><p>：</p><ul><li>进行团队的故障响应和沟通能力培训，确保团队成员能够在压力下高效协作。</li><li>分析团队在故障中的不足，提升团队协作能力。</li></ul></li></ul><h3 id=7-改进措施的执行>7. <strong>改进措施的执行</strong>
<a class=anchor href=#7-%e6%94%b9%e8%bf%9b%e6%8e%aa%e6%96%bd%e7%9a%84%e6%89%a7%e8%a1%8c>#</a></h3><p>将制定的改进措施落实到实际工作中：</p><ul><li><strong>制定任务计划</strong>：为每个改进措施指定责任人、时间节点和具体执行步骤。</li><li><strong>执行改进计划</strong>：按照计划执行，确保每个改进点得以实施。</li><li><strong>跟踪执行情况</strong>：定期检查执行进展，确保改进措施得以有效落地。</li></ul><h3 id=8-撰写故障复盘报告>8. <strong>撰写故障复盘报告</strong>
<a class=anchor href=#8-%e6%92%b0%e5%86%99%e6%95%85%e9%9a%9c%e5%a4%8d%e7%9b%98%e6%8a%a5%e5%91%8a>#</a></h3><p>在故障复盘结束后，撰写详细的故障复盘报告，报告内容一般包括：</p><ul><li><strong>故障时间线</strong>：详细列出故障发生的时间点、影响范围和恢复过程。</li><li><strong>故障原因分析</strong>：总结故障的根本原因和具体技术细节。</li><li><strong>响应评估</strong>：评估团队的响应过程，指出问题与改进点。</li><li><strong>改进计划</strong>：列出改进措施和具体的执行步骤。</li><li><strong>结论</strong>：总结经验教训，鼓励团队持续改进。</li></ul><p>复盘报告可以分享给相关的团队和管理层，确保所有人都能从故障中学习。</p><h3 id=9-后续跟进>9. <strong>后续跟进</strong>
<a class=anchor href=#9-%e5%90%8e%e7%bb%ad%e8%b7%9f%e8%bf%9b>#</a></h3><p>故障复盘后，需要进行持续跟进，确保所有的改进措施得到实施，并在未来进行验证：</p><ul><li><strong>定期回顾</strong>：在后续的例会上回顾已实施的改进措施是否有效。</li><li><strong>复盘新故障</strong>：每次新的故障发生后，继续进行复盘，并对改进措施的效果进行评估。</li></ul><h3 id=总结-11>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93-11>#</a></h3><p>故障复盘的目的是通过对故障事件的深入分析，发现问题根本原因，改进现有流程和系统架构，提升团队应对故障的能力，确保类似问题不再发生。复盘的关键在于透明、客观和系统的分析，确保团队能够从每一次故障中吸取经验教训。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#上海外包太平洋保险>上海外包太平洋保险</a></li><li><a href=#有完成过ansible比较复杂的role-task的编写吗>有完成过ansible比较复杂的role task的编写吗？</a><ul><li><a href=#1-完整的-kubernetes-集群节点加入-role-编写><strong>1. 完整的 Kubernetes 集群节点加入 Role 编写</strong></a></li><li><a href=#2-ansible-role-示例><strong>2. Ansible Role 示例</strong></a></li><li><a href=#3-role-的配置文件结构><strong>3. Role 的配置文件结构</strong></a></li><li><a href=#4-执行过程><strong>4. 执行过程</strong></a></li><li><a href=#总结><strong>总结</strong></a></li></ul></li><li><a href=#defaultsmainyml定义该-role-的默认变量可以为所有的任务设置默认值-varsmainyml可以为该-role-提供更具体的变量设置-谁的优先级更高>defaults/main.yml：定义该 Role 的默认变量，可以为所有的任务设置默认值。 vars/main.yml：可以为该 Role 提供更具体的变量设置。 谁的优先级更高</a><ul><li><a href=#优先级><strong>优先级</strong></a></li><li><a href=#优先级顺序><strong>优先级顺序：</strong></a></li><li><a href=#例子><strong>例子</strong></a></li><li><a href=#总结-1><strong>总结</strong></a></li></ul></li><li><a href=#集群多少规模多大用ansible部署>集群多少？规模多大？用ansible部署。</a></li><li><a href=#ansible变量的优先级变量的优先级怎么去设置同一变量可能出现在playbook的多个地方>ansible变量的优先级？变量的优先级怎么去设置，同一变量可能出现在playbook的多个地方</a></li><li><a href=#你是如何用优先级去控制变量的正确性>你是如何用优先级去控制变量的正确性？</a><ul><li><a href=#ansible-变量的优先级从低到高><strong>Ansible 变量的优先级（从低到高）</strong></a></li><li><a href=#优先级的示意图><strong>优先级的示意图：</strong></a></li><li><a href=#优先级控制变量正确性的方法><strong>优先级控制变量正确性的方法：</strong></a></li><li><a href=#优先级应用场景><strong>优先级应用场景：</strong></a></li><li><a href=#如何控制变量的正确性><strong>如何控制变量的正确性</strong></a></li></ul></li><li><a href=#playbook的role存在多个子的role那么如何让控制好他的执行顺序>playbook的role存在多个子的role，那么如何让控制好他的执行顺序？</a><ul><li><a href=#1-role-执行顺序role-顺序是基于-playbook-中的定义顺序来决定的>1. <strong>Role 执行顺序：Role 顺序是基于 Playbook 中的定义顺序来决定的</strong></a></li><li><a href=#2-使用>2. <strong>使用 <code>dependencies</code> 控制 Role 的执行顺序</strong></a></li><li><a href=#3-在-playbook-中使用>3. <strong>在 Playbook 中使用 <code>pre_tasks</code> 和 <code>post_tasks</code> 控制执行顺序</strong></a></li><li><a href=#4-利用>4. <strong>利用 <code>tags</code> 控制 Role 的执行顺序</strong></a></li><li><a href=#5-条件判断来控制执行顺序>5. <strong>条件判断来控制执行顺序</strong></a></li><li><a href=#6-使用>6. <strong>使用 <code>block</code> 来组合多个 Role</strong></a></li><li><a href=#7-使用>7. <strong>使用 <code>serial</code> 来控制并发执行</strong></a></li><li><a href=#总结-2><strong>总结</strong></a></li></ul></li><li><a href=#meta用过吗role-task里面main里面第一个yaml还有个meta-在执行主的yaml前去调用这个的预先的执行meta的外部扩展的子>meta用过吗？role task里面main里面第一个yaml，还有个meta 在执行主的yaml前去调用这个的预先的，执行meta的外部扩展的子</a><ul><li><a href=#metamainyml-的常见用途><code>meta/main.yml</code> 的常见用途：</a></li><li><a href=#1-role-依赖配置>1. <strong>Role 依赖配置</strong></a></li><li><a href=#2-meta>2. <strong><code>meta</code> 在 Role 中的执行</strong></a></li><li><a href=#3-如何调用>3. <strong>如何调用 <code>meta</code> 里的内容</strong></a></li><li><a href=#注意事项><strong>注意事项</strong>：</a></li><li><a href=#4-metamainyml>4. <strong><code>meta/main.yml</code> 示例</strong></a></li><li><a href=#总结-3><strong>总结</strong>：</a></li></ul></li><li><a href=#除了用ansible部署k8s外上层的软件如何部署其他类似云原生的应用会部署哪些>除了用ansible部署k8s外上层的软件如何部署，其他类似云原生的应用会部署哪些？</a><ul><li><a href=#1-云原生应用部署>1. <strong>云原生应用部署</strong></a></li><li><a href=#2-多集群管理>2. <strong>多集群管理</strong></a></li><li><a href=#3-容器编排与调度>3. <strong>容器编排与调度</strong></a></li><li><a href=#4-安全管理与身份认证>4. <strong>安全管理与身份认证</strong></a></li><li><a href=#5-自动化运维和弹性伸缩>5. <strong>自动化运维和弹性伸缩</strong></a></li><li><a href=#总结-4>总结</a></li></ul></li><li><a href=#helm用吗成品helm部署的模版有个人去完成过吗>helm用吗？成品helm部署的模版有个人去完成过吗？</a><ul><li><a href=#helm-charts-的使用>Helm Charts 的使用</a></li><li><a href=#helm-的优势>Helm 的优势</a></li></ul></li><li><a href=#内部的调优后期运维工作体现在哪>内部的调优，后期运维工作体现在哪？</a><ul><li><a href=#1-性能优化>1. <strong>性能优化</strong></a></li><li><a href=#2-高可用性和容错性设计>2. <strong>高可用性和容错性设计</strong></a></li><li><a href=#3-自动化运维>3. <strong>自动化运维</strong></a></li><li><a href=#4-安全性加强>4. <strong>安全性加强</strong></a></li><li><a href=#5-问题排查与故障处理>5. <strong>问题排查与故障处理</strong></a></li><li><a href=#6-版本升级与迁移>6. <strong>版本升级与迁移</strong></a></li><li><a href=#7-成本优化>7. <strong>成本优化</strong></a></li><li><a href=#总结-5>总结：</a></li></ul></li><li><a href=#k8s的集群的驱逐怎么做的被动驱逐为了不要被驱逐可能主机上已有应用被驱逐不让他被驱逐解决不要被驱逐的问题>k8s的集群的驱逐怎么做的？被动驱逐，为了不要被驱逐，可能主机上已有应用被驱逐，不让他被驱逐，解决不要被驱逐的问题，</a></li><li><a href=#提前扩容做一些考量>提前扩容，做一些考量，</a><ul><li><a href=#1-kubernetes-驱逐机制>1. <strong>Kubernetes 驱逐机制</strong></a></li><li><a href=#2-防止-pod-被驱逐>2. <strong>防止 Pod 被驱逐</strong></a></li><li><a href=#3-如何避免主机应用被驱逐>3. <strong>如何避免主机应用被驱逐</strong></a></li><li><a href=#总结-6>总结：</a></li></ul></li><li><a href=#kafka-zk脑裂怎么解决>kafka ，zk，脑裂怎么解决？</a><ul><li><a href=#1-kafka-中的脑裂问题及解决方法>1. <strong>Kafka 中的脑裂问题及解决方法</strong></a></li><li><a href=#2-zookeeper-中的脑裂问题及解决方法>2. <strong>Zookeeper 中的脑裂问题及解决方法</strong></a></li><li><a href=#3-总结kafka-与-zookeeper-的脑裂问题解决>3. <strong>总结：Kafka 与 Zookeeper 的脑裂问题解决</strong></a></li><li><a href=#网络分区的表现>网络分区的表现：</a></li><li><a href=#在-zookeeper-中的影响>在 Zookeeper 中的影响：</a></li><li><a href=#网络分区的解决方法>网络分区的解决方法：</a></li></ul></li><li><a href=#开发能力有没有flask的前端页面怎么做>开发能力有没有？flask的，前端页面怎么做？</a><ul><li><a href=#前端vuejs-和-flask-配合>前端：Vue.js 和 Flask 配合</a></li><li><a href=#结构概览>结构概览：</a></li><li><a href=#部署>部署：</a></li><li><a href=#1-主机管理和配置管理>1. <strong>主机管理和配置管理</strong>：</a></li><li><a href=#2-ssh-远程登录管理>2. <strong>SSH 远程登录管理</strong>：</a></li><li><a href=#3-日志管理与集中式日志分析>3. <strong>日志管理与集中式日志分析</strong>：</a></li><li><a href=#4-主机监控与报警>4. <strong>主机监控与报警</strong>：</a></li><li><a href=#5-自动化运维任务管理>5. <strong>自动化运维任务管理</strong>：</a></li><li><a href=#具体实现思路>具体实现思路：</a></li><li><a href=#示例架构>示例架构：</a></li><li><a href=#总结-7>总结：</a></li></ul></li><li><a href=#k8s的cni用的啥网络扁平网络跨层跨墙>k8s的cni用的啥，网络，扁平网络，跨层，跨墙，</a></li><li><a href=#子网可能a类-b类跨墙的这种怎么解决>子网可能A类 B类，跨墙的这种，怎么解决</a></li><li><a href=#换工作的原因>换工作的原因</a></li><li><a href=#自我介绍离职原因有无offer多久到岗>自我介绍，离职原因，有无offer，多久到岗。</a></li><li><a href=#印象比较深的中间件排障的经验>印象比较深的中间件排障的经验？</a><ul><li><a href=#1-kafka-集群的脑裂问题>1. <strong>Kafka 集群的脑裂问题</strong></a></li><li><a href=#2-redis-主从复制延迟问题>2. <strong>Redis 主从复制延迟问题</strong></a></li><li><a href=#3-nginx-高并发下的资源耗尽>3. <strong>Nginx 高并发下的资源耗尽</strong></a></li><li><a href=#4-zookeeper-的节点丢失>4. <strong>Zookeeper 的节点丢失</strong></a></li><li><a href=#总结-8>总结</a></li><li><a href=#故障转移后应用连接问题的原因>故障转移后应用连接问题的原因</a></li><li><a href=#解决方案与恢复步骤>解决方案与恢复步骤</a></li><li><a href=#总结-9>总结</a></li></ul></li><li><a href=#编程语言熟悉哪个实现最复杂的功能>编程语言熟悉哪个？实现最复杂的功能？</a><ul><li><a href=#1-flask-项目>1. <strong>Flask 项目：</strong></a></li><li><a href=#2-django-项目>2. <strong>Django 项目：</strong></a></li><li><a href=#总结-10>总结：</a></li></ul></li><li><a href=#k8s的operator用过吗helm用过吗>k8s的operator用过吗？helm用过吗？</a><ul><li><a href=#创建-helm-chart>创建 Helm Chart</a></li><li><a href=#步骤-5-部署-flask-应用>步骤 5: 部署 Flask 应用</a></li><li><a href=#步骤-6-检查部署状态>步骤 6: 检查部署状态</a></li></ul></li><li><a href=#故障复盘怎么做的>故障复盘怎么做的</a><ul><li><a href=#1-准备工作>1. <strong>准备工作</strong></a></li><li><a href=#2-回顾故障事件>2. <strong>回顾故障事件</strong></a></li><li><a href=#3-确定故障原因>3. <strong>确定故障原因</strong></a></li><li><a href=#4-评估响应过程>4. <strong>评估响应过程</strong></a></li><li><a href=#5-总结问题及其影响>5. <strong>总结问题及其影响</strong></a></li><li><a href=#6-制定改进计划>6. <strong>制定改进计划</strong></a></li><li><a href=#7-改进措施的执行>7. <strong>改进措施的执行</strong></a></li><li><a href=#8-撰写故障复盘报告>8. <strong>撰写故障复盘报告</strong></a></li><li><a href=#9-后续跟进>9. <strong>后续跟进</strong></a></li><li><a href=#总结-11>总结</a></li></ul></li></ul></nav></div></aside></main></body></html>