<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  前端填写的deployment的表单怎么变为后端deployment的yaml，以及如何被部署到k8s集群的
  #

你问的这个流程，其实就是 前端表单 → 后端生成 YAML → K8s API Server 部署 的链路。
我给你详细拆开说：


  1️⃣ 前端表单 → Deployment 配置数据
  #

前端的表单（比如输入 应用名、镜像名、副本数、CPU/内存限制、端口 等）就是 Deployment 的核心字段。
前端提交的通常是 JSON 格式的数据，例如：
{
  "name": "myapp",
  "namespace": "default",
  "replicas": 3,
  "image": "nginx:1.21",
  "cpu": "200m",
  "memory": "256Mi",
  "port": 80
}


  2️⃣ 后端 → 转换为 K8s YAML/Manifest
  #

后端拿到这个 JSON，就会用模板（或者动态拼接）生成 Deployment 的 YAML 清单：
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: nginx:1.21
        resources:
          limits:
            cpu: "200m"
            memory: "256Mi"
        ports:
        - containerPort: 80
⚡ 这里后端可能会用模板引擎（Go Template、Jinja2、Handlebars.js 等）来把表单字段替换进 YAML。'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-8-29-%E8%A1%A8%E5%8D%95%E5%88%B0%E9%9B%86%E7%BE%A4/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2025-8-28 表单到集群"><meta property="og:description" content='前端填写的deployment的表单怎么变为后端deployment的yaml，以及如何被部署到k8s集群的 # 你问的这个流程，其实就是 前端表单 → 后端生成 YAML → K8s API Server 部署 的链路。 我给你详细拆开说：
1️⃣ 前端表单 → Deployment 配置数据 # 前端的表单（比如输入 应用名、镜像名、副本数、CPU/内存限制、端口 等）就是 Deployment 的核心字段。 前端提交的通常是 JSON 格式的数据，例如：
{ "name": "myapp", "namespace": "default", "replicas": 3, "image": "nginx:1.21", "cpu": "200m", "memory": "256Mi", "port": 80 } 2️⃣ 后端 → 转换为 K8s YAML/Manifest # 后端拿到这个 JSON，就会用模板（或者动态拼接）生成 Deployment 的 YAML 清单：
apiVersion: apps/v1 kind: Deployment metadata: name: myapp namespace: default spec: replicas: 3 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: containers: - name: myapp image: nginx:1.21 resources: limits: cpu: "200m" memory: "256Mi" ports: - containerPort: 80 ⚡ 这里后端可能会用模板引擎（Go Template、Jinja2、Handlebars.js 等）来把表单字段替换进 YAML。'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2025-8-28 表单到集群 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-8-29-%E8%A1%A8%E5%8D%95%E5%88%B0%E9%9B%86%E7%BE%A4/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.72042605ceb445cbdd5c88049aca84b34b59b749da2a86131776bb6bb8424d9d.js integrity="sha256-cgQmBc60RcvdXIgEmsqEs0tZt0naKoYTF3a7a7hCTZ0=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-9-29-vercel%E5%88%9B%E5%A7%8B%E4%BA%BA%E5%AF%B9%E8%AF%9D/>2025-9-29 Vercel创始人对话</a></li><li><a href=/docs/2025-9-28-spec-workflow-mcp/>2025-9-28 spec-workflow-mcp</a></li><li><a href=/docs/2025-9-28-chrome-mcp-tools/>2025-9-28 chrome-devtools-mcp</a></li><li><a href=/docs/2025-9-19-%E7%90%86%E8%A7%A3/>2025-9-19 理解</a></li><li><a href=/docs/2025-9-10-%E6%8F%90%E7%A4%BA%E8%AF%8D/>2025-9-10 提示词</a></li><li><a href=/docs/2025-9-9-music/>2025-9-09 music资源</a></li><li><a href=/docs/2025-8-29-%E8%A1%A8%E5%8D%95%E5%88%B0%E9%9B%86%E7%BE%A4/ class=active>2025-8-28 表单到集群</a></li><li><a href=/docs/2025-6-27-geminicli/>2025-6-27 geminicli</a></li><li><a href=/docs/2025-6-23-ingress-nginx-contrller-%E5%88%86%E6%9E%90/>2025-6-23 ingress nginx contrller 内存使用过高分析</a></li><li><a href=/docs/2025-6-20-oom/>2025-6-20 oom排查思路</a></li><li><a href=/docs/2025-6-16-fire%E8%A7%84%E5%88%99/>2025-6-16 Cursor RIPER-5规则</a></li><li><a href=/docs/2025-6-12-karmada/>2025-6-12 karmada介绍</a></li><li><a href=/docs/2025-6-12-flutter%E8%A7%84%E5%88%99/>2025-6-12 flutter规则</a></li><li><a href=/docs/2025-6-10-%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/>2025-6-10 独立开发</a></li><li><a href=/docs/2025-5-21-ingress%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/>2025-5-21 主Ingress副本变为0后报503问题分析</a></li><li><a href=/docs/2025-5-7-%E6%8E%A5%E5%8D%95app/>2025-5-07 接单app设计</a></li><li><a href=/docs/2025-5-7-%E5%A5%BD%E5%BF%83%E6%80%81-app/>2025-5-07 好心态app</a></li><li><a href=/docs/2025-4-28-cursor-agent-%E6%8F%90%E7%A4%BA%E5%99%A8/>2025-4-28 cursor agent 提示器</a></li><li><a href=/docs/2025-4-16-%E8%87%AA%E7%A0%94k8s%E5%B9%B3%E5%8F%B0/>2025-4-16 自研k8s平台</a></li><li><a href=/docs/2025-4-16-sleep%E7%9D%A1%E7%9C%A0%E5%BA%94%E7%94%A8/>2025-4-16 sleep睡眠应用</a></li><li><a href=/docs/2025-4-16-paas%E8%AE%BE%E8%AE%A1/>2025-4-16 paas开发记录</a></li><li><a href=/docs/2025-4-16-cursoe-free-vip/>2025-4-16 Cursor Free VIP</a></li><li><a href=/docs/2025-4-16-boss%E7%9B%B4%E8%81%98%E8%87%AA%E5%8A%A8%E6%8A%95%E9%80%92/>2025-4-16 BOSS直聘自动投递</a></li><li><a href=/docs/2025-4-14-github%E6%8E%A8%E9%80%81/>2025-4-14 github推送</a></li><li><a href=/docs/2025-3-30-metallb/>2025-3-30 metallb</a></li><li><a href=/docs/2025-3-24-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/>2025-3-24 自我介绍</a></li><li><a href=/docs/2025-3-20-victoriametrics-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics高可用架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 thanos高可用架构</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-08-01 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 k8s面试题</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-05-01 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-04-17 面试总结</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-03-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-03-08 面试</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2024-03-04 k8s流量链路剖析</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2024-03-04 CSI剖析演进</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-03-04 CNI剖析演进</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-02-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-02-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-02-22 k8s架构师面试大全</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/2025-4-20-%E6%80%A7%E5%90%8C%E6%84%8Fapp/>2025 4 20 性同意app</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-8-28 表单到集群</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#前端填写的deployment的表单怎么变为后端deployment的yaml以及如何被部署到k8s集群的>前端填写的deployment的表单怎么变为后端deployment的yaml，以及如何被部署到k8s集群的</a></li><li><a href=#1-前端表单--deployment-配置数据>1️⃣ 前端表单 → Deployment 配置数据</a></li><li><a href=#2-后端--转换为-k8s-yamlmanifest>2️⃣ 后端 → 转换为 K8s YAML/Manifest</a></li><li><a href=#3-后端--部署到-k8s-集群>3️⃣ 后端 → 部署到 K8s 集群</a><ul><li><a href=#方式-a调用-kubectl-apply>方式 A：调用 <code>kubectl apply</code></a></li><li><a href=#方式-b直接调用-kubernetes-api>方式 B：直接调用 Kubernetes API</a></li><li><a href=#方式-c用官方-sdk>方式 C：用官方 SDK</a></li></ul></li><li><a href=#4-整体流程总结>4️⃣ 整体流程总结</a><ul><li><a href=#1-前端表单转-deployment-的-yaml>1. 前端表单转 deployment 的 YAML</a></li><li><a href=#2-yaml-被部署到-k8s-集群>2. YAML 被部署到 K8s 集群</a></li></ul></li><li><a href=#1-核心功能概览>1️⃣ 核心功能概览</a></li><li><a href=#2-前端表单---yaml-的转换>2️⃣ 前端表单 -> YAML 的转换</a></li><li><a href=#3-用户点击应用部署按钮的流程>3️⃣ 用户点击“应用部署”按钮的流程</a></li><li><a href=#4-submitsuccess---调用后端-api>4️⃣ <code>submitSuccess</code> -> 调用后端 API</a></li><li><a href=#5-调用链总结表单到-yaml-到部署>5️⃣ 调用链总结（表单到 YAML 到部署）</a></li><li><a href=#1-k8scontext-接口><strong>1️⃣ K8sContext 接口</strong></a></li><li><a href=#2-表单--yaml--创建应用><strong>2️⃣ 表单 → YAML → 创建应用</strong></a></li><li><a href=#3-获取应用资源信息><strong>3️⃣ 获取应用资源信息</strong></a></li><li><a href=#4-pause--start-应用><strong>4️⃣ Pause / Start 应用</strong></a></li><li><a href=#5-更新应用资源><strong>5️⃣ 更新应用资源</strong></a></li><li><a href=#6-删除应用><strong>6️⃣ 删除应用</strong></a></li><li><a href=#7-总结表单到-yaml-调用链><strong>7️⃣ 总结表单到 YAML 调用链</strong></a><ul><li><a href=#-解释图中各部分>✅ 解释图中各部分</a></li><li><a href=#-特点>🔹 特点</a></li></ul></li><li><a href=#-整体思路>🔑 整体思路</a></li><li><a href=#-核心函数解析>📌 核心函数解析</a><ul><li><a href=#1-json2deploycr>1. <code>json2DeployCr</code></a></li><li><a href=#2-json2service>2. <code>json2Service</code></a></li><li><a href=#3-json2ingress>3. <code>json2Ingress</code></a></li><li><a href=#4-json2configmap>4. <code>json2ConfigMap</code></a></li><li><a href=#5-json2secret>5. <code>json2Secret</code></a></li><li><a href=#6-json2hpa>6. <code>json2HPA</code></a></li><li><a href=#7-yamlstring2objects>7. <code>yamlString2Objects</code></a></li></ul></li><li><a href=#-整体流程图>📊 整体流程图</a></li><li><a href=#-总结一句话>✅ 总结一句话</a></li><li><a href=#1-kubernetes-客户端初始化>1. <strong>Kubernetes 客户端初始化</strong></a></li><li><a href=#2-判断是否在集群内部运行>2. <strong>判断是否在集群内部运行</strong></a></li><li><a href=#3-加载-kubeconfig>3. <strong>加载 kubeconfig</strong></a></li><li><a href=#4-创建-yaml-到-k8s>4. <strong>创建 YAML 到 K8s</strong></a></li><li><a href=#5-更新替换-yaml-到-k8s>5. <strong>更新/替换 YAML 到 K8s</strong></a></li><li><a href=#6-获取用户配额>6. <strong>获取用户配额</strong></a></li><li><a href=#7-获取用户余额>7. <strong>获取用户余额</strong></a></li><li><a href=#8-封装统一的-k8s-操作入口>8. <strong>封装统一的 K8s 操作入口</strong></a></li><li><a href=#-前后端流程串起来>🔗 前后端流程串起来</a></li><li><a href=#总结一句话>总结一句话</a></li><li><a href=#kubesphere-的前端填写-deployment-表单后核心流程如下>KubeSphere 的前端填写 Deployment 表单后，核心流程如下：</a></li><li><a href=#1-前端表单如何转为-deployment-的-yaml>1. 前端表单如何转为 Deployment 的 YAML</a></li><li><a href=#2-如何被部署到-k8s-集群>2. 如何被部署到 K8s 集群</a><ul><li><a href=#21-接收并-apply-资源对象>2.1 接收并 apply 资源对象</a></li><li><a href=#22-典型调用链>2.2 典型调用链</a></li></ul></li><li><a href=#相关代码参考>相关代码参考</a></li><li><a href=#1-核心结构>1️⃣ 核心结构</a></li><li><a href=#2-核心方法addmemberclusterresource>2️⃣ 核心方法：<code>addMemberClusterResource</code></a><ul><li><a href=#-做了什么>🔹 做了什么</a></li></ul></li><li><a href=#3-validatememberclusterconfiguration>3️⃣ <code>validateMemberClusterConfiguration</code></a></li><li><a href=#4-总结表单字段到-deployment-映射>4️⃣ 总结：表单字段到 Deployment 映射</a></li><li><a href=#1-核心结构-1>1️⃣ 核心结构</a></li><li><a href=#2-install--upgrade--uninstall>2️⃣ Install / Upgrade / Uninstall</a><ul><li><a href=#install>Install</a></li><li><a href=#upgrade>Upgrade</a></li><li><a href=#uninstall>Uninstall</a></li></ul></li><li><a href=#3-核心方法forapply>3️⃣ 核心方法：ForApply</a><ul><li><a href=#核心步骤>核心步骤：</a></li></ul></li><li><a href=#4-总结逻辑前端表单到-k8s-资源>4️⃣ 总结逻辑（前端表单到 K8s 资源）</a></li><li><a href=#1-前端如何将表单变为-deployment-的-yaml>1. 前端如何将表单变为 Deployment 的 YAML</a></li><li><a href=#2-如何被部署到-k8s-集群-1>2. 如何被部署到 K8s 集群</a></li><li><a href=#3-服务端go侧实际部署代码示例>3. 服务端（Go）侧实际部署代码示例</a></li><li><a href=#4-文档中的典型-yaml-示例>4. 文档中的典型 YAML 示例</a></li><li><a href=#总结流程>总结流程</a></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=前端填写的deployment的表单怎么变为后端deployment的yaml以及如何被部署到k8s集群的>前端填写的deployment的表单怎么变为后端deployment的yaml，以及如何被部署到k8s集群的
<a class=anchor href=#%e5%89%8d%e7%ab%af%e5%a1%ab%e5%86%99%e7%9a%84deployment%e7%9a%84%e8%a1%a8%e5%8d%95%e6%80%8e%e4%b9%88%e5%8f%98%e4%b8%ba%e5%90%8e%e7%ab%afdeployment%e7%9a%84yaml%e4%bb%a5%e5%8f%8a%e5%a6%82%e4%bd%95%e8%a2%ab%e9%83%a8%e7%bd%b2%e5%88%b0k8s%e9%9b%86%e7%be%a4%e7%9a%84>#</a></h2><p>你问的这个流程，其实就是 <strong>前端表单 → 后端生成 YAML → K8s API Server 部署</strong> 的链路。
我给你详细拆开说：</p><hr><h2 id=1-前端表单--deployment-配置数据>1️⃣ 前端表单 → Deployment 配置数据
<a class=anchor href=#1-%e5%89%8d%e7%ab%af%e8%a1%a8%e5%8d%95--deployment-%e9%85%8d%e7%bd%ae%e6%95%b0%e6%8d%ae>#</a></h2><p>前端的表单（比如输入 <strong>应用名、镜像名、副本数、CPU/内存限制、端口</strong> 等）就是 <strong>Deployment 的核心字段</strong>。
前端提交的通常是 JSON 格式的数据，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;myapp&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;namespace&#34;</span>: <span style=color:#e6db74>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;replicas&#34;</span>: <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;image&#34;</span>: <span style=color:#e6db74>&#34;nginx:1.21&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;cpu&#34;</span>: <span style=color:#e6db74>&#34;200m&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;memory&#34;</span>: <span style=color:#e6db74>&#34;256Mi&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;port&#34;</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=2-后端--转换为-k8s-yamlmanifest>2️⃣ 后端 → 转换为 K8s YAML/Manifest
<a class=anchor href=#2-%e5%90%8e%e7%ab%af--%e8%bd%ac%e6%8d%a2%e4%b8%ba-k8s-yamlmanifest>#</a></h2><p>后端拿到这个 JSON，就会用模板（或者动态拼接）生成 <strong>Deployment 的 YAML 清单</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>myapp</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>myapp</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>myapp</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.21</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>limits</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>cpu</span>: <span style=color:#e6db74>&#34;200m&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>memory</span>: <span style=color:#e6db74>&#34;256Mi&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p>⚡ 这里后端可能会用模板引擎（Go Template、Jinja2、Handlebars.js 等）来把表单字段替换进 YAML。</p><hr><h2 id=3-后端--部署到-k8s-集群>3️⃣ 后端 → 部署到 K8s 集群
<a class=anchor href=#3-%e5%90%8e%e7%ab%af--%e9%83%a8%e7%bd%b2%e5%88%b0-k8s-%e9%9b%86%e7%be%a4>#</a></h2><p>后端有几种方式把 YAML 部署到 K8s：</p><h3 id=方式-a调用-kubectl-apply>方式 A：调用 <code>kubectl apply</code>
<a class=anchor href=#%e6%96%b9%e5%bc%8f-a%e8%b0%83%e7%94%a8-kubectl-apply>#</a></h3><ul><li><p>后端服务器上安装 <code>kubectl</code>，</p></li><li><p>把 YAML 写到临时文件，再执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f deployment.yaml
</span></span></code></pre></div></li></ul><h3 id=方式-b直接调用-kubernetes-api>方式 B：直接调用 Kubernetes API
<a class=anchor href=#%e6%96%b9%e5%bc%8f-b%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8-kubernetes-api>#</a></h3><ul><li><p>Kubernetes 提供了 RESTful API（<code>/apis/apps/v1/namespaces/{namespace}/deployments</code>）。</p></li><li><p>后端可以把 YAML 转 JSON，然后调用 API。</p></li><li><p>例如 POST 请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>POST /apis/apps/v1/namespaces/default/deployments
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Authorization: Bearer &lt;k8s-token&gt;
</span></span></span></code></pre></div></li></ul><h3 id=方式-c用官方-sdk>方式 C：用官方 SDK
<a class=anchor href=#%e6%96%b9%e5%bc%8f-c%e7%94%a8%e5%ae%98%e6%96%b9-sdk>#</a></h3><p>不同语言都有 Kubernetes SDK：</p><ul><li>Go: <code>client-go</code></li><li>Python: <code>kubernetes</code></li><li>JavaScript/Node.js: <code>@kubernetes/client-node</code></li></ul><p>这些 SDK 可以直接用对象方式定义 Deployment，再调用 <code>createNamespacedDeployment()</code> 方法。</p><hr><h2 id=4-整体流程总结>4️⃣ 整体流程总结
<a class=anchor href=#4-%e6%95%b4%e4%bd%93%e6%b5%81%e7%a8%8b%e6%80%bb%e7%bb%93>#</a></h2><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
A[前端表单填写参数] --&gt; B[提交 JSON 到后端]
B --&gt; C[后端生成 YAML/JSON Manifest]
C --&gt; D{部署到K8s?}
D --&gt;|kubectl apply| E[K8s API Server]
D --&gt;|REST API| E
D --&gt;|SDK 调用| E
E --&gt; F[etcd 存储资源对象]
F --&gt; G[Scheduler 调度 Pod]
G --&gt; H[Kubelet 在节点上拉取镜像并运行容器]
</code></pre><hr><p>✅ <strong>一句话总结</strong>：
前端表单就是把 Deployment 的字段参数化，后端把这些参数渲染成 K8s YAML/JSON，然后通过 <code>kubectl</code> 或 API 提交给 <strong>K8s API Server</strong>，由 K8s 完成调度和容器创建。</p><hr><p>要不要我帮你写一个 <strong>Node.js 后端示例</strong>，从表单 JSON 自动生成 Deployment 并调用 Kubernetes API 创建？</p><p>根据源码，sealos前端表单到后端 YAML 及部署流程主要分为两步：</p><h3 id=1-前端表单转-deployment-的-yaml>1. 前端表单转 deployment 的 YAML
<a class=anchor href=#1-%e5%89%8d%e7%ab%af%e8%a1%a8%e5%8d%95%e8%bd%ac-deployment-%e7%9a%84-yaml>#</a></h3><ul><li>前端表单数据会被专门的函数（如 <code>json2DeployCr</code>）转换为 Kubernetes 的 YAML 格式。</li><li>以 <code>frontend/providers/applaunchpad/src/utils/deployYaml2Json.ts</code> 为例，核心函数如下：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>json2DeployCr</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>AppEditType</span>, <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;deployment&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;statefulset&#39;</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... 省略部分代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 构建 metadata、spec 等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>metadata</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>data.appName</span>, ... };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>commonSpec</span> <span style=color:#f92672>=</span> { ... };
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 最终返回 deployment/statefulset 对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 转为 YAML 字符串使用 yaml.dump
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>yaml</span>.<span style=color:#a6e22e>dump</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>apiVersion</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;apps/v1&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kind</span>: <span style=color:#66d9ef>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;deployment&#39;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;Deployment&#39;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;StatefulSet&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>metadata</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>spec</span>: <span style=color:#66d9ef>commonSpec</span>
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在页面里，通常会把表单数据收集后，调用如上方法或类似的 <code>generateYamlList</code> 方法，将数据转为 YAML：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>[
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;deployment.yaml&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>json2DeployCr</span>(<span style=color:#a6e22e>data</span>, <span style=color:#e6db74>&#39;deployment&#39;</span>)
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 其它资源（service、configmap等）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>]
</span></span></code></pre></div><h3 id=2-yaml-被部署到-k8s-集群>2. YAML 被部署到 K8s 集群
<a class=anchor href=#2-yaml-%e8%a2%ab%e9%83%a8%e7%bd%b2%e5%88%b0-k8s-%e9%9b%86%e7%be%a4>#</a></h3><ul><li>前端生成 YAML 后，调用后端接口（如 <code>applyYamlList</code>），后端会用 K8s 客户端 SDK 进行部署。</li><li>以 <code>frontend/providers/applaunchpad/src/services/backend/kubernetes.ts</code> 为例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getK8s</span>({ <span style=color:#a6e22e>kubeconfig</span> }<span style=color:#f92672>:</span> { <span style=color:#a6e22e>kubeconfig</span>: <span style=color:#66d9ef>string</span> }) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... 省略部分代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>formatYaml</span>: <span style=color:#66d9ef>k8s.KubernetesObject</span>[] <span style=color:#f92672>=</span> <span style=color:#a6e22e>yamlList</span>
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>item</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>yaml</span>.<span style=color:#a6e22e>loadAll</span>(<span style=color:#a6e22e>item</span>))
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>flat</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>item</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>metadata</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>metadata</span>.<span style=color:#66d9ef>namespace</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>namespace</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>item</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;create&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>CreateYaml</span>(<span style=color:#a6e22e>kc</span>, <span style=color:#a6e22e>formatYaml</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>type</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;replace&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>replaceYaml</span>(<span style=color:#a6e22e>kc</span>, <span style=color:#a6e22e>formatYaml</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>CreateYaml</span>(<span style=color:#a6e22e>kc</span>, <span style=color:#a6e22e>formatYaml</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><code>CreateYaml</code> 和 <code>replaceYaml</code> 等方法会调用 K8s API，把 YAML 应用到集群。</li></ul><hr><h4 id=关键流程梳理>关键流程梳理
<a class=anchor href=#%e5%85%b3%e9%94%ae%e6%b5%81%e7%a8%8b%e6%a2%b3%e7%90%86>#</a></h4><ol><li><strong>表单数据收集</strong> → 通过如 <code>json2DeployCr</code> 等方法转为 YAML 字符串。</li><li><strong>YAML 列表生成</strong> → 组织成如 <code>[ { filename: 'deployment.yaml', value: &lt;yaml字符串> } ]</code></li><li><strong>前端调用后端接口</strong>（如 <code>applyYamlList</code>）→ 后端解析 YAML 并用 K8s SDK apply 到集群。</li></ol><hr><h4 id=相关关键代码汇总>相关关键代码汇总
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e5%85%b3%e9%94%ae%e4%bb%a3%e7%a0%81%e6%b1%87%e6%80%bb>#</a></h4><ul><li>YAML 生成：<code>frontend/providers/applaunchpad/src/utils/deployYaml2Json.ts</code> (<code>json2DeployCr</code>)</li><li>YAML 应用：<code>frontend/providers/applaunchpad/src/services/backend/kubernetes.ts</code> (<code>CreateYaml</code>, <code>replaceYaml</code>)</li><li>表单到 YAML 调用链：<code>frontend/providers/applaunchpad/src/pages/app/edit/index.tsx</code>、<code>frontend/providers/applaunchpad/src/services/backend/appService.ts</code></li></ul><hr><p>如需具体某一部分的完整函数/实现可进一步指定。</p><p>好的，我来帮你梳理一下这段 <code>EditApp</code> 组件的逻辑，以及<strong>前端表单到 YAML，再到调用后端 API 部署 Kubernetes 的整个链路</strong>。我会分步骤解释并用一个调用链的方式帮你理清思路。</p><hr><h2 id=1-核心功能概览>1️⃣ 核心功能概览
<a class=anchor href=#1-%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd%e6%a6%82%e8%a7%88>#</a></h2><p><code>EditApp</code> 是一个 <strong>应用部署编辑页面</strong>，功能包括：</p><ul><li>前端表单填写应用参数（镜像、端口、CPU/内存、存储、GPU 等）</li><li>实时生成对应的 Kubernetes YAML（Deployment、StatefulSet、Service、Ingress、HPA、ConfigMap、Secret）</li><li>支持“表单模式”和“YAML模式”编辑</li><li>校验资源配额、GPU、端口冲突</li><li>调用后端接口部署或更新应用</li><li>部署成功或失败反馈给用户</li></ul><hr><h2 id=2-前端表单---yaml-的转换>2️⃣ 前端表单 -> YAML 的转换
<a class=anchor href=#2-%e5%89%8d%e7%ab%af%e8%a1%a8%e5%8d%95---yaml-%e7%9a%84%e8%bd%ac%e6%8d%a2>#</a></h2><p>核心函数是 <code>formData2Yamls</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>formData2Yamls</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>AppEditType</span>) <span style=color:#f92672>=&gt;</span> [
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;service.yaml&#39;</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>json2Service</span>(<span style=color:#a6e22e>data</span>) },
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;deployment.yaml&#39;</span> <span style=color:#a6e22e>or</span> <span style=color:#e6db74>&#39;statefulset.yaml&#39;</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>json2DeployCr</span>(<span style=color:#a6e22e>data</span>) },
</span></span><span style=display:flex><span>  ...(<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>configMapList</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> [{ <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;configmap.yaml&#39;</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>json2ConfigMap</span>(<span style=color:#a6e22e>data</span>) }] <span style=color:#f92672>:</span> []),
</span></span><span style=display:flex><span>  ...(<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>networks</span>.<span style=color:#a6e22e>some</span>(<span style=color:#a6e22e>item</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>openPublicDomain</span>) <span style=color:#f92672>?</span> [{ <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;ingress.yaml&#39;</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>json2Ingress</span>(<span style=color:#a6e22e>data</span>) }] <span style=color:#f92672>:</span> []),
</span></span><span style=display:flex><span>  ...(<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>hpa</span>.<span style=color:#a6e22e>use</span> <span style=color:#f92672>?</span> [{ <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;hpa.yaml&#39;</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>json2HPA</span>(<span style=color:#a6e22e>data</span>) }] <span style=color:#f92672>:</span> []),
</span></span><span style=display:flex><span>  ...(<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>secret</span>.<span style=color:#a6e22e>use</span> <span style=color:#f92672>?</span> [{ <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;secret.yaml&#39;</span>, <span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>json2Secret</span>(<span style=color:#a6e22e>data</span>) }] <span style=color:#f92672>:</span> [])
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>🔹 <strong>作用</strong>：将用户在表单中填写的数据，转换成 Kubernetes 可以理解的 YAML 对象。</p><ul><li><code>json2Service</code> → 生成 Service YAML</li><li><code>json2DeployCr</code> → Deployment / StatefulSet YAML</li><li><code>json2Ingress</code> → Ingress YAML（如果开启公网域名）</li><li><code>json2HPA</code> → HPA YAML（如果开启弹性伸缩）</li><li><code>json2ConfigMap</code> / <code>json2Secret</code> → 对应资源</li></ul><hr><h2 id=3-用户点击应用部署按钮的流程>3️⃣ 用户点击“应用部署”按钮的流程
<a class=anchor href=#3-%e7%94%a8%e6%88%b7%e7%82%b9%e5%87%bb%e5%ba%94%e7%94%a8%e9%83%a8%e7%bd%b2%e6%8c%89%e9%92%ae%e7%9a%84%e6%b5%81%e7%a8%8b>#</a></h2><p>在 <code>Header</code> 组件中，有一个回调 <code>applyCb</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#a6e22e>applyCb</span><span style=color:#f92672>=</span>{() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>formHook</span>.<span style=color:#a6e22e>handleSubmit</span>(<span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>data</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parseYamls</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>formData2Yamls</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setYamlList</span>(<span style=color:#a6e22e>parseYamls</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// GPU库存校验
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>gpu</span><span style=color:#f92672>?</span>.<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inventory</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>countGpuInventory</span>(<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>gpu</span><span style=color:#f92672>?</span>.<span style=color:#66d9ef>type</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>gpu</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>amount</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>inventory</span>) <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>toast</span>(...);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 网络端口冲突校验
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>checkNetworkPorts</span>(<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>networks</span>)) <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>toast</span>(...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 权限检查（编辑已有应用）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>appName</span>) <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>checkPermission</span>(...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 弹出确认框
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>openConfirm</span>(() <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>submitSuccess</span>(<span style=color:#a6e22e>parseYamls</span>))();
</span></span><span style=display:flex><span>  }, <span style=color:#a6e22e>submitError</span>)();
</span></span><span style=display:flex><span>}}
</span></span></code></pre></div><p><strong>步骤解释</strong>：</p><ol><li><code>handleSubmit</code> 获取表单数据 <code>data</code></li><li>调用 <code>formData2Yamls(data)</code> 生成 YAML 列表</li><li>检查 GPU 配额</li><li>检查网络端口冲突</li><li>权限检查</li><li>弹出确认框 <code>openConfirm</code></li><li>确认后调用 <code>submitSuccess(parseYamls)</code></li></ol><hr><h2 id=4-submitsuccess---调用后端-api>4️⃣ <code>submitSuccess</code> -> 调用后端 API
<a class=anchor href=#4-submitsuccess---%e8%b0%83%e7%94%a8%e5%90%8e%e7%ab%af-api>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>submitSuccess</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useCallback</span>(<span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>yamlList</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setIsLoading</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parsedNewYamlList</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>yamlList</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>item</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>appName</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>patch</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>patchYamlList</span>({ <span style=color:#a6e22e>parsedOldYamlList</span>: <span style=color:#66d9ef>formOldYamls.current.map</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>value</span>), <span style=color:#a6e22e>parsedNewYamlList</span>, <span style=color:#a6e22e>originalYamlList</span>: <span style=color:#66d9ef>crOldYamls.current</span> });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>putApp</span>({ <span style=color:#a6e22e>patch</span>, <span style=color:#a6e22e>appName</span>, <span style=color:#a6e22e>stateFulSetYaml</span>: <span style=color:#66d9ef>yamlList.find</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>filename</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;statefulset.yaml&#39;</span>)<span style=color:#f92672>?</span>.<span style=color:#a6e22e>value</span> });
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>postDeployApp</span>(<span style=color:#a6e22e>parsedNewYamlList</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>`/app/detail?name=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>formHook</span>.<span style=color:#a6e22e>getValues</span>(<span style=color:#e6db74>&#39;appName&#39;</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>toast</span>({ <span style=color:#a6e22e>title</span>: <span style=color:#66d9ef>t</span>(<span style=color:#a6e22e>applySuccess</span>), <span style=color:#a6e22e>status</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;success&#39;</span> });
</span></span><span style=display:flex><span>}, [...])
</span></span></code></pre></div><p>🔹 <strong>作用</strong>：把 YAML 列表发送给后端接口：</p><ul><li><code>postDeployApp(parsedNewYamlList)</code> → 新建应用</li><li><code>putApp({...})</code> → 编辑已有应用（patch 差异化更新）</li></ul><p>后端接收到 YAML 后，会调用 K8s API Server 部署资源（对应你之前贴的 <code>K8sApi</code> + <code>CreateYaml/replaceYaml</code> 逻辑）。</p><hr><h2 id=5-调用链总结表单到-yaml-到部署>5️⃣ 调用链总结（表单到 YAML 到部署）
<a class=anchor href=#5-%e8%b0%83%e7%94%a8%e9%93%be%e6%80%bb%e7%bb%93%e8%a1%a8%e5%8d%95%e5%88%b0-yaml-%e5%88%b0%e9%83%a8%e7%bd%b2>#</a></h2><p>用文字描述调用链：</p><pre tabindex=0><code>前端用户填表单
        │
        ▼
formHook.handleSubmit
        │
        ▼
formData2Yamls() → YAML 列表
        │
        ▼
校验 GPU / 网络端口 / 权限
        │
        ▼
openConfirm() 确认
        │
        ▼
submitSuccess(yamlList)
        │
        ▼
postDeployApp / putApp (调用后端 API)
        │
        ▼
后端接收 YAML
        │
        ▼
调用 K8sApi + CreateYaml/replaceYaml
        │
        ▼
K8s API Server
        │
        ▼
Pod / Deployment / Service 等资源创建完成
        │
        ▼
返回状态 → 前端 toast 提示成功
</code></pre><hr><p>如果你需要，我可以帮你画一个 <strong>Mermaid 时序图</strong>，把这个表单到 YAML 再到 K8s API Server 的完整调用链可视化出来，看起来更直观。</p><p>你想让我画吗？</p><p>好的，我帮你画一个 Mermaid 时序图，把 <strong>前端表单 → YAML → 后端 API → K8s API Server → Pod/Service</strong> 的完整调用链直观表现出来：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant User as 用户
    participant Frontend as 前端页面(Form / EditApp)
    participant Backend as 后端 API(postDeployApp / putApp)
    participant K8sApi as K8s API 层(K8sApi + CreateYaml/replaceYaml)
    participant K8sServer as K8s API Server

    User-&gt;&gt;Frontend: 填写表单（镜像、CPU、内存、端口、存储等）
    Frontend-&gt;&gt;Frontend: formHook.handleSubmit()
    Frontend-&gt;&gt;Frontend: formData2Yamls() 生成 YAML 列表
    Frontend-&gt;&gt;Frontend: 校验 GPU / 网络端口 / 权限
    Frontend-&gt;&gt;User: 弹出确认框 openConfirm()
    User-&gt;&gt;Frontend: 点击确认
    Frontend-&gt;&gt;Frontend: submitSuccess(yamlList)
    Frontend-&gt;&gt;Backend: postDeployApp / putApp(yamlList)
    Backend-&gt;&gt;K8sApi: 解析 YAML 调用 CreateYaml / replaceYaml
    K8sApi-&gt;&gt;K8sServer: 调用 K8s API Server 创建 Deployment/Service/Ingress/ConfigMap/Secret 等
    K8sServer--&gt;&gt;K8sApi: 返回资源创建结果
    K8sApi--&gt;&gt;Backend: 返回部署结果
    Backend--&gt;&gt;Frontend: 返回成功/失败状态
    Frontend-&gt;&gt;User: toast 提示部署成功或失败
</code></pre><p>✅ <strong>说明</strong>：</p><ul><li>前端负责收集表单数据、生成 YAML、校验资源和权限</li><li>后端负责接收 YAML、调用 K8s API 部署</li><li>K8sApi 层封装了 <code>KubernetesObjectApi</code> 的操作（create/replace）</li><li>最终 Kubernetes API Server 创建 Pod、Deployment、Service 等资源</li></ul><hr><p>我可以再帮你画一个 <strong>带 HPA、StatefulSet、Ingress 等资源细分的时序图</strong>，更详细地表现 YAML 对应不同资源的部署流程。</p><p>你希望我画这个更详细版本吗？</p><p>好，我们把前端表单提交到 YAML、再到不同 Kubernetes 资源的完整流程画出来，包括 <strong>Deployment/StatefulSet、Service、Ingress、ConfigMap、Secret、HPA</strong> 等。</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant User as 用户
    participant Frontend as 前端页面(Form / EditApp)
    participant Backend as 后端 API(postDeployApp / putApp)
    participant K8sApi as K8s API 层(CreateYaml / replaceYaml)
    participant K8sServer as K8s API Server
    participant Pod as Pod / StatefulSet
    participant HPA as HPA Controller
    participant Ingress as Ingress Controller

    User-&gt;&gt;Frontend: 填写表单（镜像、CPU、内存、端口、存储等）
    Frontend-&gt;&gt;Frontend: formHook.handleSubmit()
    Frontend-&gt;&gt;Frontend: formData2Yamls() 生成 YAML 列表
    Frontend-&gt;&gt;Frontend: 校验 GPU / 网络端口 / 权限
    Frontend-&gt;&gt;User: 弹出确认框 openConfirm()
    User-&gt;&gt;Frontend: 点击确认
    Frontend-&gt;&gt;Frontend: submitSuccess(yamlList)
    Frontend-&gt;&gt;Backend: postDeployApp / putApp(yamlList)
    Backend-&gt;&gt;K8sApi: 解析 YAML，按资源类型调用 CreateYaml / replaceYaml

    alt Service YAML
        K8sApi-&gt;&gt;K8sServer: 创建 Service
        K8sServer--&gt;&gt;K8sApi: 返回 Service 状态
    end

    alt Deployment / StatefulSet YAML
        K8sApi-&gt;&gt;K8sServer: 创建 Deployment / StatefulSet
        K8sServer--&gt;&gt;Pod: 调度 Pod
        Pod--&gt;&gt;K8sServer: Pod 就绪
        K8sServer--&gt;&gt;K8sApi: 返回 Deployment/StatefulSet 状态
    end

    alt ConfigMap YAML
        K8sApi-&gt;&gt;K8sServer: 创建 ConfigMap
        K8sServer--&gt;&gt;K8sApi: 返回状态
    end

    alt Secret YAML
        K8sApi-&gt;&gt;K8sServer: 创建 Secret
        K8sServer--&gt;&gt;K8sApi: 返回状态
    end

    alt Ingress YAML
        K8sApi-&gt;&gt;K8sServer: 创建 Ingress
        K8sServer--&gt;&gt;Ingress: 配置负载均衡 / 域名路由
        Ingress--&gt;&gt;K8sServer: 状态更新
        K8sServer--&gt;&gt;K8sApi: 返回状态
    end

    alt HPA YAML
        K8sApi-&gt;&gt;K8sServer: 创建 HPA
        K8sServer--&gt;&gt;HPA: HPA 监控 Deployment / StatefulSet
        HPA--&gt;&gt;Pod: 调整副本数
        HPA--&gt;&gt;K8sServer: 返回状态
        K8sServer--&gt;&gt;K8sApi: 返回 HPA 状态
    end

    K8sApi--&gt;&gt;Backend: 返回部署结果
    Backend--&gt;&gt;Frontend: 返回成功/失败状态
    Frontend-&gt;&gt;User: toast 提示部署成功或失败
</code></pre><p>✅ <strong>特点说明</strong>：</p><ol><li><strong>前端</strong>生成 YAML 时会根据表单决定资源类型（Deployment / StatefulSet / Service / Ingress / ConfigMap / Secret / HPA）</li><li><strong>后端</strong>只负责把 YAML 调用 K8sApi 层部署</li><li><strong>K8sApi</strong>把每个 YAML 转化成 Kubernetes API 调用</li><li><strong>Kubernetes Server</strong>负责调度 Pod、更新 HPA、Ingress Controller 配置等</li></ol><hr><p>如果你需要，我可以帮你再画一个 <strong>交互流程+资源依赖图</strong>，显示哪个 YAML 依赖哪个资源（比如 Deployment 依赖 ConfigMap/Secret，Ingress 依赖 Service），更像 <strong>部署拓扑图</strong>。</p><p>你希望我画这个吗？</p><p>好的，我来帮你梳理这段代码的逻辑，重点是<strong>表单提交 → YAML 生成 → Kubernetes 资源创建/操作</strong>的调用链。为了方便理解，我会按流程和模块拆解。</p><hr><h2 id=1-k8scontext-接口><strong>1️⃣ K8sContext 接口</strong>
<a class=anchor href=#1-k8scontext-%e6%8e%a5%e5%8f%a3>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>K8sContext</span> { 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kc</span>: <span style=color:#66d9ef>KubeConfig</span>;             <span style=color:#75715e>// kubeconfig
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>apiClient</span>: <span style=color:#66d9ef>KubernetesObjectApi</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>k8sCore</span>: <span style=color:#66d9ef>CoreV1Api</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>k8sApp</span>: <span style=color:#66d9ef>AppsV1Api</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>k8sAutoscaling</span>: <span style=color:#66d9ef>AutoscalingV2Api</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>k8sNetworkingApp</span>: <span style=color:#66d9ef>NetworkingV1Api</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>k8sCustomObjects</span>: <span style=color:#66d9ef>CustomObjectsApi</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>metricsClient</span>: <span style=color:#66d9ef>Metrics</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>k8sExec</span>: <span style=color:#66d9ef>Exec</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kube_user</span>: <span style=color:#66d9ef>User</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span>; 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>namespace</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span>; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>applyYamlList</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>yamlList</span>: <span style=color:#66d9ef>string</span>[], <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;create&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;replace&#39;</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>KubernetesObject</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getDeployApp</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>appName</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>V1Deployment</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#a6e22e>V1StatefulSet</span>&gt;; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getUserQuota</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>UserQuotaItemType</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;; 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getUserBalance</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>number</span>&gt;; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>这是整个 Kubernetes 操作上下文对象，封装了对各种 API 的客户端（Core、Apps、Autoscaling、Networking、CustomObjects）。</li><li><code>applyYamlList</code>：核心方法，将 YAML 列表应用到集群，可选择 <code>create</code> 或 <code>replace</code>。</li><li><code>getDeployApp</code>：获取 Deployment 或 StatefulSet，用于 pause/start/update 操作。</li></ul><hr><h2 id=2-表单--yaml--创建应用><strong>2️⃣ 表单 → YAML → 创建应用</strong>
<a class=anchor href=#2-%e8%a1%a8%e5%8d%95--yaml--%e5%88%9b%e5%bb%ba%e5%ba%94%e7%94%a8>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createApp</span>(<span style=color:#a6e22e>appForm</span>: <span style=color:#66d9ef>AppEditType</span>, <span style=color:#a6e22e>k8s</span>: <span style=color:#66d9ef>K8sContext</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>serverLoadInitData</span>(); <span style=color:#75715e>// 初始化前端数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>applyYamlList</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>k8s</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 给网络配置加上域名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>appForm</span>.<span style=color:#a6e22e>networks</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>appForm</span>.<span style=color:#a6e22e>networks</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>network</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> ({
</span></span><span style=display:flex><span>    ...<span style=color:#a6e22e>network</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>domain</span>: <span style=color:#66d9ef>global.AppConfig.cloud.domain</span>
</span></span><span style=display:flex><span>  }));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 核心：表单数据转 YAML
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parseYamls</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>formData2Yamls</span>(<span style=color:#a6e22e>appForm</span>); 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>yamls</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>parseYamls</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>item</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 调用 applyYamlList 创建所有资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>applyYamlList</span>(<span style=color:#a6e22e>yamls</span>, <span style=color:#e6db74>&#39;create&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>调用链：</strong></p><ol><li>用户在前端表单填入应用配置（镜像、CPU、内存、端口、存储、网络等）</li><li><code>formData2Yamls(appForm)</code> 将表单数据转换为 Kubernetes YAML 列表，可能包含：<ul><li>Deployment / StatefulSet</li><li>Service</li><li>Ingress</li><li>ConfigMap</li><li>Secret</li><li>HPA</li></ul></li><li><code>applyYamlList(yamls, 'create')</code> 将 YAML 应用到 Kubernetes 集群<ul><li>内部通过 <code>KubernetesObjectApi</code> 调用 <code>create</code> 或 <code>replace</code></li><li>生成对应的 Kubernetes 对象</li></ul></li></ol><blockquote><p>所以 <strong>表单 → formData2Yamls → YAML 列表 → applyYamlList → Kubernetes API → 集群对象</strong> 是创建应用的核心链路。</p></blockquote><hr><h2 id=3-获取应用资源信息><strong>3️⃣ 获取应用资源信息</strong>
<a class=anchor href=#3-%e8%8e%b7%e5%8f%96%e5%ba%94%e7%94%a8%e8%b5%84%e6%ba%90%e4%bf%a1%e6%81%af>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getAppByName</span>(<span style=color:#a6e22e>appName</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>k8s</span>: <span style=color:#66d9ef>K8sContext</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>k8sApp</span>, <span style=color:#a6e22e>k8sCore</span>, <span style=color:#a6e22e>k8sNetworkingApp</span>, <span style=color:#a6e22e>k8sAutoscaling</span>, <span style=color:#66d9ef>namespace</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>k8s</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>Promise</span>.<span style=color:#a6e22e>allSettled</span>([
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sApp</span>.<span style=color:#a6e22e>readNamespacedDeployment</span>(<span style=color:#a6e22e>appName</span>, <span style=color:#66d9ef>namespace</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sApp</span>.<span style=color:#a6e22e>readNamespacedStatefulSet</span>(<span style=color:#a6e22e>appName</span>, <span style=color:#66d9ef>namespace</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sCore</span>.<span style=color:#a6e22e>readNamespacedConfigMap</span>(<span style=color:#a6e22e>appName</span>, <span style=color:#66d9ef>namespace</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sCore</span>.<span style=color:#a6e22e>listNamespacedService</span>(<span style=color:#66d9ef>namespace</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>appDeployKey</span><span style=color:#e6db74>}</span><span style=color:#e6db74>=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>appName</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sNetworkingApp</span>.<span style=color:#a6e22e>listNamespacedIngress</span>(<span style=color:#66d9ef>namespace</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#66d9ef>undefined</span>, <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>appDeployKey</span><span style=color:#e6db74>}</span><span style=color:#e6db74>=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>appName</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sCore</span>.<span style=color:#a6e22e>readNamespacedSecret</span>(<span style=color:#a6e22e>appName</span>, <span style=color:#66d9ef>namespace</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sAutoscaling</span>.<span style=color:#a6e22e>readNamespacedHorizontalPodAutoscaler</span>(<span style=color:#a6e22e>appName</span>, <span style=color:#66d9ef>namespace</span>)
</span></span><span style=display:flex><span>  ]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>response</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>并行获取一个应用相关的全部资源（Deployment、StatefulSet、ConfigMap、Service、Ingress、Secret、HPA）。</li><li><code>Promise.allSettled</code> 确保即便某些资源不存在也不会抛出异常。</li><li>最终返回一个结果列表，用于前端展示或进一步处理。</li></ul><hr><h2 id=4-pause--start-应用><strong>4️⃣ Pause / Start 应用</strong>
<a class=anchor href=#4-pause--start-%e5%ba%94%e7%94%a8>#</a></h2><ul><li><strong>pauseApp</strong>：<ul><li>将 <code>replicas=0</code> 暂停应用</li><li>保存 HPA 配置到 annotation（<code>pauseKey</code>）</li><li>修改 Ingress 的 <code>ingress.class</code> 为 <code>pause</code></li><li>删除 HPA</li></ul></li><li><strong>startApp</strong>：<ul><li>恢复副本数</li><li>根据 <code>pauseKey</code> annotation 重新创建 HPA</li><li>修改 Ingress 恢复 <code>ingress.class</code></li><li>删除 <code>pauseKey</code> annotation</li></ul></li></ul><p><strong>核心逻辑</strong>：应用的暂停/启动通过修改 Deployment/StatefulSet 的 <code>replicas</code> 和 HPA，同时调整 Ingress 配置来实现。</p><hr><h2 id=5-更新应用资源><strong>5️⃣ 更新应用资源</strong>
<a class=anchor href=#5-%e6%9b%b4%e6%96%b0%e5%ba%94%e7%94%a8%e8%b5%84%e6%ba%90>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>updateAppResources</span>(<span style=color:#a6e22e>appName</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>updateData</span>, <span style=color:#a6e22e>k8s</span>: <span style=color:#66d9ef>K8sContext</span>)
</span></span></code></pre></div><ul><li>更新 CPU、内存、镜像、命令、环境变量、replicas</li><li>如果 <code>replicas=0</code> → pause 逻辑</li><li>如果 <code>replicas>0</code> → start 逻辑 + 恢复 HPA</li><li>通过 JSON Patch 精确修改 Deployment/StatefulSet 资源</li></ul><p><strong>流程：</strong></p><ol><li>获取当前 Deployment/StatefulSet (<code>getDeployApp</code>)</li><li>计算 JSONPatch（CPU/Memory/Command/Args/Image/Env）</li><li>调用 <code>patchNamespacedDeployment</code> / <code>patchNamespacedStatefulSet</code> 应用修改</li><li>如果涉及 replicas，则结合 pause/start 逻辑操作 HPA</li></ol><hr><h2 id=6-删除应用><strong>6️⃣ 删除应用</strong>
<a class=anchor href=#6-%e5%88%a0%e9%99%a4%e5%ba%94%e7%94%a8>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>deleteAppByName</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>k8s</span>: <span style=color:#66d9ef>K8sContext</span>)
</span></span></code></pre></div><ul><li>删除应用相关的所有资源：<ul><li>Deployment / StatefulSet</li><li>Service / ConfigMap / Secret</li><li>Ingress</li><li>PersistentVolumeClaim</li><li>HorizontalPodAutoscaler</li><li>cert-manager 的 Certificate / Issuer</li></ul></li><li>使用 <code>Promise.allSettled</code> 并过滤 404 错误，保证删除流程健壮。</li></ul><hr><h2 id=7-总结表单到-yaml-调用链><strong>7️⃣ 总结表单到 YAML 调用链</strong>
<a class=anchor href=#7-%e6%80%bb%e7%bb%93%e8%a1%a8%e5%8d%95%e5%88%b0-yaml-%e8%b0%83%e7%94%a8%e9%93%be>#</a></h2><ul><li>Pause/Start/Update 操作是基于 Deployment/StatefulSet 和 HPA 的 annotation + JSON Patch 机制</li><li>删除应用是把所有相关资源全部清理</li><li><code>getAppByName</code> 用于把集群状态同步回前端，用于展示和编辑</li></ul><hr><p>如果你想，我可以帮你画一张更完整的 <strong>表单字段 → YAML 资源类型 → API 调用 → 集群对象</strong> 的图，把每种资源的依赖关系和 pause/start HPA 逻辑都展示出来，看起来像一个完整的应用部署拓扑。</p><p>你希望我画吗？</p><p>好，我们可以把整个 <strong>表单 → YAML → 集群资源</strong> 的流程画成一张完整的拓扑图，包括 Pause/Start/HPA 逻辑。</p><p>下面是用 <strong>Mermaid</strong> 表示的图：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
    A[&#34;前端表单&#34;] --&gt; B[&#34;调用 formData2Yamls&#34;]
    B --&gt; C[&#34;生成 YAML 列表&#34;]
    C --&gt; D[&#34;调用 applyYamlList 创建或替换资源&#34;]
    D --&gt; E[&#34;Kubernetes API Server&#34;]

    E --&gt; F[&#34;创建 Deployment / StatefulSet&#34;]
    E --&gt; G[&#34;创建 Service / ConfigMap / Secret&#34;]
    E --&gt; H[&#34;创建 Ingress&#34;]
    E --&gt; I[&#34;创建 HorizontalPodAutoscaler&#34;]

    subgraph Pause_Start[&#34;暂停/启动流程&#34;]
        J[&#34;暂停应用: replicas=0, 保存 HPA 配置&#34;] --&gt; K[&#34;删除 HPA&#34;]
        L[&#34;启动应用: 恢复 replicas, 重新创建 HPA&#34;] 
    end

    F --&gt; Pause_Start
    I --&gt; Pause_Start

    subgraph Delete_App[&#34;删除应用流程&#34;]
        M[&#34;删除 Deployment / StatefulSet&#34;] 
        N[&#34;删除 Service / ConfigMap / Secret / PVC&#34;] 
        O[&#34;删除 Ingress&#34;] 
        P[&#34;删除 HPA&#34;] 
    end

    F --&gt; Delete_App
    G --&gt; Delete_App
    H --&gt; Delete_App
    I --&gt; Delete_App
</code></pre><h3 id=-解释图中各部分>✅ 解释图中各部分
<a class=anchor href=#-%e8%a7%a3%e9%87%8a%e5%9b%be%e4%b8%ad%e5%90%84%e9%83%a8%e5%88%86>#</a></h3><ol><li><strong>表单 → YAML → 集群</strong><ul><li>前端表单 <code>AppEditType</code> → <code>formData2Yamls</code> → YAML 列表 → <code>applyYamlList</code> → Kubernetes API → 集群对象。</li></ul></li><li><strong>Pause/Start</strong><ul><li>Pause：replicas 置 0 + HPA 保存到 annotation + 删除 HPA + Ingress 修改为 <code>pause</code></li><li>Start：replicas 恢复 + 根据 pauseKey annotation 重建 HPA + Ingress 恢复</li></ul></li><li><strong>资源更新</strong><ul><li>通过 JSON Patch 精确更新 Deployment/StatefulSet 中容器的 CPU/Memory/Image/Command/Args/Env</li><li>如果涉及 replicas，则走 Pause/Start 逻辑</li></ul></li><li><strong>删除应用</strong><ul><li>删除全部相关资源，包括 Deployment/StatefulSet、Service、Ingress、ConfigMap、Secret、PVC、HPA、Certificate、Issuer</li></ul></li><li><strong>获取应用状态</strong><ul><li><code>getAppByName</code> 获取集群资源 → <code>adaptAppDetail</code> + <code>transformFromLegacySchema</code> → 前端标准化对象用于展示/编辑</li></ul></li></ol><hr><p>如果你想，我可以帮你画一个 <strong>更细粒度的图</strong>，标出每种表单字段对应生成的 Kubernetes YAML 资源和字段路径，这样能直观看到表单字段到 Deployment/Service/HPA 的映射关系。</p><p>你希望我画这个更细粒度的图吗？</p><p>明白了，你希望把 <strong>前端表单字段 → YAML → Kubernetes 资源 → 字段路径</strong> 画成一个清晰的 Mermaid 流程图。我们可以按以下思路细化：</p><ul><li>每个表单字段对应的 YAML 片段</li><li>每个 YAML 对应的 Kubernetes 资源类型</li><li>关键字段路径（如 <code>spec.template.spec.containers[0].resources</code>）</li></ul><p>我给你画一个示意 Mermaid 图：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
    subgraph Form[&#34;前端表单&#34;]
        CPU[&#34;CPU&#34;]
        Memory[&#34;Memory&#34;]
        Replicas[&#34;副本数&#34;]
        Image[&#34;镜像&#34;]
        Command[&#34;启动命令&#34;]
        Args[&#34;命令参数&#34;]
        Env[&#34;环境变量&#34;]
        Network[&#34;网络配置&#34;]
    end

    subgraph formData2Yamls[&#34;formData2Yamls(appForm)&#34;]
        CPU_YAML[&#34;resources.requests/limits.cpu&#34;]
        Memory_YAML[&#34;resources.requests/limits.memory&#34;]
        Replicas_YAML[&#34;spec.replicas&#34;]
        Image_YAML[&#34;spec.template.spec.containers[0].image&#34;]
        Command_YAML[&#34;spec.template.spec.containers[0].command&#34;]
        Args_YAML[&#34;spec.template.spec.containers[0].args&#34;]
        Env_YAML[&#34;spec.template.spec.containers[0].env&#34;]
        Network_YAML[&#34;Service/Ingress domain annotations&#34;]
    end

    subgraph ApplyYAML[&#34;applyYamlList -&gt; Kubernetes API&#34;]
        Deployment[&#34;Deployment / StatefulSet&#34;]
        Service[&#34;Service / ConfigMap / Secret&#34;]
        Ingress[&#34;Ingress&#34;]
        HPA[&#34;HorizontalPodAutoscaler&#34;]
    end

    %% 表单字段到 YAML 映射
    CPU --&gt; CPU_YAML
    Memory --&gt; Memory_YAML
    Replicas --&gt; Replicas_YAML
    Image --&gt; Image_YAML
    Command --&gt; Command_YAML
    Args --&gt; Args_YAML
    Env --&gt; Env_YAML
    Network --&gt; Network_YAML

    %% YAML 到 Kubernetes 资源映射
    CPU_YAML --&gt; Deployment
    Memory_YAML --&gt; Deployment
    Replicas_YAML --&gt; Deployment
    Image_YAML --&gt; Deployment
    Command_YAML --&gt; Deployment
    Args_YAML --&gt; Deployment
    Env_YAML --&gt; Deployment
    Replicas_YAML --&gt; HPA
    CPU_YAML --&gt; HPA
    Memory_YAML --&gt; HPA
    Network_YAML --&gt; Service
    Network_YAML --&gt; Ingress
</code></pre><p>💡 说明：</p><ol><li><strong>表单字段</strong>：前端 AppEditType 的字段</li><li><strong>YAML 片段</strong>：<code>formData2Yamls</code> 生成的 YAML 对应字段路径</li><li><strong>Kubernetes 资源</strong>：最终创建的 Deployment、Service、Ingress、HPA</li></ol><p>这个图能直观看到 <strong>字段 → YAML → K8s 资源 → 字段路径</strong> 的对应关系。</p><hr><p>我可以帮你画 <strong>更详细版本</strong>，把每个字段对应的 <strong>完整 YAML 路径</strong> 都列出来，包括 HPA 的 min/max replicas、target CPU、Service 的 selector 等，这样就像一张完整映射表一样。</p><p>你希望我画这个完整详细版本吗？</p><p>好的，我帮你画一个<strong>完整、细粒度版本</strong>，把表单字段对应到具体 Kubernetes YAML 路径和资源类型，涵盖 Deployment、StatefulSet、Service、Ingress、HPA。下面是 Mermaid 流程图示例：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
    %% 前端表单字段
    subgraph Form[&#34;前端表单&#34;]
        CPU[&#34;CPU (resource.cpu)&#34;]
        Memory[&#34;内存 (resource.memory)&#34;]
        Replicas[&#34;副本数 (resource.replicas)&#34;]
        Image[&#34;镜像 (image)&#34;]
        Command[&#34;启动命令 (command)&#34;]
        Args[&#34;命令参数 (args)&#34;]
        Env[&#34;环境变量 (env)&#34;]
        NetworkDomain[&#34;网络域名 (networks.domain)&#34;]
        NetworkPort[&#34;网络端口 (networks.port)&#34;]
    end

    %% formData2Yamls 生成 YAML 映射
    subgraph YAML[&#34;formData2Yamls(appForm)生成 YAML&#34;]
        CPU_YAML[&#34;Deployment.spec.template.spec.containers[0].resources.requests/limits.cpu&#34;]
        Memory_YAML[&#34;Deployment.spec.template.spec.containers[0].resources.requests/limits.memory&#34;]
        Replicas_YAML[&#34;Deployment.spec.replicas&#34;]
        Image_YAML[&#34;Deployment.spec.template.spec.containers[0].image&#34;]
        Command_YAML[&#34;Deployment.spec.template.spec.containers[0].command&#34;]
        Args_YAML[&#34;Deployment.spec.template.spec.containers[0].args&#34;]
        Env_YAML[&#34;Deployment.spec.template.spec.containers[0].env&#34;]
        ServiceSelector[&#34;Service.spec.selector.app&#34;]
        ServicePort[&#34;Service.spec.ports&#34;]
        IngressHost[&#34;Ingress.spec.rules.host&#34;]
        IngressClass[&#34;Ingress.spec.ingressClassName / annotations&#34;]
        HPA_MinReplicas[&#34;HPA.spec.minReplicas&#34;]
        HPA_MaxReplicas[&#34;HPA.spec.maxReplicas&#34;]
        HPA_TargetCPU[&#34;HPA.spec.metrics[0].resource.target.averageUtilization&#34;]
    end

    %% YAML 到 Kubernetes 资源映射
    subgraph K8s[&#34;Kubernetes 资源&#34;]
        Deployment[&#34;Deployment / StatefulSet&#34;]
        Service[&#34;Service / ConfigMap / Secret&#34;]
        Ingress[&#34;Ingress&#34;]
        HPA[&#34;HorizontalPodAutoscaler&#34;]
    end

    %% 表单字段到 YAML 映射
    CPU --&gt; CPU_YAML
    Memory --&gt; Memory_YAML
    Replicas --&gt; Replicas_YAML
    Image --&gt; Image_YAML
    Command --&gt; Command_YAML
    Args --&gt; Args_YAML
    Env --&gt; Env_YAML
    NetworkDomain --&gt; IngressHost
    NetworkDomain --&gt; ServiceSelector
    NetworkPort --&gt; ServicePort

    %% YAML 到资源映射
    CPU_YAML --&gt; Deployment
    Memory_YAML --&gt; Deployment
    Replicas_YAML --&gt; Deployment
    Image_YAML --&gt; Deployment
    Command_YAML --&gt; Deployment
    Args_YAML --&gt; Deployment
    Env_YAML --&gt; Deployment
    ServiceSelector --&gt; Service
    ServicePort --&gt; Service
    IngressHost --&gt; Ingress
    IngressClass --&gt; Ingress

    %% HPA 映射
    Replicas --&gt; HPA_MinReplicas
    Replicas --&gt; HPA_MaxReplicas
    CPU --&gt; HPA_TargetCPU
    Memory --&gt; HPA_TargetCPU
    HPA_MinReplicas --&gt; HPA
    HPA_MaxReplicas --&gt; HPA
    HPA_TargetCPU --&gt; HPA
</code></pre><h3 id=-特点>🔹 特点
<a class=anchor href=#-%e7%89%b9%e7%82%b9>#</a></h3><ol><li><strong>表单字段</strong>：左侧显示前端 AppEditType 字段</li><li><strong>生成的 YAML</strong>：中间显示 formData2Yamls 生成的对应字段路径</li><li><strong>Kubernetes 资源</strong>：右侧显示 Deployment / StatefulSet / Service / Ingress / HPA</li><li><strong>HPA 关联</strong>：replicas、CPU、memory 会映射到 HPA 的 min/max replicas 和 target utilization</li></ol><hr><p>如果你愿意，我可以帮你再画一个 <strong>加上每个 YAML 字段生成逻辑的“注释版”图</strong>，比如：<code>CPU → requests: cpu = floor(cpu*0.1)m, limits: cpu = cpu m</code>，这样就能完整看到 <strong>表单 → 数值处理 → YAML → K8s</strong> 的整个链路。</p><p>你希望我画这个注释版吗？</p><p>太好了，你把完整代码贴出来了 🙌。这个文件就是你之前问的“前端表单怎么变成后端 deployment 的 YAML”的关键逻辑。
我给你分块解释一下，让你能一眼看清楚 <strong>从前端 JSON → Kubernetes YAML 清单</strong> 的全过程。</p><hr><h2 id=-整体思路>🔑 整体思路
<a class=anchor href=#-%e6%95%b4%e4%bd%93%e6%80%9d%e8%b7%af>#</a></h2><ol><li><strong>前端表单数据</strong>（<code>AppEditType</code>）通过 API 提交到后端。</li><li>后端用这些数据生成对应的 <strong>K8s YAML/Manifest</strong>：Deployment、Service、Ingress、ConfigMap、Secret、HPA 等。</li><li>YAML 最终被提交给 Kubernetes API Server，部署应用。</li></ol><hr><h2 id=-核心函数解析>📌 核心函数解析
<a class=anchor href=#-%e6%a0%b8%e5%bf%83%e5%87%bd%e6%95%b0%e8%a7%a3%e6%9e%90>#</a></h2><h3 id=1-json2deploycr>1. <code>json2DeployCr</code>
<a class=anchor href=#1-json2deploycr>#</a></h3><p>作用：把表单数据转成 <strong>Deployment</strong> 或 <strong>StatefulSet</strong> 的 YAML。</p><p>流程：</p><ul><li><strong>metadata</strong>：用应用名、标签、注解描述对象。</li><li><strong>spec.replicas</strong>：副本数（从表单里的 <code>hpa.minReplicas</code> 或 <code>replicas</code> 拿）。</li><li><strong>containers</strong>：容器配置，包括镜像、命令、环境变量、CPU/内存/GPU 资源、端口。</li><li><strong>volumes/volumeMounts</strong>：配置存储卷（PVC/ConfigMap）。</li><li><strong>gpuMap</strong>：如果有 GPU，给 Pod 指定 <code>nodeSelector</code> 和 <code>runtimeClassName</code>。</li><li><strong>StatefulSet 特殊逻辑</strong>：生成 <code>volumeClaimTemplates</code>，挂载数据卷。</li></ul><p>输出：一个 <strong>Deployment 或 StatefulSet 的 YAML 字符串</strong>。</p><hr><h3 id=2-json2service>2. <code>json2Service</code>
<a class=anchor href=#2-json2service>#</a></h3><p>作用：根据表单里网络配置，生成 <strong>Service YAML</strong>。</p><p>流程：</p><ul><li>遍历 <code>data.networks</code>：区分 NodePort 和 ClusterIP。</li><li>给每个端口生成对应的 <code>Service</code> 配置。</li><li>如果有 NodePort，就生成一个 <code>type: NodePort</code> 的 Service；否则生成默认的 ClusterIP。</li></ul><p>输出：一个或多个 <strong>Service YAML</strong>（用 <code>---</code> 分隔）。</p><hr><h3 id=3-json2ingress>3. <code>json2Ingress</code>
<a class=anchor href=#3-json2ingress>#</a></h3><p>作用：生成 <strong>Ingress YAML</strong>，处理域名和 TLS。</p><p>流程：</p><ul><li>遍历 <code>data.networks</code>，找出需要对外暴露的服务（<code>openPublicDomain</code> = true）。</li><li>生成 Ingress 配置（<code>rules</code>、<code>tls</code>、nginx annotations）。</li><li>如果是自定义域名，还会额外生成 <strong>Issuer</strong> 和 <strong>Certificate</strong>（由 cert-manager 管理）。</li></ul><p>输出：Ingress + TLS 证书的 YAML。</p><hr><h3 id=4-json2configmap>4. <code>json2ConfigMap</code>
<a class=anchor href=#4-json2configmap>#</a></h3><p>作用：生成 <strong>ConfigMap YAML</strong>，把用户输入的配置文件/环境写进去。</p><hr><h3 id=5-json2secret>5. <code>json2Secret</code>
<a class=anchor href=#5-json2secret>#</a></h3><p>作用：生成 <strong>Secret YAML</strong>，主要用于存储镜像仓库认证信息（<code>dockerconfigjson</code>）。</p><hr><h3 id=6-json2hpa>6. <code>json2HPA</code>
<a class=anchor href=#6-json2hpa>#</a></h3><p>作用：生成 <strong>HPA (HorizontalPodAutoscaler) YAML</strong>。</p><ul><li>根据表单里的 <code>hpa.target</code>（cpu/memory/gpu）生成对应的指标配置。</li><li>配置 <code>minReplicas</code>、<code>maxReplicas</code>、伸缩策略。</li></ul><hr><h3 id=7-yamlstring2objects>7. <code>yamlString2Objects</code>
<a class=anchor href=#7-yamlstring2objects>#</a></h3><p>辅助方法：把 YAML 字符串分割成多个对象，便于后续处理。</p><hr><h2 id=-整体流程图>📊 整体流程图
<a class=anchor href=#-%e6%95%b4%e4%bd%93%e6%b5%81%e7%a8%8b%e5%9b%be>#</a></h2><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
A[前端表单 AppEditType JSON] --&gt; B[后端函数 json2DeployCr/json2Service/json2Ingress...]
B --&gt; C[生成 YAML 字符串]
C --&gt; D[提交到 K8s API Server]
D --&gt; E[etcd 存储对象]
E --&gt; F[Scheduler 调度 Pod]
F --&gt; G[Kubelet 拉取镜像并运行容器]
</code></pre><hr><h2 id=-总结一句话>✅ 总结一句话
<a class=anchor href=#-%e6%80%bb%e7%bb%93%e4%b8%80%e5%8f%a5%e8%af%9d>#</a></h2><p>这份代码就是一个 <strong>“表单数据 → Kubernetes YAML 工厂”</strong>：</p><ul><li>把前端用户填写的参数（镜像、副本数、端口、存储、域名、环境变量、HPA …）</li><li>转换成标准的 <strong>Deployment / StatefulSet / Service / Ingress / ConfigMap / Secret / HPA YAML</strong></li><li>然后再由后端去调用 Kubernetes API 部署到集群。</li></ul><hr><p>要不要我帮你画一个 <strong>表单字段 → YAML 字段映射表</strong>，让你快速查到「前端填的某个参数最后出现在 YAML 的哪一行」？</p><p>非常好的问题 👍
你前面贴的代码（前端表单转 YAML）是 <strong>生成 YAML 清单</strong>，而这一段代码就是 <strong>把 YAML 真正部署到 Kubernetes 集群</strong> 的逻辑。
我来帮你逐步拆解：</p><hr><h2 id=1-kubernetes-客户端初始化>1. <strong>Kubernetes 客户端初始化</strong>
<a class=anchor href=#1-kubernetes-%e5%ae%a2%e6%88%b7%e7%ab%af%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>k8s</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@kubernetes/client-node&#39;</span>;
</span></span></code></pre></div><p>这里用的是 <a href=https://github.com/kubernetes-client/javascript>官方 Node.js Kubernetes Client</a>，用来连接并操作 K8s 集群。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>K8sApiDefault</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>k8s</span>.<span style=color:#a6e22e>KubeConfig</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>kc</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>k8s</span>.<span style=color:#a6e22e>KubeConfig</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kc</span>.<span style=color:#a6e22e>loadFromDefault</span>(); <span style=color:#75715e>// 默认读取 ~/.kube/config
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>kc</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果是本地调试，就直接加载 <code>~/.kube/config</code> 里的 kubeconfig 文件。</p><hr><h2 id=2-判断是否在集群内部运行>2. <strong>判断是否在集群内部运行</strong>
<a class=anchor href=#2-%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e5%9c%a8%e9%9b%86%e7%be%a4%e5%86%85%e9%83%a8%e8%bf%90%e8%a1%8c>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>CheckIsInCluster</span>()<span style=color:#f92672>:</span> [<span style=color:#66d9ef>boolean</span>, <span style=color:#66d9ef>string</span>] {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>KUBERNETES_SERVICE_HOST</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>KUBERNETES_SERVICE_PORT</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#66d9ef>true</span>, <span style=color:#e6db74>`https://</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>KUBERNETES_SERVICE_HOST</span><span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>KUBERNETES_SERVICE_PORT</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> [<span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#39;&#39;</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果代码运行在 <strong>K8s Pod 内部</strong>，Kubernetes 会注入 <code>KUBERNETES_SERVICE_HOST</code> 和 <code>KUBERNETES_SERVICE_PORT</code> 环境变量。
这样可以直接连 <strong>集群内的 API Server</strong>，而不用 kubeconfig 文件。</p><hr><h2 id=3-加载-kubeconfig>3. <strong>加载 kubeconfig</strong>
<a class=anchor href=#3-%e5%8a%a0%e8%bd%bd-kubeconfig>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>K8sApi</span>(<span style=color:#a6e22e>config</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>k8s</span>.<span style=color:#a6e22e>KubeConfig</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>kc</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>k8s</span>.<span style=color:#a6e22e>KubeConfig</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kc</span>.<span style=color:#a6e22e>loadFromString</span>(<span style=color:#a6e22e>config</span>);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>kc</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里会优先用传入的 <strong>kubeconfig 字符串</strong>，并且如果代码运行在集群内部，会把 server 地址改为集群内的 API 地址。</p><hr><h2 id=4-创建-yaml-到-k8s>4. <strong>创建 YAML 到 K8s</strong>
<a class=anchor href=#4-%e5%88%9b%e5%bb%ba-yaml-%e5%88%b0-k8s>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>CreateYaml</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kc</span>: <span style=color:#66d9ef>k8s.KubeConfig</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>specs</span>: <span style=color:#66d9ef>k8s.KubernetesObject</span>[]
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li><code>specs</code> 就是前端转出来的 YAML 解析成的 JSON 对象（Deployment, Service, Ingress 等等）。</li><li>它用 <code>KubernetesObjectApi</code> 来 <code>client.create(spec)</code>。</li><li>创建成功的对象会 push 到 <code>created</code> 数组里。</li><li>如果中途失败，会回滚：把之前成功创建的对象都删除掉。</li></ul><p>👉 这就是 <strong>把 YAML apply 到集群</strong>。</p><hr><h2 id=5-更新替换-yaml-到-k8s>5. <strong>更新/替换 YAML 到 K8s</strong>
<a class=anchor href=#5-%e6%9b%b4%e6%96%b0%e6%9b%bf%e6%8d%a2-yaml-%e5%88%b0-k8s>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>replaceYaml</span>(<span style=color:#a6e22e>kc</span>, <span style=color:#a6e22e>specs</span>)
</span></span></code></pre></div><p>逻辑：</p><ol><li>先用 <code>client.read(spec)</code> 看资源是否存在。</li><li>如果存在，就 <code>client.replace(spec)</code> 更新（需要带上 <code>resourceVersion</code> 才能替换）。</li><li>如果不存在，就 <code>client.create(spec)</code> 新建。</li></ol><p>👉 这就是 <strong>kubectl apply 的效果</strong>。</p><hr><h2 id=6-获取用户配额>6. <strong>获取用户配额</strong>
<a class=anchor href=#6-%e8%8e%b7%e5%8f%96%e7%94%a8%e6%88%b7%e9%85%8d%e9%a2%9d>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getUserQuota</span>(<span style=color:#a6e22e>kc</span>, <span style=color:#66d9ef>namespace</span>)
</span></span></code></pre></div><p>调用 <code>CoreV1Api.readNamespacedResourceQuota</code>，查询命名空间的 <strong>ResourceQuota</strong>，返回用户的 CPU、内存、存储、NodePort、GPU 使用情况。
相当于 <code>kubectl describe quota</code>。</p><hr><h2 id=7-获取用户余额>7. <strong>获取用户余额</strong>
<a class=anchor href=#7-%e8%8e%b7%e5%8f%96%e7%94%a8%e6%88%b7%e4%bd%99%e9%a2%9d>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getUserBalance</span>(<span style=color:#a6e22e>kc</span>)
</span></span></code></pre></div><p>这里调用的是 <strong>Sealos 自定义 CRD</strong> <code>account.sealos.io/v1/accounts</code>，从里面取余额。
说明这个平台在 Kubernetes 上做了 <strong>多租户和计费</strong>。</p><hr><h2 id=8-封装统一的-k8s-操作入口>8. <strong>封装统一的 K8s 操作入口</strong>
<a class=anchor href=#8-%e5%b0%81%e8%a3%85%e7%bb%9f%e4%b8%80%e7%9a%84-k8s-%e6%93%8d%e4%bd%9c%e5%85%a5%e5%8f%a3>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getK8s</span>({ <span style=color:#a6e22e>kubeconfig</span> }<span style=color:#f92672>:</span> { <span style=color:#a6e22e>kubeconfig</span>: <span style=color:#66d9ef>string</span> })
</span></span></code></pre></div><p>这个函数会返回一个对象，里面包含：</p><ul><li><code>applyYamlList</code> → 负责部署 YAML（create 或 replace）</li><li><code>getDeployApp</code> → 获取某个 app 的 Deployment/StatefulSet</li><li><code>getUserQuota</code> → 查询用户配额</li><li><code>getUserBalance</code> → 查询用户余额</li><li>还有一些 client (<code>k8sCore</code>, <code>k8sApp</code>, <code>k8sAutoscaling</code>, <code>k8sNetworkingApp</code> 等) 用于不同的资源操作。</li></ul><hr><h2 id=-前后端流程串起来>🔗 前后端流程串起来
<a class=anchor href=#-%e5%89%8d%e5%90%8e%e7%ab%af%e6%b5%81%e7%a8%8b%e4%b8%b2%e8%b5%b7%e6%9d%a5>#</a></h2><ol><li><strong>前端表单</strong>（用户填 app 名称、镜像、端口、存储等）。</li><li><strong>前端转 YAML</strong>（用你之前贴的 <code>json2DeployCr</code>、<code>json2Service</code> 等函数 → 生成 Deployment/Service/Ingress YAML 字符串）。</li><li><strong>后端解析 YAML</strong>（用 <code>yaml.loadAll</code> 解析成 JSON 对象）。</li><li><strong>后端调用 CreateYaml/replaceYaml</strong> → 通过 API Server 把对象部署到集群。</li><li>Kubernetes 调度器负责拉镜像、创建 Pod。</li></ol><hr><h2 id=总结一句话>总结一句话
<a class=anchor href=#%e6%80%bb%e7%bb%93%e4%b8%80%e5%8f%a5%e8%af%9d>#</a></h2><p>👉 前端只是 <strong>表单转 YAML</strong>，
👉 后端这段代码才是 <strong>把 YAML apply 到 Kubernetes 集群</strong>，实现跟 <code>kubectl apply -f xxx.yaml</code> 一样的功能。</p><hr><p>要不要我帮你画一个 <strong>前端表单 → YAML → API Server → 集群部署</strong> 的 <strong>流程图（Mermaid）</strong>，直观一点？</p><p>好的 👍 我给你画一个 <strong>前端表单 → YAML → K8s 集群部署</strong> 的流程图，用 Mermaid 表示：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
    A[用户在前端表单填写参数: 镜像/端口/存储/CPU等] --&gt; B[前端将表单数据转换为 YAML]

    B --&gt; C[后端 API 接收 YAML]
    C --&gt; D[后端解析 YAML 为 JSON 对象]

    D --&gt; E[调用 CreateYaml / replaceYaml 方法]
    E --&gt; F[请求发送到 Kubernetes API Server]

    F --&gt; G[API Server 校验并存储到 etcd]
    G --&gt; H[调度器分配节点]
    H --&gt; I[Kubelet 拉取镜像并启动 Pod]
    I --&gt; J[应用成功运行在 Kubernetes 集群]
</code></pre><hr><p>这个图走的流程其实就是：</p><ol><li><strong>前端</strong>：用户输入参数，转 YAML。</li><li><strong>后端</strong>：接收 YAML → 转 JSON → 调用 K8s API。</li><li><strong>API Server</strong>：存到 etcd → 调度 → 创建 Pod。</li><li><strong>最终应用部署成功</strong>。</li></ol><hr><p>要不要我再给你画一个 <strong>时序图（sequence diagram）</strong>，表现前端、后端、K8s 之间的调用过程？</p><p>好嘞 👍 用 Mermaid 的 <code>sequenceDiagram</code> 来画会更直观，表现 <strong>前端、后端、K8s API Server</strong> 的交互流程：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant FE as 前端(表单页面)
    participant BE as 后端(Node.js服务)
    participant K8S as Kubernetes API Server
    participant ETCD as etcd
    participant Kubelet as 节点Kubelet

    FE-&gt;&gt;BE: 提交表单数据 (镜像/端口/CPU/存储等)
    BE-&gt;&gt;BE: 转换为 YAML (Deployment/Service/Ingress...)
    BE-&gt;&gt;K8S: 调用 CreateYaml/replaceYaml&lt;br&gt;提交资源对象
    K8S-&gt;&gt;ETCD: 校验并写入资源对象
    K8S-&gt;&gt;BE: 返回成功(资源已创建)

    K8S-&gt;&gt;Kubelet: 调度 Pod 到节点
    Kubelet-&gt;&gt;Kubelet: 拉取镜像，启动容器
    Kubelet--&gt;&gt;K8S: 上报 Pod 状态 Running
    K8S--&gt;&gt;BE: 应用状态可查询
    BE--&gt;&gt;FE: 返回部署成功/状态信息
</code></pre><hr><p>这样你能清楚看到：</p><ol><li><strong>前端</strong> 只管提交表单；</li><li><strong>后端</strong> 负责转成 YAML 并调用 K8s API；</li><li><strong>API Server</strong> 校验+存储到 <strong>etcd</strong>；</li><li><strong>调度器 & Kubelet</strong> 完成实际的 Pod 创建；</li><li>最终状态再层层返回到前端。</li></ol><p>要不要我再给你加一版 <strong>失败场景的时序图</strong>（比如 YAML 校验失败 / 资源配额不足）？</p><h2 id=kubesphere-的前端填写-deployment-表单后核心流程如下>KubeSphere 的前端填写 Deployment 表单后，核心流程如下：
<a class=anchor href=#kubesphere-%e7%9a%84%e5%89%8d%e7%ab%af%e5%a1%ab%e5%86%99-deployment-%e8%a1%a8%e5%8d%95%e5%90%8e%e6%a0%b8%e5%bf%83%e6%b5%81%e7%a8%8b%e5%a6%82%e4%b8%8b>#</a></h2><hr><h2 id=1-前端表单如何转为-deployment-的-yaml>1. 前端表单如何转为 Deployment 的 YAML
<a class=anchor href=#1-%e5%89%8d%e7%ab%af%e8%a1%a8%e5%8d%95%e5%a6%82%e4%bd%95%e8%bd%ac%e4%b8%ba-deployment-%e7%9a%84-yaml>#</a></h2><p>KubeSphere 的前端（如控制台）填写的 Deployment 表单数据，通常会被转换为 Kubernetes Deployment 资源对象的 JSON/YAML。</p><ul><li>前端会收集表单数据，比如名称、镜像、labels、replicas、容器配置等。</li><li>这些数据会被组装成标准的 K8s Deployment 资源规范（JSON），如：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;apiVersion&#34;</span>: <span style=color:#e6db74>&#34;apps/v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;kind&#34;</span>: <span style=color:#e6db74>&#34;Deployment&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;example-deployment&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;namespace&#34;</span>: <span style=color:#e6db74>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;labels&#34;</span>: { <span style=color:#960050;background-color:#1e0010>...</span> }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;replicas&#34;</span>: <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;selector&#34;</span>: { <span style=color:#960050;background-color:#1e0010>...</span> },
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;template&#34;</span>: { <span style=color:#960050;background-color:#1e0010>...</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 KubeSphere 的代码例子参考（测试数据）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ksApiserverDeploy</span> = <span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;apiVersion&#34;: &#34;apps/v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;kind&#34;: &#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;labels&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &#34;app&#34;: &#34;ks-apiserver&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &#34;tier&#34;: &#34;backend&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        },
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;name&#34;: &#34;ks-apiserver&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;namespace&#34;: &#34;kubesphere-system&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    },
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;spec&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       ...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>
</span></span></code></pre></div><h2 id=2-如何被部署到-k8s-集群>2. 如何被部署到 K8s 集群
<a class=anchor href=#2-%e5%a6%82%e4%bd%95%e8%a2%ab%e9%83%a8%e7%bd%b2%e5%88%b0-k8s-%e9%9b%86%e7%be%a4>#</a></h2><ul><li>前端会将 YAML/JSON 通过 API 请求发送到 KubeSphere 后端（通常是 RESTful 接口）。</li><li>后端负责将这些 Deployment 对象 apply 到 Kubernetes 集群。</li></ul><p>后端关键实现如下：</p><h3 id=21-接收并-apply-资源对象>2.1 接收并 apply 资源对象
<a class=anchor href=#21-%e6%8e%a5%e6%94%b6%e5%b9%b6-apply-%e8%b5%84%e6%ba%90%e5%af%b9%e8%b1%a1>#</a></h3><p>后端会解析前端传来的 JSON/YAML，通过 K8s Dynamic Client 进行 apply：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>YamlInstaller</span>) <span style=color:#a6e22e>ForApply</span>(<span style=color:#a6e22e>tasks</span> []<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>RawMessage</span>) (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>idx</span>, <span style=color:#a6e22e>js</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tasks</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gvr</span>, <span style=color:#a6e22e>utd</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetInfoFromBytes</span>(<span style=color:#a6e22e>js</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Mapper</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>metav1</span>.<span style=color:#a6e22e>PatchOptions</span>{<span style=color:#a6e22e>FieldManager</span>: <span style=color:#e6db74>&#34;v1.FieldManager&#34;</span>}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>DynamicCli</span>.<span style=color:#a6e22e>Resource</span>(<span style=color:#a6e22e>gvr</span>).
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Namespace</span>(<span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetNamespace</span>()).
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Patch</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>TODO</span>(), <span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetName</span>(), <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>ApplyPatchType</span>, <span style=color:#a6e22e>js</span>, <span style=color:#a6e22e>opt</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>klog</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;[%d/%d] %s/%s applied&#34;</span>, <span style=color:#a6e22e>idx</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, len(<span style=color:#a6e22e>tasks</span>), <span style=color:#a6e22e>gvr</span>.<span style=color:#a6e22e>Resource</span>, <span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetName</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>前端 JSON 数据通过 API 传到后端，后端调用 K8s API，创建或更新 Deployment 资源。</li></ul><h3 id=22-典型调用链>2.2 典型调用链
<a class=anchor href=#22-%e5%85%b8%e5%9e%8b%e8%b0%83%e7%94%a8%e9%93%be>#</a></h3><ol><li>前端表单 -> 组装标准 Deployment JSON</li><li>前端通过 API 发送到后端（如 <code>/apis/apps/v1/namespaces/{namespace}/deployments</code>）</li><li>后端用 DynamicClient、RestMapper 解析 JSON 并 apply 到集群</li><li>资源被成功创建或更新</li></ol><hr><h2 id=相关代码参考>相关代码参考
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81%e5%8f%82%e8%80%83>#</a></h2><ul><li>前端表单组装 Deployment 数据（可参考测试数据）:<br><code>pkg/kapis/cluster/v1alpha1/handler_test.go:ksApiserverDeploy</code></li><li>后端应用 YAML/JSON 到 K8s 集群:<br><code>pkg/simple/client/application/yaml.go:YamlInstaller.ForApply</code></li></ul><hr><p>如需更详细的前端/后端源码入口或 API 路径，请补充需求！</p><p>好的，这段 Go 代码主要是 <strong>KubeSphere 里对 Kubernetes 集群配置的测试代码</strong>，虽然它本身是测试（<code>_test.go</code> 文件），但我们可以把它拆解来看，尤其聚焦 <strong>前端表单如何映射到 Deployment/YAML 资源</strong> 的逻辑。</p><p>我给你按层次解释：</p><hr><h2 id=1-核心结构>1️⃣ 核心结构
<a class=anchor href=#1-%e6%a0%b8%e5%bf%83%e7%bb%93%e6%9e%84>#</a></h2><ol><li><strong>Cluster 对象</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cluster</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>v1alpha1</span>.<span style=color:#a6e22e>Cluster</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ObjectMeta</span>: <span style=color:#a6e22e>metav1</span>.<span style=color:#a6e22e>ObjectMeta</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;gondor&#34;</span>},
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Spec</span>: <span style=color:#a6e22e>v1alpha1</span>.<span style=color:#a6e22e>ClusterSpec</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Connection</span>: <span style=color:#a6e22e>v1alpha1</span>.<span style=color:#a6e22e>Connection</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Type</span>:  <span style=color:#a6e22e>v1alpha1</span>.<span style=color:#a6e22e>ConnectionTypeProxy</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Token</span>: <span style=color:#e6db74>&#34;randomtoken&#34;</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>这里模拟了一个 <strong>KubeSphere 集群对象</strong>。</li><li>前端表单如果创建集群，通常会填写：<ul><li><code>cluster.name</code></li><li><code>cluster.connection.type</code>（直接/代理）</li><li><code>cluster.connection.token</code></li></ul></li></ul><p>这些字段最终映射到 Cluster CRD。</p><hr><ol><li><strong>ConfigMap 数据</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>hostMap</span> = <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;kubesphere.yaml&#34;</span>: <span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>monitoring:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  endpoint: http://prometheus-operated.kubesphere-monitoring-system.svc:9090
</span></span></span><span style=display:flex><span><span style=color:#e6db74>authentication:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  jwtSecret: ...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  oauthOptions:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    accessTokenMaxAge: 0s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    accessTokenInactivityTimeout: 0s
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>模拟了集群的 <strong>配置数据</strong>。</li><li>在前端表单中，可能有 <strong>监控地址、JWT Secret、OAuth 配置</strong>。</li><li>后端会把这些字段组装成 ConfigMap 并写入 <code>kubesphere-system</code> 命名空间。</li></ul><hr><ol><li><strong>Deployment 模板（JSON）</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ksApiserverDeploy</span> = <span style=color:#e6db74>`{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;apiVersion&#34;: &#34;apps/v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;kind&#34;: &#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;name&#34;: &#34;ks-apiserver&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;namespace&#34;: &#34;kubesphere-system&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;labels&#34;: {...}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    },
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;spec&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;replicas&#34;: 1,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;template&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &#34;spec&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                &#34;containers&#34;: [{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                    &#34;name&#34;: &#34;ks-apiserver&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                    &#34;image&#34;: &#34;kubesphere/ks-apiserver:v3.0.0&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                    &#34;command&#34;: [&#34;ks-apiserver&#34;,&#34;--logtostderr=true&#34;]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                }]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}`</span>
</span></span></code></pre></div><ul><li><p>这里是 <strong>KubeSphere Apiserver 的 Deployment 模板</strong>。</p></li><li><p><strong>前端表单对应字段映射</strong>：</p><table><thead><tr><th>表单字段</th><th>Deployment 字段</th></tr></thead><tbody><tr><td>镜像</td><td><code>containers[0].image</code></td></tr><tr><td>命令</td><td><code>containers[0].command</code></td></tr><tr><td>副本数</td><td><code>spec.replicas</code></td></tr><tr><td>环境变量/配置</td><td><code>containers[0].env</code> 或 ConfigMap 挂载</td></tr></tbody></table></li><li><p>后端通过 JSON/Struct 解析后再写入 Kubernetes。</p></li></ul><hr><h2 id=2-核心方法addmemberclusterresource>2️⃣ 核心方法：<code>addMemberClusterResource</code>
<a class=anchor href=#2-%e6%a0%b8%e5%bf%83%e6%96%b9%e6%b3%95addmemberclusterresource>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>addMemberClusterResource</span>(<span style=color:#a6e22e>targetCm</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>corev1</span>.<span style=color:#a6e22e>ConfigMap</span>, <span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 构造 clientSet</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>con</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>clientcmd</span>.<span style=color:#a6e22e>NewClientConfigFromBytes</span>(<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cli</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>con</span>.<span style=color:#a6e22e>ClientConfig</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>k8s</span>.<span style=color:#a6e22e>NewForConfig</span>(<span style=color:#a6e22e>cli</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 创建命名空间</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>CoreV1</span>().<span style=color:#a6e22e>Namespaces</span>().<span style=color:#a6e22e>Create</span>(<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 创建 ConfigMap</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>CoreV1</span>().<span style=color:#a6e22e>ConfigMaps</span>(<span style=color:#a6e22e>namespace</span>).<span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>targetCm</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 创建 Deployment</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>deploy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>appsv1</span>.<span style=color:#a6e22e>Deployment</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>([]byte(<span style=color:#a6e22e>ksApiserverDeploy</span>), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>deploy</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>AppsV1</span>().<span style=color:#a6e22e>Deployments</span>(<span style=color:#a6e22e>namespace</span>).<span style=color:#a6e22e>Create</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>deploy</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=-做了什么>🔹 做了什么
<a class=anchor href=#-%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88>#</a></h3><ol><li>读取前端表单生成的 <strong>KubeConfig</strong></li><li>初始化 Kubernetes client</li><li>创建 <strong>命名空间</strong>（如果不存在）</li><li>创建或更新 <strong>ConfigMap</strong>（前端表单字段：监控、JWT、OAuth）</li><li>创建 <strong>Deployment</strong>（前端表单字段：镜像、命令、replicas）</li></ol><hr><h2 id=3-validatememberclusterconfiguration>3️⃣ <code>validateMemberClusterConfiguration</code>
<a class=anchor href=#3-validatememberclusterconfiguration>#</a></h2><ul><li>模拟了<strong>验证成员集群配置是否有效</strong>。</li><li>流程：<ol><li>先写入 <strong>hostCm</strong></li><li>调用 <code>validateMemberClusterConfiguration</code> 校验</li><li>再写入 <strong>memberCm</strong></li><li>校验失败（确保检测到重复或错误的配置）</li></ol></li></ul><blockquote><p>这里可以理解为：前端表单生成的 ConfigMap/YAML 经过后端组装 Deployment 后，最终要验证 <strong>集群是否可用、配置是否合理</strong>。</p></blockquote><hr><h2 id=4-总结表单字段到-deployment-映射>4️⃣ 总结：表单字段到 Deployment 映射
<a class=anchor href=#4-%e6%80%bb%e7%bb%93%e8%a1%a8%e5%8d%95%e5%ad%97%e6%ae%b5%e5%88%b0-deployment-%e6%98%a0%e5%b0%84>#</a></h2><table><thead><tr><th>前端表单字段</th><th>Kubernetes 资源 & YAML 路径</th></tr></thead><tbody><tr><td>镜像</td><td>Deployment.spec.template.spec.containers[0].image</td></tr><tr><td>命令</td><td>Deployment.spec.template.spec.containers[0].command</td></tr><tr><td>命令参数</td><td>Deployment.spec.template.spec.containers[0].args</td></tr><tr><td>副本数</td><td>Deployment.spec.replicas</td></tr><tr><td>环境变量/配置</td><td>Deployment.spec.template.spec.containers[0].env / ConfigMap</td></tr><tr><td>JWT Secret / OAuth / Monitoring</td><td>ConfigMap.data[&ldquo;kubesphere.yaml&rdquo;]</td></tr></tbody></table><ul><li><strong>逻辑关系</strong>：<ul><li>表单 → 内存对象（Cluster / ConfigMap / Deployment Struct） → Kubernetes API → 真实资源</li></ul></li><li><strong>测试意图</strong>：<ul><li>验证表单生成 Deployment 是否正确</li><li>校验成员集群配置是否合理</li></ul></li></ul><hr><p>如果你需要，我可以帮你画一张 <strong>“前端表单字段 → YAML → Deployment/ConfigMap 映射图”</strong>，把上表可视化成 Mermaid 图，更直观地展示前端如何组装 Deployment 数据。</p><p>你希望我画这个图吗？</p><p>好的，这段代码实现的是 <strong>KubeSphere 后端用来将 YAML/JSON 应用到 Kubernetes 集群的一个 “安装器”</strong>，用的是动态客户端（<code>dynamic.DynamicClient</code>），模仿 Helm 的接口。我们可以逐步解析它的逻辑，尤其是 <strong>前端提交的 YAML/JSON → K8s 资源</strong> 的过程。</p><hr><h2 id=1-核心结构-1>1️⃣ 核心结构
<a class=anchor href=#1-%e6%a0%b8%e5%bf%83%e7%bb%93%e6%9e%84-1>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>YamlInstaller</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Mapper</span>      <span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>RESTMapper</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DynamicCli</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>dynamic</span>.<span style=color:#a6e22e>DynamicClient</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GvrListInfo</span> []<span style=color:#a6e22e>InsInfo</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Namespace</span>   <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>InsInfo</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>schema</span>.<span style=color:#a6e22e>GroupVersionResource</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>      <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Namespace</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>Mapper</strong>：RESTMapper，用于把 GroupVersionKind（GVK）映射到 GroupVersionResource（GVR）。</li><li><strong>DynamicCli</strong>：动态客户端，可以操作任意类型的 Kubernetes 资源（Deployment/Service/ConfigMap/CRD 等）。</li><li><strong>GvrListInfo</strong>：记录已经安装的资源信息（用于卸载）。</li><li><strong>Namespace</strong>：资源默认命名空间。</li></ul><blockquote><p>总结：这个结构体就是一个 <strong>可对任意 YAML/JSON 应用、升级、删除的动态 Helm 安装器</strong>。</p></blockquote><hr><h2 id=2-install--upgrade--uninstall>2️⃣ Install / Upgrade / Uninstall
<a class=anchor href=#2-install--upgrade--uninstall>#</a></h2><h3 id=install>Install
<a class=anchor href=#install>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>YamlInstaller</span>) <span style=color:#a6e22e>Install</span>(<span style=color:#f92672>...</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>这里暂未实现，实际上可以调用 Upgrade 来实现“安装”的逻辑。</li></ul><hr><h3 id=upgrade>Upgrade
<a class=anchor href=#upgrade>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>YamlInstaller</span>) <span style=color:#a6e22e>Upgrade</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>release</span>, <span style=color:#a6e22e>chart</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>values</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>options</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>helm</span>.<span style=color:#a6e22e>HelmOption</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>yamlList</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ReadYaml</span>(<span style=color:#a6e22e>values</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>klog</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;attempting to apply %d yaml files&#34;</span>, len(<span style=color:#a6e22e>yamlList</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>ForApply</span>(<span style=color:#a6e22e>yamlList</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>values</strong>：前端传来的 YAML/JSON 内容（[]byte）。</li><li><strong>ReadYaml</strong>：把 YAML/JSON 转成 <code>[]json.RawMessage</code>（每个对象一个 json.RawMessage）。</li><li><strong>ForApply</strong>：核心方法，将每个对象应用到 Kubernetes。</li></ul><blockquote><p>说明：这里 Upgrade 就是“把 YAML/JSON 应用到集群”，前端表单的数据最终通过这个方法落地。</p></blockquote><hr><h3 id=uninstall>Uninstall
<a class=anchor href=#uninstall>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>YamlInstaller</span>) <span style=color:#a6e22e>Uninstall</span>(<span style=color:#f92672>...</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>GvrListInfo</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>DynamicCli</span>.<span style=color:#a6e22e>Resource</span>(<span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>GroupVersionResource</span>).<span style=color:#a6e22e>Namespace</span>(<span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>Namespace</span>).
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Delete</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>metav1</span>.<span style=color:#a6e22e>DeleteOptions</span>{})
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>apierrors</span>.<span style=color:#a6e22e>IsNotFound</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>根据 <code>GvrListInfo</code> 卸载所有资源。</li><li>使用 Dynamic Client 的 <code>Delete</code> 方法。</li></ul><hr><h2 id=3-核心方法forapply>3️⃣ 核心方法：ForApply
<a class=anchor href=#3-%e6%a0%b8%e5%bf%83%e6%96%b9%e6%b3%95forapply>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>YamlInstaller</span>) <span style=color:#a6e22e>ForApply</span>(<span style=color:#a6e22e>tasks</span> []<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>RawMessage</span>) (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>idx</span>, <span style=color:#a6e22e>js</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tasks</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gvr</span>, <span style=color:#a6e22e>utd</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetInfoFromBytes</span>(<span style=color:#a6e22e>js</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Mapper</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>metav1</span>.<span style=color:#a6e22e>PatchOptions</span>{<span style=color:#a6e22e>FieldManager</span>: <span style=color:#e6db74>&#34;v1.FieldManager&#34;</span>}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>DynamicCli</span>.<span style=color:#a6e22e>Resource</span>(<span style=color:#a6e22e>gvr</span>).
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Namespace</span>(<span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetNamespace</span>()).
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Patch</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>TODO</span>(), <span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetName</span>(), <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>ApplyPatchType</span>, <span style=color:#a6e22e>js</span>, <span style=color:#a6e22e>opt</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>klog</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;[%d/%d] %s/%s applied&#34;</span>, <span style=color:#a6e22e>idx</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, len(<span style=color:#a6e22e>tasks</span>), <span style=color:#a6e22e>gvr</span>.<span style=color:#a6e22e>Resource</span>, <span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetName</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=核心步骤>核心步骤：
<a class=anchor href=#%e6%a0%b8%e5%bf%83%e6%ad%a5%e9%aa%a4>#</a></h3><ol><li><strong>解析 YAML/JSON → GVR + Unstructured</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>gvr</span>, <span style=color:#a6e22e>utd</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetInfoFromBytes</span>(<span style=color:#a6e22e>js</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Mapper</span>)
</span></span></code></pre></div><ul><li><code>GetInfoFromBytes</code>：<ul><li>解析每个对象的 <strong>apiVersion/kind/name/namespace</strong>。</li><li>返回 <code>GroupVersionResource</code>（GVR）和 <code>Unstructured</code> 对象。</li></ul></li><li><strong>前端表单映射</strong>：<ul><li>Deployment、Service、ConfigMap 等资源的字段都在这里被解析。</li></ul></li></ul><ol><li><strong>Apply 到集群</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>DynamicCli</span>.<span style=color:#a6e22e>Resource</span>(<span style=color:#a6e22e>gvr</span>).
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Namespace</span>(<span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetNamespace</span>()).
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Patch</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>TODO</span>(), <span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetName</span>(), <span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>ApplyPatchType</span>, <span style=color:#a6e22e>js</span>, <span style=color:#a6e22e>opt</span>)
</span></span></code></pre></div><ul><li>使用 <strong>Server-Side Apply</strong>（<code>ApplyPatchType</code>），类似 <code>kubectl apply -f</code>：<ul><li>如果资源不存在 → 创建</li><li>如果资源存在 → 更新</li></ul></li><li>FieldManager 用于标记这个 patch 的来源。</li></ul><ol><li><strong>日志记录</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>klog</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;[%d/%d] %s/%s applied&#34;</span>, <span style=color:#a6e22e>idx</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, len(<span style=color:#a6e22e>tasks</span>), <span style=color:#a6e22e>gvr</span>.<span style=color:#a6e22e>Resource</span>, <span style=color:#a6e22e>utd</span>.<span style=color:#a6e22e>GetName</span>())
</span></span></code></pre></div><ul><li>打印应用进度。</li></ul><hr><h2 id=4-总结逻辑前端表单到-k8s-资源>4️⃣ 总结逻辑（前端表单到 K8s 资源）
<a class=anchor href=#4-%e6%80%bb%e7%bb%93%e9%80%bb%e8%be%91%e5%89%8d%e7%ab%af%e8%a1%a8%e5%8d%95%e5%88%b0-k8s-%e8%b5%84%e6%ba%90>#</a></h2><ol><li>前端表单 → YAML/JSON 数据<ul><li>例如：<ul><li>Deployment：镜像、replicas、资源限制</li><li>Service：端口、类型</li><li>ConfigMap/Secret：配置内容</li></ul></li></ul></li><li>后端调用 <code>YamlInstaller.Upgrade</code></li><li><code>ReadYaml(values)</code> → 切成多个 <code>json.RawMessage</code></li><li><code>ForApply</code>：<ul><li><code>GetInfoFromBytes</code> → 获取 GVR + Unstructured</li><li><code>DynamicClient.Patch(ApplyPatchType)</code> → 应用到 Kubernetes</li></ul></li><li>资源应用完成，<code>GvrListInfo</code> 保存，方便卸载</li></ol><blockquote><p>⚡ 核心点：<strong>前端表单字段并不直接写 Deployment 对象，而是被序列化成 YAML/JSON，通过 DynamicClient Apply 到集群</strong>。
也就是说：前端字段 → YAML → Unstructured → Kubernetes API。</p></blockquote><hr><p>如果你想，我可以帮你画一个 <strong>前端表单字段 → JSON/YAML → DynamicClient → Deployment/Service/ConfigMap 的流程图</strong>，把整个流程可视化，更直观。</p><p>你希望我画这个图吗？</p><p>根据 TKE 源码和文档，前端表单到后端 YAML 及部署到 K8s 的流程如下：</p><hr><h2 id=1-前端如何将表单变为-deployment-的-yaml>1. 前端如何将表单变为 Deployment 的 YAML
<a class=anchor href=#1-%e5%89%8d%e7%ab%af%e5%a6%82%e4%bd%95%e5%b0%86%e8%a1%a8%e5%8d%95%e5%8f%98%e4%b8%ba-deployment-%e7%9a%84-yaml>#</a></h2><ul><li>前端页面（如工作负载创建页面）收集用户填写的 Deployment 信息（如名称、镜像、标签、副本数等）。</li><li>前端会将这些表单转换为标准的 Deployment YAML/JSON 对象。</li></ul><p><strong>相关配置与转换逻辑参考：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>/** deployment的配置 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>deployment</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>k8sVersion</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>generateResourceInfo</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>k8sVersion</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resourceName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;deployment&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>requestType</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>list</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;deployments&#39;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>isRelevantToNamespace</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>displayField</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>actionField</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>detailField</span>
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>前端页面通过配置和表单数据，生成 deployment 的 YAML 内容。</p><p>表单提交前通常会用 YAML 解析库进行格式校验：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>appCreation</span>.<span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>rawValuesType</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;yaml&#39;</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>JsYAML</span>.<span style=color:#a6e22e>safeLoad</span>(<span style=color:#a6e22e>appCreation</span>.<span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>rawValues</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setState</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>yamlValidator</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>0</span>, <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&#39;</span> }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setState</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>yamlValidator</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>2</span>, <span style=color:#a6e22e>message</span>: <span style=color:#66d9ef>t</span>(<span style=color:#e6db74>&#39;Yaml格式错误&#39;</span>) }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=2-如何被部署到-k8s-集群-1>2. 如何被部署到 K8s 集群
<a class=anchor href=#2-%e5%a6%82%e4%bd%95%e8%a2%ab%e9%83%a8%e7%bd%b2%e5%88%b0-k8s-%e9%9b%86%e7%be%a4-1>#</a></h2><ul><li>前端最终提交 YAML/JSON 资源，会调用 WebAPI（通过 RESTful API）将资源发送到后端。</li><li>后端接收到 JSON/YAML 后，使用 K8s API 创建或更新资源。</li></ul><p><strong>关键 API 代码片段：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>updateResourceIns</span>(<span style=color:#a6e22e>resource</span>: <span style=color:#66d9ef>CreateResource</span>[], <span style=color:#a6e22e>regionId</span>: <span style=color:#66d9ef>number</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>resourceIns</span>, <span style=color:#a6e22e>clusterId</span>, <span style=color:#a6e22e>resourceInfo</span>, <span style=color:#66d9ef>namespace</span>, <span style=color:#a6e22e>jsonData</span>, <span style=color:#a6e22e>isStrategic</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>resource</span>[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>reduceK8sRestfulPath</span>({ <span style=color:#a6e22e>resourceInfo</span>, <span style=color:#66d9ef>namespace</span>, <span style=color:#a6e22e>specificName</span>: <span style=color:#66d9ef>resourceIns</span>, <span style=color:#a6e22e>clusterId</span> });
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>params</span>: <span style=color:#66d9ef>RequestParams</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>method</span>: <span style=color:#66d9ef>Method.patch</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>url</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>userDefinedHeader</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;Content-Type&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>isStrategic</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;application/strategic-merge-patch+json&#39;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;application/merge-patch+json&#39;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>jsonData</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>apiParams</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;tke&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>interfaceName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;ForwardRequest&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>regionId</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>restParams</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Method</span>: <span style=color:#66d9ef>Method.patch</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Path</span>: <span style=color:#66d9ef>url</span>,
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 发起 HTTP 请求（patch 或 post），后端代理给 K8s API Server
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>后端会将这些数据代理到 K8s API Server 创建/更新 Deployment 资源。</li></ul><hr><h2 id=3-服务端go侧实际部署代码示例>3. 服务端（Go）侧实际部署代码示例
<a class=anchor href=#3-%e6%9c%8d%e5%8a%a1%e7%ab%afgo%e4%be%a7%e5%ae%9e%e9%99%85%e9%83%a8%e7%bd%b2%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b>#</a></h2><p>如果涉及业务逻辑触发 K8s 部署，可以参考如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Controller</span>) <span style=color:#a6e22e>installDeployment</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>MeshManager</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>v1</span>.<span style=color:#a6e22e>MeshManager</span>, <span style=color:#a6e22e>kubeClient</span> <span style=color:#a6e22e>kubernetes</span>.<span style=color:#a6e22e>Interface</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>deploy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>genDeployment</span>(<span style=color:#a6e22e>MeshManager</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>deploymentClient</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>kubeClient</span>.<span style=color:#a6e22e>AppsV1</span>().<span style=color:#a6e22e>Deployments</span>(<span style=color:#a6e22e>namespace</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>oldDeploy</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>deploymentClient</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>deploy</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>metav1</span>.<span style=color:#a6e22e>GetOptions</span>{})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k8serrors</span>.<span style=color:#a6e22e>IsNotFound</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>deploymentClient</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>deploy</span>, <span style=color:#a6e22e>metav1</span>.<span style=color:#a6e22e>CreateOptions</span>{})
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;get deployment failed: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newDeploy</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>oldDeploy</span>.<span style=color:#a6e22e>DeepCopy</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newDeploy</span>.<span style=color:#a6e22e>Labels</span> = <span style=color:#a6e22e>deploy</span>.<span style=color:#a6e22e>Labels</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newDeploy</span>.<span style=color:#a6e22e>Spec</span> = <span style=color:#a6e22e>deploy</span>.<span style=color:#a6e22e>Spec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 保留部分原有属性</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>oldDeploy</span>.<span style=color:#a6e22e>Spec</span>.<span style=color:#a6e22e>Template</span>.<span style=color:#a6e22e>Spec</span>.<span style=color:#a6e22e>Containers</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>newDeploy</span>.<span style=color:#a6e22e>Spec</span>.<span style=color:#a6e22e>Template</span>.<span style=color:#a6e22e>Spec</span>.<span style=color:#a6e22e>Containers</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Resources</span> = <span style=color:#a6e22e>oldDeploy</span>.<span style=color:#a6e22e>Spec</span>.<span style=color:#a6e22e>Template</span>.<span style=color:#a6e22e>Spec</span>.<span style=color:#a6e22e>Containers</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Resources</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>deploymentClient</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>newDeploy</span>, <span style=color:#a6e22e>metav1</span>.<span style=color:#a6e22e>UpdateOptions</span>{})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=4-文档中的典型-yaml-示例>4. 文档中的典型 YAML 示例
<a class=anchor href=#4-%e6%96%87%e6%a1%a3%e4%b8%ad%e7%9a%84%e5%85%b8%e5%9e%8b-yaml-%e7%a4%ba%e4%be%8b>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1beta2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:latest</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><hr><h2 id=总结流程>总结流程
<a class=anchor href=#%e6%80%bb%e7%bb%93%e6%b5%81%e7%a8%8b>#</a></h2><ol><li><strong>表单填写</strong>（前端收集数据并生成 Deployment YAML/JSON）。</li><li><strong>前端校验并提交</strong>（如 YAML 校验、调用 RESTful API）。</li><li><strong>后端处理</strong>（代理请求到 K8s API Server，创建/更新 Deployment）。</li><li><strong>K8s 集群中完成部署</strong>。</li></ol><p>如需某一部分的详细源码实现可继续追问。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#前端填写的deployment的表单怎么变为后端deployment的yaml以及如何被部署到k8s集群的>前端填写的deployment的表单怎么变为后端deployment的yaml，以及如何被部署到k8s集群的</a></li><li><a href=#1-前端表单--deployment-配置数据>1️⃣ 前端表单 → Deployment 配置数据</a></li><li><a href=#2-后端--转换为-k8s-yamlmanifest>2️⃣ 后端 → 转换为 K8s YAML/Manifest</a></li><li><a href=#3-后端--部署到-k8s-集群>3️⃣ 后端 → 部署到 K8s 集群</a><ul><li><a href=#方式-a调用-kubectl-apply>方式 A：调用 <code>kubectl apply</code></a></li><li><a href=#方式-b直接调用-kubernetes-api>方式 B：直接调用 Kubernetes API</a></li><li><a href=#方式-c用官方-sdk>方式 C：用官方 SDK</a></li></ul></li><li><a href=#4-整体流程总结>4️⃣ 整体流程总结</a><ul><li><a href=#1-前端表单转-deployment-的-yaml>1. 前端表单转 deployment 的 YAML</a></li><li><a href=#2-yaml-被部署到-k8s-集群>2. YAML 被部署到 K8s 集群</a></li></ul></li><li><a href=#1-核心功能概览>1️⃣ 核心功能概览</a></li><li><a href=#2-前端表单---yaml-的转换>2️⃣ 前端表单 -> YAML 的转换</a></li><li><a href=#3-用户点击应用部署按钮的流程>3️⃣ 用户点击“应用部署”按钮的流程</a></li><li><a href=#4-submitsuccess---调用后端-api>4️⃣ <code>submitSuccess</code> -> 调用后端 API</a></li><li><a href=#5-调用链总结表单到-yaml-到部署>5️⃣ 调用链总结（表单到 YAML 到部署）</a></li><li><a href=#1-k8scontext-接口><strong>1️⃣ K8sContext 接口</strong></a></li><li><a href=#2-表单--yaml--创建应用><strong>2️⃣ 表单 → YAML → 创建应用</strong></a></li><li><a href=#3-获取应用资源信息><strong>3️⃣ 获取应用资源信息</strong></a></li><li><a href=#4-pause--start-应用><strong>4️⃣ Pause / Start 应用</strong></a></li><li><a href=#5-更新应用资源><strong>5️⃣ 更新应用资源</strong></a></li><li><a href=#6-删除应用><strong>6️⃣ 删除应用</strong></a></li><li><a href=#7-总结表单到-yaml-调用链><strong>7️⃣ 总结表单到 YAML 调用链</strong></a><ul><li><a href=#-解释图中各部分>✅ 解释图中各部分</a></li><li><a href=#-特点>🔹 特点</a></li></ul></li><li><a href=#-整体思路>🔑 整体思路</a></li><li><a href=#-核心函数解析>📌 核心函数解析</a><ul><li><a href=#1-json2deploycr>1. <code>json2DeployCr</code></a></li><li><a href=#2-json2service>2. <code>json2Service</code></a></li><li><a href=#3-json2ingress>3. <code>json2Ingress</code></a></li><li><a href=#4-json2configmap>4. <code>json2ConfigMap</code></a></li><li><a href=#5-json2secret>5. <code>json2Secret</code></a></li><li><a href=#6-json2hpa>6. <code>json2HPA</code></a></li><li><a href=#7-yamlstring2objects>7. <code>yamlString2Objects</code></a></li></ul></li><li><a href=#-整体流程图>📊 整体流程图</a></li><li><a href=#-总结一句话>✅ 总结一句话</a></li><li><a href=#1-kubernetes-客户端初始化>1. <strong>Kubernetes 客户端初始化</strong></a></li><li><a href=#2-判断是否在集群内部运行>2. <strong>判断是否在集群内部运行</strong></a></li><li><a href=#3-加载-kubeconfig>3. <strong>加载 kubeconfig</strong></a></li><li><a href=#4-创建-yaml-到-k8s>4. <strong>创建 YAML 到 K8s</strong></a></li><li><a href=#5-更新替换-yaml-到-k8s>5. <strong>更新/替换 YAML 到 K8s</strong></a></li><li><a href=#6-获取用户配额>6. <strong>获取用户配额</strong></a></li><li><a href=#7-获取用户余额>7. <strong>获取用户余额</strong></a></li><li><a href=#8-封装统一的-k8s-操作入口>8. <strong>封装统一的 K8s 操作入口</strong></a></li><li><a href=#-前后端流程串起来>🔗 前后端流程串起来</a></li><li><a href=#总结一句话>总结一句话</a></li><li><a href=#kubesphere-的前端填写-deployment-表单后核心流程如下>KubeSphere 的前端填写 Deployment 表单后，核心流程如下：</a></li><li><a href=#1-前端表单如何转为-deployment-的-yaml>1. 前端表单如何转为 Deployment 的 YAML</a></li><li><a href=#2-如何被部署到-k8s-集群>2. 如何被部署到 K8s 集群</a><ul><li><a href=#21-接收并-apply-资源对象>2.1 接收并 apply 资源对象</a></li><li><a href=#22-典型调用链>2.2 典型调用链</a></li></ul></li><li><a href=#相关代码参考>相关代码参考</a></li><li><a href=#1-核心结构>1️⃣ 核心结构</a></li><li><a href=#2-核心方法addmemberclusterresource>2️⃣ 核心方法：<code>addMemberClusterResource</code></a><ul><li><a href=#-做了什么>🔹 做了什么</a></li></ul></li><li><a href=#3-validatememberclusterconfiguration>3️⃣ <code>validateMemberClusterConfiguration</code></a></li><li><a href=#4-总结表单字段到-deployment-映射>4️⃣ 总结：表单字段到 Deployment 映射</a></li><li><a href=#1-核心结构-1>1️⃣ 核心结构</a></li><li><a href=#2-install--upgrade--uninstall>2️⃣ Install / Upgrade / Uninstall</a><ul><li><a href=#install>Install</a></li><li><a href=#upgrade>Upgrade</a></li><li><a href=#uninstall>Uninstall</a></li></ul></li><li><a href=#3-核心方法forapply>3️⃣ 核心方法：ForApply</a><ul><li><a href=#核心步骤>核心步骤：</a></li></ul></li><li><a href=#4-总结逻辑前端表单到-k8s-资源>4️⃣ 总结逻辑（前端表单到 K8s 资源）</a></li><li><a href=#1-前端如何将表单变为-deployment-的-yaml>1. 前端如何将表单变为 Deployment 的 YAML</a></li><li><a href=#2-如何被部署到-k8s-集群-1>2. 如何被部署到 K8s 集群</a></li><li><a href=#3-服务端go侧实际部署代码示例>3. 服务端（Go）侧实际部署代码示例</a></li><li><a href=#4-文档中的典型-yaml-示例>4. 文档中的典型 YAML 示例</a></li><li><a href=#总结流程>总结流程</a></li></ul></nav></div></aside></main></body></html>