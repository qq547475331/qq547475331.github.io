<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='/*
Copyright 2015 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scheduler

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	v1 "k8s.io/api/core/v1"
	utilnet "k8s.io/apimachinery/pkg/util/net"
	"k8s.io/apimachinery/pkg/util/sets"
	restclient "k8s.io/client-go/rest"
	extenderv1 "k8s.io/kube-scheduler/extender/v1"
	schedulerapi "k8s.io/kubernetes/pkg/scheduler/apis/config"
	"k8s.io/kubernetes/pkg/scheduler/framework"
)

const (
	// DefaultExtenderTimeout defines the default extender timeout in second.
	DefaultExtenderTimeout = 5 * time.Second
)

// HTTPExtender implements the Extender interface.
type HTTPExtender struct {
	extenderURL      string
	preemptVerb      string
	filterVerb       string
	prioritizeVerb   string
	bindVerb         string
	weight           int64
	client           *http.Client
	nodeCacheCapable bool
	managedResources sets.Set[string]
	ignorable        bool
}

//这段代码定义了一个名为HTTPExtender的结构体，它实现了Extender接口。
//HTTPExtender表示一个HTTP扩展器，用于扩展Kubernetes调度器的功能。
//它通过发送HTTP请求与Kubernetes调度器进行交互，以实现自定义的调度逻辑。
//该结构体包含以下字段：  - extenderURL：扩展器的URL，用于向扩展器发送HTTP请求。
//- preemptVerb：抢占操作的动词，表示扩展器在抢占过程中执行的操作。
//- filterVerb：过滤操作的动词，表示扩展器在过滤节点时执行的操作。
//- prioritizeVerb：优先级排序操作的动词，表示扩展器在对节点进行优先级排序时执行的操作。
//- bindVerb：绑定操作的动词，表示扩展器在绑定Pod到节点时执行的操作。
//- weight：扩展器的权重，用于在优先级排序时对多个扩展器的结果进行加权计算。
//- client：用于发送HTTP请求的HTTP客户端。
//- nodeCacheCapable：表示扩展器是否支持节点缓存。
//如果为true，调度器会将节点信息缓存在本地，以减少对扩展器的请求次数。
//- managedResources：表示扩展器管理的资源集合。
//调度器会将这些资源的调度委托给扩展器处理。
//- ignorable：表示扩展器是否可以被忽略。如果为true，当扩展器出现错误时，调度器可以忽略该错误并继续进行调度。
//此外，代码还定义了一个常量DefaultExtenderTimeout，它表示默认的扩展器超时时间，单位为秒。

func makeTransport(config *schedulerapi.Extender) (http.RoundTripper, error) {
	var cfg restclient.Config
	if config.TLSConfig != nil {
		cfg.TLSClientConfig.Insecure = config.TLSConfig.Insecure
		cfg.TLSClientConfig.ServerName = config.TLSConfig.ServerName
		cfg.TLSClientConfig.CertFile = config.TLSConfig.CertFile
		cfg.TLSClientConfig.KeyFile = config.TLSConfig.KeyFile
		cfg.TLSClientConfig.CAFile = config.TLSConfig.CAFile
		cfg.TLSClientConfig.CertData = config.TLSConfig.CertData
		cfg.TLSClientConfig.KeyData = config.TLSConfig.KeyData
		cfg.TLSClientConfig.CAData = config.TLSConfig.CAData
	}
	if config.EnableHTTPS {
		hasCA := len(cfg.CAFile) > 0 || len(cfg.CAData) > 0
		if !hasCA {
			cfg.Insecure = true
		}
	}
	tlsConfig, err := restclient.TLSConfigFor(&amp;cfg)
	if err != nil {
		return nil, err
	}
	if tlsConfig != nil {
		return utilnet.SetTransportDefaults(&amp;http.Transport{
			TLSClientConfig: tlsConfig,
		}), nil
	}
	return utilnet.SetTransportDefaults(&amp;http.Transport{}), nil
}

//该函数根据给定的schedulerapi.Extender配置创建一个http.RoundTripper传输对象。
//它首先将config.TLSConfig中的配置项复制到cfg.TLSClientConfig中，然后根据config.EnableHTTPS的值设置cfg.Insecure。
//接下来，它通过调用restclient.TLSConfigFor(&amp;cfg)来获取TLS配置，并将其设置到http.Transport中。
//最后，返回设置了默认值的http.Transport对象。如果在过程中出现错误，则返回错误。

// NewHTTPExtender creates an HTTPExtender object.
func NewHTTPExtender(config *schedulerapi.Extender) (framework.Extender, error) {
	if config.HTTPTimeout.Duration.Nanoseconds() == 0 {
		config.HTTPTimeout.Duration = time.Duration(DefaultExtenderTimeout)
	}

	transport, err := makeTransport(config)
	if err != nil {
		return nil, err
	}
	client := &amp;http.Client{
		Transport: transport,
		Timeout:   config.HTTPTimeout.Duration,
	}
	managedResources := sets.New[string]()
	for _, r := range config.ManagedResources {
		managedResources.Insert(string(r.Name))
	}
	return &amp;HTTPExtender{
		extenderURL:      config.URLPrefix,
		preemptVerb:      config.PreemptVerb,
		filterVerb:       config.FilterVerb,
		prioritizeVerb:   config.PrioritizeVerb,
		bindVerb:         config.BindVerb,
		weight:           config.Weight,
		client:           client,
		nodeCacheCapable: config.NodeCacheCapable,
		managedResources: managedResources,
		ignorable:        config.Ignorable,
	}, nil
}

//该函数用于创建一个HTTPExtender对象。它根据传入的config参数初始化HTTPExtender对象的属性，并返回该对象。
//其中，makeTransport函数用于创建一个http.Transport对象，http.Client对象则使用该Transport对象以及config参数中的HTTP超时时间进行初始化。
//此外，该函数还对config.ManagedResources进行遍历，将其中的Name字段转换为string类型，并插入到managedResources集合中。
//最后，该函数返回一个初始化完成的HTTPExtender对象。

// Name returns extenderURL to identify the extender.
func (h *HTTPExtender) Name() string {
	return h.extenderURL
}

// IsIgnorable returns true indicates scheduling should not fail when this extender
// is unavailable
func (h *HTTPExtender) IsIgnorable() bool {
	return h.ignorable
}

// SupportsPreemption returns true if an extender supports preemption.
// An extender should have preempt verb defined and enabled its own node cache.
func (h *HTTPExtender) SupportsPreemption() bool {
	return len(h.preemptVerb) > 0
}

//这段代码定义了一个名为HTTPExtender的结构体及其三个方法。
//1. Name()方法返回extenderURL，用于标识扩展程序。
//2. IsIgnorable()方法返回一个布尔值，指示当此扩展程序不可用时，调度是否不应失败。如果ignorable字段为true，则返回true。
//3. SupportsPreemption()方法返回一个布尔值，表示扩展程序是否支持抢占。
//如果preemptVerb字段的长度大于0，则返回true。
//这意味着扩展程序应该定义抢占动词并启用自己的节点缓存。

// ProcessPreemption returns filtered candidate nodes and victims after running preemption logic in extender.
func (h *HTTPExtender) ProcessPreemption(
	pod *v1.Pod,
	nodeNameToVictims map[string]*extenderv1.Victims,
	nodeInfos framework.NodeInfoLister,
) (map[string]*extenderv1.Victims, error) {
	var (
		result extenderv1.ExtenderPreemptionResult
		args   *extenderv1.ExtenderPreemptionArgs
	)

	if !h.SupportsPreemption() {
		return nil, fmt.Errorf("preempt verb is not defined for extender %v but run into ProcessPreemption", h.extenderURL)
	}

	if h.nodeCacheCapable {
		// If extender has cached node info, pass NodeNameToMetaVictims in args.
		nodeNameToMetaVictims := convertToMetaVictims(nodeNameToVictims)
		args = &amp;extenderv1.ExtenderPreemptionArgs{
			Pod:                   pod,
			NodeNameToMetaVictims: nodeNameToMetaVictims,
		}
	} else {
		args = &amp;extenderv1.ExtenderPreemptionArgs{
			Pod:               pod,
			NodeNameToVictims: nodeNameToVictims,
		}
	}

	if err := h.send(h.preemptVerb, args, &amp;result); err != nil {
		return nil, err
	}

	// Extender will always return NodeNameToMetaVictims.
	// So let&#39;s convert it to NodeNameToVictims by using <nodeInfos>.
	newNodeNameToVictims, err := h.convertToVictims(result.NodeNameToMetaVictims, nodeInfos)
	if err != nil {
		return nil, err
	}
	// Do not override <nodeNameToVictims>.
	return newNodeNameToVictims, nil
}

//该函数是用于处理抢占逻辑的HTTP扩展器方法。
//它根据传入的Pod和节点信息，通过调用扩展器的抢占逻辑，返回过滤后的候选节点和受害者。
//- 首先，函数检查扩展器是否支持抢占。如果不支持，则返回错误。
//- 接下来，根据扩展器是否具有缓存的节点信息，构建不同的ExtenderPreemptionArgs对象，其中包含Pod和节点信息。
//- 然后，通过调用扩展器的指定动词（preempt），将ExtenderPreemptionArgs发送给扩展器，并将结果存储在ExtenderPreemptionResult中。
//- 最后，将扩展器返回的NodeNameToMetaVictims转换为NodeNameToVictims，并返回新的NodeNameToVictims对象。
//该函数返回的地图map[string]*extenderv1.Victims表示了每个节点的受害者列表，其中每个受害者包含了被抢占的Pod列表。

// convertToVictims converts "nodeNameToMetaVictims" from object identifiers,
// such as UIDs and names, to object pointers.
func (h *HTTPExtender) convertToVictims(
	nodeNameToMetaVictims map[string]*extenderv1.MetaVictims,
	nodeInfos framework.NodeInfoLister,
) (map[string]*extenderv1.Victims, error) {
	nodeNameToVictims := map[string]*extenderv1.Victims{}
	for nodeName, metaVictims := range nodeNameToMetaVictims {
		nodeInfo, err := nodeInfos.Get(nodeName)
		if err != nil {
			return nil, err
		}
		victims := &amp;extenderv1.Victims{
			Pods:             []*v1.Pod{},
			NumPDBViolations: metaVictims.NumPDBViolations,
		}
		for _, metaPod := range metaVictims.Pods {
			pod, err := h.convertPodUIDToPod(metaPod, nodeInfo)
			if err != nil {
				return nil, err
			}
			victims.Pods = append(victims.Pods, pod)
		}
		nodeNameToVictims[nodeName] = victims
	}
	return nodeNameToVictims, nil
}

//该函数是一个Go语言函数，它将从对象标识符（如UID和名称）组成的"nodeNameToMetaVictims"映射转换为对象指针组成的"nodeNameToVictims"映射。
//该函数使用给定的节点信息获取节点名称对应的受害者信息，并将其转换为包含Pod信息和PDB违规数量的Victims对象。
//具体来说，它遍历输入的映射，获取每个节点的MetaVictims对象，并通过节点信息获取节点的Pod信息。
//然后，它将MetaPod对象转换为Pod对象，并将其添加到Victims对象的Pod列表中。
//最后，它将转换后的Victims对象添加到输出映射中，并返回该映射。如果在转换过程中发生错误，函数将返回错误。

// convertPodUIDToPod returns v1.Pod object for given MetaPod and node info.
// The v1.Pod object is restored by nodeInfo.Pods().
// It returns an error if there&#39;s cache inconsistency between default scheduler
// and extender, i.e. when the pod is not found in nodeInfo.Pods.
func (h *HTTPExtender) convertPodUIDToPod(
	metaPod *extenderv1.MetaPod,
	nodeInfo *framework.NodeInfo) (*v1.Pod, error) {
	for _, p := range nodeInfo.Pods {
		if string(p.Pod.UID) == metaPod.UID {
			return p.Pod, nil
		}
	}
	return nil, fmt.Errorf("extender: %v claims to preempt pod (UID: %v) on node: %v, but the pod is not found on that node",
		h.extenderURL, metaPod, nodeInfo.Node().Name)
}

// convertToMetaVictims converts from struct type to meta types.
func convertToMetaVictims(
	nodeNameToVictims map[string]*extenderv1.Victims,
) map[string]*extenderv1.MetaVictims {
	nodeNameToMetaVictims := map[string]*extenderv1.MetaVictims{}
	for node, victims := range nodeNameToVictims {
		metaVictims := &amp;extenderv1.MetaVictims{
			Pods:             []*extenderv1.MetaPod{},
			NumPDBViolations: victims.NumPDBViolations,
		}
		for _, pod := range victims.Pods {
			metaPod := &amp;extenderv1.MetaPod{
				UID: string(pod.UID),
			}
			metaVictims.Pods = append(metaVictims.Pods, metaPod)
		}
		nodeNameToMetaVictims[node] = metaVictims
	}
	return nodeNameToMetaVictims
}

//该函数的功能是将从结构体类型转换为元类型。
//它接收一个nodeNameToVictims参数，该参数是一个map，其中键是节点名称，值是*extenderv1.Victims类型的指针。
//函数创建一个空的nodeNameToMetaVictims映射，然后遍历nodeNameToVictims中的每个元素。
//对于每个节点，它创建一个新的extenderv1.MetaVictims实例，并将NumPDBViolations从旧的victims实例复制到新的metaVictims实例中。
//然后，它遍历旧的victims实例中的每个Pod，为每个Pod创建一个新的extenderv1.MetaPod实例，并将UID从旧的pod实例复制到新的metaPod实例中。
//最后，它将新的metaVictims实例添加到nodeNameToMetaVictims映射中，并返回该映射。

// Filter based on extender implemented predicate functions. The filtered list is
// expected to be a subset of the supplied list; otherwise the function returns an error.
// The failedNodes and failedAndUnresolvableNodes optionally contains the list
// of failed nodes and failure reasons, except nodes in the latter are
// unresolvable.
func (h *HTTPExtender) Filter(
	pod *v1.Pod,
	nodes []*framework.NodeInfo,
) (filteredList []*framework.NodeInfo, failedNodes, failedAndUnresolvableNodes extenderv1.FailedNodesMap, err error) {
	var (
		result     extenderv1.ExtenderFilterResult
		nodeList   *v1.NodeList
		nodeNames  *[]string
		nodeResult []*framework.NodeInfo
		args       *extenderv1.ExtenderArgs
	)
	fromNodeName := make(map[string]*framework.NodeInfo)
	for _, n := range nodes {
		fromNodeName[n.Node().Name] = n
	}

	if h.filterVerb == "" {
		return nodes, extenderv1.FailedNodesMap{}, extenderv1.FailedNodesMap{}, nil
	}

	if h.nodeCacheCapable {
		nodeNameSlice := make([]string, 0, len(nodes))
		for _, node := range nodes {
			nodeNameSlice = append(nodeNameSlice, node.Node().Name)
		}
		nodeNames = &amp;nodeNameSlice
	} else {
		nodeList = &amp;v1.NodeList{}
		for _, node := range nodes {
			nodeList.Items = append(nodeList.Items, *node.Node())
		}
	}

	args = &amp;extenderv1.ExtenderArgs{
		Pod:       pod,
		Nodes:     nodeList,
		NodeNames: nodeNames,
	}

	if err := h.send(h.filterVerb, args, &amp;result); err != nil {
		return nil, nil, nil, err
	}
	if result.Error != "" {
		return nil, nil, nil, fmt.Errorf(result.Error)
	}

	if h.nodeCacheCapable && result.NodeNames != nil {
		nodeResult = make([]*framework.NodeInfo, len(*result.NodeNames))
		for i, nodeName := range *result.NodeNames {
			if n, ok := fromNodeName[nodeName]; ok {
				nodeResult[i] = n
			} else {
				return nil, nil, nil, fmt.Errorf(
					"extender %q claims a filtered node %q which is not found in the input node list",
					h.extenderURL, nodeName)
			}
		}
	} else if result.Nodes != nil {
		nodeResult = make([]*framework.NodeInfo, len(result.Nodes.Items))
		for i := range result.Nodes.Items {
			nodeResult[i] = framework.NewNodeInfo()
			nodeResult[i].SetNode(&amp;result.Nodes.Items[i])
		}
	}

	return nodeResult, result.FailedNodes, result.FailedAndUnresolvableNodes, nil
}

//该函数是一个过滤函数，基于扩展器实现的谓词函数对节点进行过滤。
//函数的输入是一个Pod对象和一个节点信息数组，输出是过滤后的节点信息数组、失败的节点信息映射、不可解析的节点信息映射和错误信息。
//函数首先通过遍历输入节点信息数组，创建一个从节点名称到节点信息的映射。
//然后根据扩展器的过滤动词，决定使用节点名称列表还是节点列表作为输入参数，构建ExtenderArgs对象，并调用扩展器的过滤方法。
//如果过滤方法返回错误，函数直接返回错误。如果过滤方法成功，函数根据返回结果构建过滤后的节点信息数组，并返回。
//如果扩展器声明了一个节点被过滤，但是在输入节点信息数组中找不到该节点，则函数返回错误。
//如果扩展器返回的结果中包含失败的节点和不可解析的节点信息，则将其添加到相应的映射中。
//总之，该函数通过调用扩展器的过滤方法，对节点进行过滤，并返回过滤后的节点信息数组和相关错误信息。

// Prioritize based on extender implemented priority functions. Weight*priority is added
// up for each such priority function. The returned score is added to the score computed
// by Kubernetes scheduler. The total score is used to do the host selection.
func (h *HTTPExtender) Prioritize(pod *v1.Pod, nodes []*framework.NodeInfo) (*extenderv1.HostPriorityList, int64, error) {
	var (
		result    extenderv1.HostPriorityList
		nodeList  *v1.NodeList
		nodeNames *[]string
		args      *extenderv1.ExtenderArgs
	)

	if h.prioritizeVerb == "" {
		result := extenderv1.HostPriorityList{}
		for _, node := range nodes {
			result = append(result, extenderv1.HostPriority{Host: node.Node().Name, Score: 0})
		}
		return &amp;result, 0, nil
	}

	if h.nodeCacheCapable {
		nodeNameSlice := make([]string, 0, len(nodes))
		for _, node := range nodes {
			nodeNameSlice = append(nodeNameSlice, node.Node().Name)
		}
		nodeNames = &amp;nodeNameSlice
	} else {
		nodeList = &amp;v1.NodeList{}
		for _, node := range nodes {
			nodeList.Items = append(nodeList.Items, *node.Node())
		}
	}

	args = &amp;extenderv1.ExtenderArgs{
		Pod:       pod,
		Nodes:     nodeList,
		NodeNames: nodeNames,
	}

	if err := h.send(h.prioritizeVerb, args, &amp;result); err != nil {
		return nil, 0, err
	}
	return &amp;result, h.weight, nil
}

//该函数是一个Go语言函数，定义在HTTPExtender结构体中，用于根据扩展程序实现的优先级函数对节点进行优先级排序。
//该函数将权重乘以优先级的总和添加到每个此类优先级函数中。
//返回的分数将添加到Kubernetes调度程序计算的分数中。总
//分数用于进行主机选择。
//函数接受一个*v1.Pod类型的pod参数，一个[]*framework.NodeInfo类型的nodes参数，以及一个error类型的结果参数。
//函数首先定义了一些局部变量，包括一个extenderv1.HostPriorityList类型的result变量，
//一个*v1.NodeList类型的nodeList变量，一个*[]string类型的nodeNames变量，以及一个*extenderv1.ExtenderArgs类型的args变量。
//如果h.prioritizeVerb为空字符串，则将每个节点的分数设置为0，并返回结果。
//如果h.nodeCacheCapable为true，则将节点名称添加到nodeNameSlice切片中，并将其赋值给nodeNames变量。
//否则，将节点对象追加到nodeList的Items字段中。
//接下来，将pod、nodeList和nodeNames赋值给args的相应字段。
//最后，调用h.send方法，将h.prioritizeVerb、args和&amp;result作为参数传递，并检查是否有错误发生。
//如果有错误，则返回错误。否则，返回结果和权重。

// Bind delegates the action of binding a pod to a node to the extender.
func (h *HTTPExtender) Bind(binding *v1.Binding) error {
	var result extenderv1.ExtenderBindingResult
	if !h.IsBinder() {
		// This shouldn&#39;t happen as this extender wouldn&#39;t have become a Binder.
		return fmt.Errorf("unexpected empty bindVerb in extender")
	}
	req := &amp;extenderv1.ExtenderBindingArgs{
		PodName:      binding.Name,
		PodNamespace: binding.Namespace,
		PodUID:       binding.UID,
		Node:         binding.Target.Name,
	}
	if err := h.send(h.bindVerb, req, &amp;result); err != nil {
		return err
	}
	if result.Error != "" {
		return fmt.Errorf(result.Error)
	}
	return nil
}

// IsBinder returns whether this extender is configured for the Bind method.
func (h *HTTPExtender) IsBinder() bool {
	return h.bindVerb != ""
}

// IsPrioritizer returns whether this extender is configured for the Prioritize method.
func (h *HTTPExtender) IsPrioritizer() bool {
	return h.prioritizeVerb != ""
}

// IsFilter returns whether this extender is configured for the Filter method.
func (h *HTTPExtender) IsFilter() bool {
	return h.filterVerb != ""
}

//这段代码定义了一个名为HTTPExtender的结构体及其相关方法。
//这个结构体用于委托将Pod绑定到节点的操作给扩展器。
//- Bind方法用于将Pod绑定到节点
//。它首先检查当前扩展器是否配置为绑定扩展器，如果不是，则返回错误。
//然后创建一个ExtenderBindingArgs请求，包含Pod的名称、命名空间、UID以及目标节点的名称，并通过调用send方法将请求发送给扩展器。
//如果发送请求或处理结果出现错误，则返回相应的错误。
//- IsBinder方法用于判断当前扩展器是否配置了绑定方法。如果bindVerb不为空，则表示配置了绑定方法。
//- IsPrioritizer方法用于判断当前扩展器是否配置了优先级方法。如果prioritizeVerb不为空，则表示配置了优先级方法。
//- IsFilter方法用于判断当前扩展器是否配置了过滤方法。如果filterVerb不为空，则表示配置了过滤方法。

// Helper function to send messages to the extender
func (h *HTTPExtender) send(action string, args interface{}, result interface{}) error {
	out, err := json.Marshal(args)
	if err != nil {
		return err
	}

	url := strings.TrimRight(h.extenderURL, "/") + "/" + action

	req, err := http.NewRequest("POST", url, bytes.NewReader(out))
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := h.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed %v with extender at URL %v, code %v", action, url, resp.StatusCode)
	}

	return json.NewDecoder(resp.Body).Decode(result)
}

//该函数是一个发送消息给扩展程序的辅助函数。
//它使用HTTP POST请求将动作、参数和结果发送到指定的扩展程序URL。
//具体步骤如下：
//1. 将参数args转换为JSON格式。
//2. 构建请求URL，通过拼接扩展程序URL和动作字符串。
//3. 创建HTTP POST请求，设置请求头的Content-Type为application/json，并将JSON数据作为请求体。
//4. 发送请求并获取响应。
//5. 检查响应状态码，如果不是200 OK，则返回错误。
//6. 将响应体解码为结果参数result。  如果在上述过程中发生错误，则返回相应的错误。

// IsInterested returns true if at least one extended resource requested by
// this pod is managed by this extender.
func (h *HTTPExtender) IsInterested(pod *v1.Pod) bool {
	if h.managedResources.Len() == 0 {
		return true
	}
	if h.hasManagedResources(pod.Spec.Containers) {
		return true
	}
	if h.hasManagedResources(pod.Spec.InitContainers) {
		return true
	}
	return false
}

//该函数是一个Go语言函数，名为IsInterested，它属于HTTPExtender类型。
//函数用于判断给定的Pod是否至少请求了一个由该extender管理的扩展资源。
//函数返回一个布尔值，如果Pod请求了至少一个由该extender管理的扩展资源，则返回true，否则返回false。
//函数主要包含以下两个步骤：
//1. 首先，函数检查HTTPExtender的managedResources列表是否为空。如果为空，则表示该extender管理所有资源，因此直接返回true。
//2. 如果managedResources不为空，函数会分别检查Pod的Spec.Containers和Spec.InitContainers字段中是否包含由该extender管理的扩展资源。
//如果存在至少一个由extender管理的扩展资源，则返回true。如果两个字段中都不包含由extender管理的扩展资源，则返回false。
//总结：该函数用于判断给定的Pod是否请求了由该extender管理的扩展资源，根据管理资源列表和Pod的容器配置进行匹配判断。

func (h *HTTPExtender) hasManagedResources(containers []v1.Container) bool {
	for i := range containers {
		container := &amp;containers[i]
		for resourceName := range container.Resources.Requests {
			if h.managedResources.Has(string(resourceName)) {
				return true
			}
		}
		for resourceName := range container.Resources.Limits {
			if h.managedResources.Has(string(resourceName)) {
				return true
			}
		}
	}
	return false
}

//该函数用于判断给定的容器列表中是否包含有管理资源。
//具体实现为遍历容器列表，再遍历容器的资源请求和限制，
//若存在管理资源则返回true，否则返回false。
'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="K8S调度器 extender.go 源码解读 2024-04-09 11:45:59.666"><meta property="og:description" content='/* Copyright 2015 The Kubernetes Authors. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ package scheduler import ( "bytes" "encoding/json" "fmt" "net/http" "strings" "time" v1 "k8s.io/api/core/v1" utilnet "k8s.io/apimachinery/pkg/util/net" "k8s.io/apimachinery/pkg/util/sets" restclient "k8s.io/client-go/rest" extenderv1 "k8s.io/kube-scheduler/extender/v1" schedulerapi "k8s.io/kubernetes/pkg/scheduler/apis/config" "k8s.io/kubernetes/pkg/scheduler/framework" ) const ( // DefaultExtenderTimeout defines the default extender timeout in second. DefaultExtenderTimeout = 5 * time.Second ) // HTTPExtender implements the Extender interface. type HTTPExtender struct { extenderURL string preemptVerb string filterVerb string prioritizeVerb string bindVerb string weight int64 client *http.Client nodeCacheCapable bool managedResources sets.Set[string] ignorable bool } //这段代码定义了一个名为HTTPExtender的结构体，它实现了Extender接口。 //HTTPExtender表示一个HTTP扩展器，用于扩展Kubernetes调度器的功能。 //它通过发送HTTP请求与Kubernetes调度器进行交互，以实现自定义的调度逻辑。 //该结构体包含以下字段： - extenderURL：扩展器的URL，用于向扩展器发送HTTP请求。 //- preemptVerb：抢占操作的动词，表示扩展器在抢占过程中执行的操作。 //- filterVerb：过滤操作的动词，表示扩展器在过滤节点时执行的操作。 //- prioritizeVerb：优先级排序操作的动词，表示扩展器在对节点进行优先级排序时执行的操作。 //- bindVerb：绑定操作的动词，表示扩展器在绑定Pod到节点时执行的操作。 //- weight：扩展器的权重，用于在优先级排序时对多个扩展器的结果进行加权计算。 //- client：用于发送HTTP请求的HTTP客户端。 //- nodeCacheCapable：表示扩展器是否支持节点缓存。 //如果为true，调度器会将节点信息缓存在本地，以减少对扩展器的请求次数。 //- managedResources：表示扩展器管理的资源集合。 //调度器会将这些资源的调度委托给扩展器处理。 //- ignorable：表示扩展器是否可以被忽略。如果为true，当扩展器出现错误时，调度器可以忽略该错误并继续进行调度。 //此外，代码还定义了一个常量DefaultExtenderTimeout，它表示默认的扩展器超时时间，单位为秒。 func makeTransport(config *schedulerapi.Extender) (http.RoundTripper, error) { var cfg restclient.Config if config.TLSConfig != nil { cfg.TLSClientConfig.Insecure = config.TLSConfig.Insecure cfg.TLSClientConfig.ServerName = config.TLSConfig.ServerName cfg.TLSClientConfig.CertFile = config.TLSConfig.CertFile cfg.TLSClientConfig.KeyFile = config.TLSConfig.KeyFile cfg.TLSClientConfig.CAFile = config.TLSConfig.CAFile cfg.TLSClientConfig.CertData = config.TLSConfig.CertData cfg.TLSClientConfig.KeyData = config.TLSConfig.KeyData cfg.TLSClientConfig.CAData = config.TLSConfig.CAData } if config.EnableHTTPS { hasCA := len(cfg.CAFile) > 0 || len(cfg.CAData) > 0 if !hasCA { cfg.Insecure = true } } tlsConfig, err := restclient.TLSConfigFor(&amp;cfg) if err != nil { return nil, err } if tlsConfig != nil { return utilnet.SetTransportDefaults(&amp;http.Transport{ TLSClientConfig: tlsConfig, }), nil } return utilnet.SetTransportDefaults(&amp;http.Transport{}), nil } //该函数根据给定的schedulerapi.Extender配置创建一个http.RoundTripper传输对象。 //它首先将config.TLSConfig中的配置项复制到cfg.TLSClientConfig中，然后根据config.EnableHTTPS的值设置cfg.Insecure。 //接下来，它通过调用restclient.TLSConfigFor(&amp;cfg)来获取TLS配置，并将其设置到http.Transport中。 //最后，返回设置了默认值的http.Transport对象。如果在过程中出现错误，则返回错误。 // NewHTTPExtender creates an HTTPExtender object. func NewHTTPExtender(config *schedulerapi.Extender) (framework.Extender, error) { if config.HTTPTimeout.Duration.Nanoseconds() == 0 { config.HTTPTimeout.Duration = time.Duration(DefaultExtenderTimeout) } transport, err := makeTransport(config) if err != nil { return nil, err } client := &amp;http.Client{ Transport: transport, Timeout: config.HTTPTimeout.Duration, } managedResources := sets.New[string]() for _, r := range config.ManagedResources { managedResources.Insert(string(r.Name)) } return &amp;HTTPExtender{ extenderURL: config.URLPrefix, preemptVerb: config.PreemptVerb, filterVerb: config.FilterVerb, prioritizeVerb: config.PrioritizeVerb, bindVerb: config.BindVerb, weight: config.Weight, client: client, nodeCacheCapable: config.NodeCacheCapable, managedResources: managedResources, ignorable: config.Ignorable, }, nil } //该函数用于创建一个HTTPExtender对象。它根据传入的config参数初始化HTTPExtender对象的属性，并返回该对象。 //其中，makeTransport函数用于创建一个http.Transport对象，http.Client对象则使用该Transport对象以及config参数中的HTTP超时时间进行初始化。 //此外，该函数还对config.ManagedResources进行遍历，将其中的Name字段转换为string类型，并插入到managedResources集合中。 //最后，该函数返回一个初始化完成的HTTPExtender对象。 // Name returns extenderURL to identify the extender. func (h *HTTPExtender) Name() string { return h.extenderURL } // IsIgnorable returns true indicates scheduling should not fail when this extender // is unavailable func (h *HTTPExtender) IsIgnorable() bool { return h.ignorable } // SupportsPreemption returns true if an extender supports preemption. // An extender should have preempt verb defined and enabled its own node cache. func (h *HTTPExtender) SupportsPreemption() bool { return len(h.preemptVerb) > 0 } //这段代码定义了一个名为HTTPExtender的结构体及其三个方法。 //1. Name()方法返回extenderURL，用于标识扩展程序。 //2. IsIgnorable()方法返回一个布尔值，指示当此扩展程序不可用时，调度是否不应失败。如果ignorable字段为true，则返回true。 //3. SupportsPreemption()方法返回一个布尔值，表示扩展程序是否支持抢占。 //如果preemptVerb字段的长度大于0，则返回true。 //这意味着扩展程序应该定义抢占动词并启用自己的节点缓存。 // ProcessPreemption returns filtered candidate nodes and victims after running preemption logic in extender. func (h *HTTPExtender) ProcessPreemption( pod *v1.Pod, nodeNameToVictims map[string]*extenderv1.Victims, nodeInfos framework.NodeInfoLister, ) (map[string]*extenderv1.Victims, error) { var ( result extenderv1.ExtenderPreemptionResult args *extenderv1.ExtenderPreemptionArgs ) if !h.SupportsPreemption() { return nil, fmt.Errorf("preempt verb is not defined for extender %v but run into ProcessPreemption", h.extenderURL) } if h.nodeCacheCapable { // If extender has cached node info, pass NodeNameToMetaVictims in args. nodeNameToMetaVictims := convertToMetaVictims(nodeNameToVictims) args = &amp;extenderv1.ExtenderPreemptionArgs{ Pod: pod, NodeNameToMetaVictims: nodeNameToMetaVictims, } } else { args = &amp;extenderv1.ExtenderPreemptionArgs{ Pod: pod, NodeNameToVictims: nodeNameToVictims, } } if err := h.send(h.preemptVerb, args, &amp;result); err != nil { return nil, err } // Extender will always return NodeNameToMetaVictims. // So let&#39;s convert it to NodeNameToVictims by using <nodeInfos>. newNodeNameToVictims, err := h.convertToVictims(result.NodeNameToMetaVictims, nodeInfos) if err != nil { return nil, err } // Do not override <nodeNameToVictims>. return newNodeNameToVictims, nil } //该函数是用于处理抢占逻辑的HTTP扩展器方法。 //它根据传入的Pod和节点信息，通过调用扩展器的抢占逻辑，返回过滤后的候选节点和受害者。 //- 首先，函数检查扩展器是否支持抢占。如果不支持，则返回错误。 //- 接下来，根据扩展器是否具有缓存的节点信息，构建不同的ExtenderPreemptionArgs对象，其中包含Pod和节点信息。 //- 然后，通过调用扩展器的指定动词（preempt），将ExtenderPreemptionArgs发送给扩展器，并将结果存储在ExtenderPreemptionResult中。 //- 最后，将扩展器返回的NodeNameToMetaVictims转换为NodeNameToVictims，并返回新的NodeNameToVictims对象。 //该函数返回的地图map[string]*extenderv1.Victims表示了每个节点的受害者列表，其中每个受害者包含了被抢占的Pod列表。 // convertToVictims converts "nodeNameToMetaVictims" from object identifiers, // such as UIDs and names, to object pointers. func (h *HTTPExtender) convertToVictims( nodeNameToMetaVictims map[string]*extenderv1.MetaVictims, nodeInfos framework.NodeInfoLister, ) (map[string]*extenderv1.Victims, error) { nodeNameToVictims := map[string]*extenderv1.Victims{} for nodeName, metaVictims := range nodeNameToMetaVictims { nodeInfo, err := nodeInfos.Get(nodeName) if err != nil { return nil, err } victims := &amp;extenderv1.Victims{ Pods: []*v1.Pod{}, NumPDBViolations: metaVictims.NumPDBViolations, } for _, metaPod := range metaVictims.Pods { pod, err := h.convertPodUIDToPod(metaPod, nodeInfo) if err != nil { return nil, err } victims.Pods = append(victims.Pods, pod) } nodeNameToVictims[nodeName] = victims } return nodeNameToVictims, nil } //该函数是一个Go语言函数，它将从对象标识符（如UID和名称）组成的"nodeNameToMetaVictims"映射转换为对象指针组成的"nodeNameToVictims"映射。 //该函数使用给定的节点信息获取节点名称对应的受害者信息，并将其转换为包含Pod信息和PDB违规数量的Victims对象。 //具体来说，它遍历输入的映射，获取每个节点的MetaVictims对象，并通过节点信息获取节点的Pod信息。 //然后，它将MetaPod对象转换为Pod对象，并将其添加到Victims对象的Pod列表中。 //最后，它将转换后的Victims对象添加到输出映射中，并返回该映射。如果在转换过程中发生错误，函数将返回错误。 // convertPodUIDToPod returns v1.Pod object for given MetaPod and node info. // The v1.Pod object is restored by nodeInfo.Pods(). // It returns an error if there&#39;s cache inconsistency between default scheduler // and extender, i.e. when the pod is not found in nodeInfo.Pods. func (h *HTTPExtender) convertPodUIDToPod( metaPod *extenderv1.MetaPod, nodeInfo *framework.NodeInfo) (*v1.Pod, error) { for _, p := range nodeInfo.Pods { if string(p.Pod.UID) == metaPod.UID { return p.Pod, nil } } return nil, fmt.Errorf("extender: %v claims to preempt pod (UID: %v) on node: %v, but the pod is not found on that node", h.extenderURL, metaPod, nodeInfo.Node().Name) } // convertToMetaVictims converts from struct type to meta types. func convertToMetaVictims( nodeNameToVictims map[string]*extenderv1.Victims, ) map[string]*extenderv1.MetaVictims { nodeNameToMetaVictims := map[string]*extenderv1.MetaVictims{} for node, victims := range nodeNameToVictims { metaVictims := &amp;extenderv1.MetaVictims{ Pods: []*extenderv1.MetaPod{}, NumPDBViolations: victims.NumPDBViolations, } for _, pod := range victims.Pods { metaPod := &amp;extenderv1.MetaPod{ UID: string(pod.UID), } metaVictims.Pods = append(metaVictims.Pods, metaPod) } nodeNameToMetaVictims[node] = metaVictims } return nodeNameToMetaVictims } //该函数的功能是将从结构体类型转换为元类型。 //它接收一个nodeNameToVictims参数，该参数是一个map，其中键是节点名称，值是*extenderv1.Victims类型的指针。 //函数创建一个空的nodeNameToMetaVictims映射，然后遍历nodeNameToVictims中的每个元素。 //对于每个节点，它创建一个新的extenderv1.MetaVictims实例，并将NumPDBViolations从旧的victims实例复制到新的metaVictims实例中。 //然后，它遍历旧的victims实例中的每个Pod，为每个Pod创建一个新的extenderv1.MetaPod实例，并将UID从旧的pod实例复制到新的metaPod实例中。 //最后，它将新的metaVictims实例添加到nodeNameToMetaVictims映射中，并返回该映射。 // Filter based on extender implemented predicate functions. The filtered list is // expected to be a subset of the supplied list; otherwise the function returns an error. // The failedNodes and failedAndUnresolvableNodes optionally contains the list // of failed nodes and failure reasons, except nodes in the latter are // unresolvable. func (h *HTTPExtender) Filter( pod *v1.Pod, nodes []*framework.NodeInfo, ) (filteredList []*framework.NodeInfo, failedNodes, failedAndUnresolvableNodes extenderv1.FailedNodesMap, err error) { var ( result extenderv1.ExtenderFilterResult nodeList *v1.NodeList nodeNames *[]string nodeResult []*framework.NodeInfo args *extenderv1.ExtenderArgs ) fromNodeName := make(map[string]*framework.NodeInfo) for _, n := range nodes { fromNodeName[n.Node().Name] = n } if h.filterVerb == "" { return nodes, extenderv1.FailedNodesMap{}, extenderv1.FailedNodesMap{}, nil } if h.nodeCacheCapable { nodeNameSlice := make([]string, 0, len(nodes)) for _, node := range nodes { nodeNameSlice = append(nodeNameSlice, node.Node().Name) } nodeNames = &amp;nodeNameSlice } else { nodeList = &amp;v1.NodeList{} for _, node := range nodes { nodeList.Items = append(nodeList.Items, *node.Node()) } } args = &amp;extenderv1.ExtenderArgs{ Pod: pod, Nodes: nodeList, NodeNames: nodeNames, } if err := h.send(h.filterVerb, args, &amp;result); err != nil { return nil, nil, nil, err } if result.Error != "" { return nil, nil, nil, fmt.Errorf(result.Error) } if h.nodeCacheCapable && result.NodeNames != nil { nodeResult = make([]*framework.NodeInfo, len(*result.NodeNames)) for i, nodeName := range *result.NodeNames { if n, ok := fromNodeName[nodeName]; ok { nodeResult[i] = n } else { return nil, nil, nil, fmt.Errorf( "extender %q claims a filtered node %q which is not found in the input node list", h.extenderURL, nodeName) } } } else if result.Nodes != nil { nodeResult = make([]*framework.NodeInfo, len(result.Nodes.Items)) for i := range result.Nodes.Items { nodeResult[i] = framework.NewNodeInfo() nodeResult[i].SetNode(&amp;result.Nodes.Items[i]) } } return nodeResult, result.FailedNodes, result.FailedAndUnresolvableNodes, nil } //该函数是一个过滤函数，基于扩展器实现的谓词函数对节点进行过滤。 //函数的输入是一个Pod对象和一个节点信息数组，输出是过滤后的节点信息数组、失败的节点信息映射、不可解析的节点信息映射和错误信息。 //函数首先通过遍历输入节点信息数组，创建一个从节点名称到节点信息的映射。 //然后根据扩展器的过滤动词，决定使用节点名称列表还是节点列表作为输入参数，构建ExtenderArgs对象，并调用扩展器的过滤方法。 //如果过滤方法返回错误，函数直接返回错误。如果过滤方法成功，函数根据返回结果构建过滤后的节点信息数组，并返回。 //如果扩展器声明了一个节点被过滤，但是在输入节点信息数组中找不到该节点，则函数返回错误。 //如果扩展器返回的结果中包含失败的节点和不可解析的节点信息，则将其添加到相应的映射中。 //总之，该函数通过调用扩展器的过滤方法，对节点进行过滤，并返回过滤后的节点信息数组和相关错误信息。 // Prioritize based on extender implemented priority functions. Weight*priority is added // up for each such priority function. The returned score is added to the score computed // by Kubernetes scheduler. The total score is used to do the host selection. func (h *HTTPExtender) Prioritize(pod *v1.Pod, nodes []*framework.NodeInfo) (*extenderv1.HostPriorityList, int64, error) { var ( result extenderv1.HostPriorityList nodeList *v1.NodeList nodeNames *[]string args *extenderv1.ExtenderArgs ) if h.prioritizeVerb == "" { result := extenderv1.HostPriorityList{} for _, node := range nodes { result = append(result, extenderv1.HostPriority{Host: node.Node().Name, Score: 0}) } return &amp;result, 0, nil } if h.nodeCacheCapable { nodeNameSlice := make([]string, 0, len(nodes)) for _, node := range nodes { nodeNameSlice = append(nodeNameSlice, node.Node().Name) } nodeNames = &amp;nodeNameSlice } else { nodeList = &amp;v1.NodeList{} for _, node := range nodes { nodeList.Items = append(nodeList.Items, *node.Node()) } } args = &amp;extenderv1.ExtenderArgs{ Pod: pod, Nodes: nodeList, NodeNames: nodeNames, } if err := h.send(h.prioritizeVerb, args, &amp;result); err != nil { return nil, 0, err } return &amp;result, h.weight, nil } //该函数是一个Go语言函数，定义在HTTPExtender结构体中，用于根据扩展程序实现的优先级函数对节点进行优先级排序。 //该函数将权重乘以优先级的总和添加到每个此类优先级函数中。 //返回的分数将添加到Kubernetes调度程序计算的分数中。总 //分数用于进行主机选择。 //函数接受一个*v1.Pod类型的pod参数，一个[]*framework.NodeInfo类型的nodes参数，以及一个error类型的结果参数。 //函数首先定义了一些局部变量，包括一个extenderv1.HostPriorityList类型的result变量， //一个*v1.NodeList类型的nodeList变量，一个*[]string类型的nodeNames变量，以及一个*extenderv1.ExtenderArgs类型的args变量。 //如果h.prioritizeVerb为空字符串，则将每个节点的分数设置为0，并返回结果。 //如果h.nodeCacheCapable为true，则将节点名称添加到nodeNameSlice切片中，并将其赋值给nodeNames变量。 //否则，将节点对象追加到nodeList的Items字段中。 //接下来，将pod、nodeList和nodeNames赋值给args的相应字段。 //最后，调用h.send方法，将h.prioritizeVerb、args和&amp;result作为参数传递，并检查是否有错误发生。 //如果有错误，则返回错误。否则，返回结果和权重。 // Bind delegates the action of binding a pod to a node to the extender. func (h *HTTPExtender) Bind(binding *v1.Binding) error { var result extenderv1.ExtenderBindingResult if !h.IsBinder() { // This shouldn&#39;t happen as this extender wouldn&#39;t have become a Binder. return fmt.Errorf("unexpected empty bindVerb in extender") } req := &amp;extenderv1.ExtenderBindingArgs{ PodName: binding.Name, PodNamespace: binding.Namespace, PodUID: binding.UID, Node: binding.Target.Name, } if err := h.send(h.bindVerb, req, &amp;result); err != nil { return err } if result.Error != "" { return fmt.Errorf(result.Error) } return nil } // IsBinder returns whether this extender is configured for the Bind method. func (h *HTTPExtender) IsBinder() bool { return h.bindVerb != "" } // IsPrioritizer returns whether this extender is configured for the Prioritize method. func (h *HTTPExtender) IsPrioritizer() bool { return h.prioritizeVerb != "" } // IsFilter returns whether this extender is configured for the Filter method. func (h *HTTPExtender) IsFilter() bool { return h.filterVerb != "" } //这段代码定义了一个名为HTTPExtender的结构体及其相关方法。 //这个结构体用于委托将Pod绑定到节点的操作给扩展器。 //- Bind方法用于将Pod绑定到节点 //。它首先检查当前扩展器是否配置为绑定扩展器，如果不是，则返回错误。 //然后创建一个ExtenderBindingArgs请求，包含Pod的名称、命名空间、UID以及目标节点的名称，并通过调用send方法将请求发送给扩展器。 //如果发送请求或处理结果出现错误，则返回相应的错误。 //- IsBinder方法用于判断当前扩展器是否配置了绑定方法。如果bindVerb不为空，则表示配置了绑定方法。 //- IsPrioritizer方法用于判断当前扩展器是否配置了优先级方法。如果prioritizeVerb不为空，则表示配置了优先级方法。 //- IsFilter方法用于判断当前扩展器是否配置了过滤方法。如果filterVerb不为空，则表示配置了过滤方法。 // Helper function to send messages to the extender func (h *HTTPExtender) send(action string, args interface{}, result interface{}) error { out, err := json.Marshal(args) if err != nil { return err } url := strings.TrimRight(h.extenderURL, "/") + "/" + action req, err := http.NewRequest("POST", url, bytes.NewReader(out)) if err != nil { return err } req.Header.Set("Content-Type", "application/json") resp, err := h.client.Do(req) if err != nil { return err } defer resp.Body.Close() if resp.StatusCode != http.StatusOK { return fmt.Errorf("failed %v with extender at URL %v, code %v", action, url, resp.StatusCode) } return json.NewDecoder(resp.Body).Decode(result) } //该函数是一个发送消息给扩展程序的辅助函数。 //它使用HTTP POST请求将动作、参数和结果发送到指定的扩展程序URL。 //具体步骤如下： //1. 将参数args转换为JSON格式。 //2. 构建请求URL，通过拼接扩展程序URL和动作字符串。 //3. 创建HTTP POST请求，设置请求头的Content-Type为application/json，并将JSON数据作为请求体。 //4. 发送请求并获取响应。 //5. 检查响应状态码，如果不是200 OK，则返回错误。 //6. 将响应体解码为结果参数result。 如果在上述过程中发生错误，则返回相应的错误。 // IsInterested returns true if at least one extended resource requested by // this pod is managed by this extender. func (h *HTTPExtender) IsInterested(pod *v1.Pod) bool { if h.managedResources.Len() == 0 { return true } if h.hasManagedResources(pod.Spec.Containers) { return true } if h.hasManagedResources(pod.Spec.InitContainers) { return true } return false } //该函数是一个Go语言函数，名为IsInterested，它属于HTTPExtender类型。 //函数用于判断给定的Pod是否至少请求了一个由该extender管理的扩展资源。 //函数返回一个布尔值，如果Pod请求了至少一个由该extender管理的扩展资源，则返回true，否则返回false。 //函数主要包含以下两个步骤： //1. 首先，函数检查HTTPExtender的managedResources列表是否为空。如果为空，则表示该extender管理所有资源，因此直接返回true。 //2. 如果managedResources不为空，函数会分别检查Pod的Spec.Containers和Spec.InitContainers字段中是否包含由该extender管理的扩展资源。 //如果存在至少一个由extender管理的扩展资源，则返回true。如果两个字段中都不包含由extender管理的扩展资源，则返回false。 //总结：该函数用于判断给定的Pod是否请求了由该extender管理的扩展资源，根据管理资源列表和Pod的容器配置进行匹配判断。 func (h *HTTPExtender) hasManagedResources(containers []v1.Container) bool { for i := range containers { container := &amp;containers[i] for resourceName := range container.Resources.Requests { if h.managedResources.Has(string(resourceName)) { return true } } for resourceName := range container.Resources.Limits { if h.managedResources.Has(string(resourceName)) { return true } } } return false } //该函数用于判断给定的容器列表中是否包含有管理资源。 //具体实现为遍历容器列表，再遍历容器的资源请求和限制， //若存在管理资源则返回true，否则返回false。'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>K8S调度器 extender.go 源码解读 2024-04-09 11:45:59.666 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.08f94944067c72307a5b42b2b0ee2b3e368ffe6c13e06a2e651ee5e8d0237c15.js integrity="sha256-CPlJRAZ8cjB6W0KysO4rPjaP/mwT4GouZR7l6NAjfBU=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>00-集群规划和基础参数设定 2023-09-28 15:19:02.214</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>01-创建证书和环境准备 2023-09-28 15:22:19.812</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>02-安装etcd集群 2023-09-28 15:23:07.363</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>0224面试</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>0226 k8s题目</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>03-安装容器运行时 2023-09-28 15:23:56.241</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>04-安装kube_master节点 2023-09-28 15:24:21.203</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>05-安装kube_node节点 2023-09-28 15:24:43.201</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>06-安装calico网络组件 2023-09-28 15:34:28.483</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>06-安装cilium网络组件 2023-09-28 15:35:23.884</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>06-安装flannel网络组件 2023-09-28 15:35:50.039</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>06-安装kube-ovn网络组件 2023-09-28 15:36:11.265</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>06-安装网络组件 2023-09-28 15:25:14.997</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>07-安装集群主要插件 2023-09-28 15:26:42.651</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>08-K8S 集群存储 2023-09-28 15:27:29.454</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>16个概念带你入门 Kubernetes 2024-04-03 15:09:21.671</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>16张硬核图解k8s网络 2024-04-03 15:12:49.601</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-2-22 k8s架构师面试大全</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-2-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-2-26 面试</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-3-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-3-4 CNI剖析演进</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-3-8 面试</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-4-17 面试总结</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 k8s面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-8-1 linux运维面试题</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 linux面试题</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2025-1-16 CSI剖析演进</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2025-1-16 k8s流量链路剖析</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-8 k8s创建pod 流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-8 k8s删除pod deployment的流程图详解</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>33款gitops与devops主流系统 2024-08-02 17:45:15.709</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>600条最强linux命令总结 2024-04-03 15:12:31.282</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>acme自动更新证书 2024-04-03 14:41:44.289</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>calico 配置 BGP Route Reflectors 2023-09-28 15:34:01.007</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>Calico网络自定义 2024-04-03 15:08:43.394</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>CICD思考 2024-04-03 15:11:24.151</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>Client-go 四种客户端 2024-04-03 14:49:34.32</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>Client-go 架构 2024-04-03 14:48:40.716</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>CNI插件选型 2024-04-03 15:01:51.29</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>Containerd 基本操作 2024-04-03 14:55:46.786</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>COREDNS之光 2024-04-03 14:54:52.059</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>dockerfile定制专属镜像 2024-08-02 17:44:00.522</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>dockerfile的copy和add的区别 2024-04-03 15:01:09.565</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>Docker重要的网络知识点 2024-04-03 15:12:10.162</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>ETCD备份 2024-04-03</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>ETCD稳定性及性能优化实践 2024-04-03 15:06:31.141</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>EX-LB 负载均衡部署 2023-09-28 15:28:51.998</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>ezctl 命令行介绍 2023-09-28 15:28:00.619</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>flanel网络 2024-04-03 15:05:04.16</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>godel-scheduler 2024-08-02 17:41:00.668</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>helm chart和repo 2024-04-03 15:00:43.125</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>istio-ingress-gateway 2024-08-02 17:51:54.75</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>istio部署 2024-08-02 17:52:40.721</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>K8S CNI剖析演进 2024-03-04 10:51:33.245</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>K8S csi openebs原理 2024-04-03 14:44:48.967</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>K8S CSI剖析演进 2024-03-04 10:52:20.507</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>K8S GPT 2024-04-03 15:02:09.127</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>K8S 开发可不止 CRUD 2024-04-03 14:50:11.765</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>K8S 探针原理 2024-04-03 14:53:29.429</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>K8S 流量链路剖析 2024-03-04 10:50:22.991</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>K8S 调度器 scheduler_one.go 源码解读 2024-04-09 11:45:28.22</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>K8S之ingress-nginx原理及配置 2024-07-05 18:02:14.243</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>k8s之kubelet源码解读 2024-03-28 15:30:39.633</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>K8S原地升级 2024-04-03 15:04:38.125</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>K8S命令指南 2024-04-03 15:14:14.207</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>K8S如何获得 IP 2024-04-16 17:09:59.658</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>k8s应用的最佳实践 2024-04-03 14:43:16.936</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>K8S控制器之 deployment_controller.go源码解读 2024-04-09 11:30:03.133</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>K8S控制器之 progress.go 进度 源码解读 2024-04-09 11:31:08.86</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>K8S控制器之 rolling.go 滚动更新 源码解读 2024-04-09 11:32:58.133</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>K8S控制器之 scheduler.go 调度器 源码解读 2024-04-09 11:44:25.171</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>K8S控制器之recreate.go 重建 源码解读 2024-04-09 11:31:49.855</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>K8S控制器之rollback.go 回滚 源码解读 2024-04-09 11:32:26.587</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>K8S控制器之stateful_pod_control.go源码解读 2024-04-10 09:42:50.078</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>K8S控制器之stateful_set_control.go源码解读 2024-04-10 09:41:30.316</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>K8S控制器之stateful_set_status_update.go源码解读 2024-04-10</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>K8S控制器之stateful_set.go源码解读 2024-04-10</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>K8S控制器之sync.go 同步 源码解读 2024-04-09 11:33:26.356</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>K8S的POD类型 2024-04-03 14:57:11.072</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>K8S的最后一块拼图 dbpaas 2024-08-02 17:48:35.899</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>k8s组件</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>k8s背后service是如何工作的 2024-08-02 17:49:44.981</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/ class=active>K8S调度器 extender.go 源码解读 2024-04-09 11:45:59.666</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>K8S调试POD 2024-04-03 14:58:15.293</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>k8s运维之清理磁盘 2024-04-03 15:13:57.279</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>K8S面试大全 2024-04-03 15:10:54.493</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>K8S面试宝典 2024-04-03 15:11:09.316</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>K8S面试题 2024-08-02 17:50:50.418</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>kruise原地升级解析 2024-08-02 17:59:31.689</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>kube-router 网络组件 2023-09-28 15:33:20.658</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>kubeasz部署k8s</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>kubekey添加新节点 2024-04-03 15:36:47.646</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>Kubernetes API 2024-04-03 14:47:30.212</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>Kubernetes 源码结构 2024-04-03 14:48:05.954</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>Kubernetes 证书详解(认证) 2024-04-03 14:52:56.54</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>Kubernetes 证书详解(鉴权) 2024-04-03 14:49:04.385</a></li><li><a href=/docs/kubewharf-kubewharf/>kubewharf 2024-08-02 17:41:32.72</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>linux awk文本处理器 8个案例 2024-08-02 17:46:53.603</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>Linux 性能优化大全 2024-04-03 15:09:06.854</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>linux系统性能优化 七个实战经验 2024-08-02 17:47:26.212</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>linux运维工程师50个常见面试题 2024-08-02 17:42:12.968</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>MetalLB L2 原理 2024-04-03 14:52:24.662</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>netctl检测集群pod间连通性 2024-08-02 18:00:36.753</a></li><li><a href=/docs/network-check-network-check/>network-check 2023-09-28 15:36:33.04</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>nginx如何解决惊群效应 2024-08-02 17:45:54.531</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>OpenKruise详细解释以及原地升级及全链路灰度发布方案 2024-07-22 11:44:46.892</a></li><li><a href=/docs/pixie-pixie/>pixie 2024-08-02 17:52:17.843</a></li><li><a href=/docs/2025-2-28-prometheus/>prometheus 面试题</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>prometheus-stack 2024-08-02 17:55:22.326</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>prometheus企业级监控使用总结 2024-04-03 15:13:11.185</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>ssl证书自签发 2024-04-03</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>TEG与istio集成 2024-08-02 17:51:20.389</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>两张图全面理解K8S原理 2024-04-03 14:51:27.431</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>个性化集群参数配置 2023-09-28 15:30:56.072</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>中级运维面试题</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>二进制部署K8S加节点操作 2024-04-03 15:08:26.726</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群 2023-04-12 04:04:09.458</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>使用 OpenFunction 在任何基础设施上运行无服务器工作负载 2024-01-21 04:02:44.459</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>使用cloudflare(CF)搭建dockerhub代理 2024-06-28 14:38:34.339</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>使用kubernees leases 轻松实现leader election 2024-04-03 15:09:46.129</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>公有云上部署 kubeasz 2023-09-28 15:31:16.19</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>单master单etcd改造为3master3etcd</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>史上最牛jenkins pipeline流水线详解 2024-08-02</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>多架构支持 2023-09-28 15:29:54.111</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>大厂总结nginx高并发优化笔记 2024-08-02 17:46:19.098</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>大规模并发下如何加快 Pod 启动速度 2024-04-03</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>如何为K8S保驾护航 2024-04-16 17:09:21.962</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>如何使用tekton快速搭建CI/CD平台 2024-04-03</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>如何调试 crash 容器的网络 2024-04-03 14:50:51.378</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>容器中域名解析以及不同dnspolicy对域名解析的影响 2024-04-03 15:04:09.254</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>容器内的 1 号进程 2024-04-03 14:46:29.998</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>容器原理 2024-04-03 14:45:58.422</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>容器的文件系统 OverlayFS 原理 2024-04-03 14:45:26.893</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>容器网络原理 2024-04-03 14:51:51.962</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>常见linux运维面试题 2024-08-02 17:42:33.873</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>开始使用 cilium 2023-09-28 15:34:49.205</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>彻悟容器网络 2024-04-07 10:30:11.55</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>快速指南 2023-09-28 15:28:25.71</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>我只想做技术 走技术路线 2024-08-02 17:43:31.897</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>搞懂K8S鉴权 2024-04-03 15:11:54.885</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>搭个日志手机系统不香吗 2024-08-02 17:47:58.794</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>操作系统说明 2023-09-28 15:31:37.694</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>文学的故乡 2024-04-03 14:40:45.926</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>是技术大神还是基础架构部的祸害 2024-08-02 17:50:26.139</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>有这3个迹象，你就该离职了 2023-09-21 16:00:22.432</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>极大提高工作效率的 Linux 命令 2024-04-03 14:42:46.957</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>构建容器镜像利器buildkit 2024-08-02 17:49:14.916</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>流量何处来何处去 2024-04-03 14:56:20.089</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>清理docker镜像 2024-08-02 17:54:48.594</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>清理残留的calico网络插件 2024-04-03 15:07:38.854</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>磁盘数据恢复 2024-04-03 14:59:27.839</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>离线安装kubephere 2024-04-03 14:59:59.885</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>离线安装集群 2023-09-28 15:29:14.742</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>美国码农薪酬</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>美国码农计划</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>自动屏蔽IP攻击 2024-04-03 14:54:11.783</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>面试0212</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>面试0219</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>面试0220</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>面试0225</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>面试0308 2024-04-03 14:57:53.576</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>面试2025-02-11</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>面试2025-0218</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>面试用 Golang 手撸 LRU 2024-04-03 14:47:00.767</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>顶级devops工具大盘点 2024-08-02 17:43:03.661</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>高级运维面试题-linux部分</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>K8S调度器 extender.go 源码解读 2024-04-09 11:45:59.666</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><pre tabindex=0><code>/*
Copyright 2015 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scheduler

import (
	&#34;bytes&#34;
	&#34;encoding/json&#34;
	&#34;fmt&#34;
	&#34;net/http&#34;
	&#34;strings&#34;
	&#34;time&#34;

	v1 &#34;k8s.io/api/core/v1&#34;
	utilnet &#34;k8s.io/apimachinery/pkg/util/net&#34;
	&#34;k8s.io/apimachinery/pkg/util/sets&#34;
	restclient &#34;k8s.io/client-go/rest&#34;
	extenderv1 &#34;k8s.io/kube-scheduler/extender/v1&#34;
	schedulerapi &#34;k8s.io/kubernetes/pkg/scheduler/apis/config&#34;
	&#34;k8s.io/kubernetes/pkg/scheduler/framework&#34;
)

const (
	// DefaultExtenderTimeout defines the default extender timeout in second.
	DefaultExtenderTimeout = 5 * time.Second
)

// HTTPExtender implements the Extender interface.
type HTTPExtender struct {
	extenderURL      string
	preemptVerb      string
	filterVerb       string
	prioritizeVerb   string
	bindVerb         string
	weight           int64
	client           *http.Client
	nodeCacheCapable bool
	managedResources sets.Set[string]
	ignorable        bool
}

//这段代码定义了一个名为HTTPExtender的结构体，它实现了Extender接口。
//HTTPExtender表示一个HTTP扩展器，用于扩展Kubernetes调度器的功能。
//它通过发送HTTP请求与Kubernetes调度器进行交互，以实现自定义的调度逻辑。
//该结构体包含以下字段：  - extenderURL：扩展器的URL，用于向扩展器发送HTTP请求。
//- preemptVerb：抢占操作的动词，表示扩展器在抢占过程中执行的操作。
//- filterVerb：过滤操作的动词，表示扩展器在过滤节点时执行的操作。
//- prioritizeVerb：优先级排序操作的动词，表示扩展器在对节点进行优先级排序时执行的操作。
//- bindVerb：绑定操作的动词，表示扩展器在绑定Pod到节点时执行的操作。
//- weight：扩展器的权重，用于在优先级排序时对多个扩展器的结果进行加权计算。
//- client：用于发送HTTP请求的HTTP客户端。
//- nodeCacheCapable：表示扩展器是否支持节点缓存。
//如果为true，调度器会将节点信息缓存在本地，以减少对扩展器的请求次数。
//- managedResources：表示扩展器管理的资源集合。
//调度器会将这些资源的调度委托给扩展器处理。
//- ignorable：表示扩展器是否可以被忽略。如果为true，当扩展器出现错误时，调度器可以忽略该错误并继续进行调度。
//此外，代码还定义了一个常量DefaultExtenderTimeout，它表示默认的扩展器超时时间，单位为秒。

func makeTransport(config *schedulerapi.Extender) (http.RoundTripper, error) {
	var cfg restclient.Config
	if config.TLSConfig != nil {
		cfg.TLSClientConfig.Insecure = config.TLSConfig.Insecure
		cfg.TLSClientConfig.ServerName = config.TLSConfig.ServerName
		cfg.TLSClientConfig.CertFile = config.TLSConfig.CertFile
		cfg.TLSClientConfig.KeyFile = config.TLSConfig.KeyFile
		cfg.TLSClientConfig.CAFile = config.TLSConfig.CAFile
		cfg.TLSClientConfig.CertData = config.TLSConfig.CertData
		cfg.TLSClientConfig.KeyData = config.TLSConfig.KeyData
		cfg.TLSClientConfig.CAData = config.TLSConfig.CAData
	}
	if config.EnableHTTPS {
		hasCA := len(cfg.CAFile) &gt; 0 || len(cfg.CAData) &gt; 0
		if !hasCA {
			cfg.Insecure = true
		}
	}
	tlsConfig, err := restclient.TLSConfigFor(&amp;cfg)
	if err != nil {
		return nil, err
	}
	if tlsConfig != nil {
		return utilnet.SetTransportDefaults(&amp;http.Transport{
			TLSClientConfig: tlsConfig,
		}), nil
	}
	return utilnet.SetTransportDefaults(&amp;http.Transport{}), nil
}

//该函数根据给定的schedulerapi.Extender配置创建一个http.RoundTripper传输对象。
//它首先将config.TLSConfig中的配置项复制到cfg.TLSClientConfig中，然后根据config.EnableHTTPS的值设置cfg.Insecure。
//接下来，它通过调用restclient.TLSConfigFor(&amp;cfg)来获取TLS配置，并将其设置到http.Transport中。
//最后，返回设置了默认值的http.Transport对象。如果在过程中出现错误，则返回错误。

// NewHTTPExtender creates an HTTPExtender object.
func NewHTTPExtender(config *schedulerapi.Extender) (framework.Extender, error) {
	if config.HTTPTimeout.Duration.Nanoseconds() == 0 {
		config.HTTPTimeout.Duration = time.Duration(DefaultExtenderTimeout)
	}

	transport, err := makeTransport(config)
	if err != nil {
		return nil, err
	}
	client := &amp;http.Client{
		Transport: transport,
		Timeout:   config.HTTPTimeout.Duration,
	}
	managedResources := sets.New[string]()
	for _, r := range config.ManagedResources {
		managedResources.Insert(string(r.Name))
	}
	return &amp;HTTPExtender{
		extenderURL:      config.URLPrefix,
		preemptVerb:      config.PreemptVerb,
		filterVerb:       config.FilterVerb,
		prioritizeVerb:   config.PrioritizeVerb,
		bindVerb:         config.BindVerb,
		weight:           config.Weight,
		client:           client,
		nodeCacheCapable: config.NodeCacheCapable,
		managedResources: managedResources,
		ignorable:        config.Ignorable,
	}, nil
}

//该函数用于创建一个HTTPExtender对象。它根据传入的config参数初始化HTTPExtender对象的属性，并返回该对象。
//其中，makeTransport函数用于创建一个http.Transport对象，http.Client对象则使用该Transport对象以及config参数中的HTTP超时时间进行初始化。
//此外，该函数还对config.ManagedResources进行遍历，将其中的Name字段转换为string类型，并插入到managedResources集合中。
//最后，该函数返回一个初始化完成的HTTPExtender对象。

// Name returns extenderURL to identify the extender.
func (h *HTTPExtender) Name() string {
	return h.extenderURL
}

// IsIgnorable returns true indicates scheduling should not fail when this extender
// is unavailable
func (h *HTTPExtender) IsIgnorable() bool {
	return h.ignorable
}

// SupportsPreemption returns true if an extender supports preemption.
// An extender should have preempt verb defined and enabled its own node cache.
func (h *HTTPExtender) SupportsPreemption() bool {
	return len(h.preemptVerb) &gt; 0
}

//这段代码定义了一个名为HTTPExtender的结构体及其三个方法。
//1. Name()方法返回extenderURL，用于标识扩展程序。
//2. IsIgnorable()方法返回一个布尔值，指示当此扩展程序不可用时，调度是否不应失败。如果ignorable字段为true，则返回true。
//3. SupportsPreemption()方法返回一个布尔值，表示扩展程序是否支持抢占。
//如果preemptVerb字段的长度大于0，则返回true。
//这意味着扩展程序应该定义抢占动词并启用自己的节点缓存。

// ProcessPreemption returns filtered candidate nodes and victims after running preemption logic in extender.
func (h *HTTPExtender) ProcessPreemption(
	pod *v1.Pod,
	nodeNameToVictims map[string]*extenderv1.Victims,
	nodeInfos framework.NodeInfoLister,
) (map[string]*extenderv1.Victims, error) {
	var (
		result extenderv1.ExtenderPreemptionResult
		args   *extenderv1.ExtenderPreemptionArgs
	)

	if !h.SupportsPreemption() {
		return nil, fmt.Errorf(&#34;preempt verb is not defined for extender %v but run into ProcessPreemption&#34;, h.extenderURL)
	}

	if h.nodeCacheCapable {
		// If extender has cached node info, pass NodeNameToMetaVictims in args.
		nodeNameToMetaVictims := convertToMetaVictims(nodeNameToVictims)
		args = &amp;extenderv1.ExtenderPreemptionArgs{
			Pod:                   pod,
			NodeNameToMetaVictims: nodeNameToMetaVictims,
		}
	} else {
		args = &amp;extenderv1.ExtenderPreemptionArgs{
			Pod:               pod,
			NodeNameToVictims: nodeNameToVictims,
		}
	}

	if err := h.send(h.preemptVerb, args, &amp;result); err != nil {
		return nil, err
	}

	// Extender will always return NodeNameToMetaVictims.
	// So let&#39;s convert it to NodeNameToVictims by using &lt;nodeInfos&gt;.
	newNodeNameToVictims, err := h.convertToVictims(result.NodeNameToMetaVictims, nodeInfos)
	if err != nil {
		return nil, err
	}
	// Do not override &lt;nodeNameToVictims&gt;.
	return newNodeNameToVictims, nil
}

//该函数是用于处理抢占逻辑的HTTP扩展器方法。
//它根据传入的Pod和节点信息，通过调用扩展器的抢占逻辑，返回过滤后的候选节点和受害者。
//- 首先，函数检查扩展器是否支持抢占。如果不支持，则返回错误。
//- 接下来，根据扩展器是否具有缓存的节点信息，构建不同的ExtenderPreemptionArgs对象，其中包含Pod和节点信息。
//- 然后，通过调用扩展器的指定动词（preempt），将ExtenderPreemptionArgs发送给扩展器，并将结果存储在ExtenderPreemptionResult中。
//- 最后，将扩展器返回的NodeNameToMetaVictims转换为NodeNameToVictims，并返回新的NodeNameToVictims对象。
//该函数返回的地图map[string]*extenderv1.Victims表示了每个节点的受害者列表，其中每个受害者包含了被抢占的Pod列表。

// convertToVictims converts &#34;nodeNameToMetaVictims&#34; from object identifiers,
// such as UIDs and names, to object pointers.
func (h *HTTPExtender) convertToVictims(
	nodeNameToMetaVictims map[string]*extenderv1.MetaVictims,
	nodeInfos framework.NodeInfoLister,
) (map[string]*extenderv1.Victims, error) {
	nodeNameToVictims := map[string]*extenderv1.Victims{}
	for nodeName, metaVictims := range nodeNameToMetaVictims {
		nodeInfo, err := nodeInfos.Get(nodeName)
		if err != nil {
			return nil, err
		}
		victims := &amp;extenderv1.Victims{
			Pods:             []*v1.Pod{},
			NumPDBViolations: metaVictims.NumPDBViolations,
		}
		for _, metaPod := range metaVictims.Pods {
			pod, err := h.convertPodUIDToPod(metaPod, nodeInfo)
			if err != nil {
				return nil, err
			}
			victims.Pods = append(victims.Pods, pod)
		}
		nodeNameToVictims[nodeName] = victims
	}
	return nodeNameToVictims, nil
}

//该函数是一个Go语言函数，它将从对象标识符（如UID和名称）组成的&#34;nodeNameToMetaVictims&#34;映射转换为对象指针组成的&#34;nodeNameToVictims&#34;映射。
//该函数使用给定的节点信息获取节点名称对应的受害者信息，并将其转换为包含Pod信息和PDB违规数量的Victims对象。
//具体来说，它遍历输入的映射，获取每个节点的MetaVictims对象，并通过节点信息获取节点的Pod信息。
//然后，它将MetaPod对象转换为Pod对象，并将其添加到Victims对象的Pod列表中。
//最后，它将转换后的Victims对象添加到输出映射中，并返回该映射。如果在转换过程中发生错误，函数将返回错误。

// convertPodUIDToPod returns v1.Pod object for given MetaPod and node info.
// The v1.Pod object is restored by nodeInfo.Pods().
// It returns an error if there&#39;s cache inconsistency between default scheduler
// and extender, i.e. when the pod is not found in nodeInfo.Pods.
func (h *HTTPExtender) convertPodUIDToPod(
	metaPod *extenderv1.MetaPod,
	nodeInfo *framework.NodeInfo) (*v1.Pod, error) {
	for _, p := range nodeInfo.Pods {
		if string(p.Pod.UID) == metaPod.UID {
			return p.Pod, nil
		}
	}
	return nil, fmt.Errorf(&#34;extender: %v claims to preempt pod (UID: %v) on node: %v, but the pod is not found on that node&#34;,
		h.extenderURL, metaPod, nodeInfo.Node().Name)
}

// convertToMetaVictims converts from struct type to meta types.
func convertToMetaVictims(
	nodeNameToVictims map[string]*extenderv1.Victims,
) map[string]*extenderv1.MetaVictims {
	nodeNameToMetaVictims := map[string]*extenderv1.MetaVictims{}
	for node, victims := range nodeNameToVictims {
		metaVictims := &amp;extenderv1.MetaVictims{
			Pods:             []*extenderv1.MetaPod{},
			NumPDBViolations: victims.NumPDBViolations,
		}
		for _, pod := range victims.Pods {
			metaPod := &amp;extenderv1.MetaPod{
				UID: string(pod.UID),
			}
			metaVictims.Pods = append(metaVictims.Pods, metaPod)
		}
		nodeNameToMetaVictims[node] = metaVictims
	}
	return nodeNameToMetaVictims
}

//该函数的功能是将从结构体类型转换为元类型。
//它接收一个nodeNameToVictims参数，该参数是一个map，其中键是节点名称，值是*extenderv1.Victims类型的指针。
//函数创建一个空的nodeNameToMetaVictims映射，然后遍历nodeNameToVictims中的每个元素。
//对于每个节点，它创建一个新的extenderv1.MetaVictims实例，并将NumPDBViolations从旧的victims实例复制到新的metaVictims实例中。
//然后，它遍历旧的victims实例中的每个Pod，为每个Pod创建一个新的extenderv1.MetaPod实例，并将UID从旧的pod实例复制到新的metaPod实例中。
//最后，它将新的metaVictims实例添加到nodeNameToMetaVictims映射中，并返回该映射。

// Filter based on extender implemented predicate functions. The filtered list is
// expected to be a subset of the supplied list; otherwise the function returns an error.
// The failedNodes and failedAndUnresolvableNodes optionally contains the list
// of failed nodes and failure reasons, except nodes in the latter are
// unresolvable.
func (h *HTTPExtender) Filter(
	pod *v1.Pod,
	nodes []*framework.NodeInfo,
) (filteredList []*framework.NodeInfo, failedNodes, failedAndUnresolvableNodes extenderv1.FailedNodesMap, err error) {
	var (
		result     extenderv1.ExtenderFilterResult
		nodeList   *v1.NodeList
		nodeNames  *[]string
		nodeResult []*framework.NodeInfo
		args       *extenderv1.ExtenderArgs
	)
	fromNodeName := make(map[string]*framework.NodeInfo)
	for _, n := range nodes {
		fromNodeName[n.Node().Name] = n
	}

	if h.filterVerb == &#34;&#34; {
		return nodes, extenderv1.FailedNodesMap{}, extenderv1.FailedNodesMap{}, nil
	}

	if h.nodeCacheCapable {
		nodeNameSlice := make([]string, 0, len(nodes))
		for _, node := range nodes {
			nodeNameSlice = append(nodeNameSlice, node.Node().Name)
		}
		nodeNames = &amp;nodeNameSlice
	} else {
		nodeList = &amp;v1.NodeList{}
		for _, node := range nodes {
			nodeList.Items = append(nodeList.Items, *node.Node())
		}
	}

	args = &amp;extenderv1.ExtenderArgs{
		Pod:       pod,
		Nodes:     nodeList,
		NodeNames: nodeNames,
	}

	if err := h.send(h.filterVerb, args, &amp;result); err != nil {
		return nil, nil, nil, err
	}
	if result.Error != &#34;&#34; {
		return nil, nil, nil, fmt.Errorf(result.Error)
	}

	if h.nodeCacheCapable &amp;&amp; result.NodeNames != nil {
		nodeResult = make([]*framework.NodeInfo, len(*result.NodeNames))
		for i, nodeName := range *result.NodeNames {
			if n, ok := fromNodeName[nodeName]; ok {
				nodeResult[i] = n
			} else {
				return nil, nil, nil, fmt.Errorf(
					&#34;extender %q claims a filtered node %q which is not found in the input node list&#34;,
					h.extenderURL, nodeName)
			}
		}
	} else if result.Nodes != nil {
		nodeResult = make([]*framework.NodeInfo, len(result.Nodes.Items))
		for i := range result.Nodes.Items {
			nodeResult[i] = framework.NewNodeInfo()
			nodeResult[i].SetNode(&amp;result.Nodes.Items[i])
		}
	}

	return nodeResult, result.FailedNodes, result.FailedAndUnresolvableNodes, nil
}

//该函数是一个过滤函数，基于扩展器实现的谓词函数对节点进行过滤。
//函数的输入是一个Pod对象和一个节点信息数组，输出是过滤后的节点信息数组、失败的节点信息映射、不可解析的节点信息映射和错误信息。
//函数首先通过遍历输入节点信息数组，创建一个从节点名称到节点信息的映射。
//然后根据扩展器的过滤动词，决定使用节点名称列表还是节点列表作为输入参数，构建ExtenderArgs对象，并调用扩展器的过滤方法。
//如果过滤方法返回错误，函数直接返回错误。如果过滤方法成功，函数根据返回结果构建过滤后的节点信息数组，并返回。
//如果扩展器声明了一个节点被过滤，但是在输入节点信息数组中找不到该节点，则函数返回错误。
//如果扩展器返回的结果中包含失败的节点和不可解析的节点信息，则将其添加到相应的映射中。
//总之，该函数通过调用扩展器的过滤方法，对节点进行过滤，并返回过滤后的节点信息数组和相关错误信息。

// Prioritize based on extender implemented priority functions. Weight*priority is added
// up for each such priority function. The returned score is added to the score computed
// by Kubernetes scheduler. The total score is used to do the host selection.
func (h *HTTPExtender) Prioritize(pod *v1.Pod, nodes []*framework.NodeInfo) (*extenderv1.HostPriorityList, int64, error) {
	var (
		result    extenderv1.HostPriorityList
		nodeList  *v1.NodeList
		nodeNames *[]string
		args      *extenderv1.ExtenderArgs
	)

	if h.prioritizeVerb == &#34;&#34; {
		result := extenderv1.HostPriorityList{}
		for _, node := range nodes {
			result = append(result, extenderv1.HostPriority{Host: node.Node().Name, Score: 0})
		}
		return &amp;result, 0, nil
	}

	if h.nodeCacheCapable {
		nodeNameSlice := make([]string, 0, len(nodes))
		for _, node := range nodes {
			nodeNameSlice = append(nodeNameSlice, node.Node().Name)
		}
		nodeNames = &amp;nodeNameSlice
	} else {
		nodeList = &amp;v1.NodeList{}
		for _, node := range nodes {
			nodeList.Items = append(nodeList.Items, *node.Node())
		}
	}

	args = &amp;extenderv1.ExtenderArgs{
		Pod:       pod,
		Nodes:     nodeList,
		NodeNames: nodeNames,
	}

	if err := h.send(h.prioritizeVerb, args, &amp;result); err != nil {
		return nil, 0, err
	}
	return &amp;result, h.weight, nil
}

//该函数是一个Go语言函数，定义在HTTPExtender结构体中，用于根据扩展程序实现的优先级函数对节点进行优先级排序。
//该函数将权重乘以优先级的总和添加到每个此类优先级函数中。
//返回的分数将添加到Kubernetes调度程序计算的分数中。总
//分数用于进行主机选择。
//函数接受一个*v1.Pod类型的pod参数，一个[]*framework.NodeInfo类型的nodes参数，以及一个error类型的结果参数。
//函数首先定义了一些局部变量，包括一个extenderv1.HostPriorityList类型的result变量，
//一个*v1.NodeList类型的nodeList变量，一个*[]string类型的nodeNames变量，以及一个*extenderv1.ExtenderArgs类型的args变量。
//如果h.prioritizeVerb为空字符串，则将每个节点的分数设置为0，并返回结果。
//如果h.nodeCacheCapable为true，则将节点名称添加到nodeNameSlice切片中，并将其赋值给nodeNames变量。
//否则，将节点对象追加到nodeList的Items字段中。
//接下来，将pod、nodeList和nodeNames赋值给args的相应字段。
//最后，调用h.send方法，将h.prioritizeVerb、args和&amp;result作为参数传递，并检查是否有错误发生。
//如果有错误，则返回错误。否则，返回结果和权重。

// Bind delegates the action of binding a pod to a node to the extender.
func (h *HTTPExtender) Bind(binding *v1.Binding) error {
	var result extenderv1.ExtenderBindingResult
	if !h.IsBinder() {
		// This shouldn&#39;t happen as this extender wouldn&#39;t have become a Binder.
		return fmt.Errorf(&#34;unexpected empty bindVerb in extender&#34;)
	}
	req := &amp;extenderv1.ExtenderBindingArgs{
		PodName:      binding.Name,
		PodNamespace: binding.Namespace,
		PodUID:       binding.UID,
		Node:         binding.Target.Name,
	}
	if err := h.send(h.bindVerb, req, &amp;result); err != nil {
		return err
	}
	if result.Error != &#34;&#34; {
		return fmt.Errorf(result.Error)
	}
	return nil
}

// IsBinder returns whether this extender is configured for the Bind method.
func (h *HTTPExtender) IsBinder() bool {
	return h.bindVerb != &#34;&#34;
}

// IsPrioritizer returns whether this extender is configured for the Prioritize method.
func (h *HTTPExtender) IsPrioritizer() bool {
	return h.prioritizeVerb != &#34;&#34;
}

// IsFilter returns whether this extender is configured for the Filter method.
func (h *HTTPExtender) IsFilter() bool {
	return h.filterVerb != &#34;&#34;
}

//这段代码定义了一个名为HTTPExtender的结构体及其相关方法。
//这个结构体用于委托将Pod绑定到节点的操作给扩展器。
//- Bind方法用于将Pod绑定到节点
//。它首先检查当前扩展器是否配置为绑定扩展器，如果不是，则返回错误。
//然后创建一个ExtenderBindingArgs请求，包含Pod的名称、命名空间、UID以及目标节点的名称，并通过调用send方法将请求发送给扩展器。
//如果发送请求或处理结果出现错误，则返回相应的错误。
//- IsBinder方法用于判断当前扩展器是否配置了绑定方法。如果bindVerb不为空，则表示配置了绑定方法。
//- IsPrioritizer方法用于判断当前扩展器是否配置了优先级方法。如果prioritizeVerb不为空，则表示配置了优先级方法。
//- IsFilter方法用于判断当前扩展器是否配置了过滤方法。如果filterVerb不为空，则表示配置了过滤方法。

// Helper function to send messages to the extender
func (h *HTTPExtender) send(action string, args interface{}, result interface{}) error {
	out, err := json.Marshal(args)
	if err != nil {
		return err
	}

	url := strings.TrimRight(h.extenderURL, &#34;/&#34;) + &#34;/&#34; + action

	req, err := http.NewRequest(&#34;POST&#34;, url, bytes.NewReader(out))
	if err != nil {
		return err
	}

	req.Header.Set(&#34;Content-Type&#34;, &#34;application/json&#34;)

	resp, err := h.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf(&#34;failed %v with extender at URL %v, code %v&#34;, action, url, resp.StatusCode)
	}

	return json.NewDecoder(resp.Body).Decode(result)
}

//该函数是一个发送消息给扩展程序的辅助函数。
//它使用HTTP POST请求将动作、参数和结果发送到指定的扩展程序URL。
//具体步骤如下：
//1. 将参数args转换为JSON格式。
//2. 构建请求URL，通过拼接扩展程序URL和动作字符串。
//3. 创建HTTP POST请求，设置请求头的Content-Type为application/json，并将JSON数据作为请求体。
//4. 发送请求并获取响应。
//5. 检查响应状态码，如果不是200 OK，则返回错误。
//6. 将响应体解码为结果参数result。  如果在上述过程中发生错误，则返回相应的错误。

// IsInterested returns true if at least one extended resource requested by
// this pod is managed by this extender.
func (h *HTTPExtender) IsInterested(pod *v1.Pod) bool {
	if h.managedResources.Len() == 0 {
		return true
	}
	if h.hasManagedResources(pod.Spec.Containers) {
		return true
	}
	if h.hasManagedResources(pod.Spec.InitContainers) {
		return true
	}
	return false
}

//该函数是一个Go语言函数，名为IsInterested，它属于HTTPExtender类型。
//函数用于判断给定的Pod是否至少请求了一个由该extender管理的扩展资源。
//函数返回一个布尔值，如果Pod请求了至少一个由该extender管理的扩展资源，则返回true，否则返回false。
//函数主要包含以下两个步骤：
//1. 首先，函数检查HTTPExtender的managedResources列表是否为空。如果为空，则表示该extender管理所有资源，因此直接返回true。
//2. 如果managedResources不为空，函数会分别检查Pod的Spec.Containers和Spec.InitContainers字段中是否包含由该extender管理的扩展资源。
//如果存在至少一个由extender管理的扩展资源，则返回true。如果两个字段中都不包含由extender管理的扩展资源，则返回false。
//总结：该函数用于判断给定的Pod是否请求了由该extender管理的扩展资源，根据管理资源列表和Pod的容器配置进行匹配判断。

func (h *HTTPExtender) hasManagedResources(containers []v1.Container) bool {
	for i := range containers {
		container := &amp;containers[i]
		for resourceName := range container.Resources.Requests {
			if h.managedResources.Has(string(resourceName)) {
				return true
			}
		}
		for resourceName := range container.Resources.Limits {
			if h.managedResources.Has(string(resourceName)) {
				return true
			}
		}
	}
	return false
}

//该函数用于判断给定的容器列表中是否包含有管理资源。
//具体实现为遍历容器列表，再遍历容器的资源请求和限制，
//若存在管理资源则返回true，否则返回false。
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>