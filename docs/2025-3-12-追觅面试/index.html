<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  你做了啥什么，对团队/项目贡献比较大的？
  #

试点，给后续上生产起到好的示范作用，后续上生产比较顺利。

  pv pvc storage-class之间的关系？
  #

在 Kubernetes 中，PV（PersistentVolume）、PVC（PersistentVolumeClaim）和 StorageClass 共同用于管理持久化存储，它们的关系如下：


  1. 关系概述
  #


StorageClass：定义存储的类型，决定如何动态创建 PV。
PV（PersistentVolume）：代表集群中的实际存储，可以是静态预先创建的，也可以通过 StorageClass 动态创建。
PVC（PersistentVolumeClaim）：Pod 申请存储时创建的存储请求，Kubernetes 根据 PVC 自动绑定合适的 PV。



  2. 详细流程
  #

1️⃣ Pod 申请存储（创建 PVC）

用户创建 PVC，声明需要多大的存储、读写权限等。
Kubernetes 查找匹配的 PV，若存在符合要求的 PV，则直接绑定。
若 PV 不匹配，Kubernetes 使用 StorageClass 动态创建 PV（如果 PVC 指定了 StorageClass）。

2️⃣ PV 绑定 PVC

如果 PVC 申请的存储满足某个 PV 的要求，就会绑定该 PV。
PVC 绑定 PV 后，Pod 只能使用该 PV，直到 PVC 释放。

3️⃣ Pod 使用 PVC"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2025-3-12  追觅面试"><meta property="og:description" content="你做了啥什么，对团队/项目贡献比较大的？ # 试点，给后续上生产起到好的示范作用，后续上生产比较顺利。
pv pvc storage-class之间的关系？ # 在 Kubernetes 中，PV（PersistentVolume）、PVC（PersistentVolumeClaim）和 StorageClass 共同用于管理持久化存储，它们的关系如下：
1. 关系概述 # StorageClass：定义存储的类型，决定如何动态创建 PV。 PV（PersistentVolume）：代表集群中的实际存储，可以是静态预先创建的，也可以通过 StorageClass 动态创建。 PVC（PersistentVolumeClaim）：Pod 申请存储时创建的存储请求，Kubernetes 根据 PVC 自动绑定合适的 PV。 2. 详细流程 # 1️⃣ Pod 申请存储（创建 PVC）
用户创建 PVC，声明需要多大的存储、读写权限等。 Kubernetes 查找匹配的 PV，若存在符合要求的 PV，则直接绑定。 若 PV 不匹配，Kubernetes 使用 StorageClass 动态创建 PV（如果 PVC 指定了 StorageClass）。 2️⃣ PV 绑定 PVC
如果 PVC 申请的存储满足某个 PV 的要求，就会绑定该 PV。 PVC 绑定 PV 后，Pod 只能使用该 PV，直到 PVC 释放。 3️⃣ Pod 使用 PVC"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2025-3-12 追觅面试 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.1a5becdf9b12587671e0a18c1cf5fae4147c67649d7de8d4211c6063e9085a8c.js integrity="sha256-Glvs35sSWHZx4KGMHPX65BR8Z2SdfejUIRxgY+kIWow=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-3-20-victoriametrics-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics高可用架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 thanos高可用架构</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/ class=active>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-08-01 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 k8s面试题</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-05-01 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-04-17 面试总结</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-03-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-03-08 面试</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2024-03-04 k8s流量链路剖析</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2024-03-04 CSI剖析演进</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-03-04 CNI剖析演进</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-02-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-02-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-02-22 k8s架构师面试大全</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-3-12 追觅面试</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-关系概述><strong>1. 关系概述</strong></a></li><li><a href=#2-详细流程><strong>2. 详细流程</strong></a></li><li><a href=#3-具体示例><strong>3. 具体示例</strong></a><ul><li><a href=#1-storageclass-定义><strong>1️⃣ StorageClass 定义</strong></a></li><li><a href=#2-pvc-申请存储><strong>2️⃣ PVC 申请存储</strong></a></li><li><a href=#3-pv-静态创建可选><strong>3️⃣ PV 静态创建（可选）</strong></a></li><li><a href=#4-pod-挂载-pvc><strong>4️⃣ Pod 挂载 PVC</strong></a></li></ul></li><li><a href=#4-总结><strong>4. 总结</strong></a><ul><li><a href=#关键点><strong>关键点</strong></a></li></ul></li></ul><ul><li><a href=#1-cni-插件优化><strong>1. CNI 插件优化</strong></a></li><li><a href=#2-pod-网络优化><strong>2. Pod 网络优化</strong></a><ul><li><a href=#1-调整-mtu><strong>(1) 调整 MTU</strong></a></li><li><a href=#2-调整-tcp-参数><strong>(2) 调整 TCP 参数</strong></a></li><li><a href=#3-使用-ipv6-dual-stack><strong>(3) 使用 IPv6 Dual Stack</strong></a></li></ul></li><li><a href=#3-service-网络优化><strong>3. Service 网络优化</strong></a><ul><li><a href=#1-优化-kube-proxy><strong>(1) 优化 kube-proxy</strong></a></li><li><a href=#2-开启-coredns-缓存><strong>(2) 开启 CoreDNS 缓存</strong></a></li><li><a href=#3-使用><strong>(3) 使用 <code>headless Service</code></strong></a></li></ul></li><li><a href=#4-负载均衡优化><strong>4. 负载均衡优化</strong></a><ul><li><a href=#1-使用-externaltrafficpolicy><strong>(1) 使用 ExternalTrafficPolicy</strong></a></li><li><a href=#2-开启><strong>(2) 开启 <code>KeepAlive</code></strong></a></li></ul></li><li><a href=#5-网络安全优化><strong>5. 网络安全优化</strong></a><ul><li><a href=#1-限制-ip-访问><strong>(1) 限制 IP 访问</strong></a></li><li><a href=#2-使用-networkpolicy><strong>(2) 使用 NetworkPolicy</strong></a></li></ul></li><li><a href=#6-使用-ebpf-提高性能><strong>6. 使用 eBPF 提高性能</strong></a></li><li><a href=#7-监控和优化><strong>7. 监控和优化</strong></a><ul><li><a href=#1-使用><strong>(1) 使用 <code>ping</code> 和 <code>iperf</code> 监控网络</strong></a></li><li><a href=#2-使用><strong>(2) 使用 <code>tcpdump</code> 分析网络问题</strong></a></li><li><a href=#3-使用-prometheus--grafana-监控><strong>(3) 使用 Prometheus + Grafana 监控</strong></a></li></ul></li><li><a href=#总结><strong>总结</strong></a></li></ul><ul><li><a href=#1-基本概念><strong>1. 基本概念</strong></a></li><li><a href=#2-iptables-解析><strong>2. iptables 解析</strong></a><ul><li><a href=#iptables-工作原理><strong>iptables 工作原理</strong></a></li><li><a href=#示例><strong>示例</strong></a></li></ul></li><li><a href=#3-ipvs-解析><strong>3. IPVS 解析</strong></a><ul><li><a href=#ipvs-工作原理><strong>IPVS 工作原理</strong></a></li><li><a href=#示例-1><strong>示例</strong></a></li></ul></li><li><a href=#4-iptables-vs-ipvs-性能对比><strong>4. iptables vs IPVS 性能对比</strong></a></li><li><a href=#5-开启-ipvs-模式><strong>5. 开启 IPVS 模式</strong></a><ul><li><a href=#1-检查内核模块><strong>(1) 检查内核模块</strong></a></li><li><a href=#2-修改-kube-proxy-配置><strong>(2) 修改 kube-proxy 配置</strong></a></li><li><a href=#3-重启><strong>(3) 重启 <code>kube-proxy</code></strong></a></li><li><a href=#4-验证-ipvs-是否生效><strong>(4) 验证 IPVS 是否生效</strong></a></li></ul></li><li><a href=#6-总结><strong>6. 总结</strong></a></li></ul><ul><li><ul><li><a href=#kubernetes-默认的-kube-proxy-模式是><strong>Kubernetes 默认的 kube-proxy 模式是 <code>iptables</code></strong></a></li><li><a href=#1><strong>1. <code>iptables</code> 是更通用的默认选择</strong></a></li><li><a href=#2><strong>2. <code>IPVS</code> 依赖额外的内核模块</strong></a></li><li><a href=#3><strong>3. <code>iptables</code> 对中小规模集群足够</strong></a></li><li><a href=#4-kubernetes-并没有放弃><strong>4. Kubernetes 并没有放弃 <code>IPVS</code></strong></a></li><li><a href=#5-如何检查当前><strong>5. 如何检查当前 <code>kube-proxy</code> 使用的模式？</strong></a></li><li><a href=#6-结论><strong>6. 结论</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#kubernetes-中-kube-proxy-的关键点总结><strong>Kubernetes 中 kube-proxy 的关键点总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#ingress-和-ingress-controller-的区别><strong>Ingress 和 Ingress Controller 的区别</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-nginx-ingress-controller最常见><strong>1. Nginx Ingress Controller</strong>（最常见）</a></li><li><a href=#2-traefik-ingress-controller云原生友好><strong>2. Traefik Ingress Controller</strong>（云原生友好）</a></li><li><a href=#3-haproxy-ingress-controller高性能><strong>3. HAProxy Ingress Controller</strong>（高性能）</a></li><li><a href=#4-kong-ingress-controllerapi-网关><strong>4. Kong Ingress Controller</strong>（API 网关）</a></li><li><a href=#5-istio-gatewayservice-mesh-方案><strong>5. Istio Gateway</strong>（Service Mesh 方案）</a></li><li><a href=#6-contour-ingress-controllerenvoy-代理><strong>6. Contour Ingress Controller</strong>（Envoy 代理）</a></li><li><a href=#7-gce-ingress-controller适用于-gcp><strong>7. GCE Ingress Controller</strong>（适用于 GCP）</a></li><li><a href=#8-aws-alb-ingress-controller适用于-aws><strong>8. AWS ALB Ingress Controller</strong>（适用于 AWS）</a></li><li><a href=#9-f5-big-ip-ingress-controller企业级><strong>9. F5 BIG-IP Ingress Controller</strong>（企业级）</a></li><li><a href=#总结不同-ingress-controller-适用场景><strong>总结：不同 Ingress Controller 适用场景</strong></a></li></ul></li></ul><ul><li><a href=#1-nginx-配置适用于独立-nginx-部署><strong>1. Nginx 配置（适用于独立 Nginx 部署）</strong></a></li><li><a href=#2-nginx-ingress-controller-配置><strong>2. Nginx Ingress Controller 配置</strong></a><ul><li><a href=#方法-1在-ingress-资源中增加-annotation><strong>方法 1：在 Ingress 资源中增加 Annotation</strong></a></li><li><a href=#方法-2修改-configmap-配置><strong>方法 2：修改 ConfigMap 配置</strong></a></li></ul></li><li><a href=#3-helm-安装-nginx-ingress-时修改><strong>3. Helm 安装 Nginx Ingress 时修改</strong></a></li><li><a href=#总结-1><strong>总结</strong></a></li></ul><ul><li><a href=#1-常见原因><strong>1. 常见原因</strong></a><ul><li><a href=#1-ingress-controller-作为反向代理><strong>(1) Ingress Controller 作为反向代理</strong></a></li><li><a href=#2-kubernetes-运行模式loadbalancer--nodeport--hostnetwork><strong>(2) Kubernetes 运行模式（LoadBalancer / NodePort / HostNetwork）</strong></a></li><li><a href=#3-snat源地址网络转换><strong>(3) SNAT（源地址网络转换）</strong></a></li></ul></li><li><a href=#2-解决方案><strong>2. 解决方案</strong></a><ul><li><a href=#方法-1使用><strong>方法 1：使用 <code>X-Forwarded-For</code> 传递真实 IP</strong></a></li><li><a href=#方法-2修改><strong>方法 2：修改 <code>externalTrafficPolicy</code> 避免 SNAT</strong></a></li><li><a href=#方法-3使用><strong>方法 3：使用 <code>proxy-protocol</code>（适用于云负载均衡）</strong></a></li></ul></li><li><a href=#3-总结><strong>3. 总结</strong></a></li></ul><ul><li><ul><li><a href=#1-生成-ssh-密钥对><strong>1. 生成 SSH 密钥对</strong></a></li><li><a href=#2-将公钥添加到-git-服务><strong>2. 将公钥添加到 Git 服务</strong></a></li><li><a href=#3-配置-ssh-客户端><strong>3. 配置 SSH 客户端</strong></a></li><li><a href=#4-使用-ssh-拉取代码><strong>4. 使用 SSH 拉取代码</strong></a></li><li><a href=#5-测试-ssh-连接><strong>5. 测试 SSH 连接</strong></a></li><li><a href=#6-配置-git-使用-ssh><strong>6. 配置 Git 使用 SSH</strong></a></li><li><a href=#总结-2><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-jenkins-集群架构><strong>1. Jenkins 集群架构</strong></a></li><li><a href=#2-配置-jenkins-agent-在不同平台上执行任务><strong>2. 配置 Jenkins Agent 在不同平台上执行任务</strong></a></li><li><a href=#3-配置多平台编译><strong>3. 配置多平台编译</strong></a></li><li><a href=#4-jenkins-集群的负载均衡和优化><strong>4. Jenkins 集群的负载均衡和优化</strong></a></li><li><a href=#5-通过-pipeline-实现跨平台构建><strong>5. 通过 Pipeline 实现跨平台构建</strong></a></li><li><a href=#总结-3><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-bridge-网络桥接网络>1. <strong>bridge 网络（桥接网络）</strong></a></li><li><a href=#2-host-网络>2. <strong>host 网络</strong></a></li><li><a href=#3-none-网络>3. <strong>none 网络</strong></a></li><li><a href=#4-overlay-网络>4. <strong>overlay 网络</strong></a></li><li><a href=#5-macvlan-网络>5. <strong>macvlan 网络</strong></a></li><li><a href=#6-host-gateway-网络docker-2010-及以上版本>6. <strong>host-gateway 网络（Docker 20.10 及以上版本）</strong></a></li><li><a href=#总结-4>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#container-网络模式>container 网络模式</a></li><li><a href=#使用示例>使用示例：</a></li><li><a href=#总结-5>总结：</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=你做了啥什么对团队项目贡献比较大的>你做了啥什么，对团队/项目贡献比较大的？
<a class=anchor href=#%e4%bd%a0%e5%81%9a%e4%ba%86%e5%95%a5%e4%bb%80%e4%b9%88%e5%af%b9%e5%9b%a2%e9%98%9f%e9%a1%b9%e7%9b%ae%e8%b4%a1%e7%8c%ae%e6%af%94%e8%be%83%e5%a4%a7%e7%9a%84>#</a></h1><p>试点，给后续上生产起到好的示范作用，后续上生产比较顺利。</p><h1 id=pv-pvc-storage-class之间的关系>pv pvc storage-class之间的关系？
<a class=anchor href=#pv-pvc-storage-class%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb>#</a></h1><p>在 Kubernetes 中，<code>PV</code>（PersistentVolume）、<code>PVC</code>（PersistentVolumeClaim）和 <code>StorageClass</code> 共同用于管理持久化存储，它们的关系如下：</p><hr><h2 id=1-关系概述><strong>1. 关系概述</strong>
<a class=anchor href=#1-%e5%85%b3%e7%b3%bb%e6%a6%82%e8%bf%b0>#</a></h2><ul><li><code>StorageClass</code>：定义存储的<strong>类型</strong>，决定如何动态创建 <code>PV</code>。</li><li><code>PV</code>（PersistentVolume）：代表集群中的<strong>实际存储</strong>，可以是静态预先创建的，也可以通过 <code>StorageClass</code> 动态创建。</li><li><code>PVC</code>（PersistentVolumeClaim）：Pod 申请存储时创建的<strong>存储请求</strong>，Kubernetes 根据 PVC 自动绑定合适的 PV。</li></ul><hr><h2 id=2-详细流程><strong>2. 详细流程</strong>
<a class=anchor href=#2-%e8%af%a6%e7%bb%86%e6%b5%81%e7%a8%8b>#</a></h2><p><strong>1️⃣ Pod 申请存储（创建 PVC）</strong></p><ul><li>用户创建 <code>PVC</code>，声明需要多大的存储、读写权限等。</li><li>Kubernetes 查找匹配的 <code>PV</code>，若存在符合要求的 <code>PV</code>，则直接绑定。</li><li>若 <code>PV</code> 不匹配，Kubernetes 使用 <code>StorageClass</code> <strong>动态创建 <code>PV</code></strong>（如果 <code>PVC</code> 指定了 <code>StorageClass</code>）。</li></ul><p><strong>2️⃣ <code>PV</code> 绑定 <code>PVC</code></strong></p><ul><li>如果 <code>PVC</code> 申请的存储满足某个 <code>PV</code> 的要求，就会绑定该 <code>PV</code>。</li><li><code>PVC</code> 绑定 <code>PV</code> 后，Pod 只能使用该 <code>PV</code>，直到 <code>PVC</code> 释放。</li></ul><p><strong>3️⃣ Pod 使用 <code>PVC</code></strong></p><ul><li>Pod 在 <code>volume</code> 字段中引用 <code>PVC</code>，让应用可以挂载持久化存储。</li></ul><p><strong>4️⃣ <code>PVC</code> 释放 <code>PV</code></strong></p><ul><li><p>当</p><pre tabindex=0><code>PVC
</code></pre><p>被删除时，</p><pre tabindex=0><code>PV
</code></pre><p>的回收策略（</p><pre tabindex=0><code>Retain
</code></pre><p>、</p><pre tabindex=0><code>Recycle
</code></pre><p>、</p><pre tabindex=0><code>Delete
</code></pre><p>）决定如何处理存储：</p><ul><li><code>Retain</code>：<code>PV</code> 保留，管理员需要手动回收数据。</li><li><code>Recycle</code>（已废弃）：简单格式化 <code>PV</code>，重新变为可用状态。</li><li><code>Delete</code>：自动删除 <code>PV</code> 及其后端存储。</li></ul></li></ul><hr><h2 id=3-具体示例><strong>3. 具体示例</strong>
<a class=anchor href=#3-%e5%85%b7%e4%bd%93%e7%a4%ba%e4%be%8b>#</a></h2><h3 id=1-storageclass-定义><strong>1️⃣ StorageClass 定义</strong>
<a class=anchor href=#1-storageclass-%e5%ae%9a%e4%b9%89>#</a></h3><p>定义一个 <code>StorageClass</code>，用于动态创建 <code>PV</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>storage.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StorageClass</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-storage-class</span>
</span></span><span style=display:flex><span><span style=color:#f92672>provisioner</span>: <span style=color:#ae81ff>kubernetes.io/aws-ebs </span> <span style=color:#75715e># 存储供应商</span>
</span></span><span style=display:flex><span><span style=color:#f92672>parameters</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>gp2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>reclaimPolicy</span>: <span style=color:#ae81ff>Delete </span> <span style=color:#75715e># PVC 删除后，PV 也删除</span>
</span></span></code></pre></div><hr><h3 id=2-pvc-申请存储><strong>2️⃣ PVC 申请存储</strong>
<a class=anchor href=#2-pvc-%e7%94%b3%e8%af%b7%e5%ad%98%e5%82%a8>#</a></h3><p>用户创建 <code>PVC</code> 来申请存储：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolumeClaim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pvc</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce </span> <span style=color:#75715e># 仅单个节点可挂载</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>10Gi </span> <span style=color:#75715e># 申请 10Gi 存储</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>storageClassName</span>: <span style=color:#ae81ff>my-storage-class </span> <span style=color:#75715e># 指定 StorageClass</span>
</span></span></code></pre></div><ul><li><p>如果集群有 <code>StorageClass</code>，则 Kubernetes <strong>动态创建 PV</strong> 并绑定 <code>PVC</code>。</p></li><li><p>如果</p><pre tabindex=0><code>PVC
</code></pre><p>不指定</p><pre tabindex=0><code>storageClassName
</code></pre><p>，则：</p><ul><li>Kubernetes 绑定已有的静态 <code>PV</code>（如果匹配）。</li><li>若 <code>PV</code> 不匹配，<code>PVC</code> 可能会一直 <code>Pending</code>。</li></ul></li></ul><hr><h3 id=3-pv-静态创建可选><strong>3️⃣ PV 静态创建（可选）</strong>
<a class=anchor href=#3-pv-%e9%9d%99%e6%80%81%e5%88%9b%e5%bb%ba%e5%8f%af%e9%80%89>#</a></h3><p>管理员可以预先创建 <code>PV</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolume</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pv</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>capacity</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>10Gi </span> <span style=color:#75715e># 存储大小</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>persistentVolumeReclaimPolicy</span>: <span style=color:#ae81ff>Retain </span> <span style=color:#75715e># PVC 删除后，PV 保留</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>path</span>: <span style=color:#e6db74>&#34;/mnt/data&#34;</span>
</span></span></code></pre></div><ul><li>如果 <code>PV</code> 满足 <code>PVC</code> 申请的要求，Kubernetes 自动绑定。</li></ul><hr><h3 id=4-pod-挂载-pvc><strong>4️⃣ Pod 挂载 PVC</strong>
<a class=anchor href=#4-pod-%e6%8c%82%e8%bd%bd-pvc>#</a></h3><p>Pod 使用 <code>PVC</code> 来持久化存储：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#e6db74>&#34;/data&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-volume</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>persistentVolumeClaim</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>claimName</span>: <span style=color:#ae81ff>my-pvc </span> <span style=color:#75715e># 绑定 PVC</span>
</span></span></code></pre></div><hr><h2 id=4-总结><strong>4. 总结</strong>
<a class=anchor href=#4-%e6%80%bb%e7%bb%93>#</a></h2><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><code>StorageClass</code></td><td>定义存储类型，决定如何动态创建 <code>PV</code></td></tr><tr><td><code>PV</code></td><td>代表实际的存储资源（静态或动态创建）</td></tr><tr><td><code>PVC</code></td><td>Pod 申请存储的方式，Kubernetes 通过 <code>PVC</code> 绑定 <code>PV</code></td></tr><tr><td><code>Pod</code></td><td>使用 <code>PVC</code> 以挂载持久化存储</td></tr></tbody></table><h3 id=关键点><strong>关键点</strong>
<a class=anchor href=#%e5%85%b3%e9%94%ae%e7%82%b9>#</a></h3><p>✅ <code>PVC</code> 申请存储 → <code>PV</code> 绑定 <code>PVC</code>
✅ <code>StorageClass</code> 支持动态创建 <code>PV</code>
✅ <code>PV</code> 的 <code>reclaimPolicy</code> 决定存储如何回收</p><p>这样，Kubernetes 能灵活管理存储，为 Pod 提供持久化存储支持！🚀</p><h1 id=怎么优化网络的问题>怎么优化网络的问题？
<a class=anchor href=#%e6%80%8e%e4%b9%88%e4%bc%98%e5%8c%96%e7%bd%91%e7%bb%9c%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h1><p>Kubernetes 网络优化涉及多个层面，包括 <strong>容器网络、CNI 插件、DNS 解析、Service 访问、负载均衡、网络安全</strong> 等。优化的重点一般是 <strong>降低延迟、提高吞吐量、减少丢包、优化服务发现</strong>。以下是一些常见的优化方案：</p><hr><h2 id=1-cni-插件优化><strong>1. CNI 插件优化</strong>
<a class=anchor href=#1-cni-%e6%8f%92%e4%bb%b6%e4%bc%98%e5%8c%96>#</a></h2><p><strong>选择合适的 CNI 插件</strong></p><ul><li><strong>Calico</strong>：支持 BGP，适用于大规模集群，适合高性能网络需求。</li><li><strong>Cilium</strong>：基于 eBPF 提供更高效的数据包处理，支持高并发。</li><li><strong>Flannel</strong>：轻量级，适合小规模集群，但不支持 NetworkPolicy。</li><li><strong>OVN-Kubernetes</strong>：支持高级网络策略，适合 OpenStack 等集成环境。</li></ul><p><strong>优化 CNI 配置</strong></p><ul><li><strong>选择合适的后端</strong>（如 Calico 的 <code>IP-in-IP</code> vs <code>VXLAN</code>，或 Cilium 的 <code>native-routing</code>）。</li><li><strong>开启 eBPF 加速</strong>（Cilium 支持 eBPF，减少 iptables 规则，提高网络性能）。</li><li><strong>减少 NAT 转换</strong>（使用 <code>DirectRouting</code> 模式，避免 <code>SNAT</code> 影响性能）。</li></ul><hr><h2 id=2-pod-网络优化><strong>2. Pod 网络优化</strong>
<a class=anchor href=#2-pod-%e7%bd%91%e7%bb%9c%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-调整-mtu><strong>(1) 调整 MTU</strong>
<a class=anchor href=#1-%e8%b0%83%e6%95%b4-mtu>#</a></h3><ul><li><p>降低 MTU 以减少分片</p><p>：默认</p><pre tabindex=0><code>1500
</code></pre><p>，如使用</p><pre tabindex=0><code>VXLAN
</code></pre><p>或</p><pre tabindex=0><code>WireGuard
</code></pre><p>，可能需要</p><pre tabindex=0><code>1400
</code></pre><p>或</p><pre tabindex=0><code>1450
</code></pre><p>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ip link set dev eth0 mtu <span style=color:#ae81ff>1400</span>
</span></span></code></pre></div></li></ul><h3 id=2-调整-tcp-参数><strong>(2) 调整 TCP 参数</strong>
<a class=anchor href=#2-%e8%b0%83%e6%95%b4-tcp-%e5%8f%82%e6%95%b0>#</a></h3><ul><li><p>允许 TCP 快速重传，减少网络丢包影响：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sysctl -w net.ipv4.tcp_fastopen<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>sysctl -w net.core.rmem_max<span style=color:#f92672>=</span><span style=color:#ae81ff>16777216</span>
</span></span><span style=display:flex><span>sysctl -w net.core.wmem_max<span style=color:#f92672>=</span><span style=color:#ae81ff>16777216</span>
</span></span></code></pre></div></li></ul><h3 id=3-使用-ipv6-dual-stack><strong>(3) 使用 IPv6 Dual Stack</strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8-ipv6-dual-stack>#</a></h3><ul><li><p>如果有 IPv6 需求，可以开启双栈支持：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>featureGates</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>IPv6DualStack</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div></li></ul><hr><h2 id=3-service-网络优化><strong>3. Service 网络优化</strong>
<a class=anchor href=#3-service-%e7%bd%91%e7%bb%9c%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-优化-kube-proxy><strong>(1) 优化 kube-proxy</strong>
<a class=anchor href=#1-%e4%bc%98%e5%8c%96-kube-proxy>#</a></h3><p>默认 <code>kube-proxy</code> 使用 <code>iptables</code>，当 <code>Service</code> 多时会影响性能，推荐 <strong>使用 <code>ipvs</code></strong> 提高性能：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit configmap -n kube-system kube-proxy
</span></span></code></pre></div><p>修改：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;ipvs&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>ipvs</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>strictARP</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>scheduler</span>: <span style=color:#e6db74>&#34;rr&#34;</span>
</span></span></code></pre></div><ul><li><code>strictARP: true</code> 解决 <code>arp flux</code> 问题，避免流量分发错误。</li><li><code>scheduler: "rr"</code> 选择轮询调度，可优化流量分配。</li></ul><h3 id=2-开启-coredns-缓存><strong>(2) 开启 CoreDNS 缓存</strong>
<a class=anchor href=#2-%e5%bc%80%e5%90%af-coredns-%e7%bc%93%e5%ad%98>#</a></h3><p>DNS 解析慢会影响 Pod 访问 <code>Service</code>，可以优化 <code>CoreDNS</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ConfigMap</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>coredns</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>kube-system</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>Corefile</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        errors
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        health
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ready
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        cache 30  # 缓存 30 秒，减少 DNS 查询
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        forward . 8.8.8.8  # 可替换为内网 DNS 服务器
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }</span>
</span></span></code></pre></div><h3 id=3-使用><strong>(3) 使用 <code>headless Service</code></strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8>#</a></h3><ul><li><p>对于 StatefulSet 等不需要</p><pre tabindex=0><code>ClusterIP
</code></pre><p>的</p><pre tabindex=0><code>Service
</code></pre><p>，可使用</p><pre tabindex=0><code>headless service
</code></pre><p>避免</p><pre tabindex=0><code>kube-proxy
</code></pre><p>代理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>clusterIP</span>: <span style=color:#ae81ff>None </span> <span style=color:#75715e># 取消 ClusterIP，直接使用 Pod IP</span>
</span></span></code></pre></div></li></ul><hr><h2 id=4-负载均衡优化><strong>4. 负载均衡优化</strong>
<a class=anchor href=#4-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-使用-externaltrafficpolicy><strong>(1) 使用 ExternalTrafficPolicy</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8-externaltrafficpolicy>#</a></h3><ul><li><p>默认情况下，<code>LoadBalancer</code> 会在 <code>NodePort</code> 层级进行 SNAT 转换，影响真实 IP 透传。</p></li><li><pre tabindex=0><code>externalTrafficPolicy: Local
</code></pre><p>让流量直接到 Pod，减少一次 NAT 转换：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-lb</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>LoadBalancer</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>externalTrafficPolicy</span>: <span style=color:#ae81ff>Local</span>
</span></span></code></pre></div></li></ul><h3 id=2-开启><strong>(2) 开启 <code>KeepAlive</code></strong>
<a class=anchor href=#2-%e5%bc%80%e5%90%af>#</a></h3><p>如果 <code>Service</code> 后端是 Nginx、Envoy 之类的负载均衡器，建议启用 <code>KeepAlive</code> 以减少连接重建开销：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>keepalive_timeout</span> <span style=color:#ae81ff>75</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>keepalive_requests</span> <span style=color:#ae81ff>1000</span>;
</span></span></code></pre></div><hr><h2 id=5-网络安全优化><strong>5. 网络安全优化</strong>
<a class=anchor href=#5-%e7%bd%91%e7%bb%9c%e5%ae%89%e5%85%a8%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-限制-ip-访问><strong>(1) 限制 IP 访问</strong>
<a class=anchor href=#1-%e9%99%90%e5%88%b6-ip-%e8%ae%bf%e9%97%ae>#</a></h3><p>如果集群暴露了外网 API Server，可以使用 <code>iptables</code> 限制访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>iptables -A INPUT -p tcp --dport <span style=color:#ae81ff>6443</span> -s 192.168.1.0/24 -j ACCEPT
</span></span><span style=display:flex><span>iptables -A INPUT -p tcp --dport <span style=color:#ae81ff>6443</span> -j DROP
</span></span></code></pre></div><h3 id=2-使用-networkpolicy><strong>(2) 使用 NetworkPolicy</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8-networkpolicy>#</a></h3><p>可以使用 <code>NetworkPolicy</code> 限制 Pod 之间的通信：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>NetworkPolicy</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>deny-all</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>podSelector</span>: {}
</span></span><span style=display:flex><span>  <span style=color:#f92672>policyTypes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>Ingress</span>
</span></span></code></pre></div><ul><li>这样 <code>default</code> 命名空间的 Pod 之间无法互相访问。</li></ul><hr><h2 id=6-使用-ebpf-提高性能><strong>6. 使用 eBPF 提高性能</strong>
<a class=anchor href=#6-%e4%bd%bf%e7%94%a8-ebpf-%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd>#</a></h2><p>如果使用 <strong>Cilium</strong>，可以开启 eBPF 来优化：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cilium status
</span></span><span style=display:flex><span>cilium config set enable-node-port true
</span></span><span style=display:flex><span>cilium config set enable-bpf-masquerade true
</span></span></code></pre></div><ul><li><strong>eBPF 取代 iptables</strong>，减少规则匹配开销，提高流量转发性能。</li></ul><hr><h2 id=7-监控和优化><strong>7. 监控和优化</strong>
<a class=anchor href=#7-%e7%9b%91%e6%8e%a7%e5%92%8c%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-使用><strong>(1) 使用 <code>ping</code> 和 <code>iperf</code> 监控网络</strong>
<a class=anchor href=#1-%e4%bd%bf%e7%94%a8>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ping &lt;pod-ip&gt;
</span></span><span style=display:flex><span>iperf3 -c &lt;pod-ip&gt;
</span></span></code></pre></div><p>可以用 <code>iperf3</code> 测试 Pod 之间的带宽：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>iperf3 -s  <span style=color:#75715e># 服务器端</span>
</span></span><span style=display:flex><span>iperf3 -c &lt;server-ip&gt; -P <span style=color:#ae81ff>10</span>  <span style=color:#75715e># 并发测试</span>
</span></span></code></pre></div><h3 id=2-使用><strong>(2) 使用 <code>tcpdump</code> 分析网络问题</strong>
<a class=anchor href=#2-%e4%bd%bf%e7%94%a8>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpdump -i eth0 port <span style=color:#ae81ff>80</span> -nn -X
</span></span></code></pre></div><h3 id=3-使用-prometheus--grafana-监控><strong>(3) 使用 Prometheus + Grafana 监控</strong>
<a class=anchor href=#3-%e4%bd%bf%e7%94%a8-prometheus--grafana-%e7%9b%91%e6%8e%a7>#</a></h3><p>可以部署 <code>cAdvisor</code>、<code>node-exporter</code>、<code>Cilium Hubble</code> 监控网络性能，及时发现异常情况。</p><hr><h2 id=总结><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><table><thead><tr><th>优化方向</th><th>具体措施</th></tr></thead><tbody><tr><td><strong>CNI 插件优化</strong></td><td>选择高性能 CNI，如 Cilium（eBPF）、Calico（BGP）</td></tr><tr><td><strong>MTU 调整</strong></td><td>降低 <code>VXLAN</code> 额外开销，如 <code>MTU=1400</code></td></tr><tr><td><strong>TCP 参数优化</strong></td><td>调整 <code>tcp_fastopen</code>，减少延迟</td></tr><tr><td><strong>优化 kube-proxy</strong></td><td>使用 <code>ipvs</code> 代替 <code>iptables</code>，提升 Service 访问速度</td></tr><tr><td><strong>优化 CoreDNS</strong></td><td>开启缓存，减少 DNS 解析延迟</td></tr><tr><td><strong>优化负载均衡</strong></td><td><code>externalTrafficPolicy: Local</code>，避免 NAT</td></tr><tr><td><strong>使用 eBPF</strong></td><td>替代 iptables，提升网络转发性能</td></tr><tr><td><strong>监控网络</strong></td><td><code>ping</code>、<code>iperf3</code>、<code>tcpdump</code>、<code>Prometheus</code> 监控</td></tr></tbody></table><p>这些优化方案可以 <strong>降低 Kubernetes 网络延迟，提高吞吐量，减少丢包</strong>，从而提升整个集群的性能。🚀</p><h1 id=iptables和ipvs的区别>iptables和ipvs的区别？
<a class=anchor href=#iptables%e5%92%8cipvs%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h1><p>在 Kubernetes <code>kube-proxy</code> 中，<strong>iptables</strong> 和 <strong>IPVS</strong> 是两种不同的 <code>Service</code> 代理模式，它们的主要区别如下：</p><hr><h2 id=1-基本概念><strong>1. 基本概念</strong>
<a class=anchor href=#1-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>iptables</strong></th><th><strong>IPVS（IP Virtual Server）</strong></th></tr></thead><tbody><tr><td><strong>工作方式</strong></td><td>规则匹配（基于 <code>Netfilter</code>）</td><td>连接跟踪（基于 <code>Netfilter</code>）</td></tr><tr><td><strong>性能</strong></td><td>规则多时性能下降（O(n) 复杂度）</td><td>高性能，O(1) 复杂度</td></tr><tr><td><strong>适用场景</strong></td><td>适用于小型集群</td><td>适用于大规模集群</td></tr><tr><td><strong>负载均衡算法</strong></td><td>仅支持 <code>随机</code>、<code>轮询</code></td><td>支持多种调度算法（<code>rr</code>、<code>wlc</code>、<code>lc</code>、<code>lblc</code> 等）</td></tr><tr><td><strong>连接跟踪</strong></td><td>依赖 <code>conntrack</code>，性能受限</td><td>独立连接跟踪，高吞吐</td></tr><tr><td><strong>规则管理</strong></td><td>规则较难管理</td><td>规则管理更灵活</td></tr></tbody></table><hr><h2 id=2-iptables-解析><strong>2. iptables 解析</strong>
<a class=anchor href=#2-iptables-%e8%a7%a3%e6%9e%90>#</a></h2><h3 id=iptables-工作原理><strong>iptables 工作原理</strong>
<a class=anchor href=#iptables-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h3><ul><li><code>iptables</code> 是 <code>Netfilter</code> 的一部分，基于规则匹配来进行流量转发。</li><li><code>kube-proxy</code> 运行在每个节点上，通过 <code>iptables</code> 规则来 NAT 访问 <code>ClusterIP</code>。</li><li><code>iptables</code> 规则匹配是 <strong>线性查找（O(n)）</strong>，规则越多，性能越低。</li></ul><h3 id=示例><strong>示例</strong>
<a class=anchor href=#%e7%a4%ba%e4%be%8b>#</a></h3><p>使用 <code>iptables -t nat -L -n --line-numbers</code> 查看 <code>KUBE-SERVICES</code> 规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Chain KUBE-SERVICES <span style=color:#f92672>(</span><span style=color:#ae81ff>2</span> references<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>num  target     prot opt source               destination
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>    KUBE-MARK-MASQ  all  --  0.0.0.0/0      10.96.0.1    /* default/kubernetes:https cluster IP */
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>    DNAT       tcp  --  0.0.0.0/0      10.96.0.1     to:192.168.1.100:6443
</span></span></code></pre></div><ul><li>规则按顺序匹配（O(n)），当规则较多时会影响性能。</li><li><code>iptables</code> 适用于 <strong>小规模集群</strong>，但 <strong>大规模规则时性能下降</strong>。</li></ul><hr><h2 id=3-ipvs-解析><strong>3. IPVS 解析</strong>
<a class=anchor href=#3-ipvs-%e8%a7%a3%e6%9e%90>#</a></h2><h3 id=ipvs-工作原理><strong>IPVS 工作原理</strong>
<a class=anchor href=#ipvs-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86>#</a></h3><ul><li><strong>IPVS（IP Virtual Server）</strong> 是 <code>Linux Kernel</code> 提供的 <strong>四层负载均衡</strong> 方案，基于 <code>Netfilter</code>。</li><li><code>kube-proxy</code> 使用 <code>IPVS</code> 直接在 <strong>内核态</strong> 处理流量，支持 <strong>高并发和低延迟</strong>。</li><li>IPVS 采用 <strong>哈希表（O(1)）</strong> 查找，提高了大规模 <code>Service</code> 的性能。</li></ul><h3 id=示例-1><strong>示例</strong>
<a class=anchor href=#%e7%a4%ba%e4%be%8b-1>#</a></h3><p>使用 <code>ipvsadm -L -n</code> 查看 <code>IPVS</code> 规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>IP Virtual Server version 1.2.1 <span style=color:#f92672>(</span>size<span style=color:#f92672>=</span>4096<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Prot LocalAddress:Port   Scheduler Flags
</span></span><span style=display:flex><span>  -&gt; RemoteAddress:Port  Forward Weight ActiveConn InActConn
</span></span><span style=display:flex><span>TCP  10.96.0.1:443 rr
</span></span><span style=display:flex><span>  -&gt; 192.168.1.100:6443 Masq    <span style=color:#ae81ff>1</span>      <span style=color:#ae81ff>3</span>          <span style=color:#ae81ff>5</span>
</span></span></code></pre></div><ul><li><code>rr</code> 表示轮询调度。</li><li>IPVS <strong>直接在内核处理转发</strong>，支持 <code>TCP</code>/<code>UDP</code>/<code>SCTP</code> 协议，吞吐量更高。</li></ul><hr><h2 id=4-iptables-vs-ipvs-性能对比><strong>4. iptables vs IPVS 性能对比</strong>
<a class=anchor href=#4-iptables-vs-ipvs-%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94>#</a></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>iptables</strong></th><th><strong>IPVS</strong></th></tr></thead><tbody><tr><td><strong>处理模式</strong></td><td>规则匹配</td><td>内核哈希表</td></tr><tr><td><strong>规则查找</strong></td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>流量转发</strong></td><td><code>SNAT</code></td><td><code>Direct Routing</code></td></tr><tr><td><strong>负载均衡算法</strong></td><td>仅 <code>随机</code> 和 <code>轮询</code></td><td><code>rr</code>、<code>lc</code>、<code>wlc</code>、<code>lblc</code> 等</td></tr><tr><td><strong>适用场景</strong></td><td>小规模集群</td><td>大规模集群</td></tr></tbody></table><p>当 Kubernetes <code>Service</code> 数量 <strong>较少（&lt;100）</strong> 时，<code>iptables</code> 的性能足够；但当 <code>Service</code> 数量 <strong>超过 500+</strong> 时，建议使用 <code>IPVS</code>。</p><hr><h2 id=5-开启-ipvs-模式><strong>5. 开启 IPVS 模式</strong>
<a class=anchor href=#5-%e5%bc%80%e5%90%af-ipvs-%e6%a8%a1%e5%bc%8f>#</a></h2><h3 id=1-检查内核模块><strong>(1) 检查内核模块</strong>
<a class=anchor href=#1-%e6%a3%80%e6%9f%a5%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97>#</a></h3><p>IPVS 依赖以下内核模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>lsmod | grep ip_vs
</span></span></code></pre></div><p>如果没有加载，可以手动加载：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>modprobe ip_vs
</span></span><span style=display:flex><span>modprobe ip_vs_rr
</span></span><span style=display:flex><span>modprobe ip_vs_wrr
</span></span><span style=display:flex><span>modprobe ip_vs_sh
</span></span></code></pre></div><h3 id=2-修改-kube-proxy-配置><strong>(2) 修改 kube-proxy 配置</strong>
<a class=anchor href=#2-%e4%bf%ae%e6%94%b9-kube-proxy-%e9%85%8d%e7%bd%ae>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit configmap -n kube-system kube-proxy
</span></span></code></pre></div><p>修改：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;ipvs&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>ipvs</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>scheduler</span>: <span style=color:#e6db74>&#34;rr&#34;</span>  <span style=color:#75715e># 轮询调度</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>strictARP</span>: <span style=color:#66d9ef>true</span>  <span style=color:#75715e># 避免流量转发错误</span>
</span></span></code></pre></div><h3 id=3-重启><strong>(3) 重启 <code>kube-proxy</code></strong>
<a class=anchor href=#3-%e9%87%8d%e5%90%af>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod -n kube-system -l k8s-app<span style=color:#f92672>=</span>kube-proxy
</span></span></code></pre></div><h3 id=4-验证-ipvs-是否生效><strong>(4) 验证 IPVS 是否生效</strong>
<a class=anchor href=#4-%e9%aa%8c%e8%af%81-ipvs-%e6%98%af%e5%90%a6%e7%94%9f%e6%95%88>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ipvsadm -L -n
</span></span></code></pre></div><p>如果输出包含 <code>IPVS</code> 规则，说明配置成功。</p><hr><h2 id=6-总结><strong>6. 总结</strong>
<a class=anchor href=#6-%e6%80%bb%e7%bb%93>#</a></h2><table><thead><tr><th><strong>选择方式</strong></th><th><strong>建议</strong></th></tr></thead><tbody><tr><td><strong>小规模集群（&lt;100 Services）</strong></td><td><code>iptables</code> 适用</td></tr><tr><td><strong>大规模集群（>500 Services）</strong></td><td><code>IPVS</code> 性能更优</td></tr><tr><td><strong>流量转发性能要求高</strong></td><td><code>IPVS</code> 更优</td></tr><tr><td><strong>需要多种负载均衡算法</strong></td><td><code>IPVS</code></td></tr></tbody></table><ul><li><strong>iptables 适合小规模集群</strong>，但当 <code>Service</code> 规则过多时，规则匹配会变慢。</li><li><strong>IPVS 适用于大规模集群</strong>，使用内核 <code>O(1)</code> 哈希查找，提高了 <code>Service</code> 性能。</li><li><strong>如果 <code>Service</code> 数量超过 500+</strong>，建议切换到 <code>IPVS</code>，避免 <code>iptables</code> 规则过多导致的性能下降。 🚀</li></ul><h1 id=现在k8s默认的kube-proxy的模式是啥ipvs还是iptables为啥>现在k8s默认的kube-proxy的模式是啥ipvs还是iptables，为啥？
<a class=anchor href=#%e7%8e%b0%e5%9c%a8k8s%e9%bb%98%e8%ae%a4%e7%9a%84kube-proxy%e7%9a%84%e6%a8%a1%e5%bc%8f%e6%98%af%e5%95%a5ipvs%e8%bf%98%e6%98%afiptables%e4%b8%ba%e5%95%a5>#</a></h1><h3 id=kubernetes-默认的-kube-proxy-模式是><strong>Kubernetes 默认的 kube-proxy 模式是 <code>iptables</code></strong>
<a class=anchor href=#kubernetes-%e9%bb%98%e8%ae%a4%e7%9a%84-kube-proxy-%e6%a8%a1%e5%bc%8f%e6%98%af>#</a></h3><p>Kubernetes 目前默认使用 <code>iptables</code> 作为 <code>kube-proxy</code> 的模式，而不是 <code>IPVS</code>，主要原因如下：</p><hr><h3 id=1><strong>1. <code>iptables</code> 是更通用的默认选择</strong>
<a class=anchor href=#1>#</a></h3><ul><li><strong>广泛兼容性</strong>：<code>iptables</code> 在大多数 Linux 发行版上默认可用，无需额外的内核模块。</li><li><strong>简单易用</strong>：基于 <code>Netfilter</code>，配置相对简单，易于维护和调试。</li><li><strong>足够的性能</strong>：对于 <strong>中小规模集群（&lt;500 个 Service）</strong>，<code>iptables</code> 性能足够，不会成为瓶颈。</li></ul><hr><h3 id=2><strong>2. <code>IPVS</code> 依赖额外的内核模块</strong>
<a class=anchor href=#2>#</a></h3><ul><li><pre tabindex=0><code>IPVS
</code></pre><p>需要加载</p><pre tabindex=0><code>ip_vs
</code></pre><p>相关的内核模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>modprobe ip_vs
</span></span><span style=display:flex><span>modprobe ip_vs_rr
</span></span><span style=display:flex><span>modprobe ip_vs_wrr
</span></span><span style=display:flex><span>modprobe ip_vs_sh
</span></span></code></pre></div></li><li><p>部分精简版 Linux 发行版（如部分 <code>Ubuntu</code> 或 <code>Alpine</code> 变种）默认不包含 <code>IPVS</code> 相关模块，需要手动安装或编译。</p></li><li><p>这导致 <code>IPVS</code> <strong>在所有环境下无法保证开箱即用</strong>，而 <code>iptables</code> 不受影响。</p></li></ul><hr><h3 id=3><strong>3. <code>iptables</code> 对中小规模集群足够</strong>
<a class=anchor href=#3>#</a></h3><ul><li><code>iptables</code> 在 <strong>少量 <code>Service</code> 场景下（&lt;500 个 Service）</strong> 性能足够，不会明显影响集群。</li><li>Kubernetes 目标是 <strong>开箱即用</strong>，默认使用 <code>iptables</code> 可以 <strong>避免 <code>IPVS</code> 的额外依赖问题</strong>，兼容性更好。</li></ul><hr><h3 id=4-kubernetes-并没有放弃><strong>4. Kubernetes 并没有放弃 <code>IPVS</code></strong>
<a class=anchor href=#4-kubernetes-%e5%b9%b6%e6%b2%a1%e6%9c%89%e6%94%be%e5%bc%83>#</a></h3><ul><li><p>如果集群规模较大（>500 Service），建议手动切换</p><pre tabindex=0><code>kube-proxy
</code></pre><p>到</p><pre tabindex=0><code>IPVS
</code></pre><p>模式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;ipvs&#34;</span>
</span></span></code></pre></div></li><li><p><code>IPVS</code> 在 <strong>大规模 Service 场景</strong> 下比 <code>iptables</code> 更优，特别是在高并发、高吞吐量的情况下。</p></li></ul><hr><h3 id=5-如何检查当前><strong>5. 如何检查当前 <code>kube-proxy</code> 使用的模式？</strong>
<a class=anchor href=#5-%e5%a6%82%e4%bd%95%e6%a3%80%e6%9f%a5%e5%bd%93%e5%89%8d>#</a></h3><p>你可以运行以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap -n kube-system kube-proxy -o yaml | grep mode
</span></span></code></pre></div><p>如果返回：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>mode</span>: <span style=color:#e6db74>&#34;iptables&#34;</span>
</span></span></code></pre></div><p>说明 <code>kube-proxy</code> 运行在 <code>iptables</code> 模式。</p><p>如果想切换到 <code>IPVS</code>，需要手动修改 <code>kube-proxy</code> 的 <code>ConfigMap</code> 并重启 <code>kube-proxy</code> Pod。</p><hr><h3 id=6-结论><strong>6. 结论</strong>
<a class=anchor href=#6-%e7%bb%93%e8%ae%ba>#</a></h3><ul><li><strong>默认 <code>kube-proxy</code> 模式是 <code>iptables</code></strong>，因为它<strong>兼容性更好</strong>，适用于<strong>大多数 Linux 发行版</strong>，并且在<strong>中小规模集群下足够稳定</strong>。</li><li><strong>如果集群规模较大（>500 Services）</strong>，推荐手动切换到 <strong><code>IPVS</code> 模式</strong>，提升 <code>kube-proxy</code> 负载均衡性能。 🚀</li></ul><h6><a class=anchor href=#>#</a></h6><h1 id=最新版本的k8s默认的kube-proxy的模式是啥ipvs还是iptables>最新版本的k8s，默认的kube-proxy的模式是啥ipvs还是iptables
<a class=anchor href=#%e6%9c%80%e6%96%b0%e7%89%88%e6%9c%ac%e7%9a%84k8s%e9%bb%98%e8%ae%a4%e7%9a%84kube-proxy%e7%9a%84%e6%a8%a1%e5%bc%8f%e6%98%af%e5%95%a5ipvs%e8%bf%98%e6%98%afiptables>#</a></h1><p>截至 Kubernetes 1.32 版本，<code>kube-proxy</code> 默认使用 <code>iptables</code> 模式。 citeturn0search7</p><p>在 Kubernetes 1.29 版本中，引入了 <code>nftables</code> 模式作为 Alpha 特性，旨在解决 <code>iptables</code> 模式下的性能问题。 目前，<code>nftables</code> 模式已进入 Beta 阶段，预计将在 1.33 版本中达到一般可用（GA）状态。 然而，出于兼容性考虑，即使 <code>nftables</code> 模式达到 GA，<code>iptables</code> 仍将作为默认模式。 citeturn0search0</p><p>需要注意的是，<code>ipvs</code> 模式在 Kubernetes 1.8 版本中引入，提供了更高效的负载均衡性能。 然而，<code>ipvs</code> 模式需要节点上预先安装 <code>ipvs</code> 内核模块。 如果这些模块未安装，<code>kube-proxy</code> 将回退到 <code>iptables</code> 模式。 citeturn0search1</p><p>因此，虽然 Kubernetes 提供了多种 <code>kube-proxy</code> 模式供用户选择，但默认情况下仍采用 <code>iptables</code> 模式。</p><h3 id=kubernetes-中-kube-proxy-的关键点总结><strong>Kubernetes 中 kube-proxy 的关键点总结</strong>
<a class=anchor href=#kubernetes-%e4%b8%ad-kube-proxy-%e7%9a%84%e5%85%b3%e9%94%ae%e7%82%b9%e6%80%bb%e7%bb%93>#</a></h3><h4 id=1-kube-proxy-的作用><strong>1. kube-proxy 的作用</strong>
<a class=anchor href=#1-kube-proxy-%e7%9a%84%e4%bd%9c%e7%94%a8>#</a></h4><ul><li>运行在 Kubernetes 集群的每个节点上（除非使用了自定义替代组件）。</li><li>负责管理 Service 的虚拟 IP（ClusterIP），实现流量转发。</li><li>监听 Service 和 EndpointSlice 资源的变化，并据此调整网络规则。</li></ul><h4 id=2-kube-proxy-的工作机制><strong>2. kube-proxy 的工作机制</strong>
<a class=anchor href=#2-kube-proxy-%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6>#</a></h4><ul><li>通过不同的代理模式（iptables、ipvs、nftables）配置节点，使流量能够正确地转发到后端 Pod 或其他端点。</li><li>规则与 Kubernetes API 服务器状态同步，确保 Service 和 EndpointSlice 变更时网络规则及时更新。</li></ul><h4 id=3-为什么-kubernetes-需要代理转发流量><strong>3. 为什么 Kubernetes 需要代理转发流量？</strong>
<a class=anchor href=#3-%e4%b8%ba%e4%bb%80%e4%b9%88-kubernetes-%e9%9c%80%e8%a6%81%e4%bb%a3%e7%90%86%e8%bd%ac%e5%8f%91%e6%b5%81%e9%87%8f>#</a></h4><ul><li>DNS 解析受 TTL 影响，部分实现不会严格遵守 TTL，可能导致缓存问题。</li><li>某些应用仅在启动时解析 DNS，导致后端 Pod 变更时无法正确更新。</li><li>频繁解析 DNS 可能会增加负载，不易管理。</li></ul><h4 id=4-代理模式><strong>4. 代理模式</strong>
<a class=anchor href=#4-%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f>#</a></h4><h5 id=1-iptables-模式><strong>(1) iptables 模式</strong>
<a class=anchor href=#1-iptables-%e6%a8%a1%e5%bc%8f>#</a></h5><ul><li>适用于 Linux 节点。</li><li>通过 iptables 规则实现 Service 虚拟 IP 到后端 Pod 的转发。</li><li>规则由 kube-proxy 监听 Service 变更并动态更新。</li><li>在拥有大量 Pod 和 Service 的大规模集群中，可能导致规则更新较慢。</li></ul><h5 id=2-ipvs-模式><strong>(2) IPVS 模式</strong>
<a class=anchor href=#2-ipvs-%e6%a8%a1%e5%bc%8f>#</a></h5><ul><li>适用于 Linux 节点。</li><li>基于 Linux 内核的 IPVS 机制，性能优于 iptables 模式。</li><li>通过哈希表管理转发表，查询效率高，适用于大规模集群。</li><li>支持多种流量调度算法，如轮询（rr）、最少连接（lc）、源哈希（sh）等。</li><li>需要 IPVS 内核模块支持，kube-proxy 启动前需确保 IPVS 可用。</li></ul><h5 id=3-nftables-模式><strong>(3) nftables 模式</strong>
<a class=anchor href=#3-nftables-%e6%a8%a1%e5%bc%8f>#</a></h5><ul><li>适用于 Linux 节点。</li><li>使用 <code>nftables</code> 替代 <code>iptables</code> 来管理流量转发规则。</li><li>目前较少使用，主要适用于不支持 <code>iptables</code> 或 <code>ipvs</code> 的场景。</li></ul><h5 id=4-windows-kernelspace-模式><strong>(4) Windows Kernelspace 模式</strong>
<a class=anchor href=#4-windows-kernelspace-%e6%a8%a1%e5%bc%8f>#</a></h5><ul><li>适用于 Windows 节点。</li><li>直接在 Windows 内核空间配置转发规则。</li></ul><h4 id=5-iptables-模式的优化><strong>5. iptables 模式的优化</strong>
<a class=anchor href=#5-iptables-%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%bc%98%e5%8c%96>#</a></h4><ul><li><pre tabindex=0><code>minSyncPeriod
</code></pre><p>控制规则最短同步间隔，默认值</p><pre tabindex=0><code>1s
</code></pre><p>。</p><ul><li>值越小，规则同步越及时，但会增加 CPU 负担。</li><li>适当增大可减少频繁更新，提高大规模集群的效率。</li></ul></li><li><pre tabindex=0><code>syncPeriod
</code></pre><p>控制定期同步时间，默认</p><pre tabindex=0><code>30s
</code></pre><p>。</p><ul><li>影响外部干预 iptables 规则后的自动恢复速度。</li><li>过去有些集群设为 <code>1h</code> 以减少更新负载，但现在不推荐。</li></ul></li></ul><h4 id=6-ipvs-代理模式的优势><strong>6. IPVS 代理模式的优势</strong>
<a class=anchor href=#6-ipvs-%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%bc%98%e5%8a%bf>#</a></h4><ul><li>相比 iptables，IPVS 具有更低的转发延迟和更高的吞吐量。</li><li>提供更丰富的负载均衡调度算法，如轮询、最少连接、哈希等。</li><li>适合大规模 Kubernetes 集群。</li></ul><h4 id=7-使用-ipvs-模式的注意事项><strong>7. 使用 IPVS 模式的注意事项</strong>
<a class=anchor href=#7-%e4%bd%bf%e7%94%a8-ipvs-%e6%a8%a1%e5%bc%8f%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h4><ul><li>需要在节点上启用 IPVS 内核模块，否则 kube-proxy 启动失败。</li><li>默认调度算法是 <code>rr</code>（轮询），可通过 <code>kube-proxy</code> 配置修改。</li><li>需要 <code>ipvsadm</code> 命令行工具来查看和管理 IPVS 规则。</li></ul><hr><p>这就是 Kubernetes 中 kube-proxy 的核心要点，你可以根据自己的需求选择合适的代理模式。 🚀</p><h1 id=ingress和ingress-controller区别>ingress和ingress-controller区别？
<a class=anchor href=#ingress%e5%92%8cingress-controller%e5%8c%ba%e5%88%ab>#</a></h1><h3 id=ingress-和-ingress-controller-的区别><strong>Ingress 和 Ingress Controller 的区别</strong>
<a class=anchor href=#ingress-%e5%92%8c-ingress-controller-%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><h4 id=1-什么是-ingress><strong>1. 什么是 Ingress？</strong>
<a class=anchor href=#1-%e4%bb%80%e4%b9%88%e6%98%af-ingress>#</a></h4><ul><li><strong>Ingress 是 Kubernetes 的 API 资源</strong>，用于定义集群内服务的外部访问规则。</li><li>提供基于 HTTP/HTTPS 的路由，允许将外部流量引导到集群内部的 Service。</li><li>可以配置<strong>主机名、路径、TLS 证书、重定向、流量规则等</strong>。</li></ul><p>示例 Ingress 资源：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>example-ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>host</span>: <span style=color:#ae81ff>example.com</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>http</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>pathType</span>: <span style=color:#ae81ff>Prefix</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>port</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>number</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p><strong>作用</strong>：</p><ul><li>访问 <code>http://example.com</code> 时，流量会被转发到 <code>my-service</code> 的 <code>80</code> 端口。</li></ul><hr><h4 id=2-什么是-ingress-controller><strong>2. 什么是 Ingress Controller？</strong>
<a class=anchor href=#2-%e4%bb%80%e4%b9%88%e6%98%af-ingress-controller>#</a></h4><ul><li><strong>Ingress Controller 是实际执行流量管理的组件</strong>。</li><li>它监听 Kubernetes 中的 Ingress 资源，并根据规则配置负载均衡器（如 Nginx、Traefik、HAProxy 等）。</li><li><strong>Ingress 本身只是规则定义，Ingress Controller 负责将规则转化为实际的流量转发行为</strong>。</li></ul><p>常见的 Ingress Controller：</p><ul><li><strong>Nginx Ingress Controller</strong>（最常用）</li><li><strong>Traefik</strong></li><li><strong>HAProxy Ingress</strong></li><li><strong>Istio Gateway</strong>（结合 Service Mesh 使用）</li><li><strong>Contour</strong></li><li><strong>Kong Ingress Controller</strong>（支持 API 网关功能）</li></ul><p>示例：使用 Nginx 作为 Ingress Controller</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
</span></span></code></pre></div><hr><h4 id=3-核心区别><strong>3. 核心区别</strong>
<a class=anchor href=#3-%e6%a0%b8%e5%bf%83%e5%8c%ba%e5%88%ab>#</a></h4><table><thead><tr><th>对比项</th><th>Ingress</th><th>Ingress Controller</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>Kubernetes 资源对象</td><td>控制 Ingress 资源的实际组件</td></tr><tr><td><strong>作用</strong></td><td>定义访问规则</td><td>解析 Ingress 规则并执行负载均衡</td></tr><tr><td><strong>是否独立工作</strong></td><td>不能单独工作，需要 Ingress Controller</td><td>需要配合 Ingress 资源</td></tr><tr><td><strong>示例</strong></td><td><code>Ingress</code> YAML 资源</td><td>Nginx、Traefik、HAProxy 等</td></tr></tbody></table><hr><h4 id=4-总结-1><strong>4. 总结</strong>
<a class=anchor href=#4-%e6%80%bb%e7%bb%93-1>#</a></h4><ul><li><strong>Ingress 是规则</strong>，定义如何让外部访问集群内部服务。</li><li><strong>Ingress Controller 是执行者</strong>，它根据 Ingress 规则配置负载均衡器，使流量正确转发。</li><li>Ingress 需要 Ingress Controller 才能生效，否则不会生效。</li></ul><p><strong>🚀 记住：Ingress 只是规则，Ingress Controller 才是真正实现流量转发的组件！</strong></p><h1 id=目前用的ingress-controller有哪几种>目前用的ingress-controller有哪几种？
<a class=anchor href=#%e7%9b%ae%e5%89%8d%e7%94%a8%e7%9a%84ingress-controller%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d>#</a></h1><p>目前主流的 <strong>Ingress Controller</strong> 主要有以下几种：</p><h3 id=1-nginx-ingress-controller最常见><strong>1. Nginx Ingress Controller</strong>（最常见）
<a class=anchor href=#1-nginx-ingress-controller%e6%9c%80%e5%b8%b8%e8%a7%81>#</a></h3><ul><li><p><strong>特点</strong>：基于 Nginx，功能丰富，支持 HTTPS、重定向、Rewrite、负载均衡等。</p></li><li><p><strong>适用场景</strong>：适合大多数 Kubernetes 集群，官方 Kubernetes 推荐。</p></li><li><p>安装方式</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
</span></span></code></pre></div></li><li><p><strong>GitHub</strong>：<a href=https://github.com/kubernetes/ingress-nginx>kubernetes/ingress-nginx</a></p></li></ul><hr><h3 id=2-traefik-ingress-controller云原生友好><strong>2. Traefik Ingress Controller</strong>（云原生友好）
<a class=anchor href=#2-traefik-ingress-controller%e4%ba%91%e5%8e%9f%e7%94%9f%e5%8f%8b%e5%a5%bd>#</a></h3><ul><li><p><strong>特点</strong>：支持动态配置、自动发现、支持 TCP/UDP、多协议负载均衡，默认自带可视化 Web UI。</p></li><li><p><strong>适用场景</strong>：适用于微服务架构，特别是使用 Kubernetes CRD 进行高级路由管理的场景。</p></li><li><p>安装方式</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install traefik traefik/traefik
</span></span></code></pre></div></li><li><p><strong>GitHub</strong>：<a href=https://github.com/traefik/traefik>traefik/traefik</a></p></li></ul><hr><h3 id=3-haproxy-ingress-controller高性能><strong>3. HAProxy Ingress Controller</strong>（高性能）
<a class=anchor href=#3-haproxy-ingress-controller%e9%ab%98%e6%80%a7%e8%83%bd>#</a></h3><ul><li><p><strong>特点</strong>：性能极高，支持高级负载均衡策略，原生支持 TCP、gRPC 和 WebSocket。</p></li><li><p><strong>适用场景</strong>：对高吞吐、高性能要求较高的场景，如银行、电信、游戏等行业。</p></li><li><p>安装方式</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install haproxy-ingress haproxy-ingress/haproxy-ingress
</span></span></code></pre></div></li><li><p><strong>GitHub</strong>：<a href=https://github.com/jcmoraisjr/haproxy-ingress>jcmoraisjr/haproxy-ingress</a></p></li></ul><hr><h3 id=4-kong-ingress-controllerapi-网关><strong>4. Kong Ingress Controller</strong>（API 网关）
<a class=anchor href=#4-kong-ingress-controllerapi-%e7%bd%91%e5%85%b3>#</a></h3><ul><li><p><strong>特点</strong>：不仅是 Ingress Controller，还是 API Gateway，支持身份认证、速率限制、日志管理等功能。</p></li><li><p><strong>适用场景</strong>：API 管理、微服务架构、需要 API 级别控制的企业级应用。</p></li><li><p>安装方式</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install kong kong/kong
</span></span></code></pre></div></li><li><p><strong>GitHub</strong>：<a href=https://github.com/Kong/kubernetes-ingress-controller>Kong/kubernetes-ingress-controller</a></p></li></ul><hr><h3 id=5-istio-gatewayservice-mesh-方案><strong>5. Istio Gateway</strong>（Service Mesh 方案）
<a class=anchor href=#5-istio-gatewayservice-mesh-%e6%96%b9%e6%a1%88>#</a></h3><ul><li><p><strong>特点</strong>：依赖 Istio Service Mesh，提供更强的流量控制能力，如流量镜像、熔断、流量拆分等。</p></li><li><p><strong>适用场景</strong>：微服务架构、需要强大流量控制能力的企业级应用。</p></li><li><p>安装方式</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>istioctl install --set profile<span style=color:#f92672>=</span>demo
</span></span></code></pre></div></li><li><p><strong>GitHub</strong>：<a href=https://istio.io/latest/docs/reference/config/networking/gateway/>Istio Gateway</a></p></li></ul><hr><h3 id=6-contour-ingress-controllerenvoy-代理><strong>6. Contour Ingress Controller</strong>（Envoy 代理）
<a class=anchor href=#6-contour-ingress-controllerenvoy-%e4%bb%a3%e7%90%86>#</a></h3><ul><li><p><strong>特点</strong>：基于 Envoy 代理，支持 HTTP/2、gRPC 代理，性能优秀。</p></li><li><p><strong>适用场景</strong>：Envoy 生态的 Kubernetes 负载均衡方案。</p></li><li><p>安装方式</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f https://projectcontour.io/quickstart/contour.yaml
</span></span></code></pre></div></li><li><p><strong>GitHub</strong>：<a href=https://github.com/projectcontour/contour>projectcontour/contour</a></p></li></ul><hr><h3 id=7-gce-ingress-controller适用于-gcp><strong>7. GCE Ingress Controller</strong>（适用于 GCP）
<a class=anchor href=#7-gce-ingress-controller%e9%80%82%e7%94%a8%e4%ba%8e-gcp>#</a></h3><ul><li><strong>特点</strong>：Google Cloud 官方提供，依赖 Google Load Balancer。</li><li><strong>适用场景</strong>：Kubernetes 部署在 Google Kubernetes Engine（GKE）时使用。</li><li><strong>GitHub</strong>：<a href=https://github.com/kubernetes/ingress-gce>kubernetes/ingress-gce</a></li></ul><hr><h3 id=8-aws-alb-ingress-controller适用于-aws><strong>8. AWS ALB Ingress Controller</strong>（适用于 AWS）
<a class=anchor href=#8-aws-alb-ingress-controller%e9%80%82%e7%94%a8%e4%ba%8e-aws>#</a></h3><ul><li><strong>特点</strong>：基于 AWS Application Load Balancer（ALB），深度集成 AWS 生态。</li><li><strong>适用场景</strong>：Kubernetes 部署在 AWS EKS 上时使用。</li><li><strong>GitHub</strong>：<a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller>kubernetes-sigs/aws-load-balancer-controller</a></li></ul><hr><h3 id=9-f5-big-ip-ingress-controller企业级><strong>9. F5 BIG-IP Ingress Controller</strong>（企业级）
<a class=anchor href=#9-f5-big-ip-ingress-controller%e4%bc%81%e4%b8%9a%e7%ba%a7>#</a></h3><ul><li><strong>特点</strong>：支持 F5 BIG-IP 设备，适用于企业级网络安全和高可用需求。</li><li><strong>适用场景</strong>：使用 F5 硬件设备的大型企业。</li><li><strong>GitHub</strong>：<a href=https://github.com/F5Networks/k8s-bigip-ctlr>F5Networks/k8s-bigip-ctlr</a></li></ul><hr><h3 id=总结不同-ingress-controller-适用场景><strong>总结：不同 Ingress Controller 适用场景</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93%e4%b8%8d%e5%90%8c-ingress-controller-%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h3><table><thead><tr><th>Ingress Controller</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Nginx</strong></td><td>通用方案，适合大部分 Kubernetes 部署</td></tr><tr><td><strong>Traefik</strong></td><td>云原生友好，支持动态发现</td></tr><tr><td><strong>HAProxy</strong></td><td>高性能、高并发场景</td></tr><tr><td><strong>Kong</strong></td><td>适用于 API Gateway 需求</td></tr><tr><td><strong>Istio Gateway</strong></td><td>结合 Service Mesh 提供更强大流量控制</td></tr><tr><td><strong>Contour</strong></td><td>基于 Envoy，适用于 HTTP/2 和 gRPC</td></tr><tr><td><strong>GCE Ingress</strong></td><td>适用于 Google Cloud（GKE）</td></tr><tr><td><strong>AWS ALB Ingress</strong></td><td>适用于 AWS（EKS）</td></tr><tr><td><strong>F5 BIG-IP</strong></td><td>适用于企业级负载均衡解决方案</td></tr></tbody></table><p>🚀 <strong>选择建议</strong>：</p><ul><li><strong>普通 Kubernetes 方案</strong> → <strong>Nginx Ingress</strong></li><li><strong>需要 API 网关功能</strong> → <strong>Kong Ingress</strong></li><li><strong>服务网格（Service Mesh）</strong> → <strong>Istio Gateway</strong></li><li><strong>高性能、低延迟需求</strong> → <strong>HAProxy</strong></li><li><strong>动态发现、可视化 UI</strong> → <strong>Traefik</strong></li><li><strong>使用 Google Cloud / AWS</strong> → <strong>GCE / ALB Ingress</strong></li></ul><h1 id=上传文件提示上传文件过大怎么处理nginx配置ingress-controller的注解>上传文件，提示上传文件过大怎么处理？nginx配置，ingress-controller的注解。
<a class=anchor href=#%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6%e6%8f%90%e7%a4%ba%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6%e8%bf%87%e5%a4%a7%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86nginx%e9%85%8d%e7%bd%aeingress-controller%e7%9a%84%e6%b3%a8%e8%a7%a3>#</a></h1><p>如果上传文件时提示文件过大，可以从 <strong>Nginx 配置</strong> 和 <strong>Ingress Controller 注解</strong> 两个方面处理。</p><hr><h2 id=1-nginx-配置适用于独立-nginx-部署><strong>1. Nginx 配置（适用于独立 Nginx 部署）</strong>
<a class=anchor href=#1-nginx-%e9%85%8d%e7%bd%ae%e9%80%82%e7%94%a8%e4%ba%8e%e7%8b%ac%e7%ab%8b-nginx-%e9%83%a8%e7%bd%b2>#</a></h2><p>修改 Nginx 配置文件 <strong>nginx.conf</strong> 或者相应的 <strong>server 块</strong>，增加 <code>client_max_body_size</code> 参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>http</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>client_max_body_size</span> <span style=color:#e6db74>100M</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>或者：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>server</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>location</span> <span style=color:#e6db74>/upload</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>client_max_body_size</span> <span style=color:#e6db74>100M</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后重启 Nginx：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl restart nginx
</span></span></code></pre></div><hr><h2 id=2-nginx-ingress-controller-配置><strong>2. Nginx Ingress Controller 配置</strong>
<a class=anchor href=#2-nginx-ingress-controller-%e9%85%8d%e7%bd%ae>#</a></h2><p>Nginx Ingress Controller 支持 <strong>自定义注解（annotations）</strong> 进行配置，常见方法有两种：</p><h3 id=方法-1在-ingress-资源中增加-annotation><strong>方法 1：在 Ingress 资源中增加 Annotation</strong>
<a class=anchor href=#%e6%96%b9%e6%b3%95-1%e5%9c%a8-ingress-%e8%b5%84%e6%ba%90%e4%b8%ad%e5%a2%9e%e5%8a%a0-annotation>#</a></h3><p>如果使用 <code>ingress-nginx</code> 控制器，可以在 Ingress 资源中添加以下注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-ingress</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nginx.ingress.kubernetes.io/proxy-body-size</span>: <span style=color:#e6db74>&#34;100m&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>host</span>: <span style=color:#ae81ff>example.com</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>http</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>pathType</span>: <span style=color:#ae81ff>Prefix</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>                <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>port</span>:
</span></span><span style=display:flex><span>                  <span style=color:#f92672>number</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p><strong>解释</strong>：</p><ul><li><code>nginx.ingress.kubernetes.io/proxy-body-size</code>：设置最大上传文件大小，默认 <strong>1M</strong>，这里改为 <strong>100M</strong>。</li></ul><hr><h3 id=方法-2修改-configmap-配置><strong>方法 2：修改 ConfigMap 配置</strong>
<a class=anchor href=#%e6%96%b9%e6%b3%95-2%e4%bf%ae%e6%94%b9-configmap-%e9%85%8d%e7%bd%ae>#</a></h3><p>如果需要全局修改 Nginx Ingress Controller 的上传限制，可以编辑 Ingress Controller 的 <code>ConfigMap</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit configmap -n ingress-nginx nginx-ingress-controller
</span></span></code></pre></div><p>添加或修改：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>proxy-body-size</span>: <span style=color:#e6db74>&#34;100m&#34;</span>
</span></span></code></pre></div><p>然后重启 Ingress Controller：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl rollout restart deployment -n ingress-nginx ingress-nginx-controller
</span></span></code></pre></div><hr><h2 id=3-helm-安装-nginx-ingress-时修改><strong>3. Helm 安装 Nginx Ingress 时修改</strong>
<a class=anchor href=#3-helm-%e5%ae%89%e8%a3%85-nginx-ingress-%e6%97%b6%e4%bf%ae%e6%94%b9>#</a></h2><p>如果是使用 <strong>Helm</strong> 安装的 <code>ingress-nginx</code>，可以在 <code>values.yaml</code> 里配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>controller</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>proxy-body-size</span>: <span style=color:#e6db74>&#34;100m&#34;</span>
</span></span></code></pre></div><p>然后执行升级：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx -f values.yaml
</span></span></code></pre></div><hr><h2 id=总结-1><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-1>#</a></h2><table><thead><tr><th>方法</th><th>适用场景</th><th>配置方式</th></tr></thead><tbody><tr><td><strong>Nginx 配置</strong></td><td>适用于独立 Nginx 部署</td><td><code>client_max_body_size 100M;</code></td></tr><tr><td><strong>Ingress Annotation</strong></td><td>适用于单个 Ingress 资源</td><td><code>nginx.ingress.kubernetes.io/proxy-body-size: "100m"</code></td></tr><tr><td><strong>修改 ConfigMap</strong></td><td>适用于全局修改 Ingress Controller</td><td><code>kubectl edit configmap -n ingress-nginx nginx-ingress-controller</code></td></tr><tr><td><strong>Helm 部署修改</strong></td><td>适用于 Helm 安装的 Ingress Controller</td><td><code>helm upgrade --install ingress-nginx ... -f values.yaml</code></td></tr></tbody></table><p>如果只是 <strong>单个 Ingress 资源</strong> 需要调整，推荐 <strong>方法 1（添加 Annotation）</strong>。
如果要 <strong>全局修改</strong>，推荐 <strong>方法 2 或 3</strong>。</p><h1 id=流量经过ingress-controller后获取不到真实ip说下原因及怎么解决>流量经过ingress-controller后获取不到真实ip，说下原因及怎么解决？
<a class=anchor href=#%e6%b5%81%e9%87%8f%e7%bb%8f%e8%bf%87ingress-controller%e5%90%8e%e8%8e%b7%e5%8f%96%e4%b8%8d%e5%88%b0%e7%9c%9f%e5%ae%9eip%e8%af%b4%e4%b8%8b%e5%8e%9f%e5%9b%a0%e5%8f%8a%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3>#</a></h1><p>流量经过 <strong>Ingress Controller</strong> 后获取不到 <strong>真实 IP</strong>，通常是因为 <strong>Nginx Ingress Controller</strong> 作为 <strong>反向代理</strong>，默认会使用自身的 IP 进行转发，导致后端 Pod 无法直接获取客户端的真实 IP。以下是常见原因及解决方案：</p><hr><h2 id=1-常见原因><strong>1. 常见原因</strong>
<a class=anchor href=#1-%e5%b8%b8%e8%a7%81%e5%8e%9f%e5%9b%a0>#</a></h2><h3 id=1-ingress-controller-作为反向代理><strong>(1) Ingress Controller 作为反向代理</strong>
<a class=anchor href=#1-ingress-controller-%e4%bd%9c%e4%b8%ba%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86>#</a></h3><ul><li>Ingress Controller <strong>默认使用代理模式</strong>，后端 Pod 看到的 IP 是 Ingress Controller 的 IP，而不是客户端的真实 IP。</li><li>解决方案：使用 <code>X-Forwarded-For</code> 头传递真实 IP，并在后端读取。</li></ul><h3 id=2-kubernetes-运行模式loadbalancer--nodeport--hostnetwork><strong>(2) Kubernetes 运行模式（LoadBalancer / NodePort / HostNetwork）</strong>
<a class=anchor href=#2-kubernetes-%e8%bf%90%e8%a1%8c%e6%a8%a1%e5%bc%8floadbalancer--nodeport--hostnetwork>#</a></h3><p>不同的部署方式会影响真实 IP 的获取：</p><ul><li>LoadBalancer 模式（ELB/ALB 等云负载均衡）<ul><li>如果前面有 <strong>云厂商的负载均衡</strong>，Ingress Controller 可能只接收到 LB 的 IP，而非客户端 IP。</li><li>解决方案：检查 <strong>云负载均衡</strong> 是否支持 <strong>直接传递真实 IP</strong>（比如开启 <code>Proxy Protocol</code>）。</li></ul></li><li>NodePort 模式<ul><li>如果 Service 类型是 <code>NodePort</code>，流量会经过 <strong>Kube-Proxy</strong> 转发，可能丢失真实 IP。</li><li>解决方案：使用 <code>externalTrafficPolicy: Local</code> 避免 SNAT。</li></ul></li><li>HostNetwork 模式<ul><li>直接使用 <strong>宿主机网络</strong> 的 Ingress Controller 可以获取真实 IP。</li></ul></li></ul><h3 id=3-snat源地址网络转换><strong>(3) SNAT（源地址网络转换）</strong>
<a class=anchor href=#3-snat%e6%ba%90%e5%9c%b0%e5%9d%80%e7%bd%91%e7%bb%9c%e8%bd%ac%e6%8d%a2>#</a></h3><ul><li>如果 Kubernetes 集群使用了 <strong>SNAT（Source NAT）</strong>，客户端 IP 可能会被替换为 Ingress Controller 的 IP。</li><li>解决方案：调整 <code>externalTrafficPolicy</code>，避免 SNAT。</li></ul><hr><h2 id=2-解决方案><strong>2. 解决方案</strong>
<a class=anchor href=#2-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88>#</a></h2><h3 id=方法-1使用><strong>方法 1：使用 <code>X-Forwarded-For</code> 传递真实 IP</strong>
<a class=anchor href=#%e6%96%b9%e6%b3%95-1%e4%bd%bf%e7%94%a8>#</a></h3><p>Nginx Ingress Controller <strong>默认支持</strong> <code>X-Forwarded-For</code> 头，我们可以在后端应用中读取该头：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>nginx.ingress.kubernetes.io/use-forwarded-headers</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span></code></pre></div><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-ingress</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nginx.ingress.kubernetes.io/use-forwarded-headers</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>host</span>: <span style=color:#ae81ff>example.com</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>http</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>pathType</span>: <span style=color:#ae81ff>Prefix</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>                <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>port</span>:
</span></span><span style=display:flex><span>                  <span style=color:#f92672>number</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><ul><li><p>后端应用需要读取</p><pre tabindex=0><code>X-Forwarded-For
</code></pre><p>头，获取</p><p>客户端真实 IP</p><p>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>X-Forwarded-For: 1.2.3.4, 10.0.0.1
</span></span></code></pre></div><p>客户端 IP = <code>1.2.3.4</code></p><p>（第一个 IP）。</p></li></ul><hr><h3 id=方法-2修改><strong>方法 2：修改 <code>externalTrafficPolicy</code> 避免 SNAT</strong>
<a class=anchor href=#%e6%96%b9%e6%b3%95-2%e4%bf%ae%e6%94%b9>#</a></h3><p>如果 Ingress Controller 通过 <code>NodePort</code> 或 <code>LoadBalancer</code> 方式暴露服务，Kubernetes 可能会进行 SNAT，丢失客户端 IP。可以修改 Service 使其直接透传流量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>ingress-nginx-controller</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>ingress-nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>LoadBalancer</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>externalTrafficPolicy</span>: <span style=color:#ae81ff>Local</span>
</span></span></code></pre></div><ul><li><code>externalTrafficPolicy: Local</code>：保持客户端原始 IP，不进行 SNAT。</li><li>适用于 <code>NodePort</code> 和 <code>LoadBalancer</code> 类型的 Service。</li></ul><hr><h3 id=方法-3使用><strong>方法 3：使用 <code>proxy-protocol</code>（适用于云负载均衡）</strong>
<a class=anchor href=#%e6%96%b9%e6%b3%95-3%e4%bd%bf%e7%94%a8>#</a></h3><p>如果 Kubernetes 部署在 <strong>云环境</strong>，并使用云厂商的 <strong>LoadBalancer</strong>，需要启用 <code>proxy-protocol</code> 透传真实 IP：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ConfigMap</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-configuration</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>ingress-nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>use-proxy-protocol</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span></code></pre></div><p>然后，在 Ingress Controller Service 里添加：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>: <span style=color:#e6db74>&#39;*&#39;</span>
</span></span></code></pre></div><ul><li>适用于 AWS ALB、GCP LB 等云负载均衡，保证传递 <strong>真实 IP</strong>。</li></ul><hr><h2 id=3-总结><strong>3. 总结</strong>
<a class=anchor href=#3-%e6%80%bb%e7%bb%93>#</a></h2><table><thead><tr><th><strong>原因</strong></th><th><strong>解决方案</strong></th></tr></thead><tbody><tr><td>Ingress 代理模式丢失 IP</td><td>使用 <code>X-Forwarded-For</code> 读取真实 IP</td></tr><tr><td><code>externalTrafficPolicy</code> 导致 SNAT</td><td>修改 <code>externalTrafficPolicy: Local</code></td></tr><tr><td>云负载均衡（ELB/ALB）丢失真实 IP</td><td>启用 <code>proxy-protocol</code> 传递真实 IP</td></tr><tr><td>直接使用宿主机网络（HostNetwork）</td><td>让 Ingress 直接运行在 <code>HostNetwork</code></td></tr></tbody></table><p><strong>最佳实践</strong>：</p><ul><li><strong>K8s 云环境（AWS/GCP/阿里云）</strong> → 开启 <code>proxy-protocol</code></li><li><strong>本地 K8s 集群（NodePort）</strong> → 设置 <code>externalTrafficPolicy: Local</code></li><li><strong>应用层（Nginx/Flask/Go/PHP）</strong> → 读取 <code>X-Forwarded-For</code> 头</li></ul><p>这样就可以正确获取 <strong>客户端真实 IP</strong>！</p><h1 id=gitssh形式拉去代码怎么配置>git，ssh形式拉去代码，怎么配置？
<a class=anchor href=#gitssh%e5%bd%a2%e5%bc%8f%e6%8b%89%e5%8e%bb%e4%bb%a3%e7%a0%81%e6%80%8e%e4%b9%88%e9%85%8d%e7%bd%ae>#</a></h1><p>要通过 <strong>SSH</strong> 方式拉取 Git 仓库的代码，需要配置 SSH 密钥并将公钥添加到 Git 服务（例如 GitHub、GitLab 或其他 Git 服务器）中。以下是配置步骤：</p><h3 id=1-生成-ssh-密钥对><strong>1. 生成 SSH 密钥对</strong>
<a class=anchor href=#1-%e7%94%9f%e6%88%90-ssh-%e5%af%86%e9%92%a5%e5%af%b9>#</a></h3><p>如果你还没有 SSH 密钥对，可以通过以下步骤生成一个。</p><h4 id=在本地机器上生成-ssh-密钥>在本地机器上生成 SSH 密钥：
<a class=anchor href=#%e5%9c%a8%e6%9c%ac%e5%9c%b0%e6%9c%ba%e5%99%a8%e4%b8%8a%e7%94%9f%e6%88%90-ssh-%e5%af%86%e9%92%a5>#</a></h4><ol><li><p>打开终端。</p></li><li><p>输入以下命令生成 SSH 密钥对：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh-keygen -t rsa -b <span style=color:#ae81ff>4096</span> -C <span style=color:#e6db74>&#34;your_email@example.com&#34;</span>
</span></span></code></pre></div><ul><li><code>-t rsa</code> 表示使用 RSA 算法。</li><li><code>-b 4096</code> 表示生成一个 4096 位的密钥。</li><li><code>-C</code> 后面是一个注释，一般填写你的邮箱。</li></ul></li><li><p>生成密钥对时，会提示选择文件保存路径，默认会保存在 <code>~/.ssh/id_rsa</code>，按 <code>Enter</code> 键选择默认路径。</p></li><li><p>输入一个 <strong>密码短语</strong>（可选），如果不想设置密码短语，直接按 <code>Enter</code> 键跳过。</p></li></ol><p>生成的密钥对包括：</p><ul><li><strong>私钥</strong>：<code>~/.ssh/id_rsa</code></li><li><strong>公钥</strong>：<code>~/.ssh/id_rsa.pub</code></li></ul><h3 id=2-将公钥添加到-git-服务><strong>2. 将公钥添加到 Git 服务</strong>
<a class=anchor href=#2-%e5%b0%86%e5%85%ac%e9%92%a5%e6%b7%bb%e5%8a%a0%e5%88%b0-git-%e6%9c%8d%e5%8a%a1>#</a></h3><p>将生成的公钥添加到你使用的 Git 服务账户中（如 GitHub、GitLab 或 Bitbucket）。</p><h4 id=github>GitHub：
<a class=anchor href=#github>#</a></h4><ol><li><p>登录到 GitHub。</p></li><li><p>点击右上角的 <strong>头像</strong> → <strong>Settings</strong>（设置）。</p></li><li><p>在左侧栏点击 <strong>SSH and GPG keys</strong>。</p></li><li><p>点击 <strong>New SSH key</strong> 按钮。</p></li><li><p>打开终端，查看公钥内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat ~/.ssh/id_rsa.pub
</span></span></code></pre></div></li><li><p>将显示的公钥内容复制粘贴到 GitHub 的 SSH 密钥配置页，点击 <strong>Add SSH key</strong>。</p></li></ol><h4 id=gitlab>GitLab：
<a class=anchor href=#gitlab>#</a></h4><ol><li>登录到 GitLab。</li><li>点击右上角的 <strong>头像</strong> → <strong>Settings</strong>。</li><li>在左侧栏点击 <strong>SSH Keys</strong>。</li><li>将公钥内容粘贴到 SSH 密钥框中，点击 <strong>Add key</strong>。</li></ol><h4 id=bitbucket>Bitbucket：
<a class=anchor href=#bitbucket>#</a></h4><ol><li>登录到 Bitbucket。</li><li>点击右上角的 <strong>头像</strong> → <strong>Personal settings</strong>（个人设置）。</li><li>在左侧栏点击 <strong>SSH keys</strong>。</li><li>粘贴公钥内容，点击 <strong>Add key</strong>。</li></ol><h3 id=3-配置-ssh-客户端><strong>3. 配置 SSH 客户端</strong>
<a class=anchor href=#3-%e9%85%8d%e7%bd%ae-ssh-%e5%ae%a2%e6%88%b7%e7%ab%af>#</a></h3><p>如果你想确保 SSH 客户端始终使用正确的密钥，可以配置 <code>~/.ssh/config</code> 文件。</p><p>编辑或创建 <code>~/.ssh/config</code> 文件，添加如下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Host github.com
</span></span><span style=display:flex><span>  User git
</span></span><span style=display:flex><span>  HostName github.com
</span></span><span style=display:flex><span>  IdentityFile ~/.ssh/id_rsa
</span></span><span style=display:flex><span>  IdentitiesOnly yes
</span></span></code></pre></div><ul><li><code>Host github.com</code>：指定对 <code>github.com</code> 使用此配置。</li><li><code>IdentityFile ~/.ssh/id_rsa</code>：指定使用的私钥文件路径。</li></ul><h3 id=4-使用-ssh-拉取代码><strong>4. 使用 SSH 拉取代码</strong>
<a class=anchor href=#4-%e4%bd%bf%e7%94%a8-ssh-%e6%8b%89%e5%8f%96%e4%bb%a3%e7%a0%81>#</a></h3><p>通过 SSH 拉取 Git 仓库时，使用 SSH URL 进行克隆。例如，GitHub 仓库的 SSH URL 形式是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone git@github.com:username/repository.git
</span></span></code></pre></div><p>对于其他 Git 服务，URL 形式也类似，例如：</p><ul><li>GitLab：<code>git@gitlab.com:username/repository.git</code></li><li>Bitbucket：<code>git@bitbucket.org:username/repository.git</code></li></ul><h3 id=5-测试-ssh-连接><strong>5. 测试 SSH 连接</strong>
<a class=anchor href=#5-%e6%b5%8b%e8%af%95-ssh-%e8%bf%9e%e6%8e%a5>#</a></h3><p>可以通过以下命令测试是否配置正确：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh -T git@github.com
</span></span></code></pre></div><p>如果配置正确，应该看到类似下面的消息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Hi username! You<span style=color:#960050;background-color:#1e0010>&#39;</span>ve successfully authenticated, but GitHub does not provide shell access.
</span></span></code></pre></div><h3 id=6-配置-git-使用-ssh><strong>6. 配置 Git 使用 SSH</strong>
<a class=anchor href=#6-%e9%85%8d%e7%bd%ae-git-%e4%bd%bf%e7%94%a8-ssh>#</a></h3><p>如果你的 Git 配置默认使用 HTTPS，可以通过以下命令将远程仓库 URL 更新为 SSH 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote set-url origin git@github.com:username/repository.git
</span></span></code></pre></div><hr><h3 id=总结-2><strong>总结：</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-2>#</a></h3><ol><li><strong>生成 SSH 密钥对</strong>：使用 <code>ssh-keygen</code> 生成私钥和公钥。</li><li><strong>将公钥添加到 Git 服务</strong>：将公钥上传到 GitHub、GitLab 或 Bitbucket。</li><li><strong>配置 SSH 客户端</strong>：通过 <code>~/.ssh/config</code> 配置 SSH 客户端，以确保使用正确的密钥。</li><li><strong>使用 SSH 拉取代码</strong>：使用 <code>git@github.com:username/repository.git</code> 格式的 URL 克隆代码。</li></ol><p>配置好 SSH 后，你就可以使用 SSH 拉取和推送代码了！</p><h1 id=jenkins在不同平台做编译agent在不同平台如何操作对jenkins集群有了解吗>jenkins在不同平台做编译，agent在不同平台如何操作？对jenkins集群有了解吗？
<a class=anchor href=#jenkins%e5%9c%a8%e4%b8%8d%e5%90%8c%e5%b9%b3%e5%8f%b0%e5%81%9a%e7%bc%96%e8%af%91agent%e5%9c%a8%e4%b8%8d%e5%90%8c%e5%b9%b3%e5%8f%b0%e5%a6%82%e4%bd%95%e6%93%8d%e4%bd%9c%e5%af%b9jenkins%e9%9b%86%e7%be%a4%e6%9c%89%e4%ba%86%e8%a7%a3%e5%90%97>#</a></h1><p>Jenkins 在多平台编译和使用不同平台的 agent 操作时，通常会涉及到 <strong>Jenkins 集群</strong> 和 <strong>Jenkins Agent</strong> 的配置。Jenkins 集群是指由多个 Jenkins 节点组成的系统，其中包括 <strong>主节点（Master）</strong> 和 <strong>代理节点（Agent）</strong>。代理节点是用于执行 Jenkins 作业的独立计算机。以下是相关的操作步骤和配置。</p><h3 id=1-jenkins-集群架构><strong>1. Jenkins 集群架构</strong>
<a class=anchor href=#1-jenkins-%e9%9b%86%e7%be%a4%e6%9e%b6%e6%9e%84>#</a></h3><p>Jenkins 集群由一个主节点和多个代理节点组成：</p><ul><li><strong>Master（主节点）</strong>：Jenkins 主节点负责调度任务、分配作业并提供 Web 界面。主节点并不执行所有的构建工作，主节点主要负责管理任务和协调代理节点的工作。</li><li><strong>Agent（代理节点）</strong>：代理节点用于实际执行 Jenkins 的作业（如构建、测试、部署等）。可以有多个代理节点，支持不同操作系统和平台，保证跨平台的构建需求。</li></ul><p>Jenkins 集群的优势：</p><ul><li><strong>负载均衡</strong>：作业可以根据需要分配到不同的代理节点，减轻主节点的负担。</li><li><strong>跨平台支持</strong>：在不同操作系统的代理节点上构建支持多平台的项目。</li></ul><h3 id=2-配置-jenkins-agent-在不同平台上执行任务><strong>2. 配置 Jenkins Agent 在不同平台上执行任务</strong>
<a class=anchor href=#2-%e9%85%8d%e7%bd%ae-jenkins-agent-%e5%9c%a8%e4%b8%8d%e5%90%8c%e5%b9%b3%e5%8f%b0%e4%b8%8a%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1>#</a></h3><p>在 Jenkins 中，代理节点可以是不同操作系统（如 Linux、Windows 或 macOS）上的机器，每个代理节点可以运行特定操作系统上需要的构建任务。以下是配置过程：</p><h4 id=步骤一安装-jenkins-主节点><strong>步骤一：安装 Jenkins 主节点</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4%e4%b8%80%e5%ae%89%e8%a3%85-jenkins-%e4%b8%bb%e8%8a%82%e7%82%b9>#</a></h4><ol><li>安装 Jenkins 主节点，并启动 Jenkins 服务。</li><li>配置 Jenkins 主节点并访问 Web 控制台，通常可以通过 <code>http://localhost:8080</code> 访问。</li></ol><h4 id=步骤二配置-agent-节点><strong>步骤二：配置 Agent 节点</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4%e4%ba%8c%e9%85%8d%e7%bd%ae-agent-%e8%8a%82%e7%82%b9>#</a></h4><p>在 Jenkins 中配置 Agent 节点时，可以选择通过以下几种方式连接代理节点：</p><ul><li><strong>SSH 连接（Linux/Mac）</strong>：对于 Linux 或 macOS 系统的代理节点，可以通过 SSH 连接进行配置。</li><li><strong>Windows 代理（Jenkins agent）</strong>：对于 Windows 系统，可以使用 <strong>Jenkins Windows Agent</strong>。</li></ul><h5 id=1-配置-linuxmacos-agent><strong>1. 配置 Linux/macOS Agent</strong>
<a class=anchor href=#1-%e9%85%8d%e7%bd%ae-linuxmacos-agent>#</a></h5><ul><li><p>在 Jenkins Web 界面中，点击 <strong>Manage Jenkins</strong> → <strong>Manage Nodes and Clouds</strong> → <strong>New Node</strong>，然后输入节点名称和选择节点类型。</p></li><li><p>选择</p><p>Permanent Agent</p><p>，并输入该节点的详细信息：</p><ul><li><p><strong>Remote root directory</strong>：代理节点上 Jenkins 工作目录的路径。</p></li><li><p><strong>Labels</strong>：标签，用于标识该代理节点，方便调度作业到此节点。</p></li><li><p>Launch method</p><p>：选择</p><pre tabindex=0><code>Launch agents via SSH
</code></pre><p>，然后提供代理节点的 SSH 配置信息，如：</p><ul><li>主机名或 IP 地址</li><li>用户名</li><li>SSH 密钥或密码</li></ul></li></ul></li><li><p>配置完成后，点击 <strong>Save</strong>。</p></li></ul><h5 id=2-配置-windows-agent><strong>2. 配置 Windows Agent</strong>
<a class=anchor href=#2-%e9%85%8d%e7%bd%ae-windows-agent>#</a></h5><p>Windows 代理节点配置略有不同，通常使用 <strong>Jenkins Agent</strong> 可执行文件进行连接：</p><ul><li>在 Jenkins Web 界面中，选择 <strong>Manage Jenkins</strong> → <strong>Manage Nodes and Clouds</strong> → <strong>New Node</strong>，并创建一个新的节点。</li><li>在 <strong>Launch method</strong> 中选择 <code>Launch agent via Java Web Start</code>，然后下载代理程序。</li><li>运行下载的代理程序，Jenkins 会自动连接并启动代理。</li></ul><h4 id=步骤三验证-agent-节点><strong>步骤三：验证 Agent 节点</strong>
<a class=anchor href=#%e6%ad%a5%e9%aa%a4%e4%b8%89%e9%aa%8c%e8%af%81-agent-%e8%8a%82%e7%82%b9>#</a></h4><p>配置完成后，在 Jenkins 控制台页面中，代理节点会显示为在线状态，并可以开始接收任务。</p><h3 id=3-配置多平台编译><strong>3. 配置多平台编译</strong>
<a class=anchor href=#3-%e9%85%8d%e7%bd%ae%e5%a4%9a%e5%b9%b3%e5%8f%b0%e7%bc%96%e8%af%91>#</a></h3><p>在 Jenkins 中进行跨平台编译时，通常会涉及到平台特定的构建工具或环境配置。你可以通过以下方式配置多平台编译：</p><h4 id=使用-labels><strong>使用 Labels</strong>
<a class=anchor href=#%e4%bd%bf%e7%94%a8-labels>#</a></h4><ul><li>在 Jenkins 作业中，可以通过 <strong>Labels</strong> 来指定该作业需要在哪些节点上运行。例如，你可以为 Windows 系统的代理节点设置 <code>windows</code> 标签，为 Linux 系统的代理节点设置 <code>linux</code> 标签。</li><li>在作业配置中，通过设置构建节点的标签来确保作业在指定的代理节点上运行。</li></ul><h4 id=使用环境变量><strong>使用环境变量</strong>
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f>#</a></h4><ul><li>在不同平台的代理节点中，设置不同的环境变量。例如，Windows 节点上可能需要设置 <code>JAVA_HOME</code>、<code>MAVEN_HOME</code> 等环境变量，而 Linux 节点上可能有不同的路径配置。</li><li>你可以在 Jenkins 中通过 <strong>Build Environment</strong> 配置环境变量，或者直接在每个平台的代理节点上设置合适的环境变量。</li></ul><h4 id=使用-platform-specific-构建工具><strong>使用 Platform-Specific 构建工具</strong>
<a class=anchor href=#%e4%bd%bf%e7%94%a8-platform-specific-%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7>#</a></h4><p>如果在不同平台上需要使用特定的构建工具，可以在 Jenkins 作业中设置不同的构建命令，或者在各个代理节点上安装平台相关的工具。例如：</p><ul><li>在 Windows 节点上使用 MSBuild 构建项目。</li><li>在 Linux 节点上使用 <code>mvn</code> 或 <code>make</code> 命令进行构建。</li></ul><h3 id=4-jenkins-集群的负载均衡和优化><strong>4. Jenkins 集群的负载均衡和优化</strong>
<a class=anchor href=#4-jenkins-%e9%9b%86%e7%be%a4%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%92%8c%e4%bc%98%e5%8c%96>#</a></h3><ul><li><strong>负载均衡</strong>：Jenkins 会根据每个节点的资源情况和标签配置将任务分配到适当的代理节点。你可以根据资源使用情况设置节点的负载均衡策略。</li><li><strong>节点管理</strong>：可以设置代理节点的 <strong>Idle time</strong>，以便节点在空闲时自动断开连接，节省资源。</li><li><strong>节点标签</strong>：根据标签将不同类型的构建任务调度到特定的节点，保证构建任务在正确的环境下运行。</li></ul><h3 id=5-通过-pipeline-实现跨平台构建><strong>5. 通过 Pipeline 实现跨平台构建</strong>
<a class=anchor href=#5-%e9%80%9a%e8%bf%87-pipeline-%e5%ae%9e%e7%8e%b0%e8%b7%a8%e5%b9%b3%e5%8f%b0%e6%9e%84%e5%bb%ba>#</a></h3><p>通过 Jenkins Pipeline，可以在同一流水线中对多个平台进行构建。例如，你可以在 Jenkins Pipeline 中配置多平台构建，如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=display:flex><span>pipeline <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    agent none
</span></span><span style=display:flex><span>    stages <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        stage<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;Build Linux&#39;</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            agent <span style=color:#f92672>{</span> label <span style=color:#e6db74>&#39;linux&#39;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            steps <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                sh <span style=color:#e6db74>&#39;./build-linux.sh&#39;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        stage<span style=color:#f92672>(</span><span style=color:#e6db74>&#39;Build Windows&#39;</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            agent <span style=color:#f92672>{</span> label <span style=color:#e6db74>&#39;windows&#39;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            steps <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                bat <span style=color:#e6db74>&#39;build-windows.bat&#39;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在上述示例中，<code>label</code> 用来指定在不同的代理节点上运行不同的构建任务。</p><h3 id=总结-3><strong>总结</strong>
<a class=anchor href=#%e6%80%bb%e7%bb%93-3>#</a></h3><ol><li><strong>Jenkins 集群</strong>：由主节点和多个代理节点组成，可以实现负载均衡和跨平台支持。</li><li><strong>Agent 配置</strong>：根据操作系统类型（Windows、Linux、macOS）选择不同的连接方法，使用 SSH 或 Java Web Start。</li><li><strong>多平台编译</strong>：通过标签（Labels）、环境变量、平台特定构建工具和流水线配置，实现跨平台构建。</li><li><strong>负载均衡</strong>：Jenkins 会根据节点的资源和标签配置分配任务，保证不同平台的构建任务可以在适当的节点上执行。</li></ol><p>通过这种方式，你可以在 Jenkins 集群中跨平台执行编译和构建任务，提高 CI/CD 流程的灵活性和可扩展性。</p><h1 id=docker的几种不同的网络类型>docker的几种不同的网络类型？
<a class=anchor href=#docker%e7%9a%84%e5%87%a0%e7%a7%8d%e4%b8%8d%e5%90%8c%e7%9a%84%e7%bd%91%e7%bb%9c%e7%b1%bb%e5%9e%8b>#</a></h1><p>Docker 提供了几种不同的网络模式，用于容器之间的通信、容器与宿主机的通信等。以下是常见的 Docker 网络类型：</p><h3 id=1-bridge-网络桥接网络>1. <strong>bridge 网络（桥接网络）</strong>
<a class=anchor href=#1-bridge-%e7%bd%91%e7%bb%9c%e6%a1%a5%e6%8e%a5%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p><strong>默认网络模式</strong>：如果没有指定其他网络，Docker 会将容器连接到 <code>bridge</code> 网络。</p></li><li><p>特点</p><p>：</p><ul><li>容器之间可以通过 IP 地址或容器名称互相通信，但默认情况下，容器不能直接访问宿主机的网络。</li><li>容器与外部网络之间的通信通过 Docker 主机的网络栈来实现，通常需要使用端口映射。</li><li>容器通过 <code>docker network bridge</code> 默认创建的虚拟网桥进行通信。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>单机部署或开发环境中，适合小规模容器部署。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --name mycontainer --network bridge myimage
</span></span></code></pre></div><h3 id=2-host-网络>2. <strong>host 网络</strong>
<a class=anchor href=#2-host-%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li>容器共享宿主机的网络命名空间。容器不会获得自己的 IP 地址，而是直接使用宿主机的 IP 地址。</li><li>容器与宿主机之间的网络通信是直接的，没有隔离。容器暴露的端口会直接映射到宿主机上。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>当容器需要访问宿主机网络的高性能通信时，适合使用 <code>host</code> 网络。</li><li>适用于需要极低延迟的场景，如高性能网络服务。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --name mycontainer --network host myimage
</span></span></code></pre></div><h3 id=3-none-网络>3. <strong>none 网络</strong>
<a class=anchor href=#3-none-%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li>容器不会连接到任何网络。</li><li>容器没有网络接口，因此容器无法与外部进行通信。只有容器内部的进程可以使用 <code>localhost</code> 进行通信。</li><li>用于对网络要求极为严格的场景，或者测试需要完全隔离的环境。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>当需要完全隔离网络的容器时，或者希望手动配置容器的网络接口。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --name mycontainer --network none myimage
</span></span></code></pre></div><h3 id=4-overlay-网络>4. <strong>overlay 网络</strong>
<a class=anchor href=#4-overlay-%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li>用于多主机容器网络，允许跨宿主机的容器之间进行通信。</li><li>Docker Swarm 或 Kubernetes 等容器编排平台使用 overlay 网络来进行容器集群内的通信。</li><li>基于 VXLAN 技术，提供了一种在多宿主机上创建虚拟网络的方式。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>多宿主机容器之间的通信，通常用于微服务架构中。</li><li>用于 Docker Swarm 集群或 Kubernetes 集群中的容器通信。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create -d overlay my_overlay_network
</span></span></code></pre></div><h3 id=5-macvlan-网络>5. <strong>macvlan 网络</strong>
<a class=anchor href=#5-macvlan-%e7%bd%91%e7%bb%9c>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li>容器获取自己的 MAC 地址，并通过宿主机的网络接口直接访问网络。</li><li>容器表现得像独立的物理主机，可以在同一物理网络上进行通信。</li><li>可用于要求容器像物理设备一样直接接入物理网络的场景。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>容器需要直接接入物理网络或需要被物理网络中的其他设备直接访问。</li><li>适用于需要更高级网络隔离的环境，例如某些企业级应用场景。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create -d macvlan --subnet<span style=color:#f92672>=</span>192.168.1.0/24 --gateway<span style=color:#f92672>=</span>192.168.1.1 my_macvlan_network
</span></span></code></pre></div><h3 id=6-host-gateway-网络docker-2010-及以上版本>6. <strong>host-gateway 网络（Docker 20.10 及以上版本）</strong>
<a class=anchor href=#6-host-gateway-%e7%bd%91%e7%bb%9cdocker-2010-%e5%8f%8a%e4%bb%a5%e4%b8%8a%e7%89%88%e6%9c%ac>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li>容器能够通过 <code>host-gateway</code> 地址访问宿主机的网络。</li><li>通常在容器需要访问宿主机或宿主机访问容器时使用，便于容器与宿主机之间的网络交互。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>在 Docker 20.10 或更高版本中，能够方便地通过容器访问宿主机网络。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create --driver bridge --gateway host-gateway my_network
</span></span></code></pre></div><h3 id=总结-4>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-4>#</a></h3><ul><li><strong>bridge</strong>：默认的容器网络，适用于单机部署。</li><li><strong>host</strong>：容器共享宿主机的网络栈，适用于高性能网络需求。</li><li><strong>none</strong>：容器没有网络连接，完全隔离。</li><li><strong>overlay</strong>：适用于跨主机容器通信，常用于集群部署。</li><li><strong>macvlan</strong>：容器获取独立的 MAC 地址，适用于需要直接访问物理网络的场景。</li><li><strong>host-gateway</strong>：容器与宿主机直接交互，便于容器访问宿主机。</li></ul><p>选择适合的网络类型可以根据具体应用场景和网络需求来决定。</p><h1 id=有container网络吗>有container网络吗
<a class=anchor href=#%e6%9c%89container%e7%bd%91%e7%bb%9c%e5%90%97>#</a></h1><p>在 Docker 中，并没有明确叫做 &ldquo;container&rdquo; 的网络类型，但 Docker 确实有一个名为 <strong>container</strong> 的网络模式，它允许容器之间共享网络命名空间。这意味着一个容器可以直接访问另一个容器的网络接口。</p><h3 id=container-网络模式>container 网络模式
<a class=anchor href=#container-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8f>#</a></h3><ul><li><p>特点</p><p>：</p><ul><li>在 <strong>container</strong> 网络模式下，容器将直接共享与指定容器相同的网络命名空间（包括 IP 地址、端口等网络信息）。</li><li>容器间会通过容器名或 IP 地址直接进行通信，无需额外的网络隔离。</li><li>当两个容器都使用 <code>--network container:&lt;container_name_or_id></code> 配置时，它们就共享一个网络栈。</li></ul></li><li><p>适用场景</p><p>：</p><ul><li>容器需要共享网络栈，通常用于需要共享 IP 地址的场景。</li><li>比如在容器内运行某些需要共享主机网络接口的应用，或者容器与其他容器需要直接进行低延迟、高效的网络通信。</li></ul></li></ul><h3 id=使用示例>使用示例：
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b>#</a></h3><p>假设你有两个容器，一个是数据库容器，另一个是应用容器。你希望应用容器共享数据库容器的网络栈，可以使用如下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --name db_container --network bridge mysql
</span></span><span style=display:flex><span>docker run --name app_container --network container:db_container myapp
</span></span></code></pre></div><p>在这个例子中，<code>app_container</code> 会使用与 <code>db_container</code> 相同的网络栈，直接访问数据库容器的 IP 地址和端口。</p><h3 id=总结-5>总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93-5>#</a></h3><ul><li><strong>container</strong> 网络模式是 Docker 的一种特殊网络模式，允许容器共享网络栈。虽然没有单独的容器网络类型叫做 &ldquo;container&rdquo;，但这是一种非常特殊且有效的容器间通信方式，通常用于容器之间高度耦合的场景。</li></ul><h6><a class=anchor href=#>#</a></h6><h1 id=反问>反问
<a class=anchor href=#%e5%8f%8d%e9%97%ae>#</a></h1><h1 id=运维团队大概有几个人管理机器规模>运维团队大概有几个人，管理机器规模？
<a class=anchor href=#%e8%bf%90%e7%bb%b4%e5%9b%a2%e9%98%9f%e5%a4%a7%e6%a6%82%e6%9c%89%e5%87%a0%e4%b8%aa%e4%ba%ba%e7%ae%a1%e7%90%86%e6%9c%ba%e5%99%a8%e8%a7%84%e6%a8%a1>#</a></h1><h1 id=日常工作>日常工作？
<a class=anchor href=#%e6%97%a5%e5%b8%b8%e5%b7%a5%e4%bd%9c>#</a></h1></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-关系概述><strong>1. 关系概述</strong></a></li><li><a href=#2-详细流程><strong>2. 详细流程</strong></a></li><li><a href=#3-具体示例><strong>3. 具体示例</strong></a><ul><li><a href=#1-storageclass-定义><strong>1️⃣ StorageClass 定义</strong></a></li><li><a href=#2-pvc-申请存储><strong>2️⃣ PVC 申请存储</strong></a></li><li><a href=#3-pv-静态创建可选><strong>3️⃣ PV 静态创建（可选）</strong></a></li><li><a href=#4-pod-挂载-pvc><strong>4️⃣ Pod 挂载 PVC</strong></a></li></ul></li><li><a href=#4-总结><strong>4. 总结</strong></a><ul><li><a href=#关键点><strong>关键点</strong></a></li></ul></li></ul><ul><li><a href=#1-cni-插件优化><strong>1. CNI 插件优化</strong></a></li><li><a href=#2-pod-网络优化><strong>2. Pod 网络优化</strong></a><ul><li><a href=#1-调整-mtu><strong>(1) 调整 MTU</strong></a></li><li><a href=#2-调整-tcp-参数><strong>(2) 调整 TCP 参数</strong></a></li><li><a href=#3-使用-ipv6-dual-stack><strong>(3) 使用 IPv6 Dual Stack</strong></a></li></ul></li><li><a href=#3-service-网络优化><strong>3. Service 网络优化</strong></a><ul><li><a href=#1-优化-kube-proxy><strong>(1) 优化 kube-proxy</strong></a></li><li><a href=#2-开启-coredns-缓存><strong>(2) 开启 CoreDNS 缓存</strong></a></li><li><a href=#3-使用><strong>(3) 使用 <code>headless Service</code></strong></a></li></ul></li><li><a href=#4-负载均衡优化><strong>4. 负载均衡优化</strong></a><ul><li><a href=#1-使用-externaltrafficpolicy><strong>(1) 使用 ExternalTrafficPolicy</strong></a></li><li><a href=#2-开启><strong>(2) 开启 <code>KeepAlive</code></strong></a></li></ul></li><li><a href=#5-网络安全优化><strong>5. 网络安全优化</strong></a><ul><li><a href=#1-限制-ip-访问><strong>(1) 限制 IP 访问</strong></a></li><li><a href=#2-使用-networkpolicy><strong>(2) 使用 NetworkPolicy</strong></a></li></ul></li><li><a href=#6-使用-ebpf-提高性能><strong>6. 使用 eBPF 提高性能</strong></a></li><li><a href=#7-监控和优化><strong>7. 监控和优化</strong></a><ul><li><a href=#1-使用><strong>(1) 使用 <code>ping</code> 和 <code>iperf</code> 监控网络</strong></a></li><li><a href=#2-使用><strong>(2) 使用 <code>tcpdump</code> 分析网络问题</strong></a></li><li><a href=#3-使用-prometheus--grafana-监控><strong>(3) 使用 Prometheus + Grafana 监控</strong></a></li></ul></li><li><a href=#总结><strong>总结</strong></a></li></ul><ul><li><a href=#1-基本概念><strong>1. 基本概念</strong></a></li><li><a href=#2-iptables-解析><strong>2. iptables 解析</strong></a><ul><li><a href=#iptables-工作原理><strong>iptables 工作原理</strong></a></li><li><a href=#示例><strong>示例</strong></a></li></ul></li><li><a href=#3-ipvs-解析><strong>3. IPVS 解析</strong></a><ul><li><a href=#ipvs-工作原理><strong>IPVS 工作原理</strong></a></li><li><a href=#示例-1><strong>示例</strong></a></li></ul></li><li><a href=#4-iptables-vs-ipvs-性能对比><strong>4. iptables vs IPVS 性能对比</strong></a></li><li><a href=#5-开启-ipvs-模式><strong>5. 开启 IPVS 模式</strong></a><ul><li><a href=#1-检查内核模块><strong>(1) 检查内核模块</strong></a></li><li><a href=#2-修改-kube-proxy-配置><strong>(2) 修改 kube-proxy 配置</strong></a></li><li><a href=#3-重启><strong>(3) 重启 <code>kube-proxy</code></strong></a></li><li><a href=#4-验证-ipvs-是否生效><strong>(4) 验证 IPVS 是否生效</strong></a></li></ul></li><li><a href=#6-总结><strong>6. 总结</strong></a></li></ul><ul><li><ul><li><a href=#kubernetes-默认的-kube-proxy-模式是><strong>Kubernetes 默认的 kube-proxy 模式是 <code>iptables</code></strong></a></li><li><a href=#1><strong>1. <code>iptables</code> 是更通用的默认选择</strong></a></li><li><a href=#2><strong>2. <code>IPVS</code> 依赖额外的内核模块</strong></a></li><li><a href=#3><strong>3. <code>iptables</code> 对中小规模集群足够</strong></a></li><li><a href=#4-kubernetes-并没有放弃><strong>4. Kubernetes 并没有放弃 <code>IPVS</code></strong></a></li><li><a href=#5-如何检查当前><strong>5. 如何检查当前 <code>kube-proxy</code> 使用的模式？</strong></a></li><li><a href=#6-结论><strong>6. 结论</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#kubernetes-中-kube-proxy-的关键点总结><strong>Kubernetes 中 kube-proxy 的关键点总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#ingress-和-ingress-controller-的区别><strong>Ingress 和 Ingress Controller 的区别</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-nginx-ingress-controller最常见><strong>1. Nginx Ingress Controller</strong>（最常见）</a></li><li><a href=#2-traefik-ingress-controller云原生友好><strong>2. Traefik Ingress Controller</strong>（云原生友好）</a></li><li><a href=#3-haproxy-ingress-controller高性能><strong>3. HAProxy Ingress Controller</strong>（高性能）</a></li><li><a href=#4-kong-ingress-controllerapi-网关><strong>4. Kong Ingress Controller</strong>（API 网关）</a></li><li><a href=#5-istio-gatewayservice-mesh-方案><strong>5. Istio Gateway</strong>（Service Mesh 方案）</a></li><li><a href=#6-contour-ingress-controllerenvoy-代理><strong>6. Contour Ingress Controller</strong>（Envoy 代理）</a></li><li><a href=#7-gce-ingress-controller适用于-gcp><strong>7. GCE Ingress Controller</strong>（适用于 GCP）</a></li><li><a href=#8-aws-alb-ingress-controller适用于-aws><strong>8. AWS ALB Ingress Controller</strong>（适用于 AWS）</a></li><li><a href=#9-f5-big-ip-ingress-controller企业级><strong>9. F5 BIG-IP Ingress Controller</strong>（企业级）</a></li><li><a href=#总结不同-ingress-controller-适用场景><strong>总结：不同 Ingress Controller 适用场景</strong></a></li></ul></li></ul><ul><li><a href=#1-nginx-配置适用于独立-nginx-部署><strong>1. Nginx 配置（适用于独立 Nginx 部署）</strong></a></li><li><a href=#2-nginx-ingress-controller-配置><strong>2. Nginx Ingress Controller 配置</strong></a><ul><li><a href=#方法-1在-ingress-资源中增加-annotation><strong>方法 1：在 Ingress 资源中增加 Annotation</strong></a></li><li><a href=#方法-2修改-configmap-配置><strong>方法 2：修改 ConfigMap 配置</strong></a></li></ul></li><li><a href=#3-helm-安装-nginx-ingress-时修改><strong>3. Helm 安装 Nginx Ingress 时修改</strong></a></li><li><a href=#总结-1><strong>总结</strong></a></li></ul><ul><li><a href=#1-常见原因><strong>1. 常见原因</strong></a><ul><li><a href=#1-ingress-controller-作为反向代理><strong>(1) Ingress Controller 作为反向代理</strong></a></li><li><a href=#2-kubernetes-运行模式loadbalancer--nodeport--hostnetwork><strong>(2) Kubernetes 运行模式（LoadBalancer / NodePort / HostNetwork）</strong></a></li><li><a href=#3-snat源地址网络转换><strong>(3) SNAT（源地址网络转换）</strong></a></li></ul></li><li><a href=#2-解决方案><strong>2. 解决方案</strong></a><ul><li><a href=#方法-1使用><strong>方法 1：使用 <code>X-Forwarded-For</code> 传递真实 IP</strong></a></li><li><a href=#方法-2修改><strong>方法 2：修改 <code>externalTrafficPolicy</code> 避免 SNAT</strong></a></li><li><a href=#方法-3使用><strong>方法 3：使用 <code>proxy-protocol</code>（适用于云负载均衡）</strong></a></li></ul></li><li><a href=#3-总结><strong>3. 总结</strong></a></li></ul><ul><li><ul><li><a href=#1-生成-ssh-密钥对><strong>1. 生成 SSH 密钥对</strong></a></li><li><a href=#2-将公钥添加到-git-服务><strong>2. 将公钥添加到 Git 服务</strong></a></li><li><a href=#3-配置-ssh-客户端><strong>3. 配置 SSH 客户端</strong></a></li><li><a href=#4-使用-ssh-拉取代码><strong>4. 使用 SSH 拉取代码</strong></a></li><li><a href=#5-测试-ssh-连接><strong>5. 测试 SSH 连接</strong></a></li><li><a href=#6-配置-git-使用-ssh><strong>6. 配置 Git 使用 SSH</strong></a></li><li><a href=#总结-2><strong>总结：</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-jenkins-集群架构><strong>1. Jenkins 集群架构</strong></a></li><li><a href=#2-配置-jenkins-agent-在不同平台上执行任务><strong>2. 配置 Jenkins Agent 在不同平台上执行任务</strong></a></li><li><a href=#3-配置多平台编译><strong>3. 配置多平台编译</strong></a></li><li><a href=#4-jenkins-集群的负载均衡和优化><strong>4. Jenkins 集群的负载均衡和优化</strong></a></li><li><a href=#5-通过-pipeline-实现跨平台构建><strong>5. 通过 Pipeline 实现跨平台构建</strong></a></li><li><a href=#总结-3><strong>总结</strong></a></li></ul></li></ul><ul><li><ul><li><a href=#1-bridge-网络桥接网络>1. <strong>bridge 网络（桥接网络）</strong></a></li><li><a href=#2-host-网络>2. <strong>host 网络</strong></a></li><li><a href=#3-none-网络>3. <strong>none 网络</strong></a></li><li><a href=#4-overlay-网络>4. <strong>overlay 网络</strong></a></li><li><a href=#5-macvlan-网络>5. <strong>macvlan 网络</strong></a></li><li><a href=#6-host-gateway-网络docker-2010-及以上版本>6. <strong>host-gateway 网络（Docker 20.10 及以上版本）</strong></a></li><li><a href=#总结-4>总结：</a></li></ul></li></ul><ul><li><ul><li><a href=#container-网络模式>container 网络模式</a></li><li><a href=#使用示例>使用示例：</a></li><li><a href=#总结-5>总结：</a></li></ul></li></ul></nav></div></aside></main></body></html>