<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="以下关于lstio中gateway 的说法，错误的是哪一项?
Gateway 主要用于管理Ingress流量
Gateway 可以配置egress gateway
Gateway 配置应用于服务负载的Envoy 代理上
Gateway 可以用来限制哪些服务可以访问外部网络
这道题考察的是对 Istio 中 Gateway 的理解。我们逐项分析，找出错误选项：


  ✅ 选项分析：
  #


  ✅ 1. Gateway 主要用于管理 Ingress 流量
  #

正确。
Istio 中的 Gateway 资源主要用于配置入口（Ingress）流量，比如通过 HTTP、HTTPS 等协议从集群外部进入服务网格。


  ✅ 2. Gateway 可以配置 egress gateway
  #

正确。
虽然 Gateway 默认是用来处理 Ingress 流量的，但 Istio 同样支持通过配置一个 Egress Gateway 来控制 出网（egress）流量，例如设置出口 IP、控制访问哪些外部服务等。
这个 egress gateway 通常是通过配置 ServiceEntry + VirtualService + Gateway 等来实现的。


  ❌ 3. Gateway 配置应用于服务负载的 Envoy 代理上
  #

错误。
这是错误选项，正确答案就是它。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/2025-5-29-%E9%94%99%E9%A2%98%E5%88%86%E6%9E%901/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2025-5-29 错题分析1"><meta property="og:description" content="以下关于lstio中gateway 的说法，错误的是哪一项? Gateway 主要用于管理Ingress流量 Gateway 可以配置egress gateway Gateway 配置应用于服务负载的Envoy 代理上 Gateway 可以用来限制哪些服务可以访问外部网络 这道题考察的是对 Istio 中 Gateway 的理解。我们逐项分析，找出错误选项：
✅ 选项分析： # ✅ 1. Gateway 主要用于管理 Ingress 流量 # 正确。 Istio 中的 Gateway 资源主要用于配置入口（Ingress）流量，比如通过 HTTP、HTTPS 等协议从集群外部进入服务网格。
✅ 2. Gateway 可以配置 egress gateway # 正确。 虽然 Gateway 默认是用来处理 Ingress 流量的，但 Istio 同样支持通过配置一个 Egress Gateway 来控制 出网（egress）流量，例如设置出口 IP、控制访问哪些外部服务等。 这个 egress gateway 通常是通过配置 ServiceEntry + VirtualService + Gateway 等来实现的。
❌ 3. Gateway 配置应用于服务负载的 Envoy 代理上 # 错误。 这是错误选项，正确答案就是它。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2025-5-29 错题分析1 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/2025-5-29-%E9%94%99%E9%A2%98%E5%88%86%E6%9E%901/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.6352bc654c0d0517fcc8e2d130af2d0f44a353e601e9930fdcf9b3c26182755b.js integrity="sha256-Y1K8ZUwNBRf8yOLRMK8tD0SjU+YB6ZMP3PmzwmGCdVs=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-6-16-fire%E8%A7%84%E5%88%99/>2025-6-16 Cursor RIPER-5规则</a></li><li><a href=/docs/2025-6-12-karmada/>2025-6-12 karmada介绍</a></li><li><a href=/docs/2025-6-12-flutter%E8%A7%84%E5%88%99/>2025-6-12 flutter规则</a></li><li><a href=/docs/2025-6-10-%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/>2025-6-10 独立开发</a></li><li><a href=/docs/2025-5-29-%E9%94%99%E9%A2%98%E5%88%86%E6%9E%902/>2025-5-29 错题分析2</a></li><li><a href=/docs/2025-5-29-%E9%94%99%E9%A2%98%E5%88%86%E6%9E%901/ class=active>2025-5-29 错题分析1</a></li><li><a href=/docs/2025-5-21-ingress%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/>2025-5-21 主Ingress副本变为0后报503问题分析</a></li><li><a href=/docs/2025-5-7-%E6%8E%A5%E5%8D%95app/>2025-5-07 接单app设计</a></li><li><a href=/docs/2025-5-7-%E5%A5%BD%E5%BF%83%E6%80%81-app/>2025-5-07 好心态app</a></li><li><a href=/docs/2025-4-28-cursor-agent-%E6%8F%90%E7%A4%BA%E5%99%A8/>2025-4-28 cursor agent 提示器</a></li><li><a href=/docs/2025-4-16-%E8%87%AA%E7%A0%94k8s%E5%B9%B3%E5%8F%B0/>2025-4-16 自研k8s平台</a></li><li><a href=/docs/2025-4-16-sleep%E7%9D%A1%E7%9C%A0%E5%BA%94%E7%94%A8/>2025-4-16 sleep睡眠应用</a></li><li><a href=/docs/2025-4-16-paas%E8%AE%BE%E8%AE%A1/>2025-4-16 paas开发记录</a></li><li><a href=/docs/2025-4-16-cursoe-free-vip/>2025-4-16 Cursor Free VIP</a></li><li><a href=/docs/2025-4-16-boss%E7%9B%B4%E8%81%98%E8%87%AA%E5%8A%A8%E6%8A%95%E9%80%92/>2025-4-16 BOSS直聘自动投递</a></li><li><a href=/docs/2025-4-14-github%E6%8E%A8%E9%80%81/>2025-4-14 github推送</a></li><li><a href=/docs/2025-3-30-metallb/>2025-3-30 metallb</a></li><li><a href=/docs/2025-3-24-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/>2025-3-24 自我介绍</a></li><li><a href=/docs/2025-3-20-victoriametrics-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics高可用架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/>2025-3-20 thanos高可用架构</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-08-01 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-08-01 k8s面试题</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-05-01 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-04-17 面试总结</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-03-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-03-08 面试</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2024-03-04 k8s流量链路剖析</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2024-03-04 CSI剖析演进</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-03-04 CNI剖析演进</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-02-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-02-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-02-22 k8s架构师面试大全</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/2025-4-20-%E6%80%A7%E5%90%8C%E6%84%8Fapp/>2025 4 20 性同意app</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-5-29 错题分析1</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#-选项分析>✅ 选项分析：</a></li><li><a href=#-正确答案>✅ 正确答案：</a></li><li><a href=#-选项分析-1>✅ 选项分析：</a></li><li><a href=#-正确答案是>✅ 正确答案是：</a></li><li><a href=#-正确的理解>✅ 正确的理解：</a></li><li><a href=#总结>❗总结：</a></li><li><a href=#-结论>✅ 结论：</a></li><li><a href=#-正确描述分析>✅ 正确描述分析：</a></li><li><a href=#-错误项>❌ 错误项：</a></li><li><a href=#-正确答案是-1>✅ 正确答案是：</a></li><li><a href=#-正确项分析>✅ 正确项分析：</a></li><li><a href=#-错误项分析>❌ 错误项分析：</a></li><li><a href=#-正确答案是-2>✅ 正确答案是：</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><pre tabindex=0><code>以下关于lstio中gateway 的说法，错误的是哪一项?
Gateway 主要用于管理Ingress流量
Gateway 可以配置egress gateway
Gateway 配置应用于服务负载的Envoy 代理上
Gateway 可以用来限制哪些服务可以访问外部网络
</code></pre><p>这道题考察的是对 <strong>Istio 中 Gateway 的理解</strong>。我们逐项分析，找出<strong>错误选项</strong>：</p><hr><h3 id=-选项分析>✅ 选项分析：
<a class=anchor href=#-%e9%80%89%e9%a1%b9%e5%88%86%e6%9e%90>#</a></h3><h4 id=-1-gateway-主要用于管理-ingress-流量>✅ 1. <code>Gateway 主要用于管理 Ingress 流量</code>
<a class=anchor href=#-1-gateway-%e4%b8%bb%e8%a6%81%e7%94%a8%e4%ba%8e%e7%ae%a1%e7%90%86-ingress-%e6%b5%81%e9%87%8f>#</a></h4><p><strong>正确</strong>。
Istio 中的 <code>Gateway</code> 资源主要用于配置入口（<strong>Ingress</strong>）流量，比如通过 HTTP、HTTPS 等协议从集群外部进入服务网格。</p><hr><h4 id=-2-gateway-可以配置-egress-gateway>✅ 2. <code>Gateway 可以配置 egress gateway</code>
<a class=anchor href=#-2-gateway-%e5%8f%af%e4%bb%a5%e9%85%8d%e7%bd%ae-egress-gateway>#</a></h4><p><strong>正确</strong>。
虽然 <code>Gateway</code> 默认是用来处理 Ingress 流量的，但 Istio 同样支持通过配置一个 <strong>Egress Gateway</strong> 来控制 <strong>出网（egress）流量</strong>，例如设置出口 IP、控制访问哪些外部服务等。
这个 egress gateway 通常是通过配置 <strong>ServiceEntry + VirtualService + Gateway</strong> 等来实现的。</p><hr><h4 id=-3-gateway-配置应用于服务负载的-envoy-代理上>❌ 3. <code>Gateway 配置应用于服务负载的 Envoy 代理上</code>
<a class=anchor href=#-3-gateway-%e9%85%8d%e7%bd%ae%e5%ba%94%e7%94%a8%e4%ba%8e%e6%9c%8d%e5%8a%a1%e8%b4%9f%e8%bd%bd%e7%9a%84-envoy-%e4%bb%a3%e7%90%86%e4%b8%8a>#</a></h4><p><strong>错误</strong>。
这是<strong>错误选项</strong>，正确答案就是它。</p><p>解释：
Istio 的 <code>Gateway</code> 配置<strong>并不是应用在每个服务的 sidecar Envoy 上</strong>，而是应用在专门部署的 <strong>Gateway Envoy 实例（比如 ingressgateway）上</strong>。</p><ul><li>Sidecar 是跟随应用 Pod 部署的 Envoy。</li><li>Gateway 是一个<strong>独立部署的 Envoy 实例</strong>，其配置不影响具体服务的 sidecar Envoy。</li></ul><p>所以这句话混淆了 Gateway 和 Sidecar 的概念，是错误的。</p><hr><h4 id=-4-gateway-可以用来限制哪些服务可以访问外部网络>✅ 4. <code>Gateway 可以用来限制哪些服务可以访问外部网络</code>
<a class=anchor href=#-4-gateway-%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e9%99%90%e5%88%b6%e5%93%aa%e4%ba%9b%e6%9c%8d%e5%8a%a1%e5%8f%af%e4%bb%a5%e8%ae%bf%e9%97%ae%e5%a4%96%e9%83%a8%e7%bd%91%e7%bb%9c>#</a></h4><p><strong>正确</strong>。
这个功能可以通过配置 <strong>Egress Gateway + ServiceEntry + VirtualService</strong> 实现，确实可以控制哪些服务能够访问哪些外部地址或 IP。</p><hr><h3 id=-正确答案>✅ 正确答案：
<a class=anchor href=#-%e6%ad%a3%e7%a1%ae%e7%ad%94%e6%a1%88>#</a></h3><blockquote><p><strong>Gateway 配置应用于服务负载的 Envoy 代理上</strong> ✅ 错误选项（答案）</p></blockquote><hr><p>如需我结合图解或 YAML 示例进一步说明，可以继续问我。</p><pre tabindex=0><code>以下关于ConfgMap和Secret对象描述，哪个是错误的?
配置项(ConfigMap):用于存储工作负载所需配置信息的资源类型，例如工作负载的环境变量，需要连接的mysql地址、端口等信息

密钥(Secret):用于存储工作负所需要认证信息、加密的敏感信息等的资源类型，例女私有镜像仓库的帐号、密码等信息
ConfigMap内容修改后，对应的pod必须重启或者重新加载配置
Secret类似于ConfigMap，是用Base64加密，密文显示，只用来存放用于鉴权的登录码信息
</code></pre><p>我们逐项分析，找出哪个关于 <strong>ConfigMap</strong> 和 <strong>Secret</strong> 的描述是错误的：</p><hr><h3 id=-选项分析-1>✅ 选项分析：
<a class=anchor href=#-%e9%80%89%e9%a1%b9%e5%88%86%e6%9e%90-1>#</a></h3><h4 id=-1-配置项configmap用于存储工作负载所需配置信息的资源类型例如工作负载的环境变量需要连接的mysql地址端口等信息>✅ 1. <strong>配置项(ConfigMap):用于存储工作负载所需配置信息的资源类型，例如工作负载的环境变量，需要连接的mysql地址、端口等信息</strong>
<a class=anchor href=#-1-%e9%85%8d%e7%bd%ae%e9%a1%b9configmap%e7%94%a8%e4%ba%8e%e5%ad%98%e5%82%a8%e5%b7%a5%e4%bd%9c%e8%b4%9f%e8%bd%bd%e6%89%80%e9%9c%80%e9%85%8d%e7%bd%ae%e4%bf%a1%e6%81%af%e7%9a%84%e8%b5%84%e6%ba%90%e7%b1%bb%e5%9e%8b%e4%be%8b%e5%a6%82%e5%b7%a5%e4%bd%9c%e8%b4%9f%e8%bd%bd%e7%9a%84%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e9%9c%80%e8%a6%81%e8%bf%9e%e6%8e%a5%e7%9a%84mysql%e5%9c%b0%e5%9d%80%e7%ab%af%e5%8f%a3%e7%ad%89%e4%bf%a1%e6%81%af>#</a></h4><p>✅ <strong>正确描述</strong>：
ConfigMap 确实用于存储非敏感配置信息，如环境变量、配置文件内容、服务地址等。</p><hr><h4 id=-2-密钥secret用于存储工作负载所需要认证信息加密的敏感信息等的资源类型例如私有镜像仓库的帐号密码等信息>✅ 2. <strong>密钥(Secret):用于存储工作负载所需要认证信息、加密的敏感信息等的资源类型，例如私有镜像仓库的帐号、密码等信息</strong>
<a class=anchor href=#-2-%e5%af%86%e9%92%a5secret%e7%94%a8%e4%ba%8e%e5%ad%98%e5%82%a8%e5%b7%a5%e4%bd%9c%e8%b4%9f%e8%bd%bd%e6%89%80%e9%9c%80%e8%a6%81%e8%ae%a4%e8%af%81%e4%bf%a1%e6%81%af%e5%8a%a0%e5%af%86%e7%9a%84%e6%95%8f%e6%84%9f%e4%bf%a1%e6%81%af%e7%ad%89%e7%9a%84%e8%b5%84%e6%ba%90%e7%b1%bb%e5%9e%8b%e4%be%8b%e5%a6%82%e7%a7%81%e6%9c%89%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93%e7%9a%84%e5%b8%90%e5%8f%b7%e5%af%86%e7%a0%81%e7%ad%89%e4%bf%a1%e6%81%af>#</a></h4><p>✅ <strong>正确描述</strong>：
Secret 是为存储敏感信息（如密码、token、证书等）设计的，符合描述。</p><hr><h4 id=-3-configmap内容修改后对应的pod必须重启或者重新加载配置>✅ 3. <strong>ConfigMap内容修改后，对应的Pod必须重启或者重新加载配置</strong>
<a class=anchor href=#-3-configmap%e5%86%85%e5%ae%b9%e4%bf%ae%e6%94%b9%e5%90%8e%e5%af%b9%e5%ba%94%e7%9a%84pod%e5%bf%85%e9%a1%bb%e9%87%8d%e5%90%af%e6%88%96%e8%80%85%e9%87%8d%e6%96%b0%e5%8a%a0%e8%bd%bd%e9%85%8d%e7%bd%ae>#</a></h4><p>✅ <strong>基本正确</strong>：
ConfigMap 修改后，Pod 是否感知变化取决于挂载方式：</p><ul><li>若以<strong>环境变量</strong>形式引用：必须重启 Pod 才生效；</li><li>若以<strong>volume 挂载</strong>方式引用，Kubelet 会定期检测 ConfigMap 变化并更新挂载内容，但应用需要<strong>主动重新加载</strong>配置。</li></ul><p>所以这句话表述是合理的。</p><hr><h4 id=-4-secret类似于configmap是用base64加密密文显示只用来存放用于鉴权的登录码信息>❌ 4. <strong>Secret类似于ConfigMap，是用Base64加密，密文显示，只用来存放用于鉴权的登录码信息</strong>
<a class=anchor href=#-4-secret%e7%b1%bb%e4%bc%bc%e4%ba%8econfigmap%e6%98%af%e7%94%a8base64%e5%8a%a0%e5%af%86%e5%af%86%e6%96%87%e6%98%be%e7%a4%ba%e5%8f%aa%e7%94%a8%e6%9d%a5%e5%ad%98%e6%94%be%e7%94%a8%e4%ba%8e%e9%89%b4%e6%9d%83%e7%9a%84%e7%99%bb%e5%bd%95%e7%a0%81%e4%bf%a1%e6%81%af>#</a></h4><p>❌ <strong>错误描述</strong>，应为正确选项。</p><p><strong>原因：</strong></p><ul><li><strong>Base64 编码不是加密！</strong> Secret 是使用 Base64 编码（<strong>可逆</strong>），主要是为了符合 API 要求或转义处理，而不是安全加密。</li><li><strong>用途也不限于“登录码信息”</strong>。Secret 可用于存放多种类型的敏感信息，例如：<ul><li>密码、API token</li><li>TLS 证书/私钥</li><li>私有镜像仓库认证信息</li><li>自定义敏感配置信息等</li></ul></li></ul><hr><h3 id=-正确答案是>✅ 正确答案是：
<a class=anchor href=#-%e6%ad%a3%e7%a1%ae%e7%ad%94%e6%a1%88%e6%98%af>#</a></h3><blockquote><p><strong>Secret类似于ConfigMap，是用Base64加密，密文显示，只用来存放用于鉴权的登录码信息</strong> ✅ 错误选项（答案）</p></blockquote><hr><p>如需我提供具体 YAML 示例或 Base64 解码演示，也可以继续问我。</p><p>这个说法：</p><blockquote><p><strong>ConfigMap 内容修改后，对应的 Pod 必须重启或者重新加载配置</strong></p></blockquote><p>是 <strong>基本正确的</strong>，但 <strong>并不绝对</strong>，这里来详细解释：</p><hr><h3 id=-正确的理解>✅ 正确的理解：
<a class=anchor href=#-%e6%ad%a3%e7%a1%ae%e7%9a%84%e7%90%86%e8%a7%a3>#</a></h3><p>ConfigMap 的更新是否会让 Pod 中的容器立即感知，取决于它是如何被挂载/使用的：</p><hr><h4 id=-使用方式一作为环境变量注入-pod>✅ <strong>使用方式一：作为环境变量注入 Pod</strong>
<a class=anchor href=#-%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f%e4%b8%80%e4%bd%9c%e4%b8%ba%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e6%b3%a8%e5%85%a5-pod>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>MYSQL_HOST</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>configMapKeyRef</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-config</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>key</span>: <span style=color:#ae81ff>mysql_host</span>
</span></span></code></pre></div><ul><li>Pod 启动时读取 ConfigMap 内容；</li><li><strong>之后即使 ConfigMap 修改，Pod 内不会自动感知变更</strong>；</li><li>✅ <strong>必须重启 Pod 才能加载新配置</strong>。</li></ul><hr><h4 id=-使用方式二以-volume-方式挂载到文件系统>✅ <strong>使用方式二：以 Volume 方式挂载到文件系统</strong>
<a class=anchor href=#-%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f%e4%ba%8c%e4%bb%a5-volume-%e6%96%b9%e5%bc%8f%e6%8c%82%e8%bd%bd%e5%88%b0%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>config-volume</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>configMap</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-config</span>
</span></span></code></pre></div><ul><li>会被挂载到容器文件系统中；</li><li>kubelet <strong>默认每隔 1 分钟（configMapAndSecretChangeDetectionStrategy）检测并刷新挂载文件</strong>；</li><li><strong>但应用必须自己重新读取文件或支持热加载</strong>，否则不会生效。</li></ul><p>所以是：</p><blockquote><p>✅ <strong>Pod 不一定要重启，但要么 Pod 重启，要么应用自己 reload 配置才生效。</strong></p></blockquote><hr><h3 id=总结>❗总结：
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><table><thead><tr><th>使用方式</th><th>ConfigMap 更新后效果</th></tr></thead><tbody><tr><td>环境变量</td><td>必须重启 Pod 才能生效</td></tr><tr><td>文件挂载</td><td>文件内容会更新，但应用需自己 reload 配置</td></tr></tbody></table><hr><h3 id=-结论>✅ 结论：
<a class=anchor href=#-%e7%bb%93%e8%ae%ba>#</a></h3><blockquote><p><strong>“ConfigMap 内容修改后，对应的 Pod 必须重启或者重新加载配置”</strong> 是<strong>准确的总结性描述</strong>。
在考试或面试中，属于 <strong>正确选项</strong>。</p></blockquote><hr><p>如你需要我演示一个自动 reload 的 sidecar 或示例配置，也可以告诉我。</p><pre tabindex=0><code>某用户的dockerfle中，依照顺序分别执行了以下命令:“WORKDIR /a&#34;“RUN /b&#34;、“WORKDIR /c”，此时之后各层的工作目录为以下哪一项?
</code></pre><pre tabindex=0><code>在集群网络地址段规划选择上，在以下哪一种网络模式下，所有集群的容器网段可以重叠，服务网段也可重叠
vpc网络
云原生网络2.0
容隧道网络
Flannel网络
</code></pre><p>在<strong>容器隧道网络</strong>模式下，所有集群的容器网段可以重叠，服务网段也可以重叠。</p><p><strong>原因：</strong></p><ul><li><strong>容器隧道网络 (例如 Flannel 的 VXLAN 模式等):</strong> 在这种模式下，不同节点上的 Pod 之间的通信会通过隧道进行封装。每个节点维护自己的容器网段，Pod 的 IP 地址只在节点内部可见。跨节点的 Pod 通信通过在宿主机之间建立隧道（例如 VXLAN）来实现，原始的 Pod IP 数据包被封装在宿主机的网络包中进行传输。因此，不同集群的容器可以使用相同的 IP 地址段，因为它们在网络层面是隔离的。服务网段通常也是集群内部的虚拟地址，只要在每个集群内部不冲突即可。</li></ul><p><strong>其他网络模式的限制：</strong></p><ul><li><strong>云原生网络 2.0 (例如直接路由模式):</strong> 在这种模式下，容器 IP 通常直接路由，需要确保不同集群的容器网段不重叠，以避免路由冲突。服务网段也通常需要避免与容器网段和节点网络重叠。</li><li><strong>Flannel 网络 (非隧道模式，例如 host-gw 模式):</strong> 在 <code>host-gw</code> 模式下，依赖宿主机路由实现 Pod 间的通信，不同集群的 Pod 网段仍然需要避免重叠，以防止路由冲突。服务网段的限制与云原生网络 2.0 类似。</li></ul><p>因此，<strong>容器隧道网络</strong>是唯一选项，允许在多个集群中重叠使用容器网段和服务网段。</p><pre tabindex=0><code>某用户的dockerfle中，依照顺序分别执行了以下命令:“WORKDIR /a&#34;“RUN d6&#34;、“WORKDIRC”，此时之后各层的工作目录为以下哪一项?
/a/b/c
</code></pre><p>用户的 Dockerfile 中执行了以下命令：</p><ol><li><code>WORKDIR /a</code></li><li><code>RUN d6</code></li><li><code>WORKDIR c</code></li></ol><p>我们来分析一下每一步执行后的工作目录：</p><ul><li><strong>执行 <code>WORKDIR /a</code>:</strong> 这条命令将容器中的当前工作目录设置为 <code>/a</code>。后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code> 和 <code>ADD</code> 指令都将以此目录为基准。</li><li><strong>执行 <code>RUN d6</code>:</strong> 这条命令会在 <code>/a</code> 目录下执行 <code>d6</code> 命令。执行完毕后，工作目录<strong>仍然是 <code>/a</code></strong>。<code>RUN</code> 指令执行 shell 命令，但不会改变后续指令的工作目录。</li><li><strong>执行 <code>WORKDIR c</code>:</strong> 这条命令会将容器中的当前工作目录<strong>更改为 <code>/c</code></strong>。注意，这里使用的是相对路径 <code>c</code>，但因为之前没有使用 <code>WORKDIR</code> 设置过相对路径的基准，或者说上一个 <code>WORKDIR</code> 设置的是绝对路径 <code>/a</code>，Docker 会将相对路径 <code>c</code> <strong>相对于根目录 <code>/</code></strong> 来解析。因此，工作目录被设置为 <code>/c</code>。</li></ul><p><strong>总结:</strong></p><ul><li>执行 <code>WORKDIR /a</code> 后，工作目录为 <code>/a</code>。</li><li>执行 <code>RUN d6</code> 后，工作目录仍然为 <code>/a</code>。</li><li>执行 <code>WORKDIR c</code> 后，工作目录变为 <code>/c</code>。</li></ul><p>因此，此时之后各层的工作目录为 <strong><code>/c</code></strong>。</p><pre tabindex=0><code>以下关于多云容器平台提供的混合云管理方案的描述，错误的是哪一项?
混合云方案是指混合华为云的CCE集群和自建数据中心的Kubernetes集群的场景
云上统一管理，公有云上实现资源、应用、网格等多云统一管理
云上伸缩应用，私有云作为备用资源，公有云作为固定资源，业务流量突发时，实现快速扩容
云上数据无关，核心数据放线下，公有云上运行与核心数据无关的应用

混合云方案是指混合华为云的CCE集群和自建数据中心的Kubernetes集群的场景
</code></pre><p>这道题考查的是对<strong>多云容器平台中混合云管理方案的理解</strong>。我们来逐项分析：</p><hr><h3 id=-正确描述分析>✅ 正确描述分析：
<a class=anchor href=#-%e6%ad%a3%e7%a1%ae%e6%8f%8f%e8%bf%b0%e5%88%86%e6%9e%90>#</a></h3><ol><li><strong>混合云方案是指混合华为云的CCE集群和自建数据中心的Kubernetes集群的场景</strong>
✔️ 正确。这是混合云最典型的场景之一，融合云上的 Kubernetes（如 CCE）与本地集群。</li><li><strong>云上统一管理，公有云上实现资源、应用、网格等多云统一管理</strong>
✔️ 正确。现代多云平台支持统一控制面（如华为云 UCM、阿里云 ASM 等）进行跨集群管理。</li><li><strong>云上数据无关，核心数据放线下，公有云上运行与核心数据无关的应用</strong>
✔️ 正确。这符合安全合规要求的一种典型数据分布方式，在政企金融领域常见。</li></ol><hr><h3 id=-错误项>❌ 错误项：
<a class=anchor href=#-%e9%94%99%e8%af%af%e9%a1%b9>#</a></h3><ol><li><strong>云上伸缩应用，私有云作为备用资源，公有云作为固定资源，业务流量突发时，实现快速扩容</strong>
⛔ <strong>错误</strong>。这个描述<strong>反了</strong>。<ul><li>实际情况是：
➤ <strong>私有云</strong>资源通常为<strong>固定资源</strong>（容量有限、扩容慢）
➤ <strong>公有云</strong>才是<strong>弹性资源</strong>（适合快速扩容、应对突发流量）</li></ul></li></ol><hr><h3 id=-正确答案是-1>✅ 正确答案是：
<a class=anchor href=#-%e6%ad%a3%e7%a1%ae%e7%ad%94%e6%a1%88%e6%98%af-1>#</a></h3><blockquote><p><strong>云上伸缩应用，私有云作为备用资源，公有云作为固定资源，业务流量突发时，实现快速扩容</strong>（❌ 错误）</p></blockquote><hr><p>如需配套图解或更详细背景资料，我可以进一步补充。</p><pre tabindex=0><code>以下关于Karmada的核心架构的描述，错误的是哪一项?

Karmada的控制面拥有自己独立的api
提供针对故障迁移、集群资源等调度策略的支持，支持用户自定义扩展
与member集群同步方面，Karmadaagent的push工作模式，可以有效分散控制面压力
Karmada支持集成KubeEdge实现对边缘k8s集群的管理

Karmada支持集成KubeEdge实现对边缘k8s集群的管理
</code></pre><p>这道题考查对 <strong>Karmada 核心架构的理解</strong>。我们逐项分析：</p><hr><h3 id=-正确项分析>✅ 正确项分析：
<a class=anchor href=#-%e6%ad%a3%e7%a1%ae%e9%a1%b9%e5%88%86%e6%9e%90>#</a></h3><ol><li><strong>Karmada 的控制面拥有自己独立的 API</strong>
✔️ 正确。Karmada 的控制面拥有独立的 API Server，提供资源统一管理能力。</li><li><strong>提供针对故障迁移、集群资源等调度策略的支持，支持用户自定义扩展</strong>
✔️ 正确。Karmada 的调度器支持跨集群调度策略，如故障恢复、资源利用率优先等，并允许扩展调度逻辑。</li><li><strong>Karmada 支持集成 KubeEdge 实现对边缘 k8s 集群的管理</strong>
✔️ 正确。Karmada 的设计初衷之一就是支持多种类型的集群，包括 KubeEdge 管理的边缘集群。</li></ol><hr><h3 id=-错误项分析>❌ 错误项分析：
<a class=anchor href=#-%e9%94%99%e8%af%af%e9%a1%b9%e5%88%86%e6%9e%90>#</a></h3><ol><li><strong>与 member 集群同步方面，Karmada-agent 的 push 工作模式，可以有效分散控制面压力</strong>
⛔ <strong>错误</strong>。<ul><li><strong>实际情况</strong>：Karmada 默认使用的是 <strong>pull 模式</strong>：由 <code>karmada-agent</code> 定期从控制面拉取资源并同步到成员集群。</li><li>这种设计是为了降低网络开销、提高控制面稳定性，而不是 push。</li></ul></li></ol><hr><h3 id=-正确答案是-2>✅ 正确答案是：
<a class=anchor href=#-%e6%ad%a3%e7%a1%ae%e7%ad%94%e6%a1%88%e6%98%af-2>#</a></h3><blockquote><p><strong>与 member 集群同步方面，Karmada-agent 的 push 工作模式，可以有效分散控制面压力</strong>（❌ 错误）</p></blockquote><hr><p>如需进一步了解 Karmada 的工作机制（如控制面组件、调度器、agent 工作流等），我可以提供详细图解或源码路径。</p><pre tabindex=0><code>以下关于多云容器平台MCP进行业务流量分担的描述，错误的是哪一项?

可以从私有云弹性扩容到公有云集群来分担流量

可以自定义域名解析权重

可以对来自不同地域的请求就近转发

需要手动控制在不同云间的应用实例的伸缩
</code></pre><p>以下关于多云容器平台 MCP 进行业务流量分担的描述，<strong>错误</strong>的是：</p><p><strong>需要手动控制在不同云间的应用实例的伸缩</strong></p><p><strong>原因：</strong></p><p>多云容器平台 MCP 的核心价值之一就是提供跨多个云环境的<strong>自动化</strong>管理能力，包括流量分担和应用伸缩。如果需要手动控制不同云之间的应用实例伸缩来分担流量，那就失去了 MCP 的自动化和便捷性优势。</p><p><strong>正确的多云流量分担场景通常包含以下自动化或半自动化的机制：</strong></p><ul><li><strong>基于预设策略的自动伸缩：</strong> MCP 能够根据监控指标（例如 CPU 利用率、内存使用率、请求延迟等）在不同的云环境中自动增加或减少应用实例，以应对流量变化。</li><li><strong>流量亲和性策略：</strong> MCP 可以根据请求的来源、用户地域等信息，将流量导向更合适的云环境中的实例，例如就近转发。</li><li><strong>统一的流量管理：</strong> MCP 提供统一的流量入口和管理机制，例如通过全局负载均衡器或服务网格，能够根据配置的策略（例如权重、健康状态）自动将流量分发到不同云环境中的后端实例。</li></ul><p><strong>其他选项的分析：</strong></p><ul><li><strong>可以从私有云弹性扩容到公有云集群来分担流量:</strong> 这是混合云和多云场景下常见的流量分担方式，利用公有云的弹性能力应对私有云不足的情况，描述是正确的。</li><li><strong>可以自定义域名解析权重:</strong> MCP 通常提供基于 DNS 的流量分发能力，允许管理员设置不同云环境的域名解析权重，从而控制流量的比例，描述是正确的。</li><li><strong>可以对来自不同地域的请求就近转发:</strong> 这是提升用户体验和降低延迟的常见策略，MCP 通常支持基于地理位置的流量路由，描述是正确的。</li></ul><p>因此，认为需要<strong>手动</strong>控制不同云之间应用实例的伸缩是错误的，MCP 的目标正是实现这种伸缩的自动化或至少是策略驱动的。</p><pre tabindex=0><code>单选题9/231、在 Pilot和Envoy 通信的场景中，XDS 协议是基于RPC 实现的传输协议。以下哪一个选项提供路由发现
服务?
LDS
RDS
CDS
EDS
</code></pre><p>正确答案是 <strong>RDS</strong>。</p><p><strong>解释：</strong></p><ul><li><strong>XDS (xDiscovery Service)</strong> 是一组由 Envoy 使用的发现协议，用于动态获取配置信息。它基于 gRPC 实现。</li><li><strong>LDS (Listener Discovery Service)</strong> 用于发现 Envoy 需要监听的端口和相关的监听器配置。</li><li><strong>RDS (Route Discovery Service)</strong> 用于发现 Envoy 如何将流量路由到不同的后端服务。它提供了路由规则、虚拟主机、路径匹配等配置信息。</li><li><strong>CDS (Cluster Discovery Service)</strong> 用于发现后端服务的集群信息，包括集群成员（Pod IP 地址和端口）、负载均衡策略、健康检查配置等。</li></ul><p>在 Pilot 和 Envoy 通信的场景中，Pilot 作为 XDS 服务的提供者，Envoy 通过订阅不同的 XDS API 来获取所需的配置。为了实现路由发现服务，Envoy 需要订阅 <strong>RDS</strong> API，从 Pilot 获取路由规则。</p><pre tabindex=0><code>单选题
10/231、以下关于lsito中Sidecar的描述，错误的是哪一项?
Sidecar将与应用业务逻辑无关的功能抽象到共同基础设施
Sidecar可独立升级
Sidecar不能降低微服务代码的复杂度
Sidecar能够使用istioctl手动注入
</code></pre><p>正确答案是 <strong>Sidecar不能降低微服务代码的复杂度</strong>。</p><p><strong>解释：</strong></p><p>Istio 的 Sidecar 代理（通常是 Envoy）的主要目标之一就是将许多与应用业务逻辑无关的通用功能（例如服务发现、负载均衡、遥测、安全策略实施等）从应用程序代码中<strong>解耦</strong>并下沉到基础设施层。</p><p>通过使用 Sidecar，微服务开发者可以更专注于自己的业务逻辑，而无需在每个服务中重复实现这些通用功能。这实际上<strong>降低了微服务代码的复杂度</strong>，使其更加轻量级和易于维护。</p><p><strong>其他选项的分析：</strong></p><ul><li><strong>Sidecar将与应用业务逻辑无关的功能抽象到共同基础设施:</strong> 这是 Sidecar 的核心设计理念和主要优势，描述是正确的。</li><li><strong>Sidecar可独立升级:</strong> Sidecar 代理可以独立于应用程序容器进行升级，这提供了更大的灵活性和降低了升级风险，描述是正确的。</li><li><strong>Sidecar能够使用 istioctl 手动注入:</strong> Istio 提供了 <code>istioctl</code> 命令行工具，用户可以使用它来手动将 Sidecar 注入到 Kubernetes Pod 中，描述是正确的。</li></ul><p>因此，认为 Sidecar 不能降低微服务代码的复杂度是错误的。相反，它是 Sidecar 的一个重要优势。</p><pre tabindex=0><code>单选题
11/231、以下关于应用服务网格ASM流量监控的相关描述，错误的是哪一项?
流量监控记录的是组件过去24小时内的数据，所以当部分组件删除后并不能及时的在拓扑图上消失，而是会仍然存在一段时间
流量治理中的故障注入功能，能够作用于基于请求比例灰度发布的场景
企业版网格多集群场景下，只支持集群内部服务之间的流量监控
企业版网格多集群场景下，暂时不支持跨集群服务之间的流量监控
</code></pre><p>正确答案是 <strong>企业版网格多集群场景下，只支持集群内部服务之间的流量监控</strong>。</p><p><strong>解释：</strong></p><p>应用服务网格 (ASM) 的核心价值之一就是提供对跨多个集群的服务流量的可观测性。在企业版网格的多集群场景下，通常会支持<strong>跨集群服务之间的流量监控</strong>。管理员可以通过统一的控制平面来查看和分析不同集群中服务之间的调用关系、性能指标和健康状态。</p><p><strong>其他选项的分析：</strong></p><ul><li><strong>流量监控记录的是组件过去24小时内的数据，所以当部分组件删除后并不能及时的在拓扑图上消失，而是会仍然存在一段时间:</strong> 这通常是出于数据聚合、性能和避免频繁更新拓扑图的考虑，是一种常见的设计，描述可能是正确的。</li><li><strong>流量治理中的故障注入功能，能够作用于基于请求比例灰度发布的场景:</strong> 故障注入（例如延迟注入、错误注入）是服务网格中用于测试系统韧性的重要功能，它可以精确地应用于符合特定条件的流量（例如灰度发布中的一部分流量），描述是正确的。</li><li><strong>企业版网格多集群场景下，暂时不支持跨集群服务之间的流量监控:</strong> 这与服务网格的核心价值相悖。企业级通常会要求具备跨集群的统一可观测性。因此，这个描述很可能是<strong>错误</strong>的。</li></ul><p>因此，<strong>企业版网格多集群场景下，只支持集群内部服务之间的流量监控</strong> 是错误的描述。企业版 ASM 通常会提供跨集群的流量监控能力。</p><pre tabindex=0><code>单选题 12/231、设置容器日志转储后，ICAget采集的日志不会实时转储，而是积攒到一定量后再转储。当积攒到的日志容量达到多少时会触发转储动作?
10MB
20MB
50MB
100M

100m
</code></pre><pre tabindex=0><code>单选题131231、应用运维管理AOM的日志管理功能不包括以下哪一项?
日志检索
日志转储
日志报表展示
日志智能订阅

日志报表展示
</code></pre><p>正确答案是 <strong>日志智能订阅</strong>。</p><p><strong>解释：</strong></p><p>应用运维管理 (AOM) 的日志管理功能通常包括对日志数据的收集、存储、检索、分析和可视化。让我们逐个分析选项：</p><ul><li><strong>日志检索:</strong> 这是日志管理的基本功能，允许用户根据关键字、时间范围、来源等条件查找特定的日志条目。</li><li><strong>日志转储:</strong> 指将存储的日志数据导出或备份到其他存储介质或系统，以满足长期存储、合规性或进一步分析的需求。</li><li><strong>日志报表展示:</strong> 日志管理系统通常提供各种报表和仪表盘，以可视化地展示日志数据的统计信息、趋势和异常情况，帮助用户更好地理解系统行为和性能。</li><li><strong>日志智能订阅:</strong> “日志智能订阅” 通常指的是用户可以根据预定义的规则或模式，自动接收符合条件的实时或近实时的日志通知或流。虽然一些高级的日志管理或事件管理系统可能包含类似功能，但这<strong>并非应用运维管理 AOM 日志管理功能的核心或常见组成部分</strong>。更常见的是告警或通知功能，这些功能基于日志分析结果触发，而不是直接订阅原始日志流。</li></ul><p>因此，<strong>日志智能订阅</strong> 不是应用运维管理 AOM 日志管理功能通常包含的选项。</p><pre tabindex=0><code>单选题 141231、对弹性到CC的Pod，若其配置的资源规格不满足CCI容器规范，virtua-kubelet会自动尝试将Pod资源向上规整到满足CCI容器规范的范围。CPU向上调整的极限是多少核?
8核
16核
32核
64核

32
</code></pre><pre tabindex=0><code>单选题

15/231、以下关于CCE和CCI的区别的描述，正确的是哪一项?

使用CCE，无需要创建集群和节点，而CCI需要创建和管理Master节点及Work节点CCE支持按需计费方式，而CCI支持包年/包月与按需计费两种方式CCE适用于大规模长期稳定的应用，而CCI适用于批后计算、高性能计算、突发扩容等场景CCE最小计A价单位为秒，CCI最小计价单位为小时
</code></pre><p>正确答案是 <strong>CCE适用于大规模长期稳定的应用，而CCI适用于批后计算、高性能计算、突发扩容等场景</strong>。</p><p><strong>解释：</strong></p><p>让我们逐一分析每个选项：</p><ul><li><strong>使用 CCE，无需要创建集群和节点，而 CCI 需要创建和管理 Master 节点及 Worker 节点:</strong> 这是<strong>错误</strong>的。CCE (Cloud Container Engine) 是华为云的 Kubernetes 服务，它<strong>需要</strong>创建和管理集群（包括 Master 和 Worker 节点），虽然华为云会托管 Master 节点。CCI (Cloud Container Instance) 才是真正的 Serverless 容器实例，<strong>无需</strong>用户管理节点。</li><li><strong>CCE 支持按需计费方式，而 CCI 支持包年/包月与按需计费两种方式:</strong> 这是<strong>错误</strong>的。CCE 和 CCI 都支持<strong>按需计费</strong>的方式。CCE 通常也支持包年/包月等预付费模式，而 CCI 主要以按需计费为主，更贴合其弹性使用的特性。</li><li><strong>CCE 适用于大规模长期稳定的应用，而 CCI 适用于批后计算、高性能计算、突发扩容等场景:</strong> 这是<strong>正确</strong>的。<ul><li><strong>CCE</strong> 提供完整的 Kubernetes 集群管理能力，适合运行需要长期稳定运行、有复杂编排和管理需求的大规模应用。</li><li><strong>CCI</strong> 提供轻量级的 Serverless 容器实例，按实际使用资源计费，启动速度快，非常适合短时任务、弹性伸缩、批处理、事件驱动等场景。</li></ul></li><li><strong>CCE 最小计价单位为秒，CCI 最小计价单位为小时:</strong> 这是<strong>错误</strong>的。通常情况下，云计算服务的计费粒度都在逐渐细化。CCE 和 CCI 的按需计费都可能支持<strong>秒级</strong>计费，具体以华为云最新的计费策略为准。</li></ul><p>因此，最准确描述 CCE 和 CCI 区别的选项是 <strong>CCE 适用于大规模长期稳定的应用，而 CCI 适用于批后计算、高性能计算、突发扩容等场景</strong>。</p><pre tabindex=0><code>单选题 16/231、以下关于华为云容器引擎CCE和自建Kubernetes集群的描述，错误的是哪一项?
自建kubermetes集群管理基础设施通常涉及安装、操作、扩展自己的集群管理软件、配置管理系统和监控解决方案，管理复杂
自建Kubermetes集群需要根据业务流量情况和健康情况人工确定容器服务的部署，可扩展性差云容器引擎CCE需自行登录服务器输入命令行查看监控、日志信息，无法及时察知系统异常
借助云容器引擎CCE，可以一键创建和升级Kubermetes容器集群，无需自行搭建Docker和Kubernetes集群
</code></pre><p>正确答案是 <strong>云容器引擎CCE需自行登录服务器输入命令行查看监控、日志信息，无法及时察觉系统异常</strong>。</p><p><strong>解释：</strong></p><p>华为云容器引擎 CCE 提供了完善的监控和日志管理功能，旨在帮助用户方便地观察和诊断集群及应用的状态。它通常包括：</p><ul><li><strong>集成的监控仪表盘:</strong> CCE 提供可视化的监控界面，展示集群、节点、Pod 和容器的各项性能指标（CPU、内存、网络等）。用户无需登录服务器即可查看这些信息。</li><li><strong>集成的日志管理:</strong> CCE 通常与华为云的日志服务 LTS 集成，用户可以在控制台集中查看和检索集群中各个容器的日志，而无需登录到每个节点或 Pod 中。</li><li><strong>告警机制:</strong> CCE 允许用户配置告警规则，当集群或应用的指标达到预设阈值时，系统会自动发送告警通知，帮助用户及时发现和处理异常。</li></ul><p>因此，认为 CCE 需要用户自行登录服务器通过命令行查看监控和日志，并且无法及时察觉系统异常是错误的。CCE 提供了更便捷和自动化的方式来管理集群的监控和日志。</p><p><strong>其他选项的分析：</strong></p><ul><li><strong>自建 Kubernetes 集群管理基础设施通常涉及安装、操作、扩展自己的集群管理软件、配置管理系统和监控解决方案，管理复杂:</strong> 这是正确的。自建 Kubernetes 集群需要用户承担更多基础设施的管理和维护工作。</li><li><strong>自建 Kubernetes 集群需要根据业务流量情况和健康情况人工确定容器服务的部署，可扩展性差:</strong> 这是相对而言正确的。虽然 Kubernetes 本身提供了弹性伸缩的能力，但在自建场景下，配置和管理这些自动伸缩策略可能更加复杂，并且依赖于用户自行搭建和维护监控告警系统。相比之下，CCE 通常提供了更便捷的自动伸缩和弹性伸缩能力。</li><li><strong>借助云容器引擎 CCE，可以一键创建和升级 Kubernetes 容器集群，无需自行搭建 Docker 和 Kubernetes 集群:</strong> 这是正确的。CCE 简化了 Kubernetes 集群的创建和管理过程，用户无需从头开始搭建底层基础设施。</li></ul><pre tabindex=0><code>单选题17/231、以下关于CCE支持的几种容器网络的描述，错误的是哪一项?

CCE支持容器隧道网络VPC网络、云原生网络2.0三种模型

子

云原生网络2.0基于vxlan隧道封装，有一定性能损耗，而容器隧道网络性能无损耗容器隧道网络和VPC网络适用于CCE集群，而云原生网络2.0适用于CC

Turbo集群

容器隧道网络和云原生网络2.0最大均可支持2000节点，而VPC网络默认仅支持200节点
</code></pre><p>正确答案是 <strong>云原生网络 2.0 基于 vxlan 隧道封装，有一定性能损耗，而容器隧道网络性能无损耗</strong>。</p><p><strong>解释：</strong></p><ul><li><strong>容器隧道网络 (例如 Flannel 的 VXLAN 模式):</strong> 这种网络模式通常会使用 <strong>VXLAN (Virtual Extensible LAN)</strong> 等隧道技术对容器间的通信进行封装，这会带来一定的<strong>性能损耗</strong>，因为需要额外的封包和解包操作。</li><li><strong>云原生网络 2.0 (例如基于 ENI 的直接路由模式):</strong> 这种网络模式通常会将容器的网络接口直接连接到 VPC 网络，容器拥有 VPC 内的 IP 地址，可以直接进行路由，<strong>性能损耗相对较小</strong>，接近于 VPC 网络的性能。它避免了额外的隧道封装开销。</li></ul><p>因此，描述云原生网络 2.0 基于 VXLAN 封装且有性能损耗，而容器隧道网络性能无损耗是错误的。情况正好相反。</p><p><strong>其他选项的分析：</strong></p><ul><li><strong>CCE 支持容器隧道网络 VPC 网络、云原生网络 2.0 三种模型:</strong> 这是正确的。CCE 通常支持这几种主流的容器网络模型，以满足不同场景的需求。</li><li><strong>容器隧道网络和 VPC 网络适用于 CCE 集群，而云原生网络 2.0 适用于 CCE Turbo 集群:</strong> 这通常是正确的。云原生网络 2.0 由于其高性能和与 VPC 的深度集成，更适合对网络性能有较高要求的 CCE Turbo 集群。</li><li><strong>容器隧道网络和云原生网络 2.0 最大均可支持 2000 节点，而 VPC 网络默认仅支持 200 节点:</strong> 这通常是正确的。容器隧道网络和云原生网络 2.0 在设计上可以支持更大规模的集群节点，而 VPC 网络可能会受到 IP 地址数量和路由规则等限制，默认支持的节点数量较少。</li></ul><pre tabindex=0><code>单选题

19/231、在ingerss中，以下哪个组件真正实现外部请求的转发?

Ingress
ingress
Service
Endpoint

service
</code></pre><p>正确答案是 <strong>Ingress Controller</strong>。</p><p>您提供的选项中没有直接提到 <strong>Ingress Controller</strong>。在 Kubernetes Ingress 的体系结构中，以下组件协同工作以实现外部请求的转发：</p><ol><li><strong>Ingress 对象 (API 对象):</strong> 它定义了将外部请求路由到集群内部服务的规则。您提供的选项中的 &ldquo;Ingress&rdquo; 和 &ldquo;ingress&rdquo; 指的是这个 API 对象。但 Ingress 对象本身<strong>不</strong>负责实际的流量转发。它只是一个配置。</li><li><strong>Ingress Controller:</strong> 这是一个具体的控制器（通常以 Pod 的形式运行在集群中），它监听 Ingress 对象的创建、更新和删除事件，并根据这些规则配置底层的负载均衡器或代理服务器（例如 Nginx Ingress Controller、Traefik、HAProxy Ingress Controller 等）。<strong>Ingress Controller 才是真正实现外部请求接收、路由和转发到后端 Service 的组件。</strong></li><li><strong>Service:</strong> Kubernetes Service 是一种抽象，它为一组 Pod 提供了一个稳定的 IP 地址和 DNS 名称。Ingress Controller 会将流量转发到后端 Service。</li><li><strong>Endpoint:</strong> Endpoint 对象记录了 Service 对应的后端 Pod 的 IP 地址和端口。Ingress Controller 通常会通过 Service 发现其对应的 Endpoint。</li></ol><p><strong>由于您提供的选项中没有 Ingress Controller，最接近的但并不完全准确的答案是 Ingress。</strong> 然而，需要明确的是，<strong>Ingress Controller</strong> 才是真正执行流量转发的组件。</p><p>如果必须从您提供的选项中选择，考虑到 Ingress 对象定义了转发规则，可以勉强选择 <strong>Ingress</strong> (或 <strong>ingress</strong>，两者在 Kubernetes 中通常不区分大小写，指的是同一个 API 对象)，但请务必理解它本身不执行转发，而是由 Ingress Controller 根据 Ingress 对象的配置来完成转发。</p><p><strong>更好的表述应该是：Ingress Controller 真正实现外部请求的转发。</strong></p><pre tabindex=0><code>单选题 20/231、在K8s中，当节点内存资源不足时，内核可以按照策略的优先级，优先终上服务质量OS低的容器，以下关于优先级的描术，哪个是正确的?

状态为burstable优先级的POD，设置的requests和limits不一致，00MAdi为0~1000，会被优先kil

状态为guaranteed优先级的POD，设置的requests和limits一致，00MAdij为-998，会被优先ki

状态为besteffort优先级的POD，不设置requests和limits，当系统OOM后，会被优先kil!

OOMAdj值越高，Qos越低
</code></pre><p>正确答案是 <strong>状态为 besteffort 优先级的 POD，不设置 requests 和 limits，当系统 OOM 后，会被优先 kill!</strong></p><p><strong>解释：</strong></p><p>Kubernetes 使用服务质量 (QoS) 类来管理 Pod 的资源分配和优先级。当节点内存不足 (OOM - Out Of Memory) 时，kubelet 会根据 Pod 的 QoS 优先级和 OOM score 杀死 Pod 以回收内存。优先级从低到高依次是：BestEffort &lt; Burstable &lt; Guaranteed。</p><p>让我们分析一下每个选项：</p><ul><li><strong>状态为 burstable 优先级的 POD，设置的 requests 和 limits 不一致，OOMAdj 为 0~1000，会被优先 kill:</strong> Burstable 优先级的 Pod 会在资源紧张时被考虑驱逐，但优先级高于 BestEffort。OOMAdj 值在 0 到 1000 之间，值越高越容易被 kill。但它们不会比 BestEffort 的 Pod 更优先被 kill。</li><li><strong>状态为 guaranteed 优先级的 POD，设置的 requests 和 limits 一致，OOMAdj 为 -998，会被优先 kill:</strong> Guaranteed 优先级的 Pod 拥有最高的优先级，kubelet 会尽力保证它们的资源需求。它们的 OOMAdj 值通常为 -998 或更低，这意味着它们最不容易被 OOM killer 杀死。</li><li><strong>状态为 besteffort 优先级的 POD，不设置 requests 和 limits，当系统 OOM 后，会被优先 kill!</strong> BestEffort 优先级的 Pod 不保证任何资源，当节点内存不足时，它们是<strong>最先</strong>被 kubelet 考虑驱逐的，因为它们对系统资源的要求最低。它们的 OOMAdj 值通常是最高的正值。</li><li><strong>OOMAdj 值越高，Qos 越低:</strong> 这是正确的。OOMAdj (Out-of-Memory Adjustment) 是 Linux 内核的一个参数，kubelet 会根据 Pod 的 QoS 类设置这个值。<strong>OOMAdj 值越高，该进程被 Linux 内核 OOM killer 杀死的可能性就越大，因此对应的 QoS 也就越低。</strong> BestEffort Pod 的 OOMAdj 值最高，Guaranteed Pod 的 OOMAdj 值最低（负值）。</li></ul><p><strong>因此，最准确的描述是状态为 besteffort 优先级的 POD 在系统 OOM 后会被优先 kill!</strong> 虽然 &ldquo;OOMAdj 值越高，Qos 越低&rdquo; 这个描述也是正确的，但问题是关于<strong>优先级</strong>的描述，而选项 C 直接描述了 BestEffort Pod 的驱逐优先级。</p><pre tabindex=0><code>单选题 21/231、当镜像仓库SWR中的镜像版本更新时，用户希望能够自动更新CCE或CCI使用该镜像的应用，应该采用以下哪一个方法实现?

在SWR中为镜像添加触发器

在CCE或CCI中更新负载部霉文件

在SWR中添加存活时间老化规则

在SWR中添加版本数目老化规则
</code></pre><p>正确答案是 <strong>A. 在 SWR 中为镜像添加触发器</strong>。</p><p><strong>解释：</strong></p><p>华为云镜像仓库 SWR (Software Repository for Container) 提供了镜像触发器 (Image Trigger) 功能。通过在 SWR 中为特定的镜像仓库和标签配置触发器，可以在镜像版本更新（例如推送了新的镜像标签）时自动触发预定义的操作。</p><p>对于自动更新 CCE 或 CCI 中使用该镜像的应用，您可以配置触发器来：</p><ul><li><strong>触发 CCE 工作负载的更新:</strong> 可以配置触发器调用 CCE 的 API 来更新 Deployment、StatefulSet 等工作负载的镜像版本，从而触发 Pod 的滚动更新。</li><li><strong>触发 CCI 实例的更新:</strong> 可以配置触发器调用 CCI 的 API 来更新容器实例的镜像版本，并触发实例的重启或更新。</li></ul><p><strong>其他选项的分析：</strong></p><ul><li><strong>B. 在 CCE 或 CCI 中更新负载部署文件:</strong> 这是一种手动更新镜像的方法，无法实现自动更新。</li><li><strong>C. 在 SWR 中添加存活时间老化规则:</strong> 存活时间老化规则用于自动删除长时间未使用的镜像版本，与自动更新应用无关。</li><li><strong>D. 在 SWR 中添加版本数目老化规则:</strong> 版本数目老化规则用于保留最新 N 个镜像版本，删除旧版本，同样与自动更新应用无关。</li></ul><p>因此，<strong>在 SWR 中为镜像添加触发器</strong> 是实现镜像版本更新时自动更新 CCE 或 CCI 应用的正确方法。</p><pre tabindex=0><code>单选题22/231、以下关于Cluster AutoScaler伸缩策略的描述，哪个是错误的?

Cluster

Cluster

当承载某应用的容器CPU使用率飙升时，可通过配置Cluster当集群里资源不足时，可通过配置Cluster

当集群里资源不足时，可通过配置Cluster

当承载某应用的容器CPU使用率飙升时，可通过配置Cluster当集群里资源不足时，可通过配置Cluster
</code></pre><p>您好！您提供的选项似乎不完整，缺少了伸缩策略的具体描述。为了给出正确的答案，请您提供完整的选项内容。</p><p>不过，我可以先根据 Cluster Autoscaler 的常见行为和策略，推测一些可能的选项以及哪个可能是错误的：</p><p><strong>Cluster Autoscaler 的常见伸缩策略通常包括：</strong></p><ul><li><strong>基于资源利用率的伸缩:</strong> 当集群中某些节点的 CPU 或内存利用率过高或过低时，自动增加或减少节点。</li><li><strong>基于 Pod Pending 的伸缩:</strong> 当集群中有因资源不足而无法调度的 Pending Pod 时，自动增加新的节点。</li><li><strong>基于自定义指标的伸缩:</strong> (通常需要集成 Horizontal Pod Autoscaler (HPA) 和 Custom Metrics Adapter) 根据应用程序的自定义指标进行节点伸缩。</li></ul><p><strong>以下是一些可能错误的描述示例 (需要您提供完整选项才能确定哪个是您题目中的错误选项)：</strong></p><ul><li><strong>Cluster Autoscaler 会根据单个容器的 CPU 使用率直接触发节点伸缩。</strong> (错误。Cluster Autoscaler 主要关注节点级别的资源利用率和 Pod 的调度需求，而不是单个容器的指标。单个容器的伸缩通常由 Horizontal Pod Autoscaler (HPA) 负责。)</li><li><strong>Cluster Autoscaler 可以保证在任何情况下都能立即满足 Pod 的资源需求。</strong> (错误。节点扩容需要时间，并且受到云提供商的资源限制。)</li><li><strong>Cluster Autoscaler 会在 Pod CPU 使用率降低时立即缩减节点。</strong> (错误。为了避免频繁伸缩，Cluster Autoscaler 通常会设置缩容的冷却时间 (scale-down-delay)。)</li><li><strong>Cluster Autoscaler 的缩容策略会优先删除运行重要应用的节点。</strong> (错误。Cluster Autoscaler 会尽量避免删除运行重要 Pod 的节点，例如带有特定的 annotation。)</li></ul><p><strong>请您提供完整的选项，我将能够准确地告诉您哪个描述是错误的。</strong></p><pre tabindex=0><code>单选题 23/231、在一个集群中部分节点配置有GPU卡，如果不希望不使用专用硬件的Pod调度到这个节点上，可以通过配置以下选项中描述的哪个策略?

通过配置Taints和Toleration策略

通过配置HPC策略

通过配置Cluster

通过配置PodAffinity策略
</code></pre><p>正确答案是 <strong>A. 通过配置 Taints 和 Toleration 策略</strong>。</p><p><strong>解释：</strong></p><ul><li><strong>Taints (污点):</strong> 您可以在配置有 GPU 卡的节点上设置 Taints。Taint 用于标记节点，表明某些 Pod 不应该调度到该节点上，除非这些 Pod 具有相应的 Toleration。例如，您可以设置一个名为 <code>nvidia.com/gpu=present:NoSchedule</code> 的 Taint 到 GPU 节点上。</li><li><strong>Toleration (容忍度):</strong> 您需要在希望调度到带有 GPU Taint 节点的 Pod 的 PodSpec 中配置相应的 Toleration。Toleration 允许 Pod 容忍一个或多个 Taints。只有当 Pod 的 Toleration 与节点的 Taint 相匹配时，该 Pod 才能调度到该节点上。</li></ul><p>通过这种 Taints 和 Toleration 的组合使用，您可以确保只有需要 GPU 资源的 Pod 才会被调度到配置了 GPU 卡的节点上，而其他不需要 GPU 的 Pod 则会被调度到没有这些 Taints 的节点上。</p><p><strong>其他选项的分析：</strong></p><ul><li><strong>B. 通过配置 HPC 策略:</strong> HPC (High-Performance Computing) 策略通常关注于高性能计算任务的资源调度和优化，例如节点亲和性、拓扑感知调度等，但它不是直接用来阻止非 GPU Pod 调度到 GPU 节点的机制。</li><li><strong>C. 通过配置 Cluster:</strong> &ldquo;Cluster&rdquo; 本身不是一个具体的策略配置选项。Cluster Autoscaler 是用于自动调整集群节点数量的组件，与控制 Pod 在特定节点上的调度无关。</li><li><strong>D. 通过配置 PodAffinity 策略:</strong> PodAffinity (Pod 亲和性) 用于控制 Pod 应该调度到哪些节点上，基于已经运行在该节点上的其他 Pod 的标签。虽然可以使用节点标签配合 PodAffinity 实现类似的效果，但 Taints 和 Toleration 是 Kubernetes 专门为控制 Pod 是否可以（或不可以）调度到特定节点而设计的机制，更加直接和清晰。</li></ul><pre tabindex=0><code>单选题 24/231、某用户使用容器隧道网络作为容器网络模型，容器网段为172.168.0.0/16(IP量为65536)，节点从容器网段中一次分配的IP网段为16，则最多可创建的节点数量和每个节点最多创建的POD数量是以下哪一项?

A)4096，16

B)4096,256

256,16

256,256
</code></pre><p>正确答案是 <strong>A) 4096，16</strong>。</p><p><strong>解释：</strong></p><ul><li><strong>容器网段:</strong> 172.168.0.0/16，总共有 216=65536 个 IP 地址。</li><li><strong>每个节点分配的 IP 网段大小:</strong> /28 (因为 32 - 16 = 16，而 216−12=24=16，所以是 /28，每个节点分配 232−28=24=16 个 IP 地址)。题目中直接说明每个节点分配的 IP 网段为 16，这等价于一个 /28 的子网。</li></ul><p><strong>计算可创建的节点数量:</strong></p><p>总 IP 地址数量 / 每个节点分配的 IP 地址数量 = 可创建的节点数量</p><p>65536/16=4096</p><p><strong>计算每个节点最多创建的 Pod 数量:</strong></p><p>在容器隧道网络模型中，每个 Pod 通常会分配一个独立的 IP 地址。因此，每个节点最多可以创建的 Pod 数量受到分配给该节点的 IP 地址数量的限制。题目中说明每个节点从容器网段中一次分配的 IP 网段为 16，这意味着每个节点最多可以拥有 <strong>16</strong> 个 Pod 的 IP 地址。</p><p>因此，最多可创建的节点数量是 4096，每个节点最多创建的 Pod 数量是 16。</p><pre tabindex=0><code>单选题26/231、以下关于多云场景下存在的挑战的描述，错误的是哪一项?
集群繁多，配置繁琐
业务过于集中
集群的边界限制，带来资源调度、弹性伸缩等受限问题
厂商绑定


业务过于集中
</code></pre><p>B) 业务过于集中</p><p>多云战略的一个主要目标和特点就是<strong>分散风险、避免业务过度集中</strong>在单一云服务商或单一地理位置。因此，“业务过于集中”与多云场景的特性是相悖的，它不是多云场景下会存在的挑战，反而是多云试图解决的问题。</p><p>其它选项描述的是多云场景下确实存在的挑战：</p><ul><li><strong>A) 集群繁多，配置繁琐:</strong> 管理和维护来自不同云服务商的多个集群，配置和运维的复杂度会显著增加。</li><li><strong>C) 集群的边界限制，带来资源调度、弹性伸缩等受限问题:</strong> 不同云平台之间存在技术壁垒和管理边界，实现跨云的统一资源调度、无缝弹性伸缩等会比较困难。</li><li><strong>D) 厂商绑定:</strong> 虽然多云旨在减少对单一厂商的过度依赖，但在实际操作中，一旦在某个云平台上使用了其特有的服务或技术，仍然可能形成一定程度的厂商绑定，迁移成本较高。</li></ul><pre tabindex=0><code>单选题

28/231、以下关于应用服务网格ASM灰度发布全流程自动化管理的说法，错误的是哪一项?

灰度版本一键部署，流量切换一键生效

B

配置式灰度策略，仅支持流量比例策略

一站式健康、性能、流量监控

能够实现灰度发布过程量化、智能化、可视化
</code></pre><p>B) 配置式灰度策略，仅支持流量比例策略</p><p><strong>错误原因：</strong></p><p>应用服务网格 (ASM) 通常提供<strong>非常灵活和丰富的流量管理策略</strong>，而不仅仅是基于流量比例的灰度发布。除了按百分比切分流量外，ASM 通常还支持更复杂的灰度策略，例如：</p><ul><li><strong>基于请求内容：</strong> 如基于 HTTP Header (例如 <code>user-agent</code>、<code>cookie</code>、自定义业务标签)、URL 路径、请求参数等进行流量切分。这允许将特定用户群体（如内测用户、特定地区用户）或特定类型的请求导向灰度版本。</li><li><strong>基于来源：</strong> 如基于源 IP 地址或源服务。</li></ul><p>声称“仅支持流量比例策略”是对现代服务网格能力的一种低估，因此这个说法是错误的。</p><p><strong>其他选项的正确性：</strong></p><ul><li><strong>A) 灰度版本一键部署，流量切换一键生效:</strong> 这是服务网格致力于实现的目标之一，通过简化操作来提高发布效率和降低风险。</li><li><strong>C) 一站式健康、性能、流量监控:</strong> 服务网格的核心能力之一就是提供强大的可观测性，对灰度版本和稳定版本的健康状况、性能指标（如延迟、错误率）和流量分布进行统一监控。</li><li><strong>D) 能够实现灰度发布过程量化、智能化、可视化:</strong> 通过监控数据，可以量化灰度版本的表现；结合自动化工具，可以实现基于策略的智能决策（如自动回滚或逐步放量）；同时，提供可视化界面来展示整个灰度过程的状态。</li></ul><pre tabindex=0><code>单选题?29/231、在lstio 架构中，基于xDS协议提供了标准的控制面规范，并以此向数据面传递服务信息和治理规则。以下哪一个选项提供集群发现服务?
LDS
RDS
CDS
Eds

rds
</code></pre><p>正确答案是：<strong>CDS</strong></p><hr><p><strong>解析：</strong></p><p>在 Istio 架构中，xDS 协议是 Envoy 与控制面通信的重要机制，它包括以下几个主要组件：</p><table><thead><tr><th>缩写</th><th>全称</th><th>功能简介</th></tr></thead><tbody><tr><td><strong>LDS</strong></td><td>Listener Discovery Service</td><td>监听器发现服务，配置监听端口及协议等。</td></tr><tr><td><strong>RDS</strong></td><td>Route Discovery Service</td><td>路由发现服务，配置路由规则。</td></tr><tr><td><strong>CDS</strong></td><td>Cluster Discovery Service</td><td><strong>集群发现服务，配置上游服务集群信息。</strong></td></tr><tr><td><strong>EDS</strong></td><td>Endpoint Discovery Service</td><td>实例发现服务，配置具体的服务实例（IP+端口）。</td></tr></tbody></table><hr><p><strong>因此，提供“集群发现服务”的是 CDS（Cluster Discovery Service）。</strong></p><p>✅ <strong>正确答案：CDS</strong></p><pre tabindex=0><code>单选题 31/231、容器洞察引擎CIE的容器洞察提供了资源全景、资源消耗、近一小时的指标展示以及故障一览和故障分析的功能。其支持查看的资源不包括以下哪个?

容器组Pod

守护进程集DaemonSet

无状态负载Deployment

有状态负载StatefulSet
</code></pre><p>好的，答案是 <strong>守护进程集DaemonSet</strong>。</p><p><strong>解释:</strong></p><p>容器洞察引擎CIE的容器洞察通常关注于代表应用实例的资源，例如：</p><ul><li><strong>容器组Pod:</strong> Kubernetes 中最小的可部署单元，包含一个或多个共享存储、网络、以及如何运行这些容器的声明的容器。</li><li><strong>无状态负载Deployment:</strong> Kubernetes 控制器，用于管理无状态应用（Pod 的副本集）。</li><li><strong>有状态负载StatefulSet:</strong> Kubernetes 控制器，用于管理有状态应用（具有稳定网络标识、持久存储等）。</li></ul><p><strong>守护进程集DaemonSet</strong> 确保在每个（或某些特定的）节点上运行一个 Pod 的副本。它更多地关注于集群级别的、通常是基础设施相关的任务，而不是代表单个应用实例。因此，容器洞察引擎的资源洞察功能通常不直接查看 DaemonSet 本身，而是关注由 DaemonSet 管理的 Pod 实例的资源使用情况。</p><p>因此，容器洞察引擎CIE的容器洞察通常不直接支持查看 <strong>守护进程集DaemonSet</strong> 这个资源对象本身，而是会查看由 DaemonSet 管理的 Pod 的资源情况。</p><pre tabindex=0><code>单选题321231、若需要将部署在CCE上的无状态负载、有状态负载、普通任务三种类型的容器实例弹性创建到华为云云容实例CCI服务上，在创建CCE集群时，需要设置集群的网络类型为以下哪一项?

VPC网络

多

容器隧道网络

VPC网络和容器隧道网络均可

CCI专用网络


vpc
</code></pre><p>好的，答案是 <strong>容器隧道网络</strong>。</p><p><strong>解释:</strong></p><p>为了能够将部署在 CCE 上的不同类型的容器实例（无状态负载 Deployment、有状态负载 StatefulSet、普通任务 Job/CronJob）弹性地创建到华为云容器实例 CCI 服务上，CCE 集群的网络类型必须设置为 <strong>容器隧道网络</strong>。</p><p><strong>原因：</strong></p><ul><li><strong>容器隧道网络</strong> 允许 CCE 集群内的 Pod 和 CCI 之间建立安全的隧道连接。这种隧道机制使得 CCE 集群内的容器实例能够通过该隧道弹性地扩展到 CCI 上，并且能够与 CCE 集群内的其他服务进行通信。</li><li><strong>VPC 网络</strong> 是华为云的基础网络，CCE 集群本身需要部署在 VPC 网络内，但仅有 VPC 网络无法直接实现 Pod 到 CCI 的弹性创建和通信。</li><li><strong>VPC 网络和容器隧道网络均可</strong> 的说法不准确。虽然 CCE 集群需要 VPC 网络作为基础，但实现弹性伸缩到 CCI 的关键在于容器隧道网络。</li><li><strong>CCI 专用网络</strong> 并非 CCE 集群的网络类型选项。CCI 本身运行在 VPC 网络中，但 CCE 集群需要特定的网络类型才能与其协同工作进行弹性伸缩。</li></ul><p><strong>总结：</strong></p><p>要实现将 CCE 上的容器实例弹性创建到 CCI，必须在创建 CCE 集群时选择 <strong>容器隧道网络</strong>。</p><pre tabindex=0><code>单选题 33/231、若需要对Kubermetes集群某节点NodeA进行下线维护，并将该节点上运行的业务Pod重新调度至其他节点，则可为此Node A节点添加以下哪一项污点效果?

NoSchedule

BPreferSchedule

PreferNoSchedule

NoExecute
</code></pre><p>好的，答案是 <strong>NoSchedule</strong> 和 <strong>NoExecute</strong> 都可以实现将 NodeA 上的业务 Pod 重新调度至其他节点，但它们的效果略有不同，需要根据具体维护需求选择。</p><p><strong>详细解释:</strong></p><ul><li><strong>NoSchedule:</strong><ul><li>当给 NodeA 添加 <code>NoSchedule</code> 污点后，<strong>新的 Pod 将不会被调度</strong>到该节点上。</li><li><strong>已经运行在 NodeA 上的 Pod 不会立即被驱逐</strong>。如果希望驱逐已有的 Pod，需要配合其他操作（例如手动删除 Pod 或使用 Drain 节点）。</li><li>因此，如果你的目标是阻止新的 Pod 调度到 NodeA 并逐步清理其上的现有 Pod，可以先添加 <code>NoSchedule</code> 污点，然后手动驱逐或等待控制器自动在其他节点创建新的副本。</li></ul></li><li><strong>PreferNoSchedule:</strong><ul><li>这是一种<strong>偏好</strong>设置，而不是强制性规则。调度器会<strong>尽量避免</strong>将新的 Pod 调度到具有该污点的节点上，但如果实在没有其他合适的节点，仍然有可能调度上去。</li><li>这个选项通常用于柔性地避免在某些节点上运行某些类型的 Pod。</li></ul></li><li><strong>PreferNoExecute:</strong><ul><li>这也是一种<strong>偏好</strong>设置，调度器会<strong>尽量避免</strong>将新的 Pod 调度到具有该污点的节点上。</li><li><strong>已经运行在 NodeA 上的 Pod 不会被驱逐</strong>。</li></ul></li><li><strong>NoExecute:</strong><ul><li>当给 NodeA 添加 <code>NoExecute</code> 污点后，<strong>新的 Pod 将不会被调度</strong>到该节点上。</li><li><strong>最重要的是，已经运行在 NodeA 上的 Pod 会被驱逐（evicted）</strong>，除非 Pod 本身定义了可以容忍该污点。</li><li>这是进行节点维护并快速将业务 Pod 迁移到其他节点的常用选项。</li></ul></li></ul><p><strong>总结:</strong></p><p>为了实现将 NodeA 上的业务 Pod 重新调度至其他节点并阻止新的 Pod 调度到该节点，你可以选择：</p><ul><li><strong>NoSchedule:</strong> 阻止新的 Pod 调度，但需要额外操作驱逐现有 Pod。</li><li><strong>NoExecute:</strong> <strong>更直接地实现你的需求</strong>，它会阻止新的 Pod 调度，并且会自动驱逐已经运行在该节点上的 Pod（除非 Pod 有相应的容忍度设置）。</li></ul><p>因此，最符合题目要求的选项是 <strong>NoExecute</strong>，因为它能直接触发 Pod 的重新调度。如果你希望更温和地处理，可以先使用 <code>NoSchedule</code>，再配合节点排空（<code>kubectl drain</code>) 命令。但从选项来看，<strong>NoExecute</strong> 是更直接的答案。</p><p>考虑到题目只要求添加一个污点效果，并且目标是“并将该节点上运行的业务 Pod 重新调度至其他节点”，<strong>NoExecute</strong> 是最合适的选择。</p><pre tabindex=0><code>单选题341231、以下关于Service的YAML文件中的参数的描述，错误的是哪一项?

kind参数后应填写为Service

metada.name参数指定Service的名称

specports中targetPort参数指定Service对外暴露的端口

spectype参数指定Service的类型
</code></pre><p>好的，答案是 <strong>spec.ports 中 targetPort 参数指定 Service 对外暴露的端口</strong>。</p><p><strong>解释:</strong></p><p>让我们逐个分析这些描述：</p><ul><li><strong>kind 参数后应填写为 Service:</strong> 这是正确的。在 Kubernetes 的 YAML 配置文件中，<code>kind</code> 字段用于指定资源对象的类型，对于 Service 来说，其值应为 <code>Service</code>。</li><li><strong>metadata.name 参数指定 Service 的名称:</strong> 这也是正确的。<code>metadata.name</code> 字段用于为 Kubernetes 资源对象（包括 Service）指定一个在命名空间内唯一的名称。</li><li><strong>spec.ports 中 targetPort 参数指定 Service 对外暴露的端口:</strong> 这是<strong>错误</strong>的。<code>spec.ports.targetPort</code> 参数指定的是 <strong>Pod 中容器暴露的端口</strong>，Service 会将接收到的流量转发到与 <code>targetPort</code> 匹配的 Pod 的端口上。Service 对外暴露的端口是由 <code>spec.ports.port</code> 参数指定的。</li><li><strong>spec.type 参数指定 Service 的类型:</strong> 这是正确的。<code>spec.type</code> 字段用于指定 Service 的类型，常见的类型包括 <code>ClusterIP</code>、<code>NodePort</code>、<code>LoadBalancer</code> 和 <code>ExternalName</code>。</li></ul><p><strong>正确理解 Service 的端口配置:</strong></p><p>在 Service 的 <code>spec.ports</code> 数组中，通常会包含以下字段：</p><ul><li><strong>port:</strong> Service 本身对外暴露的端口。客户端通过这个端口访问 Service。</li><li><strong>targetPort:</strong> 后端 Pod 中容器监听的端口。Service 会将接收到的流量转发到这些 Pod 的 <code>targetPort</code> 上。</li><li><strong>protocol:</strong> 暴露的协议，通常是 TCP 或 UDP。</li><li><strong>nodePort (仅在 type 为 NodePort 或 LoadBalancer 时使用):</strong> 在每个 Node 上的保留端口，外部可以通过 <code>NodeIP:NodePort</code> 访问 Service。</li></ul><p>因此，错误的是关于 <code>targetPort</code> 的描述。<code>targetPort</code> 不是 Service 对外暴露的端口，而是后端 Pod 容器的端口。</p><pre tabindex=0><code>单选题36/231、以下关于不同类型的Service的描述，错误的是哪一项?

NodePort类型的Service会让Kubemetes集群每个节点上保留一个相同的端口BLoadBalancer类型的Service是NodePort类型Service的扩展

NodePort类型或者LoadBalancer类型的Service都会被分配-个ClusterlP

Headless
</code></pre><p>好的，答案是 <strong>NodePort 类型或者 LoadBalancer 类型的 Service 都会被分配一个 ClusterIP</strong>。</p><p><strong>解释:</strong></p><p>让我们逐个分析这些描述：</p><ul><li><strong>NodePort 类型的 Service 会让 Kubernetes 集群每个节点上保留一个相同的端口:</strong> 这是正确的。NodePort 类型的 Service 会在集群的每个 Node 上开放一个指定的端口（在 30000-32767 范围内），通过 <code>NodeIP:NodePort</code> 可以从集群外部访问 Service。</li><li><strong>LoadBalancer 类型的 Service 是 NodePort 类型 Service 的扩展:</strong> 这是正确的。LoadBalancer 类型通常在云环境中使用，它会自动创建一个外部负载均衡器，并将流量转发到后端的 NodePort Service 上。因此，LoadBalancer 依赖于 NodePort 的功能。</li><li><strong>NodePort 类型或者 LoadBalancer 类型的 Service 都会被分配一个 ClusterIP:</strong> 这是<strong>错误</strong>的。<ul><li><strong>NodePort 类型</strong>的 Service <strong>会</strong>被分配一个 ClusterIP。ClusterIP 是 Service 在集群内部的虚拟 IP 地址，用于集群内部的服务发现和负载均衡。NodePort Service 除了 NodePort 之外，也拥有一个 ClusterIP。</li><li><strong>LoadBalancer 类型</strong>的 Service <strong>也会</strong>被分配一个 ClusterIP。LoadBalancer 在提供外部访问能力的同时，在集群内部仍然通过 ClusterIP 进行服务发现和路由。</li></ul></li><li><strong>Headless Service 不会分配 ClusterIP:</strong> 这是正确的。Headless Service 通过将 Service 的 DNS 条目直接指向后端的 Pod IP 地址，而不是通过 ClusterIP 进行代理。它的 <code>spec.clusterIP</code> 字段设置为 <code>None</code>。</li></ul><p><strong>总结:</strong></p><p>NodePort 和 LoadBalancer 类型的 Service <strong>都会</strong>被分配一个 ClusterIP，用于集群内部的通信。因此，描述 &ldquo;NodePort 类型或者 LoadBalancer 类型的 Service 都会被分配一个 ClusterIP&rdquo; 本身是正确的，但题目要求找出<strong>错误</strong>的描述。</p><p>仔细审题，我之前的理解有偏差。选项 C 的描述本身是正确的。让我们重新审视所有选项，找出真正错误的那个。</p><ul><li><strong>A. NodePort 类型的 Service 会让 Kubernetes 集群每个节点上保留一个相同的端口:</strong> 正确。</li><li><strong>B. LoadBalancer 类型的 Service 是 NodePort 类型 Service 的扩展:</strong> 正确。</li><li><strong>C. NodePort 类型或者 LoadBalancer 类型的 Service 都会被分配一个 ClusterIP:</strong> 正确。</li><li><strong>D. Headless Service 不会分配 ClusterIP:</strong> 正确。</li></ul><p><strong>重新思考:</strong> 题目中可能存在一些歧义或者我之前的知识点理解存在偏差。让我们再次仔细分析 Service 的类型和特性。</p><p><strong>关键点回顾:</strong></p><ul><li><strong>ClusterIP:</strong> 集群内部的虚拟 IP，仅可在集群内部访问。所有 Service 类型（除了 Headless）都会分配一个 ClusterIP。</li><li><strong>NodePort:</strong> 在每个 Node 上开放一个端口，允许通过 <code>NodeIP:NodePort</code> 从集群外部访问。NodePort Service 也会拥有一个 ClusterIP。</li><li><strong>LoadBalancer:</strong> 在 NodePort 的基础上，由云服务商提供外部负载均衡器，将流量转发到 NodePort Service。LoadBalancer Service 也会拥有一个 ClusterIP。</li><li><strong>Headless:</strong> 不分配 ClusterIP，而是通过 DNS 直接解析到 Pod IP。</li></ul><p><strong>再次分析选项:</strong></p><p>考虑到以上回顾，选项 A、B、C 和 D 的描述都是正确的。这与题目要求找出错误项相矛盾。</p><p><strong>可能性分析:</strong></p><ol><li><strong>题目本身可能存在错误。</strong></li><li><strong>我对某些概念的理解存在细微偏差。</strong></li></ol><p>让我们再次聚焦于每个选项的细微之处。</p><ul><li><strong>选项 A:</strong> &ldquo;保留一个相同的端口&rdquo; 是准确的，每个节点都会监听同一个 NodePort。</li><li><strong>选项 B:</strong> LoadBalancer 通常通过 NodePort 实现，是其上层抽象。</li><li><strong>选项 C:</strong> 这是 Service 架构的基础，ClusterIP 用于内部路由。</li><li><strong>选项 D:</strong> Headless Service 的核心特点就是没有 ClusterIP。</li></ul><p><strong>结论:</strong></p><p>经过再次仔细分析，<strong>所有给出的描述都是正确的</strong>。题目要求找出错误的描述，但选项中并没有错误的描述。</p><p><strong>如果必须选择一个“最可能被误解”或者在某些极端情况下可能不完全准确的选项，可能是 C。</strong> 虽然通常 NodePort 和 LoadBalancer 都会分配 ClusterIP，但在非常特殊或自定义的网络配置下，理论上或许存在一些边缘情况。但这并非 Kubernetes 的标准行为。</p><p><strong>鉴于所有选项在标准 Kubernetes 行为下都是正确的，题目可能存在问题。</strong></p><p>如果我必须强制选择一个，我会选择 <strong>C</strong>，理由是虽然这是标准行为，但理解上可能会有歧义，认为外部访问的 Service 可能不需要内部 IP。但这仍然是不正确的。</p><p><strong>最终决定：</strong> 由于所有描述在标准 Kubernetes 行为下都是正确的，我认为题目本身可能存在错误。如果必须选择，我会选择 <strong>C</strong> 作为最有可能引起误解的选项，尽管它在技术上是正确的。</p><p><strong>强烈建议核对题目来源和答案。</strong></p><pre tabindex=0><code>单选题371231、以下关于Kube-Scheduler进行Pod调度的流程的描述，错误的是哪一项?

Informer组件list-watch

又

节点优选(Priorities)，先于节点预选执行，通过如LeastRequested，SelectorSpreading等策略对Node节点进行评分排序

节点预选(Predicates)，通过如CheckNodeConditon，MatchNodeSelector,Taint&amp;Toleration等策略过

滤不合适的Node节点

当Scheduler为Pod选择了一个合适的Node节点，通过Bind将Pod和节点进行绑定
</code></pre><p>好的，答案是 <strong>节点优选(Priorities)，先于节点预选执行，通过如LeastRequested，SelectorSpreading等策略对Node节点进行评分排序</strong>。</p><p><strong>解释:</strong></p><p>Kube-Scheduler 进行 Pod 调度的流程通常是这样的：</p><ol><li><strong>Informer 组件 list-watch:</strong> Informer 组件负责监听 Kubernetes API Server 中与调度相关的资源对象（如 Pod、Node、PersistentVolume 等）的变化，并将这些信息缓存到本地，供 Scheduler 使用。这是调度流程的第一步，用于获取集群的实时状态。</li><li><strong>节点预选 (Predicates):</strong> 预选阶段是根据一系列预选策略（Predicates）过滤掉不满足 Pod 调度要求的 Node 节点。例如：<ul><li><code>CheckNodeCondition</code>: 检查 Node 的健康状况。</li><li><code>MatchNodeSelector</code>: 检查 Pod 的 <code>nodeSelector</code> 是否与 Node 的标签匹配。</li><li><code>Taint & Toleration</code>: 检查 Node 的污点（Taints）是否被 Pod 的容忍度（Tolerations）所允许。 预选阶段会快速排除掉不合格的节点。</li></ul></li><li><strong>节点优选 (Priorities):</strong> 在通过预选阶段的合格节点中，优选阶段会根据一系列优选策略（Priorities）对这些节点进行评分。评分高的节点更倾向于被选择。常见的优选策略包括：<ul><li><code>LeastRequested</code>: 优先选择资源利用率较低的节点。</li><li><code>SelectorSpreading</code>: 尽量将属于同一个 ReplicaSet 或 Deployment 的 Pod 分散到不同的 Node 上。</li></ul></li><li><strong>Bind:</strong> 当 Scheduler 为 Pod 选择了一个评分最高的合适 Node 节点后，会通过 Bind 操作将该 Pod 和目标 Node 绑定。这个绑定信息会更新到 Kubernetes API Server 中，然后 kubelet 就会在被绑定的 Node 上创建并运行该 Pod。</li></ol><p><strong>因此，描述中“节点优选(Priorities)，先于节点预选执行”是错误的。正确的执行顺序是先进行节点预选 (Predicates) 过滤掉不合适的节点，然后在通过预选的节点中进行节点优选 (Priorities) 评分排序。</strong></p><pre tabindex=0><code>单选题 38/231、CCE基于Kubemetes社区容器存储接口CSl(Contaimer Storage nterface)实现了云存储服务接入能力，以下关于CCE容器存储插件的描述，哪一项是错误的?

CCE集群中的CSI客器存储插件名为Everest。

Everest插件的Everest-csi-controller组件，提供存储卷的创建、删除、扩容、云盘快照等功能

Everest插件的Everest-csi-driver组件，提供存储卷在node上的挂载、卸载、格式化等功能。

CCE集群中的容器存储插件与容器的内核版本无关
</code></pre><p>好的，答案是 <strong>CCE集群中的容器存储插件与容器的内核版本无关</strong>。</p><p><strong>解释:</strong></p><p>让我们逐个分析这些描述：</p><ul><li><strong>CCE集群中的CSI容器存储插件名为Everest。</strong> 这是正确的。华为云 CCE 集群使用的 CSI 插件通常被称为 Everest。</li><li><strong>Everest插件的Everest-csi-controller组件，提供存储卷的创建、删除、扩容、云盘快照等功能。</strong> 这是正确的。CSI controller 组件通常负责集群范围内的存储管理操作。</li><li><strong>Everest插件的Everest-csi-driver组件，提供存储卷在node上的挂载、卸载、格式化等功能。</strong> 这是正确的。CSI driver 组件运行在每个 Node 上，负责与底层存储系统交互，执行卷的挂载、卸载和格式化等节点本地操作。</li><li><strong>CCE集群中的容器存储插件与容器的内核版本无关。</strong> 这是<strong>错误</strong>的。容器存储插件（特别是 CSI driver 组件）需要与 Node 节点的操作系统和内核进行交互，以实现存储卷的挂载、卸载等操作。不同的内核版本可能需要不同版本的驱动或者特定的内核模块支持。虽然 CSI 旨在提供一个标准的接口，以减少对特定存储和内核的依赖，但实际部署和运行 CSI driver 时，仍然需要考虑其与底层操作系统和内核的兼容性。</li></ul><p><strong>总结:</strong></p><p>CCE 集群中的容器存储插件 Everest 的正常运行和功能实现，<strong>与 Node 节点的内核版本是相关的</strong>。因此，认为它们无关的描述是错误的。</p><pre tabindex=0><code>39/231、某用户的CPU管理策略为Resources.limits.cpu:500m,Resources limits.memory:512Mi,单选题Resources.requests,cpu:100m,Resources.equests.memory:256Mi，以下那一个Pod可以正常工作?

allocatable.cpu:400m, allocatable.memory:512Mi

allocatable.cpu:400m,allocatable.memory:200Mi

allocatable.cpu:80m, allocatable.memory:600Mi

allocatable.cpu:90m,alocatablememory:256Mi
</code></pre><p>好的，答案是 <strong>allocatable.cpu:400m, allocatable.memory:512Mi</strong>。</p><p><strong>解释:</strong></p><p>为了使 Pod 能够正常工作，它所请求的资源（requests）必须小于或等于 Node 上的可分配资源（allocatable），并且它所设置的资源限制（limits）也必须小于或等于 Node 上的可分配资源。</p><p>让我们分析给定的 Pod 资源需求和限制：</p><ul><li><strong>Resources.limits.cpu: 500m</strong> (Pod 的 CPU 上限为 0.5 个 CPU 核)</li><li><strong>Resources.limits.memory: 512Mi</strong> (Pod 的内存上限为 512 MiB)</li><li><strong>Resources.requests.cpu: 100m</strong> (Pod 请求的 CPU 为 0.1 个 CPU 核)</li><li><strong>Resources.requests.memory: 256Mi</strong> (Pod 请求的内存为 256 MiB)</li></ul><p>现在，我们逐个检查选项中的 Node 可分配资源：</p><ul><li><strong>A. allocatable.cpu: 400m, allocatable.memory: 512Mi</strong><ul><li>CPU 请求 (100m) &lt;= 可分配 CPU (400m) <strong>满足</strong></li><li>CPU 限制 (500m) > 可分配 CPU (400m) <strong>不满足</strong></li></ul></li><li><strong>B. allocatable.cpu: 400m, allocatable.memory: 200Mi</strong><ul><li>内存请求 (256Mi) > 可分配内存 (200Mi) <strong>不满足</strong></li></ul></li><li><strong>C. allocatable.cpu: 80m, allocatable.memory: 600Mi</strong><ul><li>CPU 请求 (100m) > 可分配 CPU (80m) <strong>不满足</strong></li></ul></li><li><strong>D. allocatable.cpu: 90m, allocatable.memory: 256Mi</strong><ul><li>CPU 请求 (100m) > 可分配 CPU (90m) <strong>不满足</strong></li></ul></li></ul><p><strong>重新分析：</strong> 我之前的理解有误，Pod 的资源请求必须小于等于 Node 的可分配资源，Pod 的资源限制也必须小于等于 Node 的可分配资源。让我们重新检查选项。</p><ul><li><strong>A. allocatable.cpu: 400m, allocatable.memory: 512Mi</strong><ul><li>CPU 请求 (100m) &lt;= 可分配 CPU (400m) <strong>满足</strong></li><li>CPU 限制 (500m) > 可分配 CPU (400m) <strong>不满足</strong></li></ul></li><li><strong>B. allocatable.cpu: 400m, allocatable.memory: 200Mi</strong><ul><li>内存请求 (256Mi) > 可分配内存 (200Mi) <strong>不满足</strong></li></ul></li><li><strong>C. allocatable.cpu: 80m, allocatable.memory: 600Mi</strong><ul><li>CPU 请求 (100m) > 可分配 CPU (80m) <strong>不满足</strong></li></ul></li><li><strong>D. allocatable.cpu: 90m, allocatable.memory: 256Mi</strong><ul><li>CPU 请求 (100m) > 可分配 CPU (90m) <strong>不满足</strong></li></ul></li></ul><p><strong>再次重新思考：</strong> 我又犯了一个错误。Pod <em>能够</em> 正常工作的前提是其资源 <em>请求</em> 可以被满足。资源 <em>限制</em> 是 Pod 可以使用的最大资源量，即使超过请求，只要不超过限制并且 Node 可分配资源足够，Pod 仍然可以被调度。</p><p>让我们再次以正确的理解来分析：Pod 能够被调度并正常工作，需要满足以下条件：</p><ol><li><strong>Pod 的 CPU 请求 &lt;= Node 的可分配 CPU</strong></li><li><strong>Pod 的内存请求 &lt;= Node 的可分配内存</strong></li></ol><p>我们不需要直接比较 Pod 的资源 <em>限制</em> 和 Node 的可分配资源，虽然在实际运行时 Pod 不能超过其限制，但调度器主要关注 <em>请求</em> 是否能够满足。</p><p>现在，让我们再次检查选项，只关注资源请求：</p><ul><li><strong>A. allocatable.cpu: 400m, allocatable.memory: 512Mi</strong><ul><li>CPU 请求 (100m) &lt;= 可分配 CPU (400m) <strong>满足</strong></li><li>内存请求 (256Mi) &lt;= 可分配内存 (512Mi) <strong>满足</strong></li><li><strong>这个 Pod 可以正常工作。</strong></li></ul></li><li><strong>B. allocatable.cpu: 400m, allocatable.memory: 200Mi</strong><ul><li>CPU 请求 (100m) &lt;= 可分配 CPU (400m) <strong>满足</strong></li><li>内存请求 (256Mi) > 可分配内存 (200Mi) <strong>不满足</strong></li></ul></li><li><strong>C. allocatable.cpu: 80m, allocatable.memory: 600Mi</strong><ul><li>CPU 请求 (100m) > 可分配 CPU (80m) <strong>不满足</strong></li></ul></li><li><strong>D. allocatable.cpu: 90m, allocatable.memory: 256Mi</strong><ul><li>CPU 请求 (100m) > 可分配 CPU (90m) <strong>不满足</strong></li></ul></li></ul><p><strong>最终答案:</strong></p><p>只有选项 <strong>A</strong> 满足 Pod 的 CPU 和内存请求都小于或等于 Node 的可分配资源。因此，这个 Pod 可以被成功调度并正常工作。</p><pre tabindex=0><code>单选题

44/231、以下关于应用服务网格ASM灰度发布优势的描述，错误的是哪一项?

灰度版本一键部署，流量切换一键生效

配置式灰度策略，支持流量比例、请求内容(Cookie

仅支持金丝雀发布

一站式健康、性能、流量监控，实现灰度发布过程量化、智能化、可视化
</code></pre><p>好的，答案是 <strong>仅支持金丝雀发布</strong>。</p><p><strong>解释:</strong></p><p>应用服务网格（ASM）的灰度发布通常提供多种策略，而不仅仅是金丝雀发布。以下是 ASM 灰度发布的一些常见优势和策略：</p><ul><li><p><strong>灰度版本一键部署，流量切换一键生效:</strong> 这是 ASM 提供的便利性之一，简化了灰度发布的部署和流量管理操作。</p></li><li><p><strong>配置式灰度策略，支持流量比例、请求内容 (Cookie 等):</strong> ASM 允许用户根据不同的策略配置流量路由，例如按流量百分比将一部分用户导向新版本，或者基于特定的请求内容（如 Cookie、Header 等）将特定用户导向新版本。这使得灰度发布更加灵活和可控。</p></li><li><p><strong>一站式健康、性能、流量监控，实现灰度发布过程量化、智能化、可视化:</strong> ASM 通常集成监控和追踪能力，可以实时监控新旧版本的健康状况、性能指标和流量情况，帮助用户做出更明智的决策，甚至实现自动化回滚或流量调整。</p></li><li><p>仅支持金丝雀发布:</p><p>这是</p><p>错误</p><p>的。金丝雀发布是灰度发布的一种常见策略，但 ASM 通常还支持其他策略，例如：</p><ul><li><strong>蓝绿发布 (Blue/Green Deployment):</strong> 同时部署新旧两个版本，将所有流量从旧版本切换到新版本。</li><li><strong>A/B 测试 (A/B Testing):</strong> 将不同用户导向不同版本以进行功能或体验的对比。</li><li><strong>流量比例切分 (Traffic Splitting):</strong> 逐步增加导向新版本的流量比例。</li></ul></li></ul><p>因此，认为 ASM 灰度发布<strong>仅支持金丝雀发布</strong>的描述是错误的。ASM 通常提供更丰富的灰度发布策略。</p><pre tabindex=0><code>531231、以下Service类型中，可用于Pod间相互发现的是哪一项?单选题

Clusterip

NodePort

LoadBalancer

Headtess
</code></pre><p>好的，答案是 <strong>ClusterIP</strong> 和 <strong>Headless</strong>。</p><p><strong>解释:</strong></p><p>让我们分析一下每种 Service 类型在 Pod 间相互发现方面的作用：</p><ul><li><strong>ClusterIP:</strong><ul><li>这是 Kubernetes Service 的默认类型。</li><li>它在集群内部创建一个虚拟 IP 地址，并将发送到该 IP 地址和端口的流量负载均衡到与该 Service 关联的 Pod 上。</li><li><strong>Pod 可以通过 ClusterIP 和 Service 名称来相互访问</strong>，而无需关心后端 Pod 的具体 IP 地址。Kubernetes 的 DNS 服务会将 Service 名称解析为 ClusterIP。因此，<strong>ClusterIP 是 Pod 间相互发现和通信的主要方式之一。</strong></li></ul></li><li><strong>NodePort:</strong><ul><li>NodePort 类型在每个 Node 节点上保留一个静态端口（在 30000-32767 范围内），并将发送到该端口的流量转发到 Service 的 ClusterIP 和端口。</li><li>虽然 NodePort 允许集群外部访问 Service，但 <strong>Pod 通常不会直接使用 NodePort 来相互发现和通信</strong>，因为这涉及到知道其他 Pod 所在的 Node IP 和 NodePort，不如直接使用 ClusterIP 方便和稳定。</li></ul></li><li><strong>LoadBalancer:</strong><ul><li>LoadBalancer 类型通常在云环境中使用，它会自动创建一个外部负载均衡器，并将流量转发到后端的 NodePort Service 上（通常也会分配一个 ClusterIP）。</li><li>与 NodePort 类似，<strong>Pod 之间通常不直接通过 LoadBalancer 的外部 IP 或域名进行通信</strong>，而是使用内部的 ClusterIP。</li></ul></li><li><strong>Headless:</strong><ul><li>Headless Service 不会分配 ClusterIP。</li><li>相反，Kubernetes DNS 会为 Headless Service 的每个后端 Pod 创建一个 DNS A 记录，记录该 Pod 的 IP 地址。</li><li><strong>Pod 可以通过 Headless Service 的名称解析到后端 Pod 的具体 IP 地址</strong>，从而实现直接通信。这对于需要 Pod 之间保持稳定网络标识的 StatefulSet 等场景非常有用。因此，<strong>Headless Service 也是 Pod 间相互发现的一种方式。</strong></li></ul></li></ul><p><strong>总结:</strong></p><p><strong>ClusterIP</strong> 是最常用的用于 Pod 间服务发现和通信的 Service 类型，它提供了一个稳定的虚拟 IP 地址供 Pod 访问。<strong>Headless</strong> Service 则通过 DNS 直接暴露后端 Pod 的 IP 地址，也实现了 Pod 间的相互发现，适用于特定的场景。</p><p>因此，选项中 <strong>ClusterIP</strong> 和 <strong>Headless</strong> 都可用于 Pod 间相互发现。如果这是一个单选题，并且只能选择一个最主要的答案，那么 <strong>ClusterIP</strong> 由于其广泛的使用场景和作为默认类型的特性，通常被认为是 Pod 间相互发现的首选方式。</p><p>然而，根据题目给出的选项，如果只能选择一个，并且 <strong>Headless</strong> 也在选项中，那么两者都提供了 Pod 间相互发现的能力。如果题目有歧义或者期望一个更常用的答案，那么 <strong>ClusterIP</strong> 可能是更倾向的选择。</p><p>鉴于问题是单选题，并且列出了两者，我需要选择最直接和最常用的答案。<strong>ClusterIP</strong> 是 Kubernetes 中实现内部服务发现和负载均衡的核心机制，因此是 Pod 间相互发现的最常见和基础的方式。</p><pre tabindex=0><code>单选题

62/231、以下关于OverridePolicyspec关健字段参数的描述，错误的是哪一项?

overriders: 差异化策略内容

B

targetCluster: 指定目标资源YAML中的差异化位置

resourceSelectors:选择关联的资源

targetCluster: 选择差异化策略生效的集群
</code></pre><p>好的，答案是 <strong>targetCluster: 指定目标资源YAML中的差异化位置</strong>。</p><p><strong>解释:</strong></p><p><code>OverridePolicySpec</code> 是 Karmada（Kubernetes Resource Multi-Cluster Administration）中用于定义跨集群资源覆盖策略的关键对象。让我们分析一下每个字段的作用：</p><ul><li><strong>overriders:</strong> 这个字段定义了具体的差异化策略内容。它包含了一系列的覆盖规则，例如修改特定的字段值、添加或删除字段等。描述是正确的。</li><li><strong>resourceSelectors:</strong> 这个字段用于选择需要应用此覆盖策略的资源。你可以通过指定资源的 Group、Version、Kind 和 Name 等信息来选择一组特定的资源。描述是正确的。</li><li><strong>targetCluster: 选择差异化策略生效的集群:</strong> 这个字段用于指定该覆盖策略应该应用到哪些目标集群。你可以通过集群的名称或其他选择器来指定目标集群。描述是正确的。</li><li><strong>targetCluster: 指定目标资源YAML中的差异化位置:</strong> 这个字段的描述是<strong>错误</strong>的。<code>targetCluster</code> 的作用是<strong>选择策略生效的目标集群</strong>，而不是指定目标资源 YAML 中的差异化位置。<strong>指定差异化位置</strong>通常是在 <code>overriders</code> 字段中通过路径（例如 JSONPath）来实现的。<code>overriders</code> 中的具体规则会指明需要在目标集群的资源 YAML 的哪个字段进行修改。</li></ul><p><strong>总结:</strong></p><p><code>targetCluster</code> 字段用于指定覆盖策略应用的目标集群，而差异化的具体位置和内容则在 <code>overriders</code> 字段中定义。因此，描述 <code>targetCluster</code> 用于指定目标资源 YAML 中的差异化位置是错误的。</p><pre tabindex=0><code>单选题

63/231、以下关于lstio中熔断机制的描述，错误的是哪一项?

熔断能够动态地将异常实例从负载均衡池中移除

被移除的实例在一段时间之后，不会被加回来再次尝试访问

对于TCP服务，如果到目标服务的连接超时和失败，则都会被记为出错

当连续的错误数超过配置的闯值时，后端实例会被移除
</code></pre><p>好的，答案是 <strong>被移除的实例在一段时间之后，不会被加回来再次尝试访问</strong>。</p><p><strong>解释:</strong></p><p>Istio 的熔断机制旨在通过临时阻止对故障服务的访问，防止故障蔓延并提高系统的整体可用性。让我们逐个分析这些描述：</p><ul><li><strong>熔断能够动态地将异常实例从负载均衡池中移除:</strong> 这是正确的。当 Istio 的 Sidecar 代理检测到后端实例出现连续的错误时，会将这些异常实例从其负载均衡池中暂时移除，从而避免将新的请求发送到这些不健康的实例。</li><li><strong>被移除的实例在一段时间之后，不会被加回来再次尝试访问:</strong> 这是<strong>错误</strong>的。Istio 的熔断机制通常包含一个<strong>恢复机制</strong>。被熔断（移除）的实例在经过一段配置的时间间隔后，Sidecar 代理会<strong>尝试重新向这些实例发送少量的探测请求</strong>，以检查它们是否已经恢复健康。如果探测成功，该实例会被重新加入到负载均衡池中。</li><li><strong>对于 TCP 服务，如果到目标服务的连接超时和失败，则都会被记为出错:</strong> 这是正确的。对于 TCP 连接，连接超时和连接失败通常都被认为是服务不健康的信号，会被熔断机制记录为错误计数。</li><li><strong>当连续的错误数超过配置的阈值时，后端实例会被移除:</strong> 这是正确的。Istio 允许用户配置触发熔断的错误阈值。当在一定时间内，对某个后端实例的连续错误请求数超过这个阈值时，该实例就会被熔断并从负载均衡池中移除。</li></ul><p><strong>总结:</strong></p><p>Istio 的熔断机制是临时的，被移除的实例在经过一定的冷却时间后会尝试恢复。因此，认为被移除的实例不会被加回来再次尝试访问的描述是错误的。</p><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/image-20250529164547751.png alt=image-20250529164547751></p><pre tabindex=0><code>单选题 67/231、在设置了华为云CCE容器日志转储后，AOM会在某个日志文件超过一定大小时对其转储，在该日止文件所在的目录下生成一个新的zip文件。但对于一个日志文件，其生成的zip文件不会永久保留，当zip文件超过多少个时AOM会删除较早的zip文件?

10

6


20


30

---
20
</code></pre><pre tabindex=0><code>71/231、以下关于不同类型的Service的描述，错误的是哪一项?
单选题
NodePort类型的Service会让Kubemetes集群每个节点上保留一个相同的端口LoadBalancer类型的Service是NodePort类型Service的扩展NodePort类型或者LoadBalancer类型的Service都会被分配一个ClusterlPHeadless Service创建后，后端相应Pod被重新创建导致Pod的IP地址发生变化，其对应的域名也会发生变化
</code></pre><p>好的，答案是 <strong>Headless Service 创建后，后端相应 Pod 被重新创建导致 Pod 的 IP 地址发生变化，其对应的域名也会发生变化</strong>。</p><p><strong>解释:</strong></p><p>让我们逐个分析这些描述：</p><ul><li><strong>NodePort 类型的 Service 会让 Kubernetes 集群每个节点上保留一个相同的端口:</strong> 这是正确的。NodePort Service 在集群的每个 Node 上开放一个相同的端口，用于从集群外部访问 Service。</li><li><strong>LoadBalancer 类型的 Service 是 NodePort 类型 Service 的扩展:</strong> 这是正确的。LoadBalancer 通常在云环境中实现，它在 NodePort 的基础上提供外部负载均衡器。</li><li><strong>NodePort 类型或者 LoadBalancer 类型的 Service 都会被分配一个 ClusterIP:</strong> 这是正确的。ClusterIP 是 Service 在集群内部的虚拟 IP，用于集群内部的服务发现和负载均衡。NodePort 和 LoadBalancer 类型也会拥有一个 ClusterIP。</li><li><strong>Headless Service 创建后，后端相应 Pod 被重新创建导致 Pod 的 IP 地址发生变化，其对应的域名也会发生变化:</strong> 这是<strong>错误</strong>的。对于 Headless Service，Kubernetes DNS 会为每个后端 Pod 创建一个 DNS A 记录，这个记录的名称通常是 <code>&lt;pod-name>.&lt;headless-service-name>.&lt;namespace>.svc.&lt;cluster-domain></code>。<strong>虽然 Pod 的 IP 地址在重新创建后会发生变化，但是 Pod 的名称通常保持不变（除非 ReplicaSet 等控制器进行了扩缩容或替换操作），因此，其对应的域名会解析到新的 IP 地址，但域名本身不会发生变化。</strong> DNS 服务会自动更新与 Pod 名称关联的 IP 地址。</li></ul><p><strong>总结:</strong></p><p>Headless Service 的关键特性是它不分配 ClusterIP，而是依赖 DNS 来直接解析到后端 Pod 的 IP 地址。当 Pod IP 地址变化时，DNS 记录会被更新，但 Pod 的域名（基于 Pod 名称和 Service 名称）通常保持不变。因此，认为其对应的域名也会发生变化的描述是错误的。</p><pre tabindex=0><code>单选题75/231、CCE基于Kubernetes社区容器存储接口CS实现了云存储服务接入能力，以下关务CCE支持的存储类型的描述，哪个是错误的?

文件存储可用于HPC高性能计算、媒体处理、内容管理和Web服务、大数据和分析应用程序等 √

块存储可用于HPC高性能计算、企业核心集群应用、企业应用系统和开发测试等

自建存储可用于高性能网站、日志存储、Devops、企业办公等

对象存储可用于大数据分析、静态网站托管、在线视频点播、基因测序、智能视频监控、备份归档、企业云盘(网盘)等


文件存储可用于HPC高性能计算、媒体处理、内容管理和Web服务、大数据和分析应用程序等 √
</code></pre><p>好的，答案是 <strong>自建存储可用于高性能网站、日志存储、Devops、企业办公等</strong>。</p><p><strong>解释:</strong></p><p>让我们逐个分析关于 CCE 支持的存储类型的描述：</p><ul><li><p><strong>文件存储可用于 HPC 高性能计算、媒体处理、内容管理和 Web 服务、大数据和分析应用程序等:</strong> 这是正确的。文件存储（例如网络文件系统 NFS）具有共享访问的特性，适用于这些需要多个实例读写相同数据的场景。</p></li><li><p><strong>块存储可用于 HPC 高性能计算、企业核心集群应用、企业应用系统和开发测试等:</strong> 这是正确的。块存储（例如云硬盘）提供高性能、低延迟的持久化存储，非常适合对 IO 性能要求高的应用和数据库等。</p></li><li><p><strong>对象存储可用于大数据分析、静态网站托管、在线视频点播、基因测序、智能视频监控、备份归档、企业云盘 (网盘) 等:</strong> 这是正确的。对象存储具有高可扩展性、低成本和海量存储的特性，适用于存储非结构化数据，并提供各种应用场景的支持。</p></li><li><p><strong>自建存储可用于高性能网站、日志存储、Devops、企业办公等:</strong> 这是<strong>错误</strong>的。<strong>自建存储</strong>通常指的是用户在 Kubernetes 集群外部自行搭建和管理的存储系统。虽然理论上可以通过各种方式将自建存储接入 Kubernetes，但将其直接列为 CCE <em>支持的存储类型</em> 并描述其适用场景是<strong>不准确的</strong>。CCE 提供的存储接入能力主要是针对华为云上的云存储服务（如文件存储 CFS、块存储 EBS、对象存储 OBS）。</p><p>将自建存储集成到 CCE 通常需要用户自行配置和管理 PersistentVolume 和 PersistentVolumeClaim，并可能需要安装和配置第三方存储驱动或使用 HostPath 等方式，但这并非 CCE 平台直接提供的、开箱即用的存储类型。描述中列出的 &ldquo;高性能网站、日志存储、Devops、企业办公&rdquo; 等场景可以使用云上的文件存储、块存储或对象存储来更好地满足需求。</p></li></ul><p><strong>总结:</strong></p><p>CCE 主要提供对华为云存储服务的集成和支持。将“自建存储”列为 CCE 直接支持的存储类型，并且描述其适用场景是错误的。用户可以使用 CCE 提供的卷管理机制来挂载和使用自建存储，但这与 CCE 平台直接提供的存储类型有所不同。</p><pre tabindex=0><code>单选题

801231、以下关于应用服务网格ASM灰度发布优势的描述，错误的是哪一项?

灰度版本一键部署，流量切换一键生效

B

配置式灰度策略，支持流量比例、请求内容(Cookie、Os、浏览器等)、源IP等

仅支持金丝雀发布

一站式健康、性能、流量监控，实现灰度发布过程量化、智能化、可视化
</code></pre><p>好的，答案仍然是 <strong>仅支持金丝雀发布</strong>。</p><p><strong>解释:</strong></p><p>与之前的第 44 题类似，应用服务网格（ASM）的灰度发布通常提供多种策略，而不仅仅是金丝雀发布。让我们再次分析这些描述：</p><ul><li><strong>灰度版本一键部署，流量切换一键生效:</strong> 这是 ASM 提供的便利性，简化了灰度发布的操作。</li><li><strong>配置式灰度策略，支持流量比例、请求内容 (Cookie、Os、浏览器等)、源IP等:</strong> ASM 通常提供丰富的流量路由策略配置，可以基于多种请求属性进行流量导向，实现更精细化的灰度发布。</li><li><strong>仅支持金丝雀发布:</strong> 这是<strong>错误</strong>的。金丝雀发布是灰度发布的一种常见策略，但 ASM 通常还支持其他策略，例如蓝绿发布、A/B 测试、流量比例切分等。</li><li><strong>一站式健康、性能、流量监控，实现灰度发布过程量化、智能化、可视化:</strong> ASM 通常集成监控和追踪能力，帮助用户实时了解新旧版本的运行状态，从而更好地进行灰度发布决策。</li></ul><p><strong>总结:</strong></p><p>认为 ASM 灰度发布<strong>仅支持金丝雀发布</strong>的描述是错误的。ASM 通常提供多种灵活的灰度发布策略。</p><pre tabindex=0><code>单选题

81/231、以下关于istio数据平面的描述，正确的是哪一项?

用来提供服务发现，流量管理功能

负责管理和配置来控制数据平面和控制平面本身组件

用来验证用户编写的lstio API配置

以sidecar方式配置代理来管理数据通信
</code></pre><p>好的，答案是 <strong>以 sidecar 方式配置代理来管理数据通信</strong>。</p><p><strong>解释:</strong></p><p>让我们分析一下每个选项：</p><ul><li><strong>用来提供服务发现，流量管理功能:</strong> 这是 <strong>控制平面</strong> 的主要职责，例如 Istiod 组件。控制平面负责生成数据平面所需的配置，包括服务发现信息和流量管理规则。</li><li><strong>负责管理和配置来控制数据平面和控制平面本身组件:</strong> 这也是 <strong>控制平面</strong> 的职责。控制平面负责管理 Sidecar 代理（数据平面组件）的生命周期和配置，并协调控制平面自身的各个组件。</li><li><strong>用来验证用户编写的 Istio API 配置:</strong> 这主要是 <strong>控制平面</strong> 中验证组件的功能，例如 Istiod 在接收用户配置时会进行语法和语义校验。</li><li><strong>以 sidecar 方式配置代理来管理数据通信:</strong> 这是 <strong>数据平面</strong> 的核心特征。在 Istio 中，数据平面由部署在每个应用 Pod 中的 Sidecar 代理（通常是 Envoy）组成。这些代理拦截 Pod 的所有入站和出站流量，并根据控制平面下发的配置执行流量管理、安全策略、遥测收集等任务。</li></ul><p><strong>总结:</strong></p><p>Istio 的数据平面是由一系列轻量级的代理（Sidecar）组成，它们与应用程序容器部署在同一个 Pod 中，负责实际的数据通信的管理和控制。</p><pre tabindex=0><code>单选题

83/231、关于华为云CCE告警监控项的描述，错误的是哪一项?

工作负载CPU使用率:服务实际使用的1分钟内平均值与申请的CPU核数量比率Pod文件系统使用率:实际使用量与文件系统容量的百分比

Pod容器错包个数:实例收到的错误包的数量

主机文件系统磁盘使用率:已使用的磁盘空间占总的磁盘空间容量百分比
</code></pre><p>好的，答案是 <strong>Pod容器错包个数:实例收到的错误包的数量</strong>。</p><p><strong>解释:</strong></p><p>让我们逐个分析这些告警监控项的描述：</p><ul><li><strong>工作负载 CPU 使用率: 服务实际使用的 1 分钟内平均值与申请的 CPU 核数量比率:</strong> 这是合理的告警监控项，用于监控工作负载的 CPU 使用情况相对于其申请量的比例，帮助判断是否存在资源瓶颈或过度使用。</li><li><strong>Pod 文件系统使用率: 实际使用量与文件系统容量的百分比:</strong> 这是常见的告警监控项，用于监控 Pod 内容器文件系统的磁盘使用情况，防止磁盘空间不足导致应用异常。</li><li><strong>主机文件系统磁盘使用率: 已使用的磁盘空间占总的磁盘空间容量百分比:</strong> 这是标准的节点级别告警监控项，用于监控 Kubernetes 节点主机的磁盘使用情况，确保节点有足够的磁盘空间运行容器和系统服务。</li><li><strong>Pod 容器错包个数: 实例收到的错误包的数量:</strong> 这是<strong>错误</strong>的描述。通常，<strong>错包率</strong>（错误包的数量与总包数量的比率）比绝对的错误包数量更有意义，因为绝对数量会受到流量大小的影响。此外，容器本身通常不直接暴露底层的网络错误包数量，这个指标更常在<strong>网络接口级别</strong>（例如，宿主机或网络设备）进行监控。针对 Pod 或容器的网络监控，更常见的是关注<strong>延迟、丢包率、连接错误</strong>等更高级别的指标。直接监控单个容器收到的错误包数量通常不是一个标准的或容易获取的容器监控指标。</li></ul><p><strong>总结:</strong></p><p>监控 Pod 容器收到的绝对错误包数量不是一个常见或直接的容器监控指标。更常用的和有意义的指标是错误包率或更高级别的网络性能指标。因此，关于 &ldquo;Pod 容器错包个数&rdquo; 的描述是错误的。</p><pre tabindex=0><code>单选题

86/231、在编辑Jb对象的YAML文件时，应调整以下哪一项字段来规定执行当前任务的并发Pod的数量?

completions

parallelism

restartPolicy

backoffLimit
</code></pre><p>好的，答案是 <strong>parallelism</strong>。</p><p><strong>解释:</strong></p><p>在 Kubernetes Job 对象的 YAML 文件中：</p><ul><li><strong><code>parallelism</code></strong>: 这个字段用于指定在任何给定时间 Job 应该并行运行的期望的 Pod 数量。如果未设置或设置为 0，则 Pod 将按顺序运行。</li><li><strong><code>completions</code></strong>: 这个字段用于指定 Job 需要成功完成的 Pod 的数量。一旦成功完成的 Pod 数量达到这个值，Job 将被视为完成。</li><li><strong><code>restartPolicy</code></strong>: 这个字段指定 Pod 中的容器因为错误退出时应该如何处理。对于 Job，通常设置为 <code>Never</code> 或 <code>OnFailure</code>。</li><li><strong><code>backoffLimit</code></strong>: 这个字段指定在 Job 被标记为失败之前，Pod 应该重试启动的次数。</li></ul><p>因此，要规定执行当前任务的并发 Pod 的数量，您需要调整 <strong><code>parallelism</code></strong> 字段。</p><pre tabindex=0><code>多选题 90/231、在K8S中，按照服务质量Qos，通常可划分为三类besteffort,burstable，和guaranteed。以下关于这三类的描述，哪些是正确的?
容器不设置requests和limits值Qos为besteffort
容器设置requests和limits但是值不一致QoS为burstable
容器设置requests和limits且值相同QoS为guaranteed
按照服务质量QoS从高到底的排序为:
</code></pre><p>好的，关于 Kubernetes (K8S) 服务质量 (QoS) 类别 besteffort、burstable 和 guaranteed 的描述，以下是正确的：</p><ul><li><strong>容器不设置 requests 和 limits 值，QoS 为 besteffort</strong>。这是正确的。当容器没有显式地设置 <code>requests</code> 和 <code>limits</code> 时，它会被分配到 <code>besteffort</code> QoS 类别。这些 Pod 的调度优先级最低，并且在节点资源紧张时最容易被驱逐。</li><li><strong>容器设置 requests 和 limits 但是值不一致，QoS 为 burstable</strong>。这是正确的。当容器同时设置了 <code>requests</code> 和 <code>limits</code>，但它们的值不相等时（CPU 或内存或两者），该容器会被分配到 <code>burstable</code> QoS 类别。这些 Pod 保证可以获得其 <code>requests</code> 的资源，但在资源充足时可以突发使用超过 <code>requests</code> 但不超过 <code>limits</code> 的资源。它们在节点资源紧张时比 <code>guaranteed</code> 低优先级，但比 <code>besteffort</code> 高。</li><li><strong>容器设置 requests 和 limits 且值相同，QoS 为 guaranteed</strong>。这是正确的。当容器同时设置了 <code>requests</code> 和 <code>limits</code>，并且对于 CPU 和内存这两个资源，它们的值都相等时，该容器会被分配到 <code>guaranteed</code> QoS 类别。这些 Pod 具有最高的调度优先级，并且只要不超过其 <code>limits</code>，就不会因为节点资源紧张而被驱逐。</li><li><strong>按照服务质量 QoS 从高到底的排序为: guaranteed > burstable > besteffort</strong>。这也是正确的。<code>guaranteed</code> 提供了最强的资源保障，其次是 <code>burstable</code>，<code>besteffort</code> 的保障最弱。</li></ul><p><strong>因此，所有列出的描述都是正确的。</strong></p><pre tabindex=0><code>多选题 91/231、某业务的生产环境需要保障业务的高可用，业务正常时期节点数一般为180,业务高峰期业务量增加明显，需要不低于500节点，此时建议使用以下哪些集群部署方式?

使用CCE Turbo集群，集群规格1000节点，计算节点分布不同AZ

使用CCE 集群，控制节点数为1，集群规格1000节点，计算节点分布不同AZV

使用CCE集群，控制节点数为3，集群规格1000节点，计算节点分布不同AZ

使用CCE Turbo集群，集群规格200节点，计算节点分布不同AZ
</code></pre><p>好的，为了保障业务的高可用并在业务高峰期支持不低于 500 个节点的需求，同时在正常时期维持 180 个节点左右，以下集群部署方式是建议使用的：</p><ul><li><strong>使用 CCE Turbo 集群，集群规格 1000 节点，计算节点分布不同 AZ</strong>。<ul><li><strong>理由：</strong> CCE Turbo 集群具备更快的弹性伸缩能力，能够迅速应对业务高峰期的节点需求。1000 节点的规格可以满足峰值 500 节点的要求，并且将计算节点分布在不同的可用区 (AZ) 可以提高集群的容灾能力，即使一个可用区发生故障，其他可用区的节点仍然可以提供服务，保障高可用。</li></ul></li><li><strong>使用 CCE 集群，控制节点数为 3，集群规格 1000 节点，计算节点分布不同 AZ</strong>。<ul><li><strong>理由：</strong> 拥有 3 个控制节点的 CCE 集群具备高可用性控制平面，即使部分控制节点发生故障，集群的管理和调度功能仍然可以正常运行。1000 节点的规格可以满足峰值需求，并且将计算节点分布在不同的可用区可以提高业务的容灾能力。虽然 CCE 集群的弹性伸缩速度可能不如 CCE Turbo，但在合理配置和预判的情况下，仍然可以满足业务高峰期的需求。</li></ul></li></ul><p><strong>不建议使用的选项：</strong></p><ul><li><strong>使用 CCE 集群，控制节点数为 1，集群规格 1000 节点，计算节点分布不同 AZ</strong>。<ul><li><strong>理由：</strong> 单控制节点的 CCE 集群存在单点故障风险。一旦控制节点发生故障，整个集群的管理和调度将受到影响，无法保障高可用。</li></ul></li><li><strong>使用 CCE Turbo 集群，集群规格 200 节点，计算节点分布不同 AZ</strong>。<ul><li><strong>理由：</strong> 200 节点的集群规格在业务正常时期可能够用，但在业务高峰期需要不低于 500 个节点的情况下，这个规格无法满足需求。即使 CCE Turbo 的弹性伸缩能力很强，也需要集群本身具备足够的容量上限。</li></ul></li></ul><p><strong>总结：</strong></p><p>为了保障高可用并满足弹性伸缩的需求，建议选择 <strong>使用 CCE Turbo 集群，集群规格 1000 节点，计算节点分布不同 AZ</strong> 和 <strong>使用 CCE 集群，控制节点数为 3，集群规格 1000 节点，计算节点分布不同 AZ</strong> 这两种部署方式。CCE Turbo 在弹性伸缩方面更具优势，而具有 3 个控制节点的 CCE 集群在控制平面层面提供了高可用性。您可以根据对弹性伸缩速度和控制平面高可用性的具体需求进行选择或组合使用。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#-选项分析>✅ 选项分析：</a></li><li><a href=#-正确答案>✅ 正确答案：</a></li><li><a href=#-选项分析-1>✅ 选项分析：</a></li><li><a href=#-正确答案是>✅ 正确答案是：</a></li><li><a href=#-正确的理解>✅ 正确的理解：</a></li><li><a href=#总结>❗总结：</a></li><li><a href=#-结论>✅ 结论：</a></li><li><a href=#-正确描述分析>✅ 正确描述分析：</a></li><li><a href=#-错误项>❌ 错误项：</a></li><li><a href=#-正确答案是-1>✅ 正确答案是：</a></li><li><a href=#-正确项分析>✅ 正确项分析：</a></li><li><a href=#-错误项分析>❌ 错误项分析：</a></li><li><a href=#-正确答案是-2>✅ 正确答案是：</a></li></ul></li></ul></nav></div></aside></main></body></html>