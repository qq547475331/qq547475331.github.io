<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="性能优化

  性能指标
  #


  高并发和响应快对应着性能优化的两个核心指标：吞吐和延时
  #





  应用负载角度：直接影响了产品终端的用户体验
  #




  系统资源角度：资源使用率、饱和度等
  #




  性能问题的本质就是系统资源已经到达瓶颈，但请求的处理还不够快，无法支撑更多的请求。性能分析实际上就是找出应用或系统的瓶颈，设法去避免或缓解它们。
  #




  选择指标评估应用程序和系统性能
  #




  为应用程序和系统设置性能目标
  #




  进行性能基准测试
  #




  性能分析定位瓶颈
  #




  性能监控和告警
  #




  对于不同的性能问题要选取不同的性能分析工具。下面是常用的Linux Performance Tools以及对应分析的性能问题类型。
  #



  到底应该怎么理解”平均负载”
  #


  平均负载：单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和我们传统意义上理解的CPU使用率并没有直接关系。
  #


  其中不可中断进程是正处于内核态关键流程中的进程（如常见的等待设备的I/O响应）。不可中断状态实际上是系统对进程和硬件设备的一种保护机制。
  #


  平均负载多少时合理
  #


  实际生产环境中将系统的平均负载监控起来，根据历史数据判断负载的变化趋势。当负载存在明显升高趋势时，及时进行分析和调查。当然也可以当设置阈值（如当平均负载高于CPU数量的70%时）
  #


  现实工作中我们会经常混淆平均负载和CPU使用率的概念，其实两者并不完全对等：
  #




  CPU 密集型进程，大量 CPU 使用会导致平均负载升高，此时两者一致
  #




  I/O 密集型进程，等待 I/O 也会导致平均负载升高，此时 CPU 使用率并不一定高
  #




  大量等待 CPU 的进程调度会导致平均负载升高，此时 CPU 使用率也会比较高
  #




  平均负载高时可能是 CPU 密集型进程导致，也可能是 I/O 繁忙导致。具体分析时可以结合 mpstat/pidstat 工具辅助分析负载来源。
  #


  CPU
  #


  CPU上下文切换(上)
  #


  CPU 上下文切换，就是把前一个任务的 CPU 上下文（CPU 寄存器和 PC）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的位置，运行新任务。其中，保存下来的上下文会存储在系统内核中，待任务重新调度执行时再加载，保证原来的任务状态不受影响。
  #


  按照任务类型，CPU 上下文切换分为：
  #




  进程上下文切换
  #




  线程上下文切换
  #




  中断上下文切换
  #




  进程上下文切换
  #


  Linux 进程按照等级权限将进程的运行空间分为内核空间和用户空间。从用户态向内核态转变时需要通过系统调用来完成。
  #


  一次系统调用过程其实进行了两次 CPU 上下文切换：
  #




  CPU 寄存器中用户态的指令位置先保存起来，CPU 寄存器更新为内核态指令的位置，跳转到内核态运行内核任务；
  #




  系统调用结束后，CPU 寄存器恢复原来保存的用户态数据，再切换到用户空间继续运行。
  #




  系统调用过程中并不会涉及虚拟内存等进程用户态资源，也不会切换进程。和传统意义上的进程上下文切换不同。因此系统调用通常称为特权模式切换。
  #


  进程是由内核管理和调度的，进程上下文切换只能发生在内核态。因此相比系统调用来说，在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存，栈保存下来。再加载新进程的内核态后，还要刷新进程的虚拟内存和用户栈。
  #


  进程只有在调度到CPU上运行时才需要切换上下文，有以下几种场景：CPU时间片轮流分配，系统资源不足导致进程挂起，进程通过sleep函数主动挂起，高优先级进程抢占时间片，硬件中断时CPU上的进程被挂起转而执行内核中的中断服务。
  #


  线程上下文切换
  #


  线程上下文切换分为两种：
  #




  前后线程同属于一个进程，切换时虚拟内存资源不变，只需要切换线程的私有数据，寄存器等；
  #




  前后线程属于不同进程，与进程上下文切换相同。
  #




  同进程的线程切换消耗资源较少，这也是多线程的优势。
  #


  中断上下文切换
  #


  中断上下文切换并不涉及到进程的用户态，因此中断上下文只包括内核态中断服务程序执行所必须的状态（CPU寄存器，内核堆栈，硬件中断参数等）。
  #


  中断处理优先级比进程高，所以中断上下文切换和进程上下文切换不会同时发生
  #


  CPU上下文切换(下)
  #

通过 vmstat 可以查看系统总体的上下文切换情况"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qq547475331.github.io/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/"><meta property="og:site_name" content="Guichen's Blog"><meta property="og:title" content="2024-04-03 Linux 性能优化大全"><meta property="og:description" content="性能优化
性能指标 # 高并发和响应快对应着性能优化的两个核心指标：吞吐和延时 # 应用负载角度：直接影响了产品终端的用户体验 # 系统资源角度：资源使用率、饱和度等 # 性能问题的本质就是系统资源已经到达瓶颈，但请求的处理还不够快，无法支撑更多的请求。性能分析实际上就是找出应用或系统的瓶颈，设法去避免或缓解它们。 # 选择指标评估应用程序和系统性能 # 为应用程序和系统设置性能目标 # 进行性能基准测试 # 性能分析定位瓶颈 # 性能监控和告警 # 对于不同的性能问题要选取不同的性能分析工具。下面是常用的Linux Performance Tools以及对应分析的性能问题类型。 # 到底应该怎么理解”平均负载” # 平均负载：单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和我们传统意义上理解的CPU使用率并没有直接关系。 # 其中不可中断进程是正处于内核态关键流程中的进程（如常见的等待设备的I/O响应）。不可中断状态实际上是系统对进程和硬件设备的一种保护机制。 # 平均负载多少时合理 # 实际生产环境中将系统的平均负载监控起来，根据历史数据判断负载的变化趋势。当负载存在明显升高趋势时，及时进行分析和调查。当然也可以当设置阈值（如当平均负载高于CPU数量的70%时） # 现实工作中我们会经常混淆平均负载和CPU使用率的概念，其实两者并不完全对等： # CPU 密集型进程，大量 CPU 使用会导致平均负载升高，此时两者一致 # I/O 密集型进程，等待 I/O 也会导致平均负载升高，此时 CPU 使用率并不一定高 # 大量等待 CPU 的进程调度会导致平均负载升高，此时 CPU 使用率也会比较高 # 平均负载高时可能是 CPU 密集型进程导致，也可能是 I/O 繁忙导致。具体分析时可以结合 mpstat/pidstat 工具辅助分析负载来源。 # CPU # CPU上下文切换(上) # CPU 上下文切换，就是把前一个任务的 CPU 上下文（CPU 寄存器和 PC）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的位置，运行新任务。其中，保存下来的上下文会存储在系统内核中，待任务重新调度执行时再加载，保证原来的任务状态不受影响。 # 按照任务类型，CPU 上下文切换分为： # 进程上下文切换 # 线程上下文切换 # 中断上下文切换 # 进程上下文切换 # Linux 进程按照等级权限将进程的运行空间分为内核空间和用户空间。从用户态向内核态转变时需要通过系统调用来完成。 # 一次系统调用过程其实进行了两次 CPU 上下文切换： # CPU 寄存器中用户态的指令位置先保存起来，CPU 寄存器更新为内核态指令的位置，跳转到内核态运行内核任务； # 系统调用结束后，CPU 寄存器恢复原来保存的用户态数据，再切换到用户空间继续运行。 # 系统调用过程中并不会涉及虚拟内存等进程用户态资源，也不会切换进程。和传统意义上的进程上下文切换不同。因此系统调用通常称为特权模式切换。 # 进程是由内核管理和调度的，进程上下文切换只能发生在内核态。因此相比系统调用来说，在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存，栈保存下来。再加载新进程的内核态后，还要刷新进程的虚拟内存和用户栈。 # 进程只有在调度到CPU上运行时才需要切换上下文，有以下几种场景：CPU时间片轮流分配，系统资源不足导致进程挂起，进程通过sleep函数主动挂起，高优先级进程抢占时间片，硬件中断时CPU上的进程被挂起转而执行内核中的中断服务。 # 线程上下文切换 # 线程上下文切换分为两种： # 前后线程同属于一个进程，切换时虚拟内存资源不变，只需要切换线程的私有数据，寄存器等； # 前后线程属于不同进程，与进程上下文切换相同。 # 同进程的线程切换消耗资源较少，这也是多线程的优势。 # 中断上下文切换 # 中断上下文切换并不涉及到进程的用户态，因此中断上下文只包括内核态中断服务程序执行所必须的状态（CPU寄存器，内核堆栈，硬件中断参数等）。 # 中断处理优先级比进程高，所以中断上下文切换和进程上下文切换不会同时发生 # CPU上下文切换(下) # 通过 vmstat 可以查看系统总体的上下文切换情况"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>2024-04-03 Linux 性能优化大全 | Guichen's Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qq547475331.github.io/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.3cb8e8434778f0c84796163dce5e3366067ef3c81eec3be98a8322df81d6631a.js integrity="sha256-PLjoQ0d48MhHlhY9zl4zZgZ+88ge7DvpioMi34HWYxo=" crossorigin=anonymous></script></head><script src=https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){mermaid.initialize({startOnLoad:!0});let e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(e=>{let t=document.createElement("div");t.classList.add("mermaid"),t.innerHTML=e.innerText,e.parentNode.replaceWith(t)}),mermaid.init(void 0,document.querySelectorAll(".mermaid"))})</script><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Guichen's Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/docs/2025-3-20-victoriametrics%E6%9E%B6%E6%9E%84/>2025-3-20 victoriametrics 架构</a></li><li><a href=/docs/2025-3-20-victoriametrics%E5%92%8Cthanos%E5%AF%B9%E6%AF%94/>2025-3-20 VictoriaMetrics 和 Thanos 对比</a></li><li><a href=/docs/2025-3-20-thanos%E6%9E%B6%E6%9E%84/>2025-3-20 thanos架构</a></li><li><a href=/docs/2025-3-18-5w-pod%E5%8E%8B%E6%B5%8B%E5%A4%8D%E7%9B%98/>2025-3-18 5w pod压测复盘</a></li><li><a href=/docs/2025-3-14-%E7%81%AB%E5%B1%B1%E4%BA%91%E8%BF%81%E7%A7%BB%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/>2025-3-14 火山云迁移工程师面试记录</a></li><li><a href=/docs/2025-3-14-vivo%E9%9D%A2%E8%AF%95/>2025-3-14 vivo面试</a></li><li><a href=/docs/2025-3-13-istio%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/>2025-3-13 istio流量分析</a></li><li><a href=/docs/2025-3-13-calico%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B5%81%E9%87%8F%E4%BC%A0%E8%BE%93%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/>2025-3-13 calico三种模式下流量传输</a></li><li><a href=/docs/2025-3-12-%E5%A1%94%E8%B5%9E%E9%9D%A2%E8%AF%95/>2025-3-12 塔赞面试</a></li><li><a href=/docs/2025-3-12-%E8%BF%BD%E8%A7%85%E9%9D%A2%E8%AF%95/>2025-3-12 追觅面试</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%A0%E9%99%A4pod-deployment%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s删除pod或deployment的流程图详解</a></li><li><a href=/docs/2025-3-8-k8s%E5%88%9B%E5%BB%BApod-deployment%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3/>2025-3-08 k8s创建pod流程图详解</a></li><li><a href=/docs/2025-2-28-prometheus%E9%A2%98%E7%9B%AE/>2025-2-28 prometheus面试题</a></li><li><a href=/docs/2025-2-26-%E9%9D%A2%E8%AF%950225/>2025-2-25 面试0225</a></li><li><a href=/docs/2025-2-24-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_ai_linux%E9%83%A8%E5%88%86/>2025-2-24 高级运维面试题-linux部分</a></li><li><a href=/docs/2025-2-24-%E4%B8%AD%E7%BA%A7%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98_%E9%A2%98%E7%9B%AE/>2025-2-24 中级运维面试题</a></li><li><a href=/docs/2025-2-24-%E9%9D%A2%E8%AF%950224/>2025-2-24 0224面试</a></li><li><a href=/docs/2025-2-20-%E9%9D%A2%E8%AF%950220/>2025-2-20 面试0220</a></li><li><a href=/docs/2025-2-19-%E9%9D%A2%E8%AF%950219/>2025-2-19 面试0219</a></li><li><a href=/docs/2025-2-18-%E9%9D%A2%E8%AF%95/>2025-2-18 面试2025-0218</a></li><li><a href=/docs/2025-2-26-k8s%E7%9B%B8%E5%85%B3/>2025-2-16 k8s题目</a></li><li><a href=/docs/2025-2-12-%E9%9D%A2%E8%AF%950212/>2025-2-12 面试0212</a></li><li><a href=/docs/2025-2-11-%E9%9D%A2%E8%AF%950211/>2025-2-11 面试2025-02-11</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%922/>2025-2-07 美国码农计划</a></li><li><a href=/docs/2025-2-7-%E8%AE%A1%E5%88%92/>2025-2-07 美国码农薪酬</a></li><li><a href=/docs/2025-2-7-k8s%E7%BB%84%E4%BB%B6/>2025-2-07 k8s组件</a></li><li><a href=/docs/2024-3-4-k8s%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90/>2025-1-16 k8s流量链路剖析</a></li><li><a href=/docs/2025-1-16-k8s%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8C%87%E5%8D%97/>2025-1-16 k8s常见故障指南</a></li><li><a href=/docs/2024-3-4-k8s-csi%E5%89%96%E6%9E%90/>2025-1-16 CSI剖析演进</a></li><li><a href=/docs/2025-1-1-%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%9B%E4%B8%9A/>2025-1-1 要不要创业</a></li><li><a href=/docs/2025-1-1-%E6%97%A9%E6%9C%9F%E6%A8%A1%E5%BC%8F/>2025-1-1 早期模式</a></li><li><a href=/docs/2025-1-1-%E5%A4%A7%E5%A0%B0%E6%B2%B3-%E6%88%91%E7%9A%84%E4%BF%9D%E5%A7%86/>2025-1-1 大堰河-我的保姆</a></li><li><a href=/docs/2025-1-1-%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8/>2025-1-1 初创公司</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E8%80%85%E4%BA%A4%E6%B5%81/>2025-1-1 创业者交流</a></li><li><a href=/docs/2025-1-1-%E5%88%9B%E4%B8%9A%E7%82%B9%E5%AD%90/>2025-1-1 创业点子</a></li><li><a href=/docs/2025-1-1-sealos%E8%8E%B7%E6%8A%95/>2025-1-1 sealos获投</a></li><li><a href=/docs/2024-8-1-linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 linux面试题</a></li><li><a href=/docs/2024-8-1-%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BF%85%E7%9C%8B/>2024-8-1 linux运维面试题</a></li><li><a href=/docs/2024-8-1-kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98/>2024-8-1 k8s面试题</a></li><li><a href=/docs/2024-5-14-%E5%8D%95master%E5%8D%95etcd%E6%94%B9%E9%80%A0/>2024-5-1 单master单etcd改造为3master3etcd</a></li><li><a href=/docs/2024-4-17-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/>2024-4-17 面试总结</a></li><li><a href=/docs/2024-3-8-%E9%9D%A2%E8%AF%950308/>2024-3-8 面试</a></li><li><a href=/docs/2024-3-4-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B/>2024-3-4 CNI剖析演进</a></li><li><a href=/docs/2024-3-19-%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86/>2024-3-19 两张图全面理解k8s原理</a></li><li><a href=/docs/2024-2-26-%E9%9D%A2%E8%AF%95/>2024-2-26 面试</a></li><li><a href=/docs/2024-2-22-k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/>2024-2-22 k8s面试宝典</a></li><li><a href=/docs/2024-2-22-k8s%E6%9E%B6%E6%9E%84%E5%B8%88%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/>2024-2-22 k8s架构师面试大全</a></li><li><a href=/docs/2024-12-10-docker-registrry/>2024-12-10 docker registrry</a></li><li><a href=/docs/2024-12-09-openstack-ssh%E8%BF%9E%E6%8E%A5/>2024-12-09 openstack ssh连接</a></li><li><a href=/docs/2024-12-08-mutilpass%E9%83%A8%E7%BD%B2openstack/>2024-12-09 mutilpass部署openstack devstack形式</a></li><li><a href=/docs/2024-12-09-helmchart-%E9%83%A8%E7%BD%B2flask%E5%BA%94%E7%94%A8/>2024-12-09 helmchart 部署flask应用</a></li><li><a href=/docs/2024-12-09-docker-daemon.json/>2024-12-09 docker daemon.json</a></li><li><a href=/docs/2024-12-08-%E5%9D%97%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%E5%8C%BA%E5%88%AB/>2024-12-08 块存储和对象储存区别</a></li><li><a href=/docs/2024-12-08-openstack%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/>2024-12-08 openstack需要几台虚拟机</a></li><li><a href=/docs/2024-12-08-openstack%E5%92%8Ckubernetes%E5%8C%BA%E5%88%AB/>2024-12-08 openstack和kubernetes区别</a></li><li><a href=/docs/2024-12-08-nano%E6%93%8D%E4%BD%9C/>2024-12-08 nano操作</a></li><li><a href=/docs/2024-12-08-mutilpass%E6%93%8D%E4%BD%9C/>2024-12-08 mutilpass操作</a></li><li><a href=/docs/2024-12-08-devstack/>2024-12-08 devstack</a></li><li><a href=/docs/2024-12-07-microk8s/>2024-12-07 microk8s</a></li><li><a href=/docs/2024-12-05-kubeasz%E9%83%A8%E7%BD%B2k8s/>2024-12-05 kubeasz部署k8s</a></li><li><a href=/docs/2024-10-20-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/>2024-10-20 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li><li><a href=/docs/%E9%A1%B6%E7%BA%A7devops%E5%B7%A5%E5%85%B7%E5%A4%A7%E7%9B%98%E7%82%B9-ding-ji-devops-gong-ju-da-pan-dian/>2024-08-02 顶级devops工具大盘点</a></li><li><a href=/docs/%E6%B8%85%E7%90%86docker%E9%95%9C%E5%83%8F-qing-li-docker-jing-xiang/>2024-08-02 清理docker镜像</a></li><li><a href=/docs/%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%88%A9%E5%99%A8buildkit-gou-jian-rong-qi-jing-xiang-li-qi-buildkit/>2024-08-02 构建容器镜像利器buildkit</a></li><li><a href=/docs/%E6%98%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%A5%9E%E8%BF%98%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E7%9A%84%E7%A5%B8%E5%AE%B3-shi-ji-shu-da-shen-hai-shi-ji-chu-jia-gou-bu-de-huo-hai/>2024-08-02 是技术大神还是基础架构部的祸害</a></li><li><a href=/docs/%E6%90%AD%E4%B8%AA%E6%97%A5%E5%BF%97%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8D%E9%A6%99%E5%90%97-da-ge-ri-zhi-shou-ji-xi-tong-bu-xiang-ma/>2024-08-02 搭个日志手机系统不香吗</a></li><li><a href=/docs/%E6%88%91%E5%8F%AA%E6%83%B3%E5%81%9A%E6%8A%80%E6%9C%AF-%E8%B5%B0%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-wo-zhi-xiang-zuo-ji-shu-zou-ji-shu-lu-xian/>2024-08-02 我只想做技术 走技术路线</a></li><li><a href=/docs/%E5%B8%B8%E8%A7%81linux%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98-chang-jian-linux-yun-wei-mian-shi-ti/>2024-08-02 常见linux运维面试题</a></li><li><a href=/docs/%E5%A4%A7%E5%8E%82%E6%80%BB%E7%BB%93nginx%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0-da-chang-zong-jie-nginx-gao-bing-fa-you-hua-bi-ji/>2024-08-02 大厂总结nginx高并发优化笔记</a></li><li><a href=/docs/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%89%9Bjenkins-pipeline%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AF%A6%E8%A7%A3-shi-shang-zui-niu-jenkinspipeline-liu-shui-xian-xiang-jie/>2024-08-02 史上最牛jenkins pipeline流水线详解</a></li><li><a href=/docs/teg%E4%B8%8Eistio%E9%9B%86%E6%88%90-teg-yu-istio-ji-cheng/>2024-08-02 TEG与istio集成</a></li><li><a href=/docs/prometheus-stack-prometheus-stack/>2024-08-02 prometheus-stack</a></li><li><a href=/docs/pixie-pixie/>2024-08-02 pixie</a></li><li><a href=/docs/nginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94-nginx-ru-he-jie-jue-jing-qun-xiao-ying/>2024-08-02 nginx如何解决惊群效应</a></li><li><a href=/docs/netctl%E6%A3%80%E6%B5%8B%E9%9B%86%E7%BE%A4pod%E9%97%B4%E8%BF%9E%E9%80%9A%E6%80%A7-netctl-jian-ce-ji-qun-pod-jian-lian-tong-xing/>2024-08-02 netctl检测集群pod间连通性</a></li><li><a href=/docs/linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%8850%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-linux-yun-wei-gong-cheng-shi-50-ge-chang-jian-mian-shi-ti/>2024-08-02 linux运维工程师50个常见面试题</a></li><li><a href=/docs/linux%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%83%E4%B8%AA%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C-linux-xi-tong-xing-neng-you-hua-qi-ge-shi-zhan-jing-yan/>2024-08-02 linux系统性能优化 七个实战经验</a></li><li><a href=/docs/linux-awk%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%99%A8-8%E4%B8%AA%E6%A1%88%E4%BE%8B-linuxawk-wen-ben-chu-li-qi-8-ge-an-li/>2024-08-02 linux awk文本处理器 8个案例</a></li><li><a href=/docs/kubewharf-kubewharf/>2024-08-02 kubewharf</a></li><li><a href=/docs/kruise%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E8%A7%A3%E6%9E%90-kruise-yuan-de-sheng-ji-jie-xi/>2024-08-02 kruise原地升级解析</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E9%A2%98-k8s-mian-shi-ti/>2024-08-02 K8S面试题</a></li><li><a href=/docs/k8s%E8%83%8C%E5%90%8Eservice%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-k8s-bei-hou-service-shi-ru-he-gong-zuo-de/>2024-08-02 k8s背后service是如何工作的</a></li><li><a href=/docs/k8s%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E6%8B%BC%E5%9B%BE-dbpaas-k8s-de-zui-hou-yi-kuai-pin-tu-dbpaas/>2024-08-02 K8S的最后一块拼图</a></li><li><a href=/docs/istio%E9%83%A8%E7%BD%B2-istio-bu-shu/>2024-08-02 istio部署</a></li><li><a href=/docs/istio-ingress-gateway-istio-ingress-gateway/>2024-08-02 istio-ingress-gateway</a></li><li><a href=/docs/godel-scheduler-godel-scheduler/>2024-08-02 godel-scheduler</a></li><li><a href=/docs/dockerfile%E5%AE%9A%E5%88%B6%E4%B8%93%E5%B1%9E%E9%95%9C%E5%83%8F-dockerfile-ding-zhi-zhuan-shu-jing-xiang/>2024-08-02 dockerfile定制专属镜像</a></li><li><a href=/docs/33%E6%AC%BEgitops%E4%B8%8Edevops%E4%B8%BB%E6%B5%81%E7%B3%BB%E7%BB%9F-33-kuan-gitops-yu-devops-zhu-liu-xi-tong/>2024-08-02 33款gitops与devops主流系统</a></li><li><a href=/docs/openkruise%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-openkruise-xiang-xi-jie-shi-yi-ji-yuan-de-sheng-ji-ji-quan-lian-lu-hui-du-fa-bu-fang-an/>2024-07-22 OpenKruise详细解释以及原地升级及全链路灰度发布方案</a></li><li><a href=/docs/k8s%E4%B9%8Bingress-nginx%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE-k8s-zhi-ingress-nginx-yuan-li-ji-pei-zhi/>2024-07-05 K8S之ingress-nginx原理及配置</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8cloudflarecf%E6%90%AD%E5%BB%BAdockerhub%E4%BB%A3%E7%90%86-shi-yong-cloudflarecf-da-jian-dockerhub-dai-li/>2024-06-28 使用cloudflare(CF)搭建dockerhub代理</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%B8%BAk8s%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA-ru-he-wei-k8s-bao-jia-hu-hang/>2024-04-16 如何为K8S保驾护航</a></li><li><a href=/docs/k8s%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97-ip-k8s-ru-he-huo-de-ip/>2024-04-16 K8S如何获得 IP</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_setgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_status_updatego%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetstatusupdatego-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_status_update.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_set_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulsetcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_set_control.go源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bstateful_pod_controlgo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-statefulpodcontrolgo-yuan-ma-jie-du/>2024-04-10 K8S控制器之stateful_pod_control.go源码解读</a></li><li><a href=/docs/k8s%E8%B0%83%E5%BA%A6%E5%99%A8-extendergo-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-extendergo-yuan-ma-jie-du/>2024-04-09 K8S调度器 extender.go 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Bsyncgo-%E5%90%8C%E6%AD%A5-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-syncgo-tong-bu-yuan-ma-jie-du/>2024-04-09 K8S控制器之sync.go 同步 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brollbackgo-%E5%9B%9E%E6%BB%9A-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollbackgo-hui-gun-yuan-ma-jie-du/>2024-04-09 K8S控制器之rollback.go 回滚 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8Brecreatego-%E9%87%8D%E5%BB%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-recreatego-zhong-jian-yuan-ma-jie-du/>2024-04-09 K8S控制器之recreate.go 重建 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-schedulergo-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-schedulergo-diao-du-qi-yuan-ma-jie-du/>2024-04-09 K8S控制器之 scheduler.go 调度器 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-rollinggo-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-rollinggo-gun-dong-geng-xin-yuan-ma-jie-du/>2024-04-09 K8S控制器之 rolling.go 滚动更新 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-progressgo-%E8%BF%9B%E5%BA%A6-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-progressgo-jin-du-yuan-ma-jie-du/>2024-04-09 K8S控制器之 progress.go 进度 源码解读</a></li><li><a href=/docs/k8s%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B-deployment_controllergo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-kong-zhi-qi-zhi-deploymentcontrollergo-yuan-ma-jie-du/>2024-04-09 K8S控制器之 deployment_controller.go源码解读</a></li><li><a href=/docs/k8s-%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler_onego-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-diao-du-qi-scheduleronego-yuan-ma-jie-du/>2024-04-09 K8S 调度器 scheduler_one.go 源码解读</a></li><li><a href=/docs/%E5%BD%BB%E6%82%9F%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C-che-wu-rong-qi-wang-luo/>2024-04-07 彻悟容器网络</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%95%E7%94%A8-golang-%E6%89%8B%E6%92%B8-lru-mian-shi-yong-golang-shou-lu-lru/>2024-04-03 面试用 Golang 手撸 LRU</a></li><li><a href=/docs/%E8%87%AA%E5%8A%A8%E5%B1%8F%E8%94%BDip%E6%94%BB%E5%87%BB-zi-dong-ping-bi-ip-gong-ji/>2024-04-03 自动屏蔽IP攻击</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85kubephere-li-xian-an-zhuang-kubephere/>2024-04-03 离线安装kubephere</a></li><li><a href=/docs/%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D-ci-pan-shu-ju-hui-fu/>2024-04-03 磁盘数据恢复</a></li><li><a href=/docs/%E6%B8%85%E7%90%86%E6%AE%8B%E7%95%99%E7%9A%84calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6-qing-li-can-liu-de-calico-wang-luo/>2024-04-03 清理残留的calico网络插件</a></li><li><a href=/docs/%E6%B5%81%E9%87%8F%E4%BD%95%E5%A4%84%E6%9D%A5%E4%BD%95%E5%A4%84%E5%8E%BB-liu-liang-he-chu-lai-he-chu-qu/>2024-04-03 流量何处来何处去</a></li><li><a href=/docs/%E6%9E%81%E5%A4%A7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84-linux-%E5%91%BD%E4%BB%A4-ji-da-ti-gao-gong-zuo-xiao-lv-de-linux-ming-ling/>2024-04-03 极大提高工作效率的 Linux 命令</a></li><li><a href=/docs/%E6%96%87%E5%AD%A6%E7%9A%84%E6%95%85%E4%B9%A1-wen-xue-de-gu-xiang/>2024-04-03 文学的故乡</a></li><li><a href=/docs/%E6%90%9E%E6%87%82k8s%E9%89%B4%E6%9D%83-gao-dong-k8s-jian-quan/>2024-04-03 搞懂K8S鉴权</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-rong-qi-wang-luo-yuan-li/>2024-04-03 容器网络原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80-overlayfs-%E5%8E%9F%E7%90%86-rong-qi-de-wen-jian-xi-tong--yi-overlayfs-yuan-li/>2024-04-03 容器的文件系统 OverlayFS 原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86-rong-qi-yuan-li/>2024-04-03 容器原理</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84-1-%E5%8F%B7%E8%BF%9B%E7%A8%8B-rong-qi-nei-de-1-hao-jin-cheng/>2024-04-03 容器内的 1 号进程</a></li><li><a href=/docs/%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%90%8Cdnspolicy%E5%AF%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BD%B1%E5%93%8D-rong-qi-zhong-yu-ming-jie-xi-yi-ji-bu-tong-dnspolicy-dui-yu-ming-jie-xi-de-ying-xiang/>2024-04-03 容器中域名解析以及不同dnspolicy对域名解析的影响</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95-crash-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C-ru-he-diao-shi-crash-rong-qi-de-wang-luo/>2024-04-03 如何调试 crash 容器的网络</a></li><li><a href=/docs/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tekton%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcicd%E5%B9%B3%E5%8F%B0-ru-he-shi-yong-tekton-kuai-su-da-jian-cicd-ping-tai/>2024-04-03 如何使用tekton快速搭建CI/CD平台</a></li><li><a href=/docs/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB-pod-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6-da-gui-mo-bing-fa-xia-ru-he-jia-kuai-pod-qi-dong-su-du/>2024-04-03 大规模并发下如何加快 Pod 启动速度</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8kubernees-leases-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0leader-election-shi-yong-kuberneesleases-qing-song-shi-xian-leaderelection/>2024-04-03 使用kubernees leases 轻松实现leader election</a></li><li><a href=/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s%E5%8A%A0%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-er-jin-zhi-bu-shu-k8s-jia-jie-dian-cao-zuo/>2024-04-03 二进制部署K8S加节点操作</a></li><li><a href=/docs/%E4%B8%A4%E5%BC%A0%E5%9B%BE%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3k8s%E5%8E%9F%E7%90%86-liang-zhang-tu-quan-mian-li-jie-k8s-yuan-li/>2024-04-03 两张图全面理解K8S原理</a></li><li><a href=/docs/ssl%E8%AF%81%E4%B9%A6%E8%87%AA%E7%AD%BE%E5%8F%91-ssl-zheng-shu-zi-qian-fa/>2024-04-03 ssl证书自签发</a></li><li><a href=/docs/prometheus%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93-prometheus-qi-ye-ji-jian-kong-shi-yong-zong-jie/>2024-04-03 prometheus企业级监控使用总结</a></li><li><a href=/docs/metallb-l2-%E5%8E%9F%E7%90%86-metallbl2-yuan-li/>2024-04-03 MetalLB L2 原理</a></li><li><a href=/docs/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8-linux-xing-neng-you-hua-da-quan/ class=active>2024-04-03 Linux 性能优化大全</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E9%89%B4%E6%9D%83-kubernetes-zheng-shu-xiang-jie--jian-quan-/>2024-04-03 Kubernetes 证书详解(鉴权)</a></li><li><a href=/docs/kubernetes-%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3%E8%AE%A4%E8%AF%81-kubernetes-zheng-shu-xiang-jie--ren-zheng-/>2024-04-03 Kubernetes 证书详解(认证)</a></li><li><a href=/docs/kubernetes-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84-kubernetes-yuan-ma-jie-gou/>2024-04-03 Kubernetes 源码结构</a></li><li><a href=/docs/kubernetes-api-kubernetesapi/>2024-04-03 Kubernetes API</a></li><li><a href=/docs/kubekey%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9-kubekey-tian-jia-xin-jie-dian/>2024-04-03 kubekey添加新节点</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-k8s-mian-shi-bao-dian/>2024-04-03 K8S面试宝典</a></li><li><a href=/docs/k8s%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8-k8s-mian-shi-da-quan/>2024-04-03 K8S面试大全</a></li><li><a href=/docs/k8s%E8%BF%90%E7%BB%B4%E4%B9%8B%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98-k8s-yun-wei-zhi-qing-li-ci-pan/>2024-04-03 k8s运维之清理磁盘</a></li><li><a href=/docs/k8s%E8%B0%83%E8%AF%95pod-k8s-diao-shi-pod/>2024-04-03 K8S调试POD</a></li><li><a href=/docs/k8s%E7%9A%84pod%E7%B1%BB%E5%9E%8B-k8s-de-pod-lei-xing/>2024-04-03 K8S的POD类型</a></li><li><a href=/docs/k8s%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-k8s-ying-yong-de-zui-jia-shi-jian/>2024-04-03 k8s应用的最佳实践</a></li><li><a href=/docs/k8s%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97-k8s-ming-ling-zhi-nan/>2024-04-03 K8S命令指南</a></li><li><a href=/docs/k8s%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7-k8s-yuan-de-sheng-ji/>2024-04-03 K8S原地升级</a></li><li><a href=/docs/k8s-%E6%8E%A2%E9%92%88%E5%8E%9F%E7%90%86-k8s-tan-zhen-yuan-li/>2024-04-03 K8S 探针原理</a></li><li><a href=/docs/k8s-%E5%BC%80%E5%8F%91%E5%8F%AF%E4%B8%8D%E6%AD%A2-crud-k8s-kai-fa-ke-bu-zhi-crud/>2024-04-03 K8S 开发可不止 CRUD</a></li><li><a href=/docs/k8s-gpt-k8sgpt/>2024-04-03 K8S GPT</a></li><li><a href=/docs/k8s-csi-openebs%E5%8E%9F%E7%90%86-k8scsiopenebs-yuan-li/>2024-04-03 K8S csi openebs原理</a></li><li><a href=/docs/helm-chart%E5%92%8Crepo-helmchart-he-repo/>2024-04-03 helm chart和repo</a></li><li><a href=/docs/flanel%E7%BD%91%E7%BB%9C-flanel-wang-luo/>2024-04-03 flanel网络</a></li><li><a href=/docs/etcd%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-etcd-wen-ding-xing-ji-xing-neng-you-hua-shi-jian/>2024-04-03 ETCD稳定性及性能优化实践</a></li><li><a href=/docs/etcd%E5%A4%87%E4%BB%BD-etcd-bei-fen/>2024-04-03 ETCD备份</a></li><li><a href=/docs/docker%E9%87%8D%E8%A6%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9-docker-zhong-yao-de-wang-luo-zhi-shi-dian/>2024-04-03 Docker重要的网络知识点</a></li><li><a href=/docs/dockerfile%E7%9A%84copy%E5%92%8Cadd%E7%9A%84%E5%8C%BA%E5%88%AB-dockerfile-de-copy-he-add-de-qu-bie/>2024-04-03 dockerfile的copy和add的区别</a></li><li><a href=/docs/coredns%E4%B9%8B%E5%85%89-coredns-zhi-guang/>2024-04-03 COREDNS之光</a></li><li><a href=/docs/containerd-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-containerd-ji-ben-cao-zuo/>2024-04-03 Containerd 基本操作</a></li><li><a href=/docs/cni%E6%8F%92%E4%BB%B6%E9%80%89%E5%9E%8B-cni-cha-jian-xuan-xing/>2024-04-03 CNI插件选型</a></li><li><a href=/docs/client-go-%E6%9E%B6%E6%9E%84-client-go-jia-gou/>2024-04-03 Client-go 架构</a></li><li><a href=/docs/client-go-%E5%9B%9B%E7%A7%8D%E5%AE%A2%E6%88%B7%E7%AB%AF-client-go-si-zhong-ke-hu-duan/>2024-04-03 Client-go 四种客户端</a></li><li><a href=/docs/cicd%E6%80%9D%E8%80%83-cicd-si-kao/>2024-04-03 CICD思考</a></li><li><a href=/docs/calico%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AE%9A%E4%B9%89-calico-wang-luo-zi-ding-yi/>2024-04-03 Calico网络自定义</a></li><li><a href=/docs/acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6-acme-zi-dong-geng-xin-zheng-shu/>2024-04-03 acme自动更新证书</a></li><li><a href=/docs/16%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-kubernetes-16-ge-gai-nian-dai-ni-ru-men-kubernetes/>2024-04-03 16个概念带你入门 Kubernetes</a></li><li><a href=/docs/%E9%9D%A2%E8%AF%950308-mian-shi-0308/>2024-04-03 面试0308</a></li><li><a href=/docs/600%E6%9D%A1%E6%9C%80%E5%BC%BAlinux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93-600-tiao-zui-qiang-linux-ming-ling-zong-jie/>2024-04-03 600条最强linux命令总结</a></li><li><a href=/docs/16%E5%BC%A0%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3k8s%E7%BD%91%E7%BB%9C-16-zhang-ying-he-tu-jie-k8s-wang-luo/>2024-04-03 16张硬核图解k8s网络</a></li><li><a href=/docs/k8s%E4%B9%8Bkubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-k8s-zhi-kubelet-yuan-ma-jie-du/>2024-03-28 k8s之kubelet源码解读</a></li><li><a href=/docs/k8s-%E6%B5%81%E9%87%8F%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90-k8s-liu-liang-lian-lu-pou-xi/>2024-03-04 K8S 流量链路剖析</a></li><li><a href=/docs/k8s-csi%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scsi-pou-xi-yan-jin/>2024-03-04 K8S CSI剖析演进</a></li><li><a href=/docs/k8s-cni%E5%89%96%E6%9E%90%E6%BC%94%E8%BF%9B-k8scni-pou-xi-yan-jin/>2024-03-04 K8S CNI剖析演进</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-openfunction-%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD-shi-yong-openfunction-zai-ren-he-ji-chu-she-shi-shang-yun-xing-wu-fu-wu-qi-gong-zuo-fu-zai/>2024-01-21 使用 OpenFunction 在任何基础设施上运行无服务器工作负载</a></li><li><a href=/docs/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4-li-xian-an-zhuang-ji-qun/>2023-09-28 离线安装集群</a></li><li><a href=/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B4%E6%98%8E-cao-zuo-xi-tong-shuo-ming/>2023-09-28 操作系统说明</a></li><li><a href=/docs/%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97-kuai-su-zhi-nan/>2023-09-28 快速指南</a></li><li><a href=/docs/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-cilium-kai-shi-shi-yong-cilium/>2023-09-28 开始使用 cilium</a></li><li><a href=/docs/%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81-duo-jia-gou-zhi-chi/>2023-09-28 多架构支持</a></li><li><a href=/docs/%E5%85%AC%E6%9C%89%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2-kubeasz-gong-you-yun-shang-bu-shu-kubeasz/>2023-09-28 公有云上部署</a></li><li><a href=/docs/%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-ge-xing-hua-ji-qun-can-shu-pei-zhi/>2023-09-28 个性化集群参数配置</a></li><li><a href=/docs/network-check-network-check/>2023-09-28 network-check</a></li><li><a href=/docs/kube-router-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-kube-router-wang-luo-zu-jian/>2023-09-28 kube-router 网络组件</a></li><li><a href=/docs/ezctl-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%8B%E7%BB%8D-ezctl-ming-ling-xing-jie-shao/>2023-09-28 ezctl 命令行介绍</a></li><li><a href=/docs/ex-lb-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%83%A8%E7%BD%B2-ex-lb-fu-zai-jun-heng-bu-shu/>2023-09-28 EX-LB 负载均衡部署</a></li><li><a href=/docs/calico-%E9%85%8D%E7%BD%AE-bgp-route-reflectors-calico-pei-zhi-bgproutereflectors/>2023-09-28 calico 配置 BGP Route Reflectors</a></li><li><a href=/docs/07-%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4%E4%B8%BB%E8%A6%81%E6%8F%92%E4%BB%B6-07--an-zhuang-ji-qun-zhu-yao-cha-jian/>2023-09-28 15:26:42.651 07-安装集群主要插件</a></li><li><a href=/docs/08-k8s-%E9%9B%86%E7%BE%A4%E5%AD%98%E5%82%A8--k8s-ji-qun-cun-chu/>2023-09-28 08-K8S 集群存储</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-wang-luo-zu-jian/>2023-09-28 06-安装网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85kube-ovn%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-kube-ovn-wang-luo-zu-jian/>2023-09-28 06-安装kube-ovn网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85flannel%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-flannel-wang-luo-zu-jian/>2023-09-28 06-安装flannel网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85cilium%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-cilium-wang-luo-zu-jian/>2023-09-28 06-安装cilium网络组件</a></li><li><a href=/docs/06-%E5%AE%89%E8%A3%85calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-06--an-zhuang-calico-wang-luo-zu-jian/>2023-09-28 06-安装calico网络组件</a></li><li><a href=/docs/02-%E5%AE%89%E8%A3%85etcd%E9%9B%86%E7%BE%A4-02--an-zhuang-etcd-ji-qun/>2023-09-28 02-安装etcd集群</a></li><li><a href=/docs/00-%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A-00--ji-qun-gui-hua-he-ji-chu-can-shu-she-ding/>2023-09-28 00-集群规划和基础参数设定</a></li><li><a href=/docs/05-%E5%AE%89%E8%A3%85kube_node%E8%8A%82%E7%82%B9-05--an-zhuang-kubenode-jie-dian/>2023-09-28 05-安装kube_node节点</a></li><li><a href=/docs/04-%E5%AE%89%E8%A3%85kube_master%E8%8A%82%E7%82%B9-04--an-zhuang-kubemaster-jie-dian/>2023-09-28 04-安装kube_master节点</a></li><li><a href=/docs/03-%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-03--an-zhuang-rong-qi-yun-xing-shi/>2023-09-28 03-安装容器运行时</a></li><li><a href=/docs/01-%E5%88%9B%E5%BB%BA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-01--chuang-jian-zheng-shu-he-huan-jing-zhun-bei/>2023-09-28 01-创建证书和环境准备</a></li><li><a href=/docs/%E6%9C%89%E8%BF%993%E4%B8%AA%E8%BF%B9%E8%B1%A1%E4%BD%A0%E5%B0%B1%E8%AF%A5%E7%A6%BB%E8%81%8C%E4%BA%86-you-zhe-3-ge-ji-xiang--ni-jiu-gai-li-zhi-le/>2023-09-21 思考</a></li><li><a href=/docs/%E4%BD%BF%E7%94%A8-keepalived-%E5%92%8C-haproxy-%E5%88%9B%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8-kubernetes-%E9%9B%86%E7%BE%A4-shi-yong-keepalived-he-haproxy-chuang-jian-gao-ke-yong-kubernetes-ji-qun/>2023-04-12 使用 Keepalived 和 HAproxy 创建高可用 Kubernetes 集群</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2024-04-03 Linux 性能优化大全</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li><li><a href=#cpu><strong>CPU</strong></a></li><li><a href=#内存><strong>内存</strong></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p><strong>性能优化</strong></p><h4 id=性能指标><strong>性能指标</strong>
<a class=anchor href=#%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87>#</a></h4><h5 id=高并发和响应快对应着性能优化的两个核心指标吞吐和延时>高并发和响应快对应着性能优化的两个核心指标：吞吐和延时
<a class=anchor href=#%e9%ab%98%e5%b9%b6%e5%8f%91%e5%92%8c%e5%93%8d%e5%ba%94%e5%bf%ab%e5%af%b9%e5%ba%94%e7%9d%80%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e7%9a%84%e4%b8%a4%e4%b8%aa%e6%a0%b8%e5%bf%83%e6%8c%87%e6%a0%87%e5%90%9e%e5%90%90%e5%92%8c%e5%bb%b6%e6%97%b6>#</a></h5><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/picture/202402261533052.png alt=image-20240226153330970></p><ul><li><h5 id=应用负载角度直接影响了产品终端的用户体验>应用负载角度：直接影响了产品终端的用户体验
<a class=anchor href=#%e5%ba%94%e7%94%a8%e8%b4%9f%e8%bd%bd%e8%a7%92%e5%ba%a6%e7%9b%b4%e6%8e%a5%e5%bd%b1%e5%93%8d%e4%ba%86%e4%ba%a7%e5%93%81%e7%bb%88%e7%ab%af%e7%9a%84%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c>#</a></h5></li><li><h5 id=系统资源角度资源使用率饱和度等>系统资源角度：资源使用率、饱和度等
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90%e8%a7%92%e5%ba%a6%e8%b5%84%e6%ba%90%e4%bd%bf%e7%94%a8%e7%8e%87%e9%a5%b1%e5%92%8c%e5%ba%a6%e7%ad%89>#</a></h5></li></ul><h5 id=性能问题的本质就是系统资源已经到达瓶颈但请求的处理还不够快无法支撑更多的请求性能分析实际上就是找出应用或系统的瓶颈设法去避免或缓解它们>性能问题的本质就是系统资源已经到达瓶颈，但请求的处理还不够快，无法支撑更多的请求。性能分析实际上就是找出应用或系统的瓶颈，设法去避免或缓解它们。
<a class=anchor href=#%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e7%9a%84%e6%9c%ac%e8%b4%a8%e5%b0%b1%e6%98%af%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90%e5%b7%b2%e7%bb%8f%e5%88%b0%e8%be%be%e7%93%b6%e9%a2%88%e4%bd%86%e8%af%b7%e6%b1%82%e7%9a%84%e5%a4%84%e7%90%86%e8%bf%98%e4%b8%8d%e5%a4%9f%e5%bf%ab%e6%97%a0%e6%b3%95%e6%94%af%e6%92%91%e6%9b%b4%e5%a4%9a%e7%9a%84%e8%af%b7%e6%b1%82%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%ae%9e%e9%99%85%e4%b8%8a%e5%b0%b1%e6%98%af%e6%89%be%e5%87%ba%e5%ba%94%e7%94%a8%e6%88%96%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%93%b6%e9%a2%88%e8%ae%be%e6%b3%95%e5%8e%bb%e9%81%bf%e5%85%8d%e6%88%96%e7%bc%93%e8%a7%a3%e5%ae%83%e4%bb%ac>#</a></h5><ul><li><h5 id=选择指标评估应用程序和系统性能>选择指标评估应用程序和系统性能
<a class=anchor href=#%e9%80%89%e6%8b%a9%e6%8c%87%e6%a0%87%e8%af%84%e4%bc%b0%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e5%92%8c%e7%b3%bb%e7%bb%9f%e6%80%a7%e8%83%bd>#</a></h5></li><li><h5 id=为应用程序和系统设置性能目标>为应用程序和系统设置性能目标
<a class=anchor href=#%e4%b8%ba%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e5%92%8c%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae%e6%80%a7%e8%83%bd%e7%9b%ae%e6%a0%87>#</a></h5></li><li><h5 id=进行性能基准测试>进行性能基准测试
<a class=anchor href=#%e8%bf%9b%e8%a1%8c%e6%80%a7%e8%83%bd%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95>#</a></h5></li><li><h5 id=性能分析定位瓶颈>性能分析定位瓶颈
<a class=anchor href=#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%ae%9a%e4%bd%8d%e7%93%b6%e9%a2%88>#</a></h5></li><li><h5 id=性能监控和告警>性能监控和告警
<a class=anchor href=#%e6%80%a7%e8%83%bd%e7%9b%91%e6%8e%a7%e5%92%8c%e5%91%8a%e8%ad%a6>#</a></h5></li></ul><h5 id=对于不同的性能问题要选取不同的性能分析工具下面是常用的linux-performance-tools以及对应分析的性能问题类型>对于不同的性能问题要选取不同的性能分析工具。下面是常用的Linux Performance Tools以及对应分析的性能问题类型。
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e4%b8%8d%e5%90%8c%e7%9a%84%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e8%a6%81%e9%80%89%e5%8f%96%e4%b8%8d%e5%90%8c%e7%9a%84%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7%e4%b8%8b%e9%9d%a2%e6%98%af%e5%b8%b8%e7%94%a8%e7%9a%84linux-performance-tools%e4%bb%a5%e5%8f%8a%e5%af%b9%e5%ba%94%e5%88%86%e6%9e%90%e7%9a%84%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e7%b1%bb%e5%9e%8b>#</a></h5><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/picture/202402261533139.png alt=image-20240226153358031></p><h4 id=到底应该怎么理解平均负载><strong>到底应该怎么理解”平均负载”</strong>
<a class=anchor href=#%e5%88%b0%e5%ba%95%e5%ba%94%e8%af%a5%e6%80%8e%e4%b9%88%e7%90%86%e8%a7%a3%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd>#</a></h4><h5 id=平均负载单位时间内系统处于可运行状态和不可中断状态的平均进程数也就是平均活跃进程数它和我们传统意义上理解的cpu使用率并没有直接关系>平均负载：单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和我们传统意义上理解的CPU使用率并没有直接关系。
<a class=anchor href=#%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%8d%95%e4%bd%8d%e6%97%b6%e9%97%b4%e5%86%85%e7%b3%bb%e7%bb%9f%e5%a4%84%e4%ba%8e%e5%8f%af%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81%e5%92%8c%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81%e7%9a%84%e5%b9%b3%e5%9d%87%e8%bf%9b%e7%a8%8b%e6%95%b0%e4%b9%9f%e5%b0%b1%e6%98%af%e5%b9%b3%e5%9d%87%e6%b4%bb%e8%b7%83%e8%bf%9b%e7%a8%8b%e6%95%b0%e5%ae%83%e5%92%8c%e6%88%91%e4%bb%ac%e4%bc%a0%e7%bb%9f%e6%84%8f%e4%b9%89%e4%b8%8a%e7%90%86%e8%a7%a3%e7%9a%84cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e5%b9%b6%e6%b2%a1%e6%9c%89%e7%9b%b4%e6%8e%a5%e5%85%b3%e7%b3%bb>#</a></h5><h5 id=其中不可中断进程是正处于内核态关键流程中的进程如常见的等待设备的io响应不可中断状态实际上是系统对进程和硬件设备的一种保护机制>其中不可中断进程是正处于内核态关键流程中的进程（如常见的等待设备的I/O响应）。不可中断状态实际上是系统对进程和硬件设备的一种保护机制。
<a class=anchor href=#%e5%85%b6%e4%b8%ad%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e8%bf%9b%e7%a8%8b%e6%98%af%e6%ad%a3%e5%a4%84%e4%ba%8e%e5%86%85%e6%a0%b8%e6%80%81%e5%85%b3%e9%94%ae%e6%b5%81%e7%a8%8b%e4%b8%ad%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%a6%82%e5%b8%b8%e8%a7%81%e7%9a%84%e7%ad%89%e5%be%85%e8%ae%be%e5%a4%87%e7%9a%84io%e5%93%8d%e5%ba%94%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81%e5%ae%9e%e9%99%85%e4%b8%8a%e6%98%af%e7%b3%bb%e7%bb%9f%e5%af%b9%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%a1%ac%e4%bb%b6%e8%ae%be%e5%a4%87%e7%9a%84%e4%b8%80%e7%a7%8d%e4%bf%9d%e6%8a%a4%e6%9c%ba%e5%88%b6>#</a></h5><h4 id=平均负载多少时合理><strong>平均负载多少时合理</strong>
<a class=anchor href=#%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%a4%9a%e5%b0%91%e6%97%b6%e5%90%88%e7%90%86>#</a></h4><h5 id=实际生产环境中将系统的平均负载监控起来根据历史数据判断负载的变化趋势当负载存在明显升高趋势时及时进行分析和调查当然也可以当设置阈值如当平均负载高于cpu数量的70时>实际生产环境中将系统的平均负载监控起来，根据历史数据判断负载的变化趋势。当负载存在明显升高趋势时，及时进行分析和调查。当然也可以当设置阈值（如当平均负载高于CPU数量的70%时）
<a class=anchor href=#%e5%ae%9e%e9%99%85%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83%e4%b8%ad%e5%b0%86%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e7%9b%91%e6%8e%a7%e8%b5%b7%e6%9d%a5%e6%a0%b9%e6%8d%ae%e5%8e%86%e5%8f%b2%e6%95%b0%e6%8d%ae%e5%88%a4%e6%96%ad%e8%b4%9f%e8%bd%bd%e7%9a%84%e5%8f%98%e5%8c%96%e8%b6%8b%e5%8a%bf%e5%bd%93%e8%b4%9f%e8%bd%bd%e5%ad%98%e5%9c%a8%e6%98%8e%e6%98%be%e5%8d%87%e9%ab%98%e8%b6%8b%e5%8a%bf%e6%97%b6%e5%8f%8a%e6%97%b6%e8%bf%9b%e8%a1%8c%e5%88%86%e6%9e%90%e5%92%8c%e8%b0%83%e6%9f%a5%e5%bd%93%e7%84%b6%e4%b9%9f%e5%8f%af%e4%bb%a5%e5%bd%93%e8%ae%be%e7%bd%ae%e9%98%88%e5%80%bc%e5%a6%82%e5%bd%93%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e9%ab%98%e4%ba%8ecpu%e6%95%b0%e9%87%8f%e7%9a%8470%e6%97%b6>#</a></h5><h5 id=现实工作中我们会经常混淆平均负载和cpu使用率的概念其实两者并不完全对等>现实工作中我们会经常混淆平均负载和CPU使用率的概念，其实两者并不完全对等：
<a class=anchor href=#%e7%8e%b0%e5%ae%9e%e5%b7%a5%e4%bd%9c%e4%b8%ad%e6%88%91%e4%bb%ac%e4%bc%9a%e7%bb%8f%e5%b8%b8%e6%b7%b7%e6%b7%86%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%92%8ccpu%e4%bd%bf%e7%94%a8%e7%8e%87%e7%9a%84%e6%a6%82%e5%bf%b5%e5%85%b6%e5%ae%9e%e4%b8%a4%e8%80%85%e5%b9%b6%e4%b8%8d%e5%ae%8c%e5%85%a8%e5%af%b9%e7%ad%89>#</a></h5><ul><li><h5 id=cpu-密集型进程大量-cpu-使用会导致平均负载升高此时两者一致>CPU 密集型进程，大量 CPU 使用会导致平均负载升高，此时两者一致
<a class=anchor href=#cpu-%e5%af%86%e9%9b%86%e5%9e%8b%e8%bf%9b%e7%a8%8b%e5%a4%a7%e9%87%8f-cpu-%e4%bd%bf%e7%94%a8%e4%bc%9a%e5%af%bc%e8%87%b4%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%8d%87%e9%ab%98%e6%ad%a4%e6%97%b6%e4%b8%a4%e8%80%85%e4%b8%80%e8%87%b4>#</a></h5></li><li><h5 id=io-密集型进程等待-io-也会导致平均负载升高此时-cpu-使用率并不一定高>I/O 密集型进程，等待 I/O 也会导致平均负载升高，此时 CPU 使用率并不一定高
<a class=anchor href=#io-%e5%af%86%e9%9b%86%e5%9e%8b%e8%bf%9b%e7%a8%8b%e7%ad%89%e5%be%85-io-%e4%b9%9f%e4%bc%9a%e5%af%bc%e8%87%b4%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%8d%87%e9%ab%98%e6%ad%a4%e6%97%b6-cpu-%e4%bd%bf%e7%94%a8%e7%8e%87%e5%b9%b6%e4%b8%8d%e4%b8%80%e5%ae%9a%e9%ab%98>#</a></h5></li><li><h5 id=大量等待-cpu-的进程调度会导致平均负载升高此时-cpu-使用率也会比较高>大量等待 CPU 的进程调度会导致平均负载升高，此时 CPU 使用率也会比较高
<a class=anchor href=#%e5%a4%a7%e9%87%8f%e7%ad%89%e5%be%85-cpu-%e7%9a%84%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e4%bc%9a%e5%af%bc%e8%87%b4%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%8d%87%e9%ab%98%e6%ad%a4%e6%97%b6-cpu-%e4%bd%bf%e7%94%a8%e7%8e%87%e4%b9%9f%e4%bc%9a%e6%af%94%e8%be%83%e9%ab%98>#</a></h5></li></ul><h5 id=平均负载高时可能是-cpu-密集型进程导致也可能是-io-繁忙导致具体分析时可以结合-mpstatpidstat-工具辅助分析负载来源>平均负载高时可能是 CPU 密集型进程导致，也可能是 I/O 繁忙导致。具体分析时可以结合 mpstat/pidstat 工具辅助分析负载来源。
<a class=anchor href=#%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e9%ab%98%e6%97%b6%e5%8f%af%e8%83%bd%e6%98%af-cpu-%e5%af%86%e9%9b%86%e5%9e%8b%e8%bf%9b%e7%a8%8b%e5%af%bc%e8%87%b4%e4%b9%9f%e5%8f%af%e8%83%bd%e6%98%af-io-%e7%b9%81%e5%bf%99%e5%af%bc%e8%87%b4%e5%85%b7%e4%bd%93%e5%88%86%e6%9e%90%e6%97%b6%e5%8f%af%e4%bb%a5%e7%bb%93%e5%90%88-mpstatpidstat-%e5%b7%a5%e5%85%b7%e8%be%85%e5%8a%a9%e5%88%86%e6%9e%90%e8%b4%9f%e8%bd%bd%e6%9d%a5%e6%ba%90>#</a></h5><h3 id=cpu><strong>CPU</strong>
<a class=anchor href=#cpu>#</a></h3><h4 id=cpu上下文切换上><strong>CPU上下文切换(上)</strong>
<a class=anchor href=#cpu%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e4%b8%8a>#</a></h4><h5 id=cpu-上下文切换就是把前一个任务的-cpu-上下文cpu-寄存器和-pc保存起来然后加载新任务的上下文到这些寄存器和程序计数器最后再跳转到程序计数器所指的位置运行新任务其中保存下来的上下文会存储在系统内核中待任务重新调度执行时再加载保证原来的任务状态不受影响>CPU 上下文切换，就是把前一个任务的 CPU 上下文（CPU 寄存器和 PC）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的位置，运行新任务。其中，保存下来的上下文会存储在系统内核中，待任务重新调度执行时再加载，保证原来的任务状态不受影响。
<a class=anchor href=#cpu-%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%b0%b1%e6%98%af%e6%8a%8a%e5%89%8d%e4%b8%80%e4%b8%aa%e4%bb%bb%e5%8a%a1%e7%9a%84-cpu-%e4%b8%8a%e4%b8%8b%e6%96%87cpu-%e5%af%84%e5%ad%98%e5%99%a8%e5%92%8c-pc%e4%bf%9d%e5%ad%98%e8%b5%b7%e6%9d%a5%e7%84%b6%e5%90%8e%e5%8a%a0%e8%bd%bd%e6%96%b0%e4%bb%bb%e5%8a%a1%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%b0%e8%bf%99%e4%ba%9b%e5%af%84%e5%ad%98%e5%99%a8%e5%92%8c%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8%e6%9c%80%e5%90%8e%e5%86%8d%e8%b7%b3%e8%bd%ac%e5%88%b0%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8%e6%89%80%e6%8c%87%e7%9a%84%e4%bd%8d%e7%bd%ae%e8%bf%90%e8%a1%8c%e6%96%b0%e4%bb%bb%e5%8a%a1%e5%85%b6%e4%b8%ad%e4%bf%9d%e5%ad%98%e4%b8%8b%e6%9d%a5%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e4%bc%9a%e5%ad%98%e5%82%a8%e5%9c%a8%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e4%b8%ad%e5%be%85%e4%bb%bb%e5%8a%a1%e9%87%8d%e6%96%b0%e8%b0%83%e5%ba%a6%e6%89%a7%e8%a1%8c%e6%97%b6%e5%86%8d%e5%8a%a0%e8%bd%bd%e4%bf%9d%e8%af%81%e5%8e%9f%e6%9d%a5%e7%9a%84%e4%bb%bb%e5%8a%a1%e7%8a%b6%e6%80%81%e4%b8%8d%e5%8f%97%e5%bd%b1%e5%93%8d>#</a></h5><h5 id=按照任务类型cpu-上下文切换分为>按照任务类型，CPU 上下文切换分为：
<a class=anchor href=#%e6%8c%89%e7%85%a7%e4%bb%bb%e5%8a%a1%e7%b1%bb%e5%9e%8bcpu-%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%88%86%e4%b8%ba>#</a></h5><ul><li><h5 id=进程上下文切换>进程上下文切换
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>#</a></h5></li><li><h5 id=线程上下文切换>线程上下文切换
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>#</a></h5></li><li><h5 id=中断上下文切换>中断上下文切换
<a class=anchor href=#%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>#</a></h5></li></ul><h5 id=进程上下文切换-1><strong>进程上下文切换</strong>
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2-1>#</a></h5><h5 id=linux-进程按照等级权限将进程的运行空间分为内核空间和用户空间从用户态向内核态转变时需要通过系统调用来完成>Linux 进程按照等级权限将进程的运行空间分为内核空间和用户空间。从用户态向内核态转变时需要通过系统调用来完成。
<a class=anchor href=#linux-%e8%bf%9b%e7%a8%8b%e6%8c%89%e7%85%a7%e7%ad%89%e7%ba%a7%e6%9d%83%e9%99%90%e5%b0%86%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%bf%90%e8%a1%8c%e7%a9%ba%e9%97%b4%e5%88%86%e4%b8%ba%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%92%8c%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e4%bb%8e%e7%94%a8%e6%88%b7%e6%80%81%e5%90%91%e5%86%85%e6%a0%b8%e6%80%81%e8%bd%ac%e5%8f%98%e6%97%b6%e9%9c%80%e8%a6%81%e9%80%9a%e8%bf%87%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%9d%a5%e5%ae%8c%e6%88%90>#</a></h5><h5 id=一次系统调用过程其实进行了两次-cpu-上下文切换>一次系统调用过程其实进行了两次 CPU 上下文切换：
<a class=anchor href=#%e4%b8%80%e6%ac%a1%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e8%bf%87%e7%a8%8b%e5%85%b6%e5%ae%9e%e8%bf%9b%e8%a1%8c%e4%ba%86%e4%b8%a4%e6%ac%a1-cpu-%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>#</a></h5><ul><li><h5 id=cpu-寄存器中用户态的指令位置先保存起来cpu-寄存器更新为内核态指令的位置跳转到内核态运行内核任务>CPU 寄存器中用户态的指令位置先保存起来，CPU 寄存器更新为内核态指令的位置，跳转到内核态运行内核任务；
<a class=anchor href=#cpu-%e5%af%84%e5%ad%98%e5%99%a8%e4%b8%ad%e7%94%a8%e6%88%b7%e6%80%81%e7%9a%84%e6%8c%87%e4%bb%a4%e4%bd%8d%e7%bd%ae%e5%85%88%e4%bf%9d%e5%ad%98%e8%b5%b7%e6%9d%a5cpu-%e5%af%84%e5%ad%98%e5%99%a8%e6%9b%b4%e6%96%b0%e4%b8%ba%e5%86%85%e6%a0%b8%e6%80%81%e6%8c%87%e4%bb%a4%e7%9a%84%e4%bd%8d%e7%bd%ae%e8%b7%b3%e8%bd%ac%e5%88%b0%e5%86%85%e6%a0%b8%e6%80%81%e8%bf%90%e8%a1%8c%e5%86%85%e6%a0%b8%e4%bb%bb%e5%8a%a1>#</a></h5></li><li><h5 id=系统调用结束后cpu-寄存器恢复原来保存的用户态数据再切换到用户空间继续运行>系统调用结束后，CPU 寄存器恢复原来保存的用户态数据，再切换到用户空间继续运行。
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%bb%93%e6%9d%9f%e5%90%8ecpu-%e5%af%84%e5%ad%98%e5%99%a8%e6%81%a2%e5%a4%8d%e5%8e%9f%e6%9d%a5%e4%bf%9d%e5%ad%98%e7%9a%84%e7%94%a8%e6%88%b7%e6%80%81%e6%95%b0%e6%8d%ae%e5%86%8d%e5%88%87%e6%8d%a2%e5%88%b0%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e7%bb%a7%e7%bb%ad%e8%bf%90%e8%a1%8c>#</a></h5></li></ul><h5 id=系统调用过程中并不会涉及虚拟内存等进程用户态资源也不会切换进程和传统意义上的进程上下文切换不同因此系统调用通常称为特权模式切换>系统调用过程中并不会涉及虚拟内存等进程用户态资源，也不会切换进程。和传统意义上的进程上下文切换不同。因此系统调用通常称为特权模式切换。
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%b9%b6%e4%b8%8d%e4%bc%9a%e6%b6%89%e5%8f%8a%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%ad%89%e8%bf%9b%e7%a8%8b%e7%94%a8%e6%88%b7%e6%80%81%e8%b5%84%e6%ba%90%e4%b9%9f%e4%b8%8d%e4%bc%9a%e5%88%87%e6%8d%a2%e8%bf%9b%e7%a8%8b%e5%92%8c%e4%bc%a0%e7%bb%9f%e6%84%8f%e4%b9%89%e4%b8%8a%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e4%b8%8d%e5%90%8c%e5%9b%a0%e6%ad%a4%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e9%80%9a%e5%b8%b8%e7%a7%b0%e4%b8%ba%e7%89%b9%e6%9d%83%e6%a8%a1%e5%bc%8f%e5%88%87%e6%8d%a2>#</a></h5><h5 id=进程是由内核管理和调度的进程上下文切换只能发生在内核态因此相比系统调用来说在保存当前进程的内核状态和cpu寄存器之前需要先把该进程的虚拟内存栈保存下来再加载新进程的内核态后还要刷新进程的虚拟内存和用户栈>进程是由内核管理和调度的，进程上下文切换只能发生在内核态。因此相比系统调用来说，在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存，栈保存下来。再加载新进程的内核态后，还要刷新进程的虚拟内存和用户栈。
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e6%98%af%e7%94%b1%e5%86%85%e6%a0%b8%e7%ae%a1%e7%90%86%e5%92%8c%e8%b0%83%e5%ba%a6%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%8f%aa%e8%83%bd%e5%8f%91%e7%94%9f%e5%9c%a8%e5%86%85%e6%a0%b8%e6%80%81%e5%9b%a0%e6%ad%a4%e7%9b%b8%e6%af%94%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%9d%a5%e8%af%b4%e5%9c%a8%e4%bf%9d%e5%ad%98%e5%bd%93%e5%89%8d%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%86%85%e6%a0%b8%e7%8a%b6%e6%80%81%e5%92%8ccpu%e5%af%84%e5%ad%98%e5%99%a8%e4%b9%8b%e5%89%8d%e9%9c%80%e8%a6%81%e5%85%88%e6%8a%8a%e8%af%a5%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e6%a0%88%e4%bf%9d%e5%ad%98%e4%b8%8b%e6%9d%a5%e5%86%8d%e5%8a%a0%e8%bd%bd%e6%96%b0%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%86%85%e6%a0%b8%e6%80%81%e5%90%8e%e8%bf%98%e8%a6%81%e5%88%b7%e6%96%b0%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%92%8c%e7%94%a8%e6%88%b7%e6%a0%88>#</a></h5><h5 id=进程只有在调度到cpu上运行时才需要切换上下文有以下几种场景cpu时间片轮流分配系统资源不足导致进程挂起进程通过sleep函数主动挂起高优先级进程抢占时间片硬件中断时cpu上的进程被挂起转而执行内核中的中断服务>进程只有在调度到CPU上运行时才需要切换上下文，有以下几种场景：CPU时间片轮流分配，系统资源不足导致进程挂起，进程通过sleep函数主动挂起，高优先级进程抢占时间片，硬件中断时CPU上的进程被挂起转而执行内核中的中断服务。
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e5%8f%aa%e6%9c%89%e5%9c%a8%e8%b0%83%e5%ba%a6%e5%88%b0cpu%e4%b8%8a%e8%bf%90%e8%a1%8c%e6%97%b6%e6%89%8d%e9%9c%80%e8%a6%81%e5%88%87%e6%8d%a2%e4%b8%8a%e4%b8%8b%e6%96%87%e6%9c%89%e4%bb%a5%e4%b8%8b%e5%87%a0%e7%a7%8d%e5%9c%ba%e6%99%afcpu%e6%97%b6%e9%97%b4%e7%89%87%e8%bd%ae%e6%b5%81%e5%88%86%e9%85%8d%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90%e4%b8%8d%e8%b6%b3%e5%af%bc%e8%87%b4%e8%bf%9b%e7%a8%8b%e6%8c%82%e8%b5%b7%e8%bf%9b%e7%a8%8b%e9%80%9a%e8%bf%87sleep%e5%87%bd%e6%95%b0%e4%b8%bb%e5%8a%a8%e6%8c%82%e8%b5%b7%e9%ab%98%e4%bc%98%e5%85%88%e7%ba%a7%e8%bf%9b%e7%a8%8b%e6%8a%a2%e5%8d%a0%e6%97%b6%e9%97%b4%e7%89%87%e7%a1%ac%e4%bb%b6%e4%b8%ad%e6%96%ad%e6%97%b6cpu%e4%b8%8a%e7%9a%84%e8%bf%9b%e7%a8%8b%e8%a2%ab%e6%8c%82%e8%b5%b7%e8%bd%ac%e8%80%8c%e6%89%a7%e8%a1%8c%e5%86%85%e6%a0%b8%e4%b8%ad%e7%9a%84%e4%b8%ad%e6%96%ad%e6%9c%8d%e5%8a%a1>#</a></h5><h5 id=线程上下文切换-1><strong>线程上下文切换</strong>
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2-1>#</a></h5><h5 id=线程上下文切换分为两种>线程上下文切换分为两种：
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%88%86%e4%b8%ba%e4%b8%a4%e7%a7%8d>#</a></h5><ul><li><h5 id=前后线程同属于一个进程切换时虚拟内存资源不变只需要切换线程的私有数据寄存器等>前后线程同属于一个进程，切换时虚拟内存资源不变，只需要切换线程的私有数据，寄存器等；
<a class=anchor href=#%e5%89%8d%e5%90%8e%e7%ba%bf%e7%a8%8b%e5%90%8c%e5%b1%9e%e4%ba%8e%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b%e5%88%87%e6%8d%a2%e6%97%b6%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e8%b5%84%e6%ba%90%e4%b8%8d%e5%8f%98%e5%8f%aa%e9%9c%80%e8%a6%81%e5%88%87%e6%8d%a2%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%a7%81%e6%9c%89%e6%95%b0%e6%8d%ae%e5%af%84%e5%ad%98%e5%99%a8%e7%ad%89>#</a></h5></li><li><h5 id=前后线程属于不同进程与进程上下文切换相同>前后线程属于不同进程，与进程上下文切换相同。
<a class=anchor href=#%e5%89%8d%e5%90%8e%e7%ba%bf%e7%a8%8b%e5%b1%9e%e4%ba%8e%e4%b8%8d%e5%90%8c%e8%bf%9b%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e7%9b%b8%e5%90%8c>#</a></h5></li></ul><h5 id=同进程的线程切换消耗资源较少这也是多线程的优势>同进程的线程切换消耗资源较少，这也是多线程的优势。
<a class=anchor href=#%e5%90%8c%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%88%87%e6%8d%a2%e6%b6%88%e8%80%97%e8%b5%84%e6%ba%90%e8%be%83%e5%b0%91%e8%bf%99%e4%b9%9f%e6%98%af%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%bc%98%e5%8a%bf>#</a></h5><h5 id=中断上下文切换-1><strong>中断上下文切换</strong>
<a class=anchor href=#%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2-1>#</a></h5><h5 id=中断上下文切换并不涉及到进程的用户态因此中断上下文只包括内核态中断服务程序执行所必须的状态cpu寄存器内核堆栈硬件中断参数等>中断上下文切换并不涉及到进程的用户态，因此中断上下文只包括内核态中断服务程序执行所必须的状态（CPU寄存器，内核堆栈，硬件中断参数等）。
<a class=anchor href=#%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%b9%b6%e4%b8%8d%e6%b6%89%e5%8f%8a%e5%88%b0%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%94%a8%e6%88%b7%e6%80%81%e5%9b%a0%e6%ad%a4%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87%e5%8f%aa%e5%8c%85%e6%8b%ac%e5%86%85%e6%a0%b8%e6%80%81%e4%b8%ad%e6%96%ad%e6%9c%8d%e5%8a%a1%e7%a8%8b%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%89%80%e5%bf%85%e9%a1%bb%e7%9a%84%e7%8a%b6%e6%80%81cpu%e5%af%84%e5%ad%98%e5%99%a8%e5%86%85%e6%a0%b8%e5%a0%86%e6%a0%88%e7%a1%ac%e4%bb%b6%e4%b8%ad%e6%96%ad%e5%8f%82%e6%95%b0%e7%ad%89>#</a></h5><h5 id=中断处理优先级比进程高所以中断上下文切换和进程上下文切换不会同时发生>中断处理优先级比进程高，所以中断上下文切换和进程上下文切换不会同时发生
<a class=anchor href=#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e4%bc%98%e5%85%88%e7%ba%a7%e6%af%94%e8%bf%9b%e7%a8%8b%e9%ab%98%e6%89%80%e4%bb%a5%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%92%8c%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e4%b8%8d%e4%bc%9a%e5%90%8c%e6%97%b6%e5%8f%91%e7%94%9f>#</a></h5><h4 id=cpu上下文切换下><strong>CPU上下文切换(下)</strong>
<a class=anchor href=#cpu%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e4%b8%8b>#</a></h4><p>通过 vmstat 可以查看系统总体的上下文切换情况</p><pre tabindex=0><code>vmstat 5         #每隔5s输出一组数据procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 1  0      0 103388 145412 511056    0    0    18    60    1    1  2  1 96  0  0 0  0      0 103388 145412 511076    0    0     0     2  450 1176  1  1 99  0  0 0  0      0 103388 145412 511076    0    0     0     8  429 1135  1  1 98  0  0 0  0      0 103388 145412 511076    0    0     0     0  431 1132  1  1 98  0  0 0  0      0 103388 145412 511076    0    0     0    10  467 1195  1  1 98  0  0 1  0      0 103388 145412 511076    0    0     0     2  426 1139  1  0 99  0  0 4  0      0  95184 145412 511108    0    0     0    74  500 1228  4  1 94  0  0 0  0      0 103512 145416 511076    0    0     0   455  723 1573 12  3 83  2  0
</code></pre><ul><li><h5 id=cs-context-switch-每秒上下文切换次数>cs （context switch） 每秒上下文切换次数
<a class=anchor href=#cs-context-switch-%e6%af%8f%e7%a7%92%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%ac%a1%e6%95%b0>#</a></h5></li><li><h5 id=in-interrupt-每秒中断次数>in （interrupt） 每秒中断次数
<a class=anchor href=#in-interrupt-%e6%af%8f%e7%a7%92%e4%b8%ad%e6%96%ad%e6%ac%a1%e6%95%b0>#</a></h5></li><li><h5 id=r-runnning-or-runnable就绪队列的长度正在运行和等待cpu的进程数>r （runnning or runnable）就绪队列的长度，正在运行和等待CPU的进程数
<a class=anchor href=#r-runnning-or-runnable%e5%b0%b1%e7%bb%aa%e9%98%9f%e5%88%97%e7%9a%84%e9%95%bf%e5%ba%a6%e6%ad%a3%e5%9c%a8%e8%bf%90%e8%a1%8c%e5%92%8c%e7%ad%89%e5%be%85cpu%e7%9a%84%e8%bf%9b%e7%a8%8b%e6%95%b0>#</a></h5></li><li><h5 id=b-blocked-处于不可中断睡眠状态的进程数>b （Blocked） 处于不可中断睡眠状态的进程数
<a class=anchor href=#b-blocked-%e5%a4%84%e4%ba%8e%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e7%9d%a1%e7%9c%a0%e7%8a%b6%e6%80%81%e7%9a%84%e8%bf%9b%e7%a8%8b%e6%95%b0>#</a></h5></li></ul><h5 id=要查看每个进程的详细情况需要使用pidstat来查看每个进程上下文切换情况>要查看每个进程的详细情况，需要使用pidstat来查看每个进程上下文切换情况
<a class=anchor href=#%e8%a6%81%e6%9f%a5%e7%9c%8b%e6%af%8f%e4%b8%aa%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%af%a6%e7%bb%86%e6%83%85%e5%86%b5%e9%9c%80%e8%a6%81%e4%bd%bf%e7%94%a8pidstat%e6%9d%a5%e6%9f%a5%e7%9c%8b%e6%af%8f%e4%b8%aa%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%83%85%e5%86%b5>#</a></h5><pre tabindex=0><code>pidstat -w 514时51分16秒   UID       PID   cswch/s nvcswch/s  Command14时51分21秒     0         1      0.80      0.00  systemd14时51分21秒     0         6      1.40      0.00  ksoftirqd/014时51分21秒     0         9     32.67      0.00  rcu_sched14时51分21秒     0        11      0.40      0.00  watchdog/014时51分21秒     0        32      0.20      0.00  khugepaged14时51分21秒     0       271      0.20      0.00  jbd2/vda1-814时51分21秒     0      1332      0.20      0.00  argusagent14时51分21秒     0      5265     10.02      0.00  AliSecGuard14时51分21秒     0      7439      7.82      0.00  kworker/0:214时51分21秒     0      7906      0.20      0.00  pidstat14时51分21秒     0      8346      0.20      0.00  sshd14时51分21秒     0     20654      9.82      0.00  AliYunDun14时51分21秒     0     25766      0.20      0.00  kworker/u2:114时51分21秒     0     28603      1.00      0.00  python3
</code></pre><ul><li><h5 id=cswch-每秒自愿上下文切换次数进程无法获取所需资源导致的上下文切换>cswch 每秒自愿上下文切换次数（进程无法获取所需资源导致的上下文切换）
<a class=anchor href=#cswch-%e6%af%8f%e7%a7%92%e8%87%aa%e6%84%bf%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%ac%a1%e6%95%b0%e8%bf%9b%e7%a8%8b%e6%97%a0%e6%b3%95%e8%8e%b7%e5%8f%96%e6%89%80%e9%9c%80%e8%b5%84%e6%ba%90%e5%af%bc%e8%87%b4%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>#</a></h5></li><li><h5 id=nvcswch-每秒非自愿上下文切换次数时间片轮流等系统强制调度>nvcswch 每秒非自愿上下文切换次数（时间片轮流等系统强制调度）
<a class=anchor href=#nvcswch-%e6%af%8f%e7%a7%92%e9%9d%9e%e8%87%aa%e6%84%bf%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%ac%a1%e6%95%b0%e6%97%b6%e9%97%b4%e7%89%87%e8%bd%ae%e6%b5%81%e7%ad%89%e7%b3%bb%e7%bb%9f%e5%bc%ba%e5%88%b6%e8%b0%83%e5%ba%a6>#</a></h5></li></ul><pre tabindex=0><code>vmstat 1 1    #新终端观察上下文切换情况此时发现cs数据明显升高，同时观察其他指标：r列：远超系统CPU个数，说明存在大量CPU竞争us和sy列：sy列占比80%，说明CPU主要被内核占用in列：中断次数明显上升，说明中断处理也是潜在问题
</code></pre><h5 id=说明运行等待cpu的进程过多导致大量的上下文切换上下文切换导致系统的cpu占用率高>说明运行/等待CPU的进程过多，导致大量的上下文切换，上下文切换导致系统的CPU占用率高
<a class=anchor href=#%e8%af%b4%e6%98%8e%e8%bf%90%e8%a1%8c%e7%ad%89%e5%be%85cpu%e7%9a%84%e8%bf%9b%e7%a8%8b%e8%bf%87%e5%a4%9a%e5%af%bc%e8%87%b4%e5%a4%a7%e9%87%8f%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%af%bc%e8%87%b4%e7%b3%bb%e7%bb%9f%e7%9a%84cpu%e5%8d%a0%e7%94%a8%e7%8e%87%e9%ab%98>#</a></h5><ul><li></li></ul><pre tabindex=0><code>pidstat -w -u 1  #查看到底哪个进程导致的问题
</code></pre><h5 id=从结果中看出是-sysbench-导致-cpu-使用率过高但是-pidstat-输出的上下文次数加起来也并不多分析-sysbench-模拟的是线程的切换因此需要在-pidstat-后加--t-参数查看线程指标>从结果中看出是 sysbench 导致 CPU 使用率过高，但是 pidstat 输出的上下文次数加起来也并不多。分析 sysbench 模拟的是线程的切换，因此需要在 pidstat 后加 -t 参数查看线程指标。
<a class=anchor href=#%e4%bb%8e%e7%bb%93%e6%9e%9c%e4%b8%ad%e7%9c%8b%e5%87%ba%e6%98%af-sysbench-%e5%af%bc%e8%87%b4-cpu-%e4%bd%bf%e7%94%a8%e7%8e%87%e8%bf%87%e9%ab%98%e4%bd%86%e6%98%af-pidstat-%e8%be%93%e5%87%ba%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e6%ac%a1%e6%95%b0%e5%8a%a0%e8%b5%b7%e6%9d%a5%e4%b9%9f%e5%b9%b6%e4%b8%8d%e5%a4%9a%e5%88%86%e6%9e%90-sysbench-%e6%a8%a1%e6%8b%9f%e7%9a%84%e6%98%af%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%88%87%e6%8d%a2%e5%9b%a0%e6%ad%a4%e9%9c%80%e8%a6%81%e5%9c%a8-pidstat-%e5%90%8e%e5%8a%a0--t-%e5%8f%82%e6%95%b0%e6%9f%a5%e7%9c%8b%e7%ba%bf%e7%a8%8b%e6%8c%87%e6%a0%87>#</a></h5><h5 id=另外对于中断次数过多我们可以通过-procinterrupts-文件读取>另外对于中断次数过多，我们可以通过 /proc/interrupts 文件读取
<a class=anchor href=#%e5%8f%a6%e5%a4%96%e5%af%b9%e4%ba%8e%e4%b8%ad%e6%96%ad%e6%ac%a1%e6%95%b0%e8%bf%87%e5%a4%9a%e6%88%91%e4%bb%ac%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87-procinterrupts-%e6%96%87%e4%bb%b6%e8%af%bb%e5%8f%96>#</a></h5><ul><li></li></ul><pre tabindex=0><code>watch -d cat /proc/interrupts
</code></pre><h5 id=发现次数变化速度最快的是重调度中断res该中断用来唤醒空闲状态的cpu来调度新的任务运行分析还是因为过多任务的调度问题和上下文切换分析一致>发现次数变化速度最快的是重调度中断（RES），该中断用来唤醒空闲状态的CPU来调度新的任务运行。分析还是因为过多任务的调度问题，和上下文切换分析一致。
<a class=anchor href=#%e5%8f%91%e7%8e%b0%e6%ac%a1%e6%95%b0%e5%8f%98%e5%8c%96%e9%80%9f%e5%ba%a6%e6%9c%80%e5%bf%ab%e7%9a%84%e6%98%af%e9%87%8d%e8%b0%83%e5%ba%a6%e4%b8%ad%e6%96%adres%e8%af%a5%e4%b8%ad%e6%96%ad%e7%94%a8%e6%9d%a5%e5%94%a4%e9%86%92%e7%a9%ba%e9%97%b2%e7%8a%b6%e6%80%81%e7%9a%84cpu%e6%9d%a5%e8%b0%83%e5%ba%a6%e6%96%b0%e7%9a%84%e4%bb%bb%e5%8a%a1%e8%bf%90%e8%a1%8c%e5%88%86%e6%9e%90%e8%bf%98%e6%98%af%e5%9b%a0%e4%b8%ba%e8%bf%87%e5%a4%9a%e4%bb%bb%e5%8a%a1%e7%9a%84%e8%b0%83%e5%ba%a6%e9%97%ae%e9%a2%98%e5%92%8c%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%88%86%e6%9e%90%e4%b8%80%e8%87%b4>#</a></h5><p><strong>某个应用的CPU使用率达到100%，怎么办？</strong></p><h5 id=linux作为多任务操作系统将cpu时间划分为很短的时间片通过调度器轮流分配给各个任务使用为了维护cpu时间linux通过事先定义的节拍率触发时间中断并使用全局变了jiffies记录开机以来的节拍数时间中断发生一次该值1>Linux作为多任务操作系统，将CPU时间划分为很短的时间片，通过调度器轮流分配给各个任务使用。为了维护CPU时间，Linux通过事先定义的节拍率，触发时间中断，并使用全局变了jiffies记录开机以来的节拍数。时间中断发生一次该值+1.
<a class=anchor href=#linux%e4%bd%9c%e4%b8%ba%e5%a4%9a%e4%bb%bb%e5%8a%a1%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%b0%86cpu%e6%97%b6%e9%97%b4%e5%88%92%e5%88%86%e4%b8%ba%e5%be%88%e7%9f%ad%e7%9a%84%e6%97%b6%e9%97%b4%e7%89%87%e9%80%9a%e8%bf%87%e8%b0%83%e5%ba%a6%e5%99%a8%e8%bd%ae%e6%b5%81%e5%88%86%e9%85%8d%e7%bb%99%e5%90%84%e4%b8%aa%e4%bb%bb%e5%8a%a1%e4%bd%bf%e7%94%a8%e4%b8%ba%e4%ba%86%e7%bb%b4%e6%8a%a4cpu%e6%97%b6%e9%97%b4linux%e9%80%9a%e8%bf%87%e4%ba%8b%e5%85%88%e5%ae%9a%e4%b9%89%e7%9a%84%e8%8a%82%e6%8b%8d%e7%8e%87%e8%a7%a6%e5%8f%91%e6%97%b6%e9%97%b4%e4%b8%ad%e6%96%ad%e5%b9%b6%e4%bd%bf%e7%94%a8%e5%85%a8%e5%b1%80%e5%8f%98%e4%ba%86jiffies%e8%ae%b0%e5%bd%95%e5%bc%80%e6%9c%ba%e4%bb%a5%e6%9d%a5%e7%9a%84%e8%8a%82%e6%8b%8d%e6%95%b0%e6%97%b6%e9%97%b4%e4%b8%ad%e6%96%ad%e5%8f%91%e7%94%9f%e4%b8%80%e6%ac%a1%e8%af%a5%e5%80%bc1>#</a></h5><h5 id=cpu使用率除了空闲时间以外的其他时间占总cpu时间的百分比可以通过procstat中的数据来计算出cpu使用率因为procstat时开机以来的节拍数累加值计算出来的是开机以来的平均cpu使用率一般意义不大可以间隔取一段时间的两次值作差来计算该段时间内的平均cpu使用率性能分析工具给出的都是间隔一段时间的平均cpu使用率要注意间隔时间的设置>CPU使用率，除了空闲时间以外的其他时间占总CPU时间的百分比。可以通过/proc/stat中的数据来计算出CPU使用率。因为/proc/stat时开机以来的节拍数累加值，计算出来的是开机以来的平均CPU使用率，一般意义不大。可以间隔取一段时间的两次值作差来计算该段时间内的平均CPU使用率。性能分析工具给出的都是间隔一段时间的平均CPU使用率，要注意间隔时间的设置。
<a class=anchor href=#cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e9%99%a4%e4%ba%86%e7%a9%ba%e9%97%b2%e6%97%b6%e9%97%b4%e4%bb%a5%e5%a4%96%e7%9a%84%e5%85%b6%e4%bb%96%e6%97%b6%e9%97%b4%e5%8d%a0%e6%80%bbcpu%e6%97%b6%e9%97%b4%e7%9a%84%e7%99%be%e5%88%86%e6%af%94%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87procstat%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e6%9d%a5%e8%ae%a1%e7%ae%97%e5%87%bacpu%e4%bd%bf%e7%94%a8%e7%8e%87%e5%9b%a0%e4%b8%baprocstat%e6%97%b6%e5%bc%80%e6%9c%ba%e4%bb%a5%e6%9d%a5%e7%9a%84%e8%8a%82%e6%8b%8d%e6%95%b0%e7%b4%af%e5%8a%a0%e5%80%bc%e8%ae%a1%e7%ae%97%e5%87%ba%e6%9d%a5%e7%9a%84%e6%98%af%e5%bc%80%e6%9c%ba%e4%bb%a5%e6%9d%a5%e7%9a%84%e5%b9%b3%e5%9d%87cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e4%b8%80%e8%88%ac%e6%84%8f%e4%b9%89%e4%b8%8d%e5%a4%a7%e5%8f%af%e4%bb%a5%e9%97%b4%e9%9a%94%e5%8f%96%e4%b8%80%e6%ae%b5%e6%97%b6%e9%97%b4%e7%9a%84%e4%b8%a4%e6%ac%a1%e5%80%bc%e4%bd%9c%e5%b7%ae%e6%9d%a5%e8%ae%a1%e7%ae%97%e8%af%a5%e6%ae%b5%e6%97%b6%e9%97%b4%e5%86%85%e7%9a%84%e5%b9%b3%e5%9d%87cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7%e7%bb%99%e5%87%ba%e7%9a%84%e9%83%bd%e6%98%af%e9%97%b4%e9%9a%94%e4%b8%80%e6%ae%b5%e6%97%b6%e9%97%b4%e7%9a%84%e5%b9%b3%e5%9d%87cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e8%a6%81%e6%b3%a8%e6%84%8f%e9%97%b4%e9%9a%94%e6%97%b6%e9%97%b4%e7%9a%84%e8%ae%be%e7%bd%ae>#</a></h5><h5 id=cpu使用率可以通过top-或-ps来查看分析进程的cpu问题可以通过perf它以性能事件采样为基础不仅可以分析系统的各种事件和内核性能还可以用来分析指定应用程序的性能问题>CPU使用率可以通过top 或 ps来查看。分析进程的CPU问题可以通过perf，它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。
<a class=anchor href=#cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87top-%e6%88%96-ps%e6%9d%a5%e6%9f%a5%e7%9c%8b%e5%88%86%e6%9e%90%e8%bf%9b%e7%a8%8b%e7%9a%84cpu%e9%97%ae%e9%a2%98%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87perf%e5%ae%83%e4%bb%a5%e6%80%a7%e8%83%bd%e4%ba%8b%e4%bb%b6%e9%87%87%e6%a0%b7%e4%b8%ba%e5%9f%ba%e7%a1%80%e4%b8%8d%e4%bb%85%e5%8f%af%e4%bb%a5%e5%88%86%e6%9e%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%90%84%e7%a7%8d%e4%ba%8b%e4%bb%b6%e5%92%8c%e5%86%85%e6%a0%b8%e6%80%a7%e8%83%bd%e8%bf%98%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e5%88%86%e6%9e%90%e6%8c%87%e5%ae%9a%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98>#</a></h5><h5 id=perf-top--perf-record--perf-report--g-开启调用关系的采样>perf top / perf record / perf report （-g 开启调用关系的采样）
<a class=anchor href=#perf-top--perf-record--perf-report--g-%e5%bc%80%e5%90%af%e8%b0%83%e7%94%a8%e5%85%b3%e7%b3%bb%e7%9a%84%e9%87%87%e6%a0%b7>#</a></h5><pre tabindex=0><code>sudo docker run --name nginx -p 10000:80 -itd feisky/nginxsudo docker run --name phpfpm -itd --network container:nginx feisky/php-fpm
ab -c 10 -n 100 http://XXX.XXX.XXX.XXX:10000/ #测试Nginx服务性能
</code></pre><h5 id=发现此时每秒可承受请求给长少此时将测试的请求数从100增加到10000在另外一个终端运行top查看每个cpu的使用率发现系统中几个php-fpm进程导致cpu使用率骤升>发现此时每秒可承受请求给长少，此时将测试的请求数从100增加到10000。在另外一个终端运行top查看每个CPU的使用率。发现系统中几个php-fpm进程导致CPU使用率骤升。
<a class=anchor href=#%e5%8f%91%e7%8e%b0%e6%ad%a4%e6%97%b6%e6%af%8f%e7%a7%92%e5%8f%af%e6%89%bf%e5%8f%97%e8%af%b7%e6%b1%82%e7%bb%99%e9%95%bf%e5%b0%91%e6%ad%a4%e6%97%b6%e5%b0%86%e6%b5%8b%e8%af%95%e7%9a%84%e8%af%b7%e6%b1%82%e6%95%b0%e4%bb%8e100%e5%a2%9e%e5%8a%a0%e5%88%b010000%e5%9c%a8%e5%8f%a6%e5%a4%96%e4%b8%80%e4%b8%aa%e7%bb%88%e7%ab%af%e8%bf%90%e8%a1%8ctop%e6%9f%a5%e7%9c%8b%e6%af%8f%e4%b8%aacpu%e7%9a%84%e4%bd%bf%e7%94%a8%e7%8e%87%e5%8f%91%e7%8e%b0%e7%b3%bb%e7%bb%9f%e4%b8%ad%e5%87%a0%e4%b8%aaphp-fpm%e8%bf%9b%e7%a8%8b%e5%af%bc%e8%87%b4cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e9%aa%a4%e5%8d%87>#</a></h5><h5 id=接着用perf来分析具体是php-fpm中哪个函数导致该问题>接着用perf来分析具体是php-fpm中哪个函数导致该问题。
<a class=anchor href=#%e6%8e%a5%e7%9d%80%e7%94%a8perf%e6%9d%a5%e5%88%86%e6%9e%90%e5%85%b7%e4%bd%93%e6%98%afphp-fpm%e4%b8%ad%e5%93%aa%e4%b8%aa%e5%87%bd%e6%95%b0%e5%af%bc%e8%87%b4%e8%af%a5%e9%97%ae%e9%a2%98>#</a></h5><pre tabindex=0><code>perf top -g -p XXXX #对某一个php-fpm进程进行分析
</code></pre><h5 id=发现其中-sqrt-和-add_function-占用-cpu-过多-此时查看源码找到原来是sqrt中在发布前没有删除测试代码段存在一个百万次的循环导致将该无用代码删除后发现nginx负载能力明显提升>发现其中 sqrt 和 add_function 占用 CPU 过多， 此时查看源码找到原来是sqrt中在发布前没有删除测试代码段，存在一个百万次的循环导致。将该无用代码删除后发现nginx负载能力明显提升
<a class=anchor href=#%e5%8f%91%e7%8e%b0%e5%85%b6%e4%b8%ad-sqrt-%e5%92%8c-add_function-%e5%8d%a0%e7%94%a8-cpu-%e8%bf%87%e5%a4%9a-%e6%ad%a4%e6%97%b6%e6%9f%a5%e7%9c%8b%e6%ba%90%e7%a0%81%e6%89%be%e5%88%b0%e5%8e%9f%e6%9d%a5%e6%98%afsqrt%e4%b8%ad%e5%9c%a8%e5%8f%91%e5%b8%83%e5%89%8d%e6%b2%a1%e6%9c%89%e5%88%a0%e9%99%a4%e6%b5%8b%e8%af%95%e4%bb%a3%e7%a0%81%e6%ae%b5%e5%ad%98%e5%9c%a8%e4%b8%80%e4%b8%aa%e7%99%be%e4%b8%87%e6%ac%a1%e7%9a%84%e5%be%aa%e7%8e%af%e5%af%bc%e8%87%b4%e5%b0%86%e8%af%a5%e6%97%a0%e7%94%a8%e4%bb%a3%e7%a0%81%e5%88%a0%e9%99%a4%e5%90%8e%e5%8f%91%e7%8e%b0nginx%e8%b4%9f%e8%bd%bd%e8%83%bd%e5%8a%9b%e6%98%8e%e6%98%be%e6%8f%90%e5%8d%87>#</a></h5><p><strong>系统的CPU使用率很高，为什么找不到高CPU的应用？</strong></p><pre tabindex=0><code>sudo docker run --name nginx -p 10000:80 -itd feisky/nginx:spsudo docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:spab -c 100 -n 1000 http://XXX.XXX.XXX.XXX:10000/ #并发100个请求测试
</code></pre><h5 id=实验结果中每秒请求数依旧不高我们将并发请求数降为5后nginx负载能力依旧很低>实验结果中每秒请求数依旧不高，我们将并发请求数降为5后，nginx负载能力依旧很低。
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c%e4%b8%ad%e6%af%8f%e7%a7%92%e8%af%b7%e6%b1%82%e6%95%b0%e4%be%9d%e6%97%a7%e4%b8%8d%e9%ab%98%e6%88%91%e4%bb%ac%e5%b0%86%e5%b9%b6%e5%8f%91%e8%af%b7%e6%b1%82%e6%95%b0%e9%99%8d%e4%b8%ba5%e5%90%8enginx%e8%b4%9f%e8%bd%bd%e8%83%bd%e5%8a%9b%e4%be%9d%e6%97%a7%e5%be%88%e4%bd%8e>#</a></h5><h5 id=此时用top和pidstat发现系统cpu使用率过高但是并没有发现cpu使用率高的进程>此时用top和pidstat发现系统CPU使用率过高，但是并没有发现CPU使用率高的进程。
<a class=anchor href=#%e6%ad%a4%e6%97%b6%e7%94%a8top%e5%92%8cpidstat%e5%8f%91%e7%8e%b0%e7%b3%bb%e7%bb%9fcpu%e4%bd%bf%e7%94%a8%e7%8e%87%e8%bf%87%e9%ab%98%e4%bd%86%e6%98%af%e5%b9%b6%e6%b2%a1%e6%9c%89%e5%8f%91%e7%8e%b0cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e9%ab%98%e7%9a%84%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=出现这种情况一般时我们分析时遗漏的什么信息重新运行top命令并观察一会发现就绪队列中处于running状态的进行过多超过了我们的并发请求次数5-再仔细查看进程运行数据发现nginx和php-fpm都处于sleep状态真正处于运行的却是几个stress进程>出现这种情况一般时我们分析时遗漏的什么信息，重新运行top命令并观察一会。发现就绪队列中处于Running状态的进行过多，超过了我们的并发请求次数5. 再仔细查看进程运行数据，发现nginx和php-fpm都处于sleep状态，真正处于运行的却是几个stress进程。
<a class=anchor href=#%e5%87%ba%e7%8e%b0%e8%bf%99%e7%a7%8d%e6%83%85%e5%86%b5%e4%b8%80%e8%88%ac%e6%97%b6%e6%88%91%e4%bb%ac%e5%88%86%e6%9e%90%e6%97%b6%e9%81%97%e6%bc%8f%e7%9a%84%e4%bb%80%e4%b9%88%e4%bf%a1%e6%81%af%e9%87%8d%e6%96%b0%e8%bf%90%e8%a1%8ctop%e5%91%bd%e4%bb%a4%e5%b9%b6%e8%a7%82%e5%af%9f%e4%b8%80%e4%bc%9a%e5%8f%91%e7%8e%b0%e5%b0%b1%e7%bb%aa%e9%98%9f%e5%88%97%e4%b8%ad%e5%a4%84%e4%ba%8erunning%e7%8a%b6%e6%80%81%e7%9a%84%e8%bf%9b%e8%a1%8c%e8%bf%87%e5%a4%9a%e8%b6%85%e8%bf%87%e4%ba%86%e6%88%91%e4%bb%ac%e7%9a%84%e5%b9%b6%e5%8f%91%e8%af%b7%e6%b1%82%e6%ac%a1%e6%95%b05-%e5%86%8d%e4%bb%94%e7%bb%86%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e8%bf%90%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%8f%91%e7%8e%b0nginx%e5%92%8cphp-fpm%e9%83%bd%e5%a4%84%e4%ba%8esleep%e7%8a%b6%e6%80%81%e7%9c%9f%e6%ad%a3%e5%a4%84%e4%ba%8e%e8%bf%90%e8%a1%8c%e7%9a%84%e5%8d%b4%e6%98%af%e5%87%a0%e4%b8%aastress%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=下一步就利用pidstat分析这几个stress进程发现没有任何输出用ps-aux交叉验证发现依旧不存在该进程说明不是工具的问题再top查看发现stress进程的进程号变化了此时有可能时以下两种原因导致>下一步就利用pidstat分析这几个stress进程，发现没有任何输出。用ps aux交叉验证发现依旧不存在该进程。说明不是工具的问题。再top查看发现stress进程的进程号变化了，此时有可能时以下两种原因导致：
<a class=anchor href=#%e4%b8%8b%e4%b8%80%e6%ad%a5%e5%b0%b1%e5%88%a9%e7%94%a8pidstat%e5%88%86%e6%9e%90%e8%bf%99%e5%87%a0%e4%b8%aastress%e8%bf%9b%e7%a8%8b%e5%8f%91%e7%8e%b0%e6%b2%a1%e6%9c%89%e4%bb%bb%e4%bd%95%e8%be%93%e5%87%ba%e7%94%a8ps-aux%e4%ba%a4%e5%8f%89%e9%aa%8c%e8%af%81%e5%8f%91%e7%8e%b0%e4%be%9d%e6%97%a7%e4%b8%8d%e5%ad%98%e5%9c%a8%e8%af%a5%e8%bf%9b%e7%a8%8b%e8%af%b4%e6%98%8e%e4%b8%8d%e6%98%af%e5%b7%a5%e5%85%b7%e7%9a%84%e9%97%ae%e9%a2%98%e5%86%8dtop%e6%9f%a5%e7%9c%8b%e5%8f%91%e7%8e%b0stress%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%8f%b7%e5%8f%98%e5%8c%96%e4%ba%86%e6%ad%a4%e6%97%b6%e6%9c%89%e5%8f%af%e8%83%bd%e6%97%b6%e4%bb%a5%e4%b8%8b%e4%b8%a4%e7%a7%8d%e5%8e%9f%e5%9b%a0%e5%af%bc%e8%87%b4>#</a></h5><ul><li><h5 id=进程不停的崩溃重启如段错误配置错误等此时进程退出后可能又被监控系统重启>进程不停的崩溃重启（如段错误/配置错误等），此时进程退出后可能又被监控系统重启；
<a class=anchor href=#%e8%bf%9b%e7%a8%8b%e4%b8%8d%e5%81%9c%e7%9a%84%e5%b4%a9%e6%ba%83%e9%87%8d%e5%90%af%e5%a6%82%e6%ae%b5%e9%94%99%e8%af%af%e9%85%8d%e7%bd%ae%e9%94%99%e8%af%af%e7%ad%89%e6%ad%a4%e6%97%b6%e8%bf%9b%e7%a8%8b%e9%80%80%e5%87%ba%e5%90%8e%e5%8f%af%e8%83%bd%e5%8f%88%e8%a2%ab%e7%9b%91%e6%8e%a7%e7%b3%bb%e7%bb%9f%e9%87%8d%e5%90%af>#</a></h5></li><li><h5 id=短时进程导致即其他应用内部通过-exec-调用的外面命令这些命令一般只运行很短时间就结束很难用top这种间隔较长的工具来发现>短时进程导致，即其他应用内部通过 exec 调用的外面命令，这些命令一般只运行很短时间就结束，很难用top这种间隔较长的工具来发现
<a class=anchor href=#%e7%9f%ad%e6%97%b6%e8%bf%9b%e7%a8%8b%e5%af%bc%e8%87%b4%e5%8d%b3%e5%85%b6%e4%bb%96%e5%ba%94%e7%94%a8%e5%86%85%e9%83%a8%e9%80%9a%e8%bf%87-exec-%e8%b0%83%e7%94%a8%e7%9a%84%e5%a4%96%e9%9d%a2%e5%91%bd%e4%bb%a4%e8%bf%99%e4%ba%9b%e5%91%bd%e4%bb%a4%e4%b8%80%e8%88%ac%e5%8f%aa%e8%bf%90%e8%a1%8c%e5%be%88%e7%9f%ad%e6%97%b6%e9%97%b4%e5%b0%b1%e7%bb%93%e6%9d%9f%e5%be%88%e9%9a%be%e7%94%a8top%e8%bf%99%e7%a7%8d%e9%97%b4%e9%9a%94%e8%be%83%e9%95%bf%e7%9a%84%e5%b7%a5%e5%85%b7%e6%9d%a5%e5%8f%91%e7%8e%b0>#</a></h5></li></ul><h5 id=可以通过pstree来查找-stress-的父进程找出调用关系>可以通过pstree来查找 stress 的父进程，找出调用关系。
<a class=anchor href=#%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87pstree%e6%9d%a5%e6%9f%a5%e6%89%be-stress-%e7%9a%84%e7%88%b6%e8%bf%9b%e7%a8%8b%e6%89%be%e5%87%ba%e8%b0%83%e7%94%a8%e5%85%b3%e7%b3%bb>#</a></h5><pre tabindex=0><code>pstree | grep stress
</code></pre><h5 id=发现是php-fpm调用的该子进程此时去查看源码可以看出每个请求都会调用一个stress命令来模拟io压力之前top显示的结果是cpu使用率升高是否真的是由该stress命令导致的还需要继续分析代码中给每个请求加了verbose1的参数后可以查看stress命令的输出在中断测试该命令结果显示stress命令运行时存在因权限问题导致的文件创建失败的bug>发现是php-fpm调用的该子进程，此时去查看源码可以看出每个请求都会调用一个stress命令来模拟I/O压力。之前top显示的结果是CPU使用率升高，是否真的是由该stress命令导致的，还需要继续分析。代码中给每个请求加了verbose=1的参数后可以查看stress命令的输出，在中断测试该命令结果显示stress命令运行时存在因权限问题导致的文件创建失败的bug。
<a class=anchor href=#%e5%8f%91%e7%8e%b0%e6%98%afphp-fpm%e8%b0%83%e7%94%a8%e7%9a%84%e8%af%a5%e5%ad%90%e8%bf%9b%e7%a8%8b%e6%ad%a4%e6%97%b6%e5%8e%bb%e6%9f%a5%e7%9c%8b%e6%ba%90%e7%a0%81%e5%8f%af%e4%bb%a5%e7%9c%8b%e5%87%ba%e6%af%8f%e4%b8%aa%e8%af%b7%e6%b1%82%e9%83%bd%e4%bc%9a%e8%b0%83%e7%94%a8%e4%b8%80%e4%b8%aastress%e5%91%bd%e4%bb%a4%e6%9d%a5%e6%a8%a1%e6%8b%9fio%e5%8e%8b%e5%8a%9b%e4%b9%8b%e5%89%8dtop%e6%98%be%e7%a4%ba%e7%9a%84%e7%bb%93%e6%9e%9c%e6%98%afcpu%e4%bd%bf%e7%94%a8%e7%8e%87%e5%8d%87%e9%ab%98%e6%98%af%e5%90%a6%e7%9c%9f%e7%9a%84%e6%98%af%e7%94%b1%e8%af%a5stress%e5%91%bd%e4%bb%a4%e5%af%bc%e8%87%b4%e7%9a%84%e8%bf%98%e9%9c%80%e8%a6%81%e7%bb%a7%e7%bb%ad%e5%88%86%e6%9e%90%e4%bb%a3%e7%a0%81%e4%b8%ad%e7%bb%99%e6%af%8f%e4%b8%aa%e8%af%b7%e6%b1%82%e5%8a%a0%e4%ba%86verbose1%e7%9a%84%e5%8f%82%e6%95%b0%e5%90%8e%e5%8f%af%e4%bb%a5%e6%9f%a5%e7%9c%8bstress%e5%91%bd%e4%bb%a4%e7%9a%84%e8%be%93%e5%87%ba%e5%9c%a8%e4%b8%ad%e6%96%ad%e6%b5%8b%e8%af%95%e8%af%a5%e5%91%bd%e4%bb%a4%e7%bb%93%e6%9e%9c%e6%98%be%e7%a4%bastress%e5%91%bd%e4%bb%a4%e8%bf%90%e8%a1%8c%e6%97%b6%e5%ad%98%e5%9c%a8%e5%9b%a0%e6%9d%83%e9%99%90%e9%97%ae%e9%a2%98%e5%af%bc%e8%87%b4%e7%9a%84%e6%96%87%e4%bb%b6%e5%88%9b%e5%bb%ba%e5%a4%b1%e8%b4%a5%e7%9a%84bug>#</a></h5><h5 id=此时依旧只是猜测下一步继续通过perf工具来分析性能报告显示确实时stress占用了大量的cpu通过修复权限问题来优化解决即可>此时依旧只是猜测，下一步继续通过perf工具来分析。性能报告显示确实时stress占用了大量的CPU，通过修复权限问题来优化解决即可。
<a class=anchor href=#%e6%ad%a4%e6%97%b6%e4%be%9d%e6%97%a7%e5%8f%aa%e6%98%af%e7%8c%9c%e6%b5%8b%e4%b8%8b%e4%b8%80%e6%ad%a5%e7%bb%a7%e7%bb%ad%e9%80%9a%e8%bf%87perf%e5%b7%a5%e5%85%b7%e6%9d%a5%e5%88%86%e6%9e%90%e6%80%a7%e8%83%bd%e6%8a%a5%e5%91%8a%e6%98%be%e7%a4%ba%e7%a1%ae%e5%ae%9e%e6%97%b6stress%e5%8d%a0%e7%94%a8%e4%ba%86%e5%a4%a7%e9%87%8f%e7%9a%84cpu%e9%80%9a%e8%bf%87%e4%bf%ae%e5%a4%8d%e6%9d%83%e9%99%90%e9%97%ae%e9%a2%98%e6%9d%a5%e4%bc%98%e5%8c%96%e8%a7%a3%e5%86%b3%e5%8d%b3%e5%8f%af>#</a></h5><p><strong>系统中出现大量不可中断进程和僵尸进程怎么办？</strong></p><p><strong>进程状态</strong></p><blockquote><p><strong>R</strong> Running/Runnable，表示进程在CPU的就绪队列中，正在运行或者等待运行；
<strong>D</strong> Disk Sleep，不可中断状态睡眠，一般表示进程正在跟硬件交互，并且交互过程中不允许被其他进程中断；
<strong>Z</strong> Zombie，僵尸进程，表示进程实际上已经结束，但是父进程还没有回收它的资源；
<strong>S</strong> Interruptible Sleep，可中断睡眠状态，表示进程因为等待某个事件而被系统挂起，当等待事件发生则会被唤醒并进入R状态；
<strong>I</strong> Idle，空闲状态，用在不可中断睡眠的内核线程上。该状态不会导致平均负载升高；
<strong>T</strong> Stop/Traced，表示进程处于暂停或跟踪状态（SIGSTOP/SIGCONT， GDB调试）；
<strong>X</strong> Dead，进程已经消亡，不会在top/ps中看到。</p></blockquote><h5 id=对于不可中断状态一般都是在很短时间内结束可忽略但是如果系统或硬件发生故障进程可能会保持不可中断状态很久甚至系统中出现大量不可中断状态此时需注意是否出现了io性能问题>对于不可中断状态，一般都是在很短时间内结束，可忽略。但是如果系统或硬件发生故障，进程可能会保持不可中断状态很久，甚至系统中出现大量不可中断状态，此时需注意是否出现了I/O性能问题。
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81%e4%b8%80%e8%88%ac%e9%83%bd%e6%98%af%e5%9c%a8%e5%be%88%e7%9f%ad%e6%97%b6%e9%97%b4%e5%86%85%e7%bb%93%e6%9d%9f%e5%8f%af%e5%bf%bd%e7%95%a5%e4%bd%86%e6%98%af%e5%a6%82%e6%9e%9c%e7%b3%bb%e7%bb%9f%e6%88%96%e7%a1%ac%e4%bb%b6%e5%8f%91%e7%94%9f%e6%95%85%e9%9a%9c%e8%bf%9b%e7%a8%8b%e5%8f%af%e8%83%bd%e4%bc%9a%e4%bf%9d%e6%8c%81%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81%e5%be%88%e4%b9%85%e7%94%9a%e8%87%b3%e7%b3%bb%e7%bb%9f%e4%b8%ad%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8f%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e7%8a%b6%e6%80%81%e6%ad%a4%e6%97%b6%e9%9c%80%e6%b3%a8%e6%84%8f%e6%98%af%e5%90%a6%e5%87%ba%e7%8e%b0%e4%ba%86io%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98>#</a></h5><h5 id=僵尸进程一般多进程应用容易遇到父进程来不及处理子进程状态时子进程就提前退出此时子进程就变成了僵尸进程大量的僵尸进程会用尽pid进程号导致新进程无法建立>僵尸进程一般多进程应用容易遇到，父进程来不及处理子进程状态时子进程就提前退出，此时子进程就变成了僵尸进程。大量的僵尸进程会用尽PID进程号，导致新进程无法建立。
<a class=anchor href=#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e4%b8%80%e8%88%ac%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%ba%94%e7%94%a8%e5%ae%b9%e6%98%93%e9%81%87%e5%88%b0%e7%88%b6%e8%bf%9b%e7%a8%8b%e6%9d%a5%e4%b8%8d%e5%8f%8a%e5%a4%84%e7%90%86%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e6%97%b6%e5%ad%90%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%8f%90%e5%89%8d%e9%80%80%e5%87%ba%e6%ad%a4%e6%97%b6%e5%ad%90%e8%bf%9b%e7%a8%8b%e5%b0%b1%e5%8f%98%e6%88%90%e4%ba%86%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e5%a4%a7%e9%87%8f%e7%9a%84%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e4%bc%9a%e7%94%a8%e5%b0%bdpid%e8%bf%9b%e7%a8%8b%e5%8f%b7%e5%af%bc%e8%87%b4%e6%96%b0%e8%bf%9b%e7%a8%8b%e6%97%a0%e6%b3%95%e5%bb%ba%e7%ab%8b>#</a></h5><p><strong>磁盘O_DIRECT问题</strong></p><pre tabindex=0><code>sudo docker run --privileged --name=app -itd feisky/app:iowaitps aux | grep &#39;/app&#39;
</code></pre><h5 id=可以看到此时有多个app进程运行状态分别时ss和d其中后面s表示进程是一个会话的领导进程号表示前台进程组>可以看到此时有多个app进程运行，状态分别时Ss+和D+。其中后面s表示进程是一个会话的领导进程，+号表示前台进程组。
<a class=anchor href=#%e5%8f%af%e4%bb%a5%e7%9c%8b%e5%88%b0%e6%ad%a4%e6%97%b6%e6%9c%89%e5%a4%9a%e4%b8%aaapp%e8%bf%9b%e7%a8%8b%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81%e5%88%86%e5%88%ab%e6%97%b6ss%e5%92%8cd%e5%85%b6%e4%b8%ad%e5%90%8e%e9%9d%a2s%e8%a1%a8%e7%a4%ba%e8%bf%9b%e7%a8%8b%e6%98%af%e4%b8%80%e4%b8%aa%e4%bc%9a%e8%af%9d%e7%9a%84%e9%a2%86%e5%af%bc%e8%bf%9b%e7%a8%8b%e5%8f%b7%e8%a1%a8%e7%a4%ba%e5%89%8d%e5%8f%b0%e8%bf%9b%e7%a8%8b%e7%bb%84>#</a></h5><h5 id=其中进程组表示一组相互关联的进程子进程是父进程所在组的组员会话指共享同一个控制终端的一个或多个进程组>其中进程组表示一组相互关联的进程，子进程是父进程所在组的组员。会话指共享同一个控制终端的一个或多个进程组。
<a class=anchor href=#%e5%85%b6%e4%b8%ad%e8%bf%9b%e7%a8%8b%e7%bb%84%e8%a1%a8%e7%a4%ba%e4%b8%80%e7%bb%84%e7%9b%b8%e4%ba%92%e5%85%b3%e8%81%94%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%ad%90%e8%bf%9b%e7%a8%8b%e6%98%af%e7%88%b6%e8%bf%9b%e7%a8%8b%e6%89%80%e5%9c%a8%e7%bb%84%e7%9a%84%e7%bb%84%e5%91%98%e4%bc%9a%e8%af%9d%e6%8c%87%e5%85%b1%e4%ba%ab%e5%90%8c%e4%b8%80%e4%b8%aa%e6%8e%a7%e5%88%b6%e7%bb%88%e7%ab%af%e7%9a%84%e4%b8%80%e4%b8%aa%e6%88%96%e5%a4%9a%e4%b8%aa%e8%bf%9b%e7%a8%8b%e7%bb%84>#</a></h5><h5 id=用top查看系统资源发现1平均负载在逐渐增加且1分钟内平均负载达到了cpu个数说明系统可能已经有了性能瓶颈2僵尸进程比较多且在不停增加3us和sys-cpu使用率都不高iowait却比较高4每个进程cpu使用率也不高但有两个进程处于d状态可能在等待io>用top查看系统资源发现：1）平均负载在逐渐增加，且1分钟内平均负载达到了CPU个数，说明系统可能已经有了性能瓶颈；2）僵尸进程比较多且在不停增加；3）us和sys CPU使用率都不高，iowait却比较高；4）每个进程CPU使用率也不高，但有两个进程处于D状态，可能在等待IO。
<a class=anchor href=#%e7%94%a8top%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90%e5%8f%91%e7%8e%b01%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%9c%a8%e9%80%90%e6%b8%90%e5%a2%9e%e5%8a%a0%e4%b8%941%e5%88%86%e9%92%9f%e5%86%85%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e8%be%be%e5%88%b0%e4%ba%86cpu%e4%b8%aa%e6%95%b0%e8%af%b4%e6%98%8e%e7%b3%bb%e7%bb%9f%e5%8f%af%e8%83%bd%e5%b7%b2%e7%bb%8f%e6%9c%89%e4%ba%86%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%882%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e6%af%94%e8%be%83%e5%a4%9a%e4%b8%94%e5%9c%a8%e4%b8%8d%e5%81%9c%e5%a2%9e%e5%8a%a03us%e5%92%8csys-cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e9%83%bd%e4%b8%8d%e9%ab%98iowait%e5%8d%b4%e6%af%94%e8%be%83%e9%ab%984%e6%af%8f%e4%b8%aa%e8%bf%9b%e7%a8%8bcpu%e4%bd%bf%e7%94%a8%e7%8e%87%e4%b9%9f%e4%b8%8d%e9%ab%98%e4%bd%86%e6%9c%89%e4%b8%a4%e4%b8%aa%e8%bf%9b%e7%a8%8b%e5%a4%84%e4%ba%8ed%e7%8a%b6%e6%80%81%e5%8f%af%e8%83%bd%e5%9c%a8%e7%ad%89%e5%be%85io>#</a></h5><h5 id=分析目前数据可知iowait过高导致系统平均负载升高僵尸进程不断增长说明有程序没能正确清理子进程资源>分析目前数据可知：iowait过高导致系统平均负载升高，僵尸进程不断增长说明有程序没能正确清理子进程资源。
<a class=anchor href=#%e5%88%86%e6%9e%90%e7%9b%ae%e5%89%8d%e6%95%b0%e6%8d%ae%e5%8f%af%e7%9f%a5iowait%e8%bf%87%e9%ab%98%e5%af%bc%e8%87%b4%e7%b3%bb%e7%bb%9f%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e5%8d%87%e9%ab%98%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e4%b8%8d%e6%96%ad%e5%a2%9e%e9%95%bf%e8%af%b4%e6%98%8e%e6%9c%89%e7%a8%8b%e5%ba%8f%e6%b2%a1%e8%83%bd%e6%ad%a3%e7%a1%ae%e6%b8%85%e7%90%86%e5%ad%90%e8%bf%9b%e7%a8%8b%e8%b5%84%e6%ba%90>#</a></h5><h5 id=用dstat来分析因为它可以同时查看cpu和io两种资源的使用情况便于对比分析>用dstat来分析，因为它可以同时查看CPU和I/O两种资源的使用情况，便于对比分析。
<a class=anchor href=#%e7%94%a8dstat%e6%9d%a5%e5%88%86%e6%9e%90%e5%9b%a0%e4%b8%ba%e5%ae%83%e5%8f%af%e4%bb%a5%e5%90%8c%e6%97%b6%e6%9f%a5%e7%9c%8bcpu%e5%92%8cio%e4%b8%a4%e7%a7%8d%e8%b5%84%e6%ba%90%e7%9a%84%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5%e4%be%bf%e4%ba%8e%e5%af%b9%e6%af%94%e5%88%86%e6%9e%90>#</a></h5><pre tabindex=0><code>dstat 1 10    #间隔1秒输出10组数据
</code></pre><h5 id=可以看到当waiiowait升高时磁盘请求read都会很大说明iowait的升高和磁盘的读请求有关接下来分析到底时哪个进程在读磁盘>可以看到当wai（iowait）升高时磁盘请求read都会很大，说明iowait的升高和磁盘的读请求有关。接下来分析到底时哪个进程在读磁盘。
<a class=anchor href=#%e5%8f%af%e4%bb%a5%e7%9c%8b%e5%88%b0%e5%bd%93waiiowait%e5%8d%87%e9%ab%98%e6%97%b6%e7%a3%81%e7%9b%98%e8%af%b7%e6%b1%82read%e9%83%bd%e4%bc%9a%e5%be%88%e5%a4%a7%e8%af%b4%e6%98%8eiowait%e7%9a%84%e5%8d%87%e9%ab%98%e5%92%8c%e7%a3%81%e7%9b%98%e7%9a%84%e8%af%bb%e8%af%b7%e6%b1%82%e6%9c%89%e5%85%b3%e6%8e%a5%e4%b8%8b%e6%9d%a5%e5%88%86%e6%9e%90%e5%88%b0%e5%ba%95%e6%97%b6%e5%93%aa%e4%b8%aa%e8%bf%9b%e7%a8%8b%e5%9c%a8%e8%af%bb%e7%a3%81%e7%9b%98>#</a></h5><h5 id=之前-top-查看的处于-d-状态的进程号用-pidstat--d--p-xxx-展示进程的-io-统计数据发现处于-d-状态的进程都没有任何读写操作在用-pidstat--d-查看所有进程的-io统计数据看到-app-进程在进行磁盘读操作每秒读取-32mb-的数据进程访问磁盘必须使用系统调用处于内核态接下来重点就是找到app进程的系统调用>之前 Top 查看的处于 D 状态的进程号，用 pidstat -d -p XXX 展示进程的 I/O 统计数据。发现处于 D 状态的进程都没有任何读写操作。在用 pidstat -d 查看所有进程的 I/O统计数据，看到 app 进程在进行磁盘读操作，每秒读取 32MB 的数据。进程访问磁盘必须使用系统调用处于内核态，接下来重点就是找到app进程的系统调用。
<a class=anchor href=#%e4%b9%8b%e5%89%8d-top-%e6%9f%a5%e7%9c%8b%e7%9a%84%e5%a4%84%e4%ba%8e-d-%e7%8a%b6%e6%80%81%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%8f%b7%e7%94%a8-pidstat--d--p-xxx-%e5%b1%95%e7%a4%ba%e8%bf%9b%e7%a8%8b%e7%9a%84-io-%e7%bb%9f%e8%ae%a1%e6%95%b0%e6%8d%ae%e5%8f%91%e7%8e%b0%e5%a4%84%e4%ba%8e-d-%e7%8a%b6%e6%80%81%e7%9a%84%e8%bf%9b%e7%a8%8b%e9%83%bd%e6%b2%a1%e6%9c%89%e4%bb%bb%e4%bd%95%e8%af%bb%e5%86%99%e6%93%8d%e4%bd%9c%e5%9c%a8%e7%94%a8-pidstat--d-%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e8%bf%9b%e7%a8%8b%e7%9a%84-io%e7%bb%9f%e8%ae%a1%e6%95%b0%e6%8d%ae%e7%9c%8b%e5%88%b0-app-%e8%bf%9b%e7%a8%8b%e5%9c%a8%e8%bf%9b%e8%a1%8c%e7%a3%81%e7%9b%98%e8%af%bb%e6%93%8d%e4%bd%9c%e6%af%8f%e7%a7%92%e8%af%bb%e5%8f%96-32mb-%e7%9a%84%e6%95%b0%e6%8d%ae%e8%bf%9b%e7%a8%8b%e8%ae%bf%e9%97%ae%e7%a3%81%e7%9b%98%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%a4%84%e4%ba%8e%e5%86%85%e6%a0%b8%e6%80%81%e6%8e%a5%e4%b8%8b%e6%9d%a5%e9%87%8d%e7%82%b9%e5%b0%b1%e6%98%af%e6%89%be%e5%88%b0app%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8>#</a></h5><pre tabindex=0><code>sudo strace -p XXX #对app进程调用进行跟踪
</code></pre><h5 id=报错没有权限因为已经时-root-权限了所以遇到这种情况首先要检查进程状态是否正常ps-命令查找该进程已经处于z状态即僵尸进程>报错没有权限，因为已经时 root 权限了。所以遇到这种情况，首先要检查进程状态是否正常。ps 命令查找该进程已经处于Z状态，即僵尸进程。
<a class=anchor href=#%e6%8a%a5%e9%94%99%e6%b2%a1%e6%9c%89%e6%9d%83%e9%99%90%e5%9b%a0%e4%b8%ba%e5%b7%b2%e7%bb%8f%e6%97%b6-root-%e6%9d%83%e9%99%90%e4%ba%86%e6%89%80%e4%bb%a5%e9%81%87%e5%88%b0%e8%bf%99%e7%a7%8d%e6%83%85%e5%86%b5%e9%a6%96%e5%85%88%e8%a6%81%e6%a3%80%e6%9f%a5%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81%e6%98%af%e5%90%a6%e6%ad%a3%e5%b8%b8ps-%e5%91%bd%e4%bb%a4%e6%9f%a5%e6%89%be%e8%af%a5%e8%bf%9b%e7%a8%8b%e5%b7%b2%e7%bb%8f%e5%a4%84%e4%ba%8ez%e7%8a%b6%e6%80%81%e5%8d%b3%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=这种情况下top-pidstat之类的工具无法给出更多的信息此时像第5篇一样用-perf-record--d和-perf-report-进行分析查看app进程调用栈>这种情况下top pidstat之类的工具无法给出更多的信息，此时像第5篇一样，用 perf record -d和 perf report 进行分析，查看app进程调用栈。
<a class=anchor href=#%e8%bf%99%e7%a7%8d%e6%83%85%e5%86%b5%e4%b8%8btop-pidstat%e4%b9%8b%e7%b1%bb%e7%9a%84%e5%b7%a5%e5%85%b7%e6%97%a0%e6%b3%95%e7%bb%99%e5%87%ba%e6%9b%b4%e5%a4%9a%e7%9a%84%e4%bf%a1%e6%81%af%e6%ad%a4%e6%97%b6%e5%83%8f%e7%ac%ac5%e7%af%87%e4%b8%80%e6%a0%b7%e7%94%a8-perf-record--d%e5%92%8c-perf-report-%e8%bf%9b%e8%a1%8c%e5%88%86%e6%9e%90%e6%9f%a5%e7%9c%8bapp%e8%bf%9b%e7%a8%8b%e8%b0%83%e7%94%a8%e6%a0%88>#</a></h5><h5 id=看到-app-确实在通过系统调用-sys_read-读取数据并且从-new_sync_read和-blkdev_direct_io看出进程时进行直接读操作请求直接从磁盘读没有通过缓存导致iowait升高>看到 app 确实在通过系统调用 sys_read() 读取数据，并且从 new_sync_read和 blkdev_direct_IO看出进程时进行直接读操作，请求直接从磁盘读，没有通过缓存导致iowait升高。
<a class=anchor href=#%e7%9c%8b%e5%88%b0-app-%e7%a1%ae%e5%ae%9e%e5%9c%a8%e9%80%9a%e8%bf%87%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8-sys_read-%e8%af%bb%e5%8f%96%e6%95%b0%e6%8d%ae%e5%b9%b6%e4%b8%94%e4%bb%8e-new_sync_read%e5%92%8c-blkdev_direct_io%e7%9c%8b%e5%87%ba%e8%bf%9b%e7%a8%8b%e6%97%b6%e8%bf%9b%e8%a1%8c%e7%9b%b4%e6%8e%a5%e8%af%bb%e6%93%8d%e4%bd%9c%e8%af%b7%e6%b1%82%e7%9b%b4%e6%8e%a5%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e6%b2%a1%e6%9c%89%e9%80%9a%e8%bf%87%e7%bc%93%e5%ad%98%e5%af%bc%e8%87%b4iowait%e5%8d%87%e9%ab%98>#</a></h5><h5 id=通过层层分析后root-cause-是-app-内部进行了磁盘的直接io然后定位到具体代码位置进行优化即可>通过层层分析后，root cause 是 app 内部进行了磁盘的直接I/O。然后定位到具体代码位置进行优化即可。
<a class=anchor href=#%e9%80%9a%e8%bf%87%e5%b1%82%e5%b1%82%e5%88%86%e6%9e%90%e5%90%8eroot-cause-%e6%98%af-app-%e5%86%85%e9%83%a8%e8%bf%9b%e8%a1%8c%e4%ba%86%e7%a3%81%e7%9b%98%e7%9a%84%e7%9b%b4%e6%8e%a5io%e7%84%b6%e5%90%8e%e5%ae%9a%e4%bd%8d%e5%88%b0%e5%85%b7%e4%bd%93%e4%bb%a3%e7%a0%81%e4%bd%8d%e7%bd%ae%e8%bf%9b%e8%a1%8c%e4%bc%98%e5%8c%96%e5%8d%b3%e5%8f%af>#</a></h5><p><strong>僵尸进程</strong></p><h5 id=上述优化后-iowait-显著下降但是僵尸进程数量仍旧在增加首先要定位僵尸进程的父进程通过pstree--aps-xxx打印出该僵尸进程的调用树发现父进程就是app进程>上述优化后 iowait 显著下降，但是僵尸进程数量仍旧在增加。首先要定位僵尸进程的父进程，通过pstree -aps XXX，打印出该僵尸进程的调用树，发现父进程就是app进程。
<a class=anchor href=#%e4%b8%8a%e8%bf%b0%e4%bc%98%e5%8c%96%e5%90%8e-iowait-%e6%98%be%e8%91%97%e4%b8%8b%e9%99%8d%e4%bd%86%e6%98%af%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e6%95%b0%e9%87%8f%e4%bb%8d%e6%97%a7%e5%9c%a8%e5%a2%9e%e5%8a%a0%e9%a6%96%e5%85%88%e8%a6%81%e5%ae%9a%e4%bd%8d%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%88%b6%e8%bf%9b%e7%a8%8b%e9%80%9a%e8%bf%87pstree--aps-xxx%e6%89%93%e5%8d%b0%e5%87%ba%e8%af%a5%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%b0%83%e7%94%a8%e6%a0%91%e5%8f%91%e7%8e%b0%e7%88%b6%e8%bf%9b%e7%a8%8b%e5%b0%b1%e6%98%afapp%e8%bf%9b%e7%a8%8b>#</a></h5><h5 id=查看app代码看看子进程结束的处理是否正确是否调用waitwaitpid有没有注册sigchild信号的处理函数等>查看app代码，看看子进程结束的处理是否正确（是否调用wait()/waitpid()，有没有注册SIGCHILD信号的处理函数等）。
<a class=anchor href=#%e6%9f%a5%e7%9c%8bapp%e4%bb%a3%e7%a0%81%e7%9c%8b%e7%9c%8b%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%bb%93%e6%9d%9f%e7%9a%84%e5%a4%84%e7%90%86%e6%98%af%e5%90%a6%e6%ad%a3%e7%a1%ae%e6%98%af%e5%90%a6%e8%b0%83%e7%94%a8waitwaitpid%e6%9c%89%e6%b2%a1%e6%9c%89%e6%b3%a8%e5%86%8csigchild%e4%bf%a1%e5%8f%b7%e7%9a%84%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0%e7%ad%89>#</a></h5><h5 id=碰到iowait升高时先用dstat-pidstat等工具确认是否存在磁盘io问题再找是哪些进程导致io不能用strace直接分析进程调用时可以通过perf工具分析>碰到iowait升高时，先用dstat pidstat等工具确认是否存在磁盘I/O问题，再找是哪些进程导致I/O，不能用strace直接分析进程调用时可以通过perf工具分析。
<a class=anchor href=#%e7%a2%b0%e5%88%b0iowait%e5%8d%87%e9%ab%98%e6%97%b6%e5%85%88%e7%94%a8dstat-pidstat%e7%ad%89%e5%b7%a5%e5%85%b7%e7%a1%ae%e8%ae%a4%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e7%a3%81%e7%9b%98io%e9%97%ae%e9%a2%98%e5%86%8d%e6%89%be%e6%98%af%e5%93%aa%e4%ba%9b%e8%bf%9b%e7%a8%8b%e5%af%bc%e8%87%b4io%e4%b8%8d%e8%83%bd%e7%94%a8strace%e7%9b%b4%e6%8e%a5%e5%88%86%e6%9e%90%e8%bf%9b%e7%a8%8b%e8%b0%83%e7%94%a8%e6%97%b6%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87perf%e5%b7%a5%e5%85%b7%e5%88%86%e6%9e%90>#</a></h5><h5 id=对于僵尸问题用pstree找到父进程然后看源码检查子进程结束的处理逻辑即可>对于僵尸问题，用pstree找到父进程，然后看源码检查子进程结束的处理逻辑即可。
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e5%83%b5%e5%b0%b8%e9%97%ae%e9%a2%98%e7%94%a8pstree%e6%89%be%e5%88%b0%e7%88%b6%e8%bf%9b%e7%a8%8b%e7%84%b6%e5%90%8e%e7%9c%8b%e6%ba%90%e7%a0%81%e6%a3%80%e6%9f%a5%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%bb%93%e6%9d%9f%e7%9a%84%e5%a4%84%e7%90%86%e9%80%bb%e8%be%91%e5%8d%b3%e5%8f%af>#</a></h5><h4 id=cpu性能指标><strong>CPU性能指标</strong>
<a class=anchor href=#cpu%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87>#</a></h4><ul><li><p><strong>CPU使用率</strong></p></li><li><ul><li><h5 id=用户cpu使用率-包括用户态user和低优先级用户态nice-该指标过高说明应用程序比较繁忙>用户CPU使用率, 包括用户态(user)和低优先级用户态(nice). 该指标过高说明应用程序比较繁忙.
<a class=anchor href=#%e7%94%a8%e6%88%b7cpu%e4%bd%bf%e7%94%a8%e7%8e%87-%e5%8c%85%e6%8b%ac%e7%94%a8%e6%88%b7%e6%80%81user%e5%92%8c%e4%bd%8e%e4%bc%98%e5%85%88%e7%ba%a7%e7%94%a8%e6%88%b7%e6%80%81nice-%e8%af%a5%e6%8c%87%e6%a0%87%e8%bf%87%e9%ab%98%e8%af%b4%e6%98%8e%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e6%af%94%e8%be%83%e7%b9%81%e5%bf%99>#</a></h5></li><li><h5 id=系统cpu使用率-cpu在内核态运行的时间百分比不含中断-该指标高说明内核比较繁忙>系统CPU使用率, CPU在内核态运行的时间百分比(不含中断). 该指标高说明内核比较繁忙.
<a class=anchor href=#%e7%b3%bb%e7%bb%9fcpu%e4%bd%bf%e7%94%a8%e7%8e%87-cpu%e5%9c%a8%e5%86%85%e6%a0%b8%e6%80%81%e8%bf%90%e8%a1%8c%e7%9a%84%e6%97%b6%e9%97%b4%e7%99%be%e5%88%86%e6%af%94%e4%b8%8d%e5%90%ab%e4%b8%ad%e6%96%ad-%e8%af%a5%e6%8c%87%e6%a0%87%e9%ab%98%e8%af%b4%e6%98%8e%e5%86%85%e6%a0%b8%e6%af%94%e8%be%83%e7%b9%81%e5%bf%99>#</a></h5></li><li><h5 id=等待io的cpu使用率-iowait-该指标高说明系统与硬件设备io交互时间比较长>等待I/O的CPU使用率, iowait, 该指标高说明系统与硬件设备I/O交互时间比较长.
<a class=anchor href=#%e7%ad%89%e5%be%85io%e7%9a%84cpu%e4%bd%bf%e7%94%a8%e7%8e%87-iowait-%e8%af%a5%e6%8c%87%e6%a0%87%e9%ab%98%e8%af%b4%e6%98%8e%e7%b3%bb%e7%bb%9f%e4%b8%8e%e7%a1%ac%e4%bb%b6%e8%ae%be%e5%a4%87io%e4%ba%a4%e4%ba%92%e6%97%b6%e9%97%b4%e6%af%94%e8%be%83%e9%95%bf>#</a></h5></li><li><h5 id=软硬中断cpu使用率-该指标高说明系统中发生大量中断>软/硬中断CPU使用率, 该指标高说明系统中发生大量中断.
<a class=anchor href=#%e8%bd%af%e7%a1%ac%e4%b8%ad%e6%96%adcpu%e4%bd%bf%e7%94%a8%e7%8e%87-%e8%af%a5%e6%8c%87%e6%a0%87%e9%ab%98%e8%af%b4%e6%98%8e%e7%b3%bb%e7%bb%9f%e4%b8%ad%e5%8f%91%e7%94%9f%e5%a4%a7%e9%87%8f%e4%b8%ad%e6%96%ad>#</a></h5></li><li><h5 id=steal-cpu--guest-cpu-表示虚拟机占用的cpu百分比>steal CPU / guest CPU, 表示虚拟机占用的CPU百分比.
<a class=anchor href=#steal-cpu--guest-cpu-%e8%a1%a8%e7%a4%ba%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8d%a0%e7%94%a8%e7%9a%84cpu%e7%99%be%e5%88%86%e6%af%94>#</a></h5></li></ul></li><li><p><strong>平均负载</strong></p></li><li><ul><li><h5 id=理想情况下平均负载等于逻辑cpu个数表示每个cpu都被充分利用-若大于则说明系统负载较重>理想情况下平均负载等于逻辑CPU个数,表示每个CPU都被充分利用. 若大于则说明系统负载较重.
<a class=anchor href=#%e7%90%86%e6%83%b3%e6%83%85%e5%86%b5%e4%b8%8b%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e7%ad%89%e4%ba%8e%e9%80%bb%e8%be%91cpu%e4%b8%aa%e6%95%b0%e8%a1%a8%e7%a4%ba%e6%af%8f%e4%b8%aacpu%e9%83%bd%e8%a2%ab%e5%85%85%e5%88%86%e5%88%a9%e7%94%a8-%e8%8b%a5%e5%a4%a7%e4%ba%8e%e5%88%99%e8%af%b4%e6%98%8e%e7%b3%bb%e7%bb%9f%e8%b4%9f%e8%bd%bd%e8%be%83%e9%87%8d>#</a></h5></li></ul></li><li><p><strong>进程上下文切换</strong></p></li><li><ul><li><h5 id=包括无法获取资源的自愿切换和系统强制调度时的非自愿切换-上下文切换本身是保证linux正常运行的一项核心功能-过多的切换则会将原本运行进程的cpu时间消耗在寄存器内核占及虚拟内存等数据保存和恢复上>包括无法获取资源的自愿切换和系统强制调度时的非自愿切换. 上下文切换本身是保证Linux正常运行的一项核心功能. 过多的切换则会将原本运行进程的CPU时间消耗在寄存器,内核占及虚拟内存等数据保存和恢复上
<a class=anchor href=#%e5%8c%85%e6%8b%ac%e6%97%a0%e6%b3%95%e8%8e%b7%e5%8f%96%e8%b5%84%e6%ba%90%e7%9a%84%e8%87%aa%e6%84%bf%e5%88%87%e6%8d%a2%e5%92%8c%e7%b3%bb%e7%bb%9f%e5%bc%ba%e5%88%b6%e8%b0%83%e5%ba%a6%e6%97%b6%e7%9a%84%e9%9d%9e%e8%87%aa%e6%84%bf%e5%88%87%e6%8d%a2-%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%9c%ac%e8%ba%ab%e6%98%af%e4%bf%9d%e8%af%81linux%e6%ad%a3%e5%b8%b8%e8%bf%90%e8%a1%8c%e7%9a%84%e4%b8%80%e9%a1%b9%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd-%e8%bf%87%e5%a4%9a%e7%9a%84%e5%88%87%e6%8d%a2%e5%88%99%e4%bc%9a%e5%b0%86%e5%8e%9f%e6%9c%ac%e8%bf%90%e8%a1%8c%e8%bf%9b%e7%a8%8b%e7%9a%84cpu%e6%97%b6%e9%97%b4%e6%b6%88%e8%80%97%e5%9c%a8%e5%af%84%e5%ad%98%e5%99%a8%e5%86%85%e6%a0%b8%e5%8d%a0%e5%8f%8a%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%ad%89%e6%95%b0%e6%8d%ae%e4%bf%9d%e5%ad%98%e5%92%8c%e6%81%a2%e5%a4%8d%e4%b8%8a>#</a></h5></li></ul></li><li><p><strong>CPU缓存命中率</strong></p></li><li><ul><li><h5 id=cpu缓存的复用情况命中率越高性能越好-其中l1l2常用在单核l3则用在多核中>CPU缓存的复用情况,命中率越高性能越好. 其中L1/L2常用在单核,L3则用在多核中
<a class=anchor href=#cpu%e7%bc%93%e5%ad%98%e7%9a%84%e5%a4%8d%e7%94%a8%e6%83%85%e5%86%b5%e5%91%bd%e4%b8%ad%e7%8e%87%e8%b6%8a%e9%ab%98%e6%80%a7%e8%83%bd%e8%b6%8a%e5%a5%bd-%e5%85%b6%e4%b8%adl1l2%e5%b8%b8%e7%94%a8%e5%9c%a8%e5%8d%95%e6%a0%b8l3%e5%88%99%e7%94%a8%e5%9c%a8%e5%a4%9a%e6%a0%b8%e4%b8%ad>#</a></h5></li></ul></li></ul><h4 id=性能工具><strong>性能工具</strong>
<a class=anchor href=#%e6%80%a7%e8%83%bd%e5%b7%a5%e5%85%b7>#</a></h4><ul><li><p><strong>平均负载案例</strong></p></li><li><ul><li><h5 id=先用uptime查看系统平均负载>先用uptime查看系统平均负载
<a class=anchor href=#%e5%85%88%e7%94%a8uptime%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd>#</a></h5></li><li><h5 id=判断负载在升高后再用mpstat和pidstat分别查看每个cpu和每个进程cpu使用情况找出导致平均负载较高的进程>判断负载在升高后再用mpstat和pidstat分别查看每个CPU和每个进程CPU使用情况.找出导致平均负载较高的进程.
<a class=anchor href=#%e5%88%a4%e6%96%ad%e8%b4%9f%e8%bd%bd%e5%9c%a8%e5%8d%87%e9%ab%98%e5%90%8e%e5%86%8d%e7%94%a8mpstat%e5%92%8cpidstat%e5%88%86%e5%88%ab%e6%9f%a5%e7%9c%8b%e6%af%8f%e4%b8%aacpu%e5%92%8c%e6%af%8f%e4%b8%aa%e8%bf%9b%e7%a8%8bcpu%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5%e6%89%be%e5%87%ba%e5%af%bc%e8%87%b4%e5%b9%b3%e5%9d%87%e8%b4%9f%e8%bd%bd%e8%be%83%e9%ab%98%e7%9a%84%e8%bf%9b%e7%a8%8b>#</a></h5></li></ul></li><li><p><strong>上下文切换案例</strong></p></li><li><ul><li><h5 id=先用vmstat查看系统上下文切换和中断次数>先用vmstat查看系统上下文切换和中断次数
<a class=anchor href=#%e5%85%88%e7%94%a8vmstat%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%92%8c%e4%b8%ad%e6%96%ad%e6%ac%a1%e6%95%b0>#</a></h5></li><li><h5 id=再用pidstat观察进程的自愿和非自愿上下文切换情况>再用pidstat观察进程的自愿和非自愿上下文切换情况
<a class=anchor href=#%e5%86%8d%e7%94%a8pidstat%e8%a7%82%e5%af%9f%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%87%aa%e6%84%bf%e5%92%8c%e9%9d%9e%e8%87%aa%e6%84%bf%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%83%85%e5%86%b5>#</a></h5></li><li><h5 id=最后通过pidstat观察线程的上下文切换情况>最后通过pidstat观察线程的上下文切换情况
<a class=anchor href=#%e6%9c%80%e5%90%8e%e9%80%9a%e8%bf%87pidstat%e8%a7%82%e5%af%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%83%85%e5%86%b5>#</a></h5></li></ul></li><li><p><strong>进程CPU使用率高案例</strong></p></li><li><ul><li><h5 id=先用top查看系统和进程的cpu使用情况定位到进程>先用top查看系统和进程的CPU使用情况,定位到进程
<a class=anchor href=#%e5%85%88%e7%94%a8top%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e5%92%8c%e8%bf%9b%e7%a8%8b%e7%9a%84cpu%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5%e5%ae%9a%e4%bd%8d%e5%88%b0%e8%bf%9b%e7%a8%8b>#</a></h5></li><li><h5 id=再用perf-top观察进程调用链定位到具体函数>再用perf top观察进程调用链,定位到具体函数
<a class=anchor href=#%e5%86%8d%e7%94%a8perf-top%e8%a7%82%e5%af%9f%e8%bf%9b%e7%a8%8b%e8%b0%83%e7%94%a8%e9%93%be%e5%ae%9a%e4%bd%8d%e5%88%b0%e5%85%b7%e4%bd%93%e5%87%bd%e6%95%b0>#</a></h5></li></ul></li><li><p><strong>系统CPU使用率高案例</strong></p></li><li><ul><li><h5 id=先用top查看系统和进程的cpu使用情况toppidstat都无法找到cpu使用率高的进程>先用top查看系统和进程的CPU使用情况,top/pidstat都无法找到CPU使用率高的进程
<a class=anchor href=#%e5%85%88%e7%94%a8top%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e5%92%8c%e8%bf%9b%e7%a8%8b%e7%9a%84cpu%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5toppidstat%e9%83%bd%e6%97%a0%e6%b3%95%e6%89%be%e5%88%b0cpu%e4%bd%bf%e7%94%a8%e7%8e%87%e9%ab%98%e7%9a%84%e8%bf%9b%e7%a8%8b>#</a></h5></li><li><h5 id=重新审视top输出>重新审视top输出
<a class=anchor href=#%e9%87%8d%e6%96%b0%e5%ae%a1%e8%a7%86top%e8%be%93%e5%87%ba>#</a></h5></li><li><h5 id=从cpu使用率不高但是处于running状态的进程入手>从CPU使用率不高,但是处于Running状态的进程入手
<a class=anchor href=#%e4%bb%8ecpu%e4%bd%bf%e7%94%a8%e7%8e%87%e4%b8%8d%e9%ab%98%e4%bd%86%e6%98%af%e5%a4%84%e4%ba%8erunning%e7%8a%b6%e6%80%81%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%85%a5%e6%89%8b>#</a></h5></li><li><h5 id=perf-recordreport发现短时进程导致-execsnoop工具>perf record/report发现短时进程导致 (execsnoop工具)
<a class=anchor href=#perf-recordreport%e5%8f%91%e7%8e%b0%e7%9f%ad%e6%97%b6%e8%bf%9b%e7%a8%8b%e5%af%bc%e8%87%b4-execsnoop%e5%b7%a5%e5%85%b7>#</a></h5></li></ul></li><li><p><strong>不可中断和僵尸进程案例</strong></p></li><li><ul><li><h5 id=先用top观察iowait升高发现大量不可中断和僵尸进程>先用top观察iowait升高,发现大量不可中断和僵尸进程
<a class=anchor href=#%e5%85%88%e7%94%a8top%e8%a7%82%e5%af%9fiowait%e5%8d%87%e9%ab%98%e5%8f%91%e7%8e%b0%e5%a4%a7%e9%87%8f%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e5%92%8c%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b>#</a></h5></li><li><h5 id=strace无法跟踪进程系统调用>strace无法跟踪进程系统调用
<a class=anchor href=#strace%e6%97%a0%e6%b3%95%e8%b7%9f%e8%b8%aa%e8%bf%9b%e7%a8%8b%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8>#</a></h5></li><li><h5 id=perf分析调用链发现根源来自磁盘直接io>perf分析调用链发现根源来自磁盘直接I/O
<a class=anchor href=#perf%e5%88%86%e6%9e%90%e8%b0%83%e7%94%a8%e9%93%be%e5%8f%91%e7%8e%b0%e6%a0%b9%e6%ba%90%e6%9d%a5%e8%87%aa%e7%a3%81%e7%9b%98%e7%9b%b4%e6%8e%a5io>#</a></h5></li></ul></li><li><p><strong>软中断案例</strong></p></li><li><ul><li><h5 id=top观察系统软中断cpu使用率高>top观察系统软中断CPU使用率高
<a class=anchor href=#top%e8%a7%82%e5%af%9f%e7%b3%bb%e7%bb%9f%e8%bd%af%e4%b8%ad%e6%96%adcpu%e4%bd%bf%e7%94%a8%e7%8e%87%e9%ab%98>#</a></h5></li><li><h5 id=查看procsoftirqs找到变化速率较快的几种软中断>查看/proc/softirqs找到变化速率较快的几种软中断
<a class=anchor href=#%e6%9f%a5%e7%9c%8bprocsoftirqs%e6%89%be%e5%88%b0%e5%8f%98%e5%8c%96%e9%80%9f%e7%8e%87%e8%be%83%e5%bf%ab%e7%9a%84%e5%87%a0%e7%a7%8d%e8%bd%af%e4%b8%ad%e6%96%ad>#</a></h5></li><li><h5 id=sar命令发现是网络小包问题>sar命令发现是网络小包问题
<a class=anchor href=#sar%e5%91%bd%e4%bb%a4%e5%8f%91%e7%8e%b0%e6%98%af%e7%bd%91%e7%bb%9c%e5%b0%8f%e5%8c%85%e9%97%ae%e9%a2%98>#</a></h5></li><li><h5 id=tcpdump找出网络帧的类型和来源确定syn-flood攻击导致>tcpdump找出网络帧的类型和来源，确定SYN FLOOD攻击导致
<a class=anchor href=#tcpdump%e6%89%be%e5%87%ba%e7%bd%91%e7%bb%9c%e5%b8%a7%e7%9a%84%e7%b1%bb%e5%9e%8b%e5%92%8c%e6%9d%a5%e6%ba%90%e7%a1%ae%e5%ae%9asyn-flood%e6%94%bb%e5%87%bb%e5%af%bc%e8%87%b4>#</a></h5></li></ul></li></ul><h5 id=根据不同的性能指标来找合适的工具>根据不同的性能指标来找合适的工具：
<a class=anchor href=#%e6%a0%b9%e6%8d%ae%e4%b8%8d%e5%90%8c%e7%9a%84%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87%e6%9d%a5%e6%89%be%e5%90%88%e9%80%82%e7%9a%84%e5%b7%a5%e5%85%b7>#</a></h5><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/picture/202402261536136.png alt=image-20240226153633005></p><p>先运行几个支持指标较多的工具，如 top/vmstat/pidstat，根据它们的输出可以得出是哪种类型的性能问题。定位到进程后再用 strace/perf 分析调用情况进一步分析。如果是软中断导致用 /proc/softirqs</p><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/picture/202402261536865.png alt=image-20240226153643766></p><h4 id=cpu优化><strong>CPU优化</strong>
<a class=anchor href=#cpu%e4%bc%98%e5%8c%96>#</a></h4><ul><li><p><strong>应用程序优化</strong></p></li><li><ul><li><h5 id=编译器优化编译阶段开启优化选项如gcc--o2>编译器优化：编译阶段开启优化选项，如gcc -O2
<a class=anchor href=#%e7%bc%96%e8%af%91%e5%99%a8%e4%bc%98%e5%8c%96%e7%bc%96%e8%af%91%e9%98%b6%e6%ae%b5%e5%bc%80%e5%90%af%e4%bc%98%e5%8c%96%e9%80%89%e9%a1%b9%e5%a6%82gcc--o2>#</a></h5></li><li><h5 id=算法优化>算法优化
<a class=anchor href=#%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96>#</a></h5></li><li><h5 id=异步处理避免程序因为等待某个资源而一直阻塞提升程序的并发处理能力将轮询替换为事件通知>异步处理：避免程序因为等待某个资源而一直阻塞，提升程序的并发处理能力。(将轮询替换为事件通知)
<a class=anchor href=#%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e9%81%bf%e5%85%8d%e7%a8%8b%e5%ba%8f%e5%9b%a0%e4%b8%ba%e7%ad%89%e5%be%85%e6%9f%90%e4%b8%aa%e8%b5%84%e6%ba%90%e8%80%8c%e4%b8%80%e7%9b%b4%e9%98%bb%e5%a1%9e%e6%8f%90%e5%8d%87%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%b9%b6%e5%8f%91%e5%a4%84%e7%90%86%e8%83%bd%e5%8a%9b%e5%b0%86%e8%bd%ae%e8%af%a2%e6%9b%bf%e6%8d%a2%e4%b8%ba%e4%ba%8b%e4%bb%b6%e9%80%9a%e7%9f%a5>#</a></h5></li><li><h5 id=多线程代替多进程减少上下文切换成本>多线程代替多进程：减少上下文切换成本
<a class=anchor href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%bb%a3%e6%9b%bf%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%87%8f%e5%b0%91%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e6%88%90%e6%9c%ac>#</a></h5></li><li><h5 id=善用缓存加快程序处理速度>善用缓存：加快程序处理速度
<a class=anchor href=#%e5%96%84%e7%94%a8%e7%bc%93%e5%ad%98%e5%8a%a0%e5%bf%ab%e7%a8%8b%e5%ba%8f%e5%a4%84%e7%90%86%e9%80%9f%e5%ba%a6>#</a></h5></li></ul></li><li><p><strong>系统优化</strong></p></li><li><ul><li><h5 id=cpu绑定将进程绑定要1个多个cpu上提高cpu缓存命中率减少cpu调度带来的上下文切换>CPU绑定：将进程绑定要1个/多个CPU上，提高CPU缓存命中率，减少CPU调度带来的上下文切换
<a class=anchor href=#cpu%e7%bb%91%e5%ae%9a%e5%b0%86%e8%bf%9b%e7%a8%8b%e7%bb%91%e5%ae%9a%e8%a6%811%e4%b8%aa%e5%a4%9a%e4%b8%aacpu%e4%b8%8a%e6%8f%90%e9%ab%98cpu%e7%bc%93%e5%ad%98%e5%91%bd%e4%b8%ad%e7%8e%87%e5%87%8f%e5%b0%91cpu%e8%b0%83%e5%ba%a6%e5%b8%a6%e6%9d%a5%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>#</a></h5></li><li><h5 id=cpu独占cpu亲和性机制来分配进程>CPU独占：CPU亲和性机制来分配进程
<a class=anchor href=#cpu%e7%8b%ac%e5%8d%a0cpu%e4%ba%b2%e5%92%8c%e6%80%a7%e6%9c%ba%e5%88%b6%e6%9d%a5%e5%88%86%e9%85%8d%e8%bf%9b%e7%a8%8b>#</a></h5></li><li><h5 id=优先级调整使用nice适当降低非核心应用的优先级>优先级调整：使用nice适当降低非核心应用的优先级
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e8%b0%83%e6%95%b4%e4%bd%bf%e7%94%a8nice%e9%80%82%e5%bd%93%e9%99%8d%e4%bd%8e%e9%9d%9e%e6%a0%b8%e5%bf%83%e5%ba%94%e7%94%a8%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7>#</a></h5></li><li><h5 id=为进程设置资源显示-cgroups设置使用上限防止由某个应用自身问题耗尽系统资源>为进程设置资源显示: cgroups设置使用上限，防止由某个应用自身问题耗尽系统资源
<a class=anchor href=#%e4%b8%ba%e8%bf%9b%e7%a8%8b%e8%ae%be%e7%bd%ae%e8%b5%84%e6%ba%90%e6%98%be%e7%a4%ba-cgroups%e8%ae%be%e7%bd%ae%e4%bd%bf%e7%94%a8%e4%b8%8a%e9%99%90%e9%98%b2%e6%ad%a2%e7%94%b1%e6%9f%90%e4%b8%aa%e5%ba%94%e7%94%a8%e8%87%aa%e8%ba%ab%e9%97%ae%e9%a2%98%e8%80%97%e5%b0%bd%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90>#</a></h5></li><li><h5 id=numa优化-cpu尽可能访问本地内存>NUMA优化: CPU尽可能访问本地内存
<a class=anchor href=#numa%e4%bc%98%e5%8c%96-cpu%e5%b0%bd%e5%8f%af%e8%83%bd%e8%ae%bf%e9%97%ae%e6%9c%ac%e5%9c%b0%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=中断负载均衡-irpbalance将中断处理过程自动负载均衡到各个cpu上>中断负载均衡: irpbalance，将中断处理过程自动负载均衡到各个CPU上
<a class=anchor href=#%e4%b8%ad%e6%96%ad%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1-irpbalance%e5%b0%86%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b%e8%87%aa%e5%8a%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%88%b0%e5%90%84%e4%b8%aacpu%e4%b8%8a>#</a></h5></li></ul></li><li><p><strong>TPS、QPS、系统吞吐量的区别和理解</strong></p></li><li><ul><li><h5 id=qpstps>QPS（TPS）
<a class=anchor href=#qpstps>#</a></h5></li><li><h5 id=并发数>并发数
<a class=anchor href=#%e5%b9%b6%e5%8f%91%e6%95%b0>#</a></h5></li><li><h5 id=响应时间>响应时间
<a class=anchor href=#%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4>#</a></h5></li><li><h5 id=qpstps并发数平均相应时间>QPS（TPS）=并发数/平均相应时间
<a class=anchor href=#qpstps%e5%b9%b6%e5%8f%91%e6%95%b0%e5%b9%b3%e5%9d%87%e7%9b%b8%e5%ba%94%e6%97%b6%e9%97%b4>#</a></h5></li><li><h5 id=用户请求服务器>用户请求服务器
<a class=anchor href=#%e7%94%a8%e6%88%b7%e8%af%b7%e6%b1%82%e6%9c%8d%e5%8a%a1%e5%99%a8>#</a></h5></li><li><h5 id=服务器内部处理>服务器内部处理
<a class=anchor href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%86%85%e9%83%a8%e5%a4%84%e7%90%86>#</a></h5></li><li><h5 id=服务器返回给客户>服务器返回给客户
<a class=anchor href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%bf%94%e5%9b%9e%e7%bb%99%e5%ae%a2%e6%88%b7>#</a></h5><h5 id=qps-类似-tps但是对于一个页面的访问形成一个-tps但是一次页面请求可能包含多次对服务器的请求可能计入多次-qps>QPS 类似 TPS，但是对于一个页面的访问形成一个 TPS，但是一次页面请求可能包含多次对服务器的请求，可能计入多次 QPS
<a class=anchor href=#qps-%e7%b1%bb%e4%bc%bc-tps%e4%bd%86%e6%98%af%e5%af%b9%e4%ba%8e%e4%b8%80%e4%b8%aa%e9%a1%b5%e9%9d%a2%e7%9a%84%e8%ae%bf%e9%97%ae%e5%bd%a2%e6%88%90%e4%b8%80%e4%b8%aa-tps%e4%bd%86%e6%98%af%e4%b8%80%e6%ac%a1%e9%a1%b5%e9%9d%a2%e8%af%b7%e6%b1%82%e5%8f%af%e8%83%bd%e5%8c%85%e5%90%ab%e5%a4%9a%e6%ac%a1%e5%af%b9%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e8%af%b7%e6%b1%82%e5%8f%af%e8%83%bd%e8%ae%a1%e5%85%a5%e5%a4%9a%e6%ac%a1-qps>#</a></h5></li><li><h5 id=qpsqueries-per-second每秒查询率一台服务器每秒能够响应的查询次数>QPS（Queries Per Second）每秒查询率，一台服务器每秒能够响应的查询次数.
<a class=anchor href=#qpsqueries-per-second%e6%af%8f%e7%a7%92%e6%9f%a5%e8%af%a2%e7%8e%87%e4%b8%80%e5%8f%b0%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%af%8f%e7%a7%92%e8%83%bd%e5%a4%9f%e5%93%8d%e5%ba%94%e7%9a%84%e6%9f%a5%e8%af%a2%e6%ac%a1%e6%95%b0>#</a></h5></li><li><h5 id=tpstransactions-per-second每秒事务数软件测试的结果>TPS（Transactions Per Second）每秒事务数，软件测试的结果.
<a class=anchor href=#tpstransactions-per-second%e6%af%8f%e7%a7%92%e4%ba%8b%e5%8a%a1%e6%95%b0%e8%bd%af%e4%bb%b6%e6%b5%8b%e8%af%95%e7%9a%84%e7%bb%93%e6%9e%9c>#</a></h5></li></ul></li><li><h5 id=系统吞吐量包括几个重要参数>系统吞吐量，包括几个重要参数：
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e5%90%9e%e5%90%90%e9%87%8f%e5%8c%85%e6%8b%ac%e5%87%a0%e4%b8%aa%e9%87%8d%e8%a6%81%e5%8f%82%e6%95%b0>#</a></h5></li><li><h5 id=qpstps-1>QPS(TPS)
<a class=anchor href=#qpstps-1>#</a></h5></li><li><h5 id=并发数-1>并发数
<a class=anchor href=#%e5%b9%b6%e5%8f%91%e6%95%b0-1>#</a></h5></li><li><h5 id=响应时间-1>响应时间
<a class=anchor href=#%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4-1>#</a></h5></li><li><h5 id=qpstps并发数平均相应时间-1>QPS(TPS)=并发数/平均相应时间
<a class=anchor href=#qpstps%e5%b9%b6%e5%8f%91%e6%95%b0%e5%b9%b3%e5%9d%87%e7%9b%b8%e5%ba%94%e6%97%b6%e9%97%b4-1>#</a></h5></li></ul><h3 id=内存><strong>内存</strong>
<a class=anchor href=#%e5%86%85%e5%ad%98>#</a></h3><h4 id=linux内存是怎么工作的><strong>Linux内存是怎么工作的</strong>
<a class=anchor href=#linux%e5%86%85%e5%ad%98%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84>#</a></h4><h5 id=内存映射><strong>内存映射</strong>
<a class=anchor href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84>#</a></h5><h5 id=大多数计算机用的主存都是动态随机访问内存dram只有内核才可以直接访问物理内存linux内核给每个进程提供了一个独立的虚拟地址空间并且这个地址空间是连续的这样进程就可以很方便的访问内存虚拟内存>大多数计算机用的主存都是动态随机访问内存(DRAM)，只有内核才可以直接访问物理内存。Linux内核给每个进程提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样进程就可以很方便的访问内存(虚拟内存)。
<a class=anchor href=#%e5%a4%a7%e5%a4%9a%e6%95%b0%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%94%a8%e7%9a%84%e4%b8%bb%e5%ad%98%e9%83%bd%e6%98%af%e5%8a%a8%e6%80%81%e9%9a%8f%e6%9c%ba%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98dram%e5%8f%aa%e6%9c%89%e5%86%85%e6%a0%b8%e6%89%8d%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e8%ae%bf%e9%97%ae%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98linux%e5%86%85%e6%a0%b8%e7%bb%99%e6%af%8f%e4%b8%aa%e8%bf%9b%e7%a8%8b%e6%8f%90%e4%be%9b%e4%ba%86%e4%b8%80%e4%b8%aa%e7%8b%ac%e7%ab%8b%e7%9a%84%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%b9%b6%e4%b8%94%e8%bf%99%e4%b8%aa%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e6%98%af%e8%bf%9e%e7%bb%ad%e7%9a%84%e8%bf%99%e6%a0%b7%e8%bf%9b%e7%a8%8b%e5%b0%b1%e5%8f%af%e4%bb%a5%e5%be%88%e6%96%b9%e4%be%bf%e7%9a%84%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98>#</a></h5><h5 id=虚拟地址空间的内部分为内核空间和用户空间两部分不同字长的处理器地址空间的范围不同32位系统内核空间占用1g用户空间占3g64位系统内核空间和用户空间都是128t分别占内存空间的最高和最低处中间部分为未定义>虚拟地址空间的内部分为内核空间和用户空间两部分，不同字长的处理器地址空间的范围不同。32位系统内核空间占用1G，用户空间占3G。64位系统内核空间和用户空间都是128T，分别占内存空间的最高和最低处，中间部分为未定义。
<a class=anchor href=#%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e7%9a%84%e5%86%85%e9%83%a8%e5%88%86%e4%b8%ba%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%92%8c%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e4%b8%a4%e9%83%a8%e5%88%86%e4%b8%8d%e5%90%8c%e5%ad%97%e9%95%bf%e7%9a%84%e5%a4%84%e7%90%86%e5%99%a8%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e7%9a%84%e8%8c%83%e5%9b%b4%e4%b8%8d%e5%90%8c32%e4%bd%8d%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%8d%a0%e7%94%a81g%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e5%8d%a03g64%e4%bd%8d%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%92%8c%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e9%83%bd%e6%98%af128t%e5%88%86%e5%88%ab%e5%8d%a0%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%9a%84%e6%9c%80%e9%ab%98%e5%92%8c%e6%9c%80%e4%bd%8e%e5%a4%84%e4%b8%ad%e9%97%b4%e9%83%a8%e5%88%86%e4%b8%ba%e6%9c%aa%e5%ae%9a%e4%b9%89>#</a></h5><h5 id=并不是所有的虚拟内存都会分配物理内存只有实际使用的才会分配后的物理内存通过内存映射管理为了完成内存映射内核为每个进程都维护了一个页表记录虚拟地址和物理地址的映射关系页表实际存储在cpu的内存管理单元mmu中处理器可以直接通过硬件找出要访问的内存>并不是所有的虚拟内存都会分配物理内存，只有实际使用的才会。分配后的物理内存通过内存映射管理。为了完成内存映射，内核为每个进程都维护了一个页表，记录虚拟地址和物理地址的映射关系。页表实际存储在CPU的内存管理单元MMU中，处理器可以直接通过硬件找出要访问的内存。
<a class=anchor href=#%e5%b9%b6%e4%b8%8d%e6%98%af%e6%89%80%e6%9c%89%e7%9a%84%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e9%83%bd%e4%bc%9a%e5%88%86%e9%85%8d%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e5%8f%aa%e6%9c%89%e5%ae%9e%e9%99%85%e4%bd%bf%e7%94%a8%e7%9a%84%e6%89%8d%e4%bc%9a%e5%88%86%e9%85%8d%e5%90%8e%e7%9a%84%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e9%80%9a%e8%bf%87%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e7%ae%a1%e7%90%86%e4%b8%ba%e4%ba%86%e5%ae%8c%e6%88%90%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e5%86%85%e6%a0%b8%e4%b8%ba%e6%af%8f%e4%b8%aa%e8%bf%9b%e7%a8%8b%e9%83%bd%e7%bb%b4%e6%8a%a4%e4%ba%86%e4%b8%80%e4%b8%aa%e9%a1%b5%e8%a1%a8%e8%ae%b0%e5%bd%95%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e5%92%8c%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%9a%84%e6%98%a0%e5%b0%84%e5%85%b3%e7%b3%bb%e9%a1%b5%e8%a1%a8%e5%ae%9e%e9%99%85%e5%ad%98%e5%82%a8%e5%9c%a8cpu%e7%9a%84%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%8d%95%e5%85%83mmu%e4%b8%ad%e5%a4%84%e7%90%86%e5%99%a8%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e9%80%9a%e8%bf%87%e7%a1%ac%e4%bb%b6%e6%89%be%e5%87%ba%e8%a6%81%e8%ae%bf%e9%97%ae%e7%9a%84%e5%86%85%e5%ad%98>#</a></h5><h5 id=当进程访问的虚拟地址在页表中查不到时系统会产生一个缺页异常进入内核空间分配物理内存更新进程页表再返回用户空间恢复进程的运行>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存，更新进程页表，再返回用户空间恢复进程的运行。
<a class=anchor href=#%e5%bd%93%e8%bf%9b%e7%a8%8b%e8%ae%bf%e9%97%ae%e7%9a%84%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e5%9c%a8%e9%a1%b5%e8%a1%a8%e4%b8%ad%e6%9f%a5%e4%b8%8d%e5%88%b0%e6%97%b6%e7%b3%bb%e7%bb%9f%e4%bc%9a%e4%ba%a7%e7%94%9f%e4%b8%80%e4%b8%aa%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8%e8%bf%9b%e5%85%a5%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e6%9b%b4%e6%96%b0%e8%bf%9b%e7%a8%8b%e9%a1%b5%e8%a1%a8%e5%86%8d%e8%bf%94%e5%9b%9e%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e6%81%a2%e5%a4%8d%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%bf%90%e8%a1%8c>#</a></h5><h5 id=mmu以页为单位管理内存页大小4kb为了解决页表项过多问题linux提供了多级页表和hugepage的机制>MMU以页为单位管理内存，页大小4KB。为了解决页表项过多问题Linux提供了多级页表和HugePage的机制。
<a class=anchor href=#mmu%e4%bb%a5%e9%a1%b5%e4%b8%ba%e5%8d%95%e4%bd%8d%e7%ae%a1%e7%90%86%e5%86%85%e5%ad%98%e9%a1%b5%e5%a4%a7%e5%b0%8f4kb%e4%b8%ba%e4%ba%86%e8%a7%a3%e5%86%b3%e9%a1%b5%e8%a1%a8%e9%a1%b9%e8%bf%87%e5%a4%9a%e9%97%ae%e9%a2%98linux%e6%8f%90%e4%be%9b%e4%ba%86%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8%e5%92%8chugepage%e7%9a%84%e6%9c%ba%e5%88%b6>#</a></h5><h5 id=虚拟内存空间分布><strong>虚拟内存空间分布</strong>
<a class=anchor href=#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e5%b8%83>#</a></h5><h5 id=用户空间内存从低到高是五种不同的内存段>用户空间内存从低到高是五种不同的内存段：
<a class=anchor href=#%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e5%86%85%e5%ad%98%e4%bb%8e%e4%bd%8e%e5%88%b0%e9%ab%98%e6%98%af%e4%ba%94%e7%a7%8d%e4%b8%8d%e5%90%8c%e7%9a%84%e5%86%85%e5%ad%98%e6%ae%b5>#</a></h5><ul><li><h5 id=只读段-代码和常量等><strong>只读段</strong> 代码和常量等
<a class=anchor href=#%e5%8f%aa%e8%af%bb%e6%ae%b5-%e4%bb%a3%e7%a0%81%e5%92%8c%e5%b8%b8%e9%87%8f%e7%ad%89>#</a></h5></li><li><h5 id=数据段-全局变量等><strong>数据段</strong> 全局变量等
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%ae%b5-%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e7%ad%89>#</a></h5></li><li><h5 id=堆-动态分配的内存从低地址开始向上增长>堆 动态分配的内存，从低地址开始向上增长
<a class=anchor href=#%e5%a0%86-%e5%8a%a8%e6%80%81%e5%88%86%e9%85%8d%e7%9a%84%e5%86%85%e5%ad%98%e4%bb%8e%e4%bd%8e%e5%9c%b0%e5%9d%80%e5%bc%80%e5%a7%8b%e5%90%91%e4%b8%8a%e5%a2%9e%e9%95%bf>#</a></h5></li><li><h5 id=文件映射-动态库共享内存等从高地址开始向下增长><strong>文件映射</strong> 动态库、共享内存等，从高地址开始向下增长
<a class=anchor href=#%e6%96%87%e4%bb%b6%e6%98%a0%e5%b0%84-%e5%8a%a8%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e7%ad%89%e4%bb%8e%e9%ab%98%e5%9c%b0%e5%9d%80%e5%bc%80%e5%a7%8b%e5%90%91%e4%b8%8b%e5%a2%9e%e9%95%bf>#</a></h5></li><li><h5 id=栈-包括局部变量和函数调用的上下文等栈的大小是固定的一般8mb><strong>栈</strong> 包括局部变量和函数调用的上下文等，栈的大小是固定的。一般8MB
<a class=anchor href=#%e6%a0%88-%e5%8c%85%e6%8b%ac%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%92%8c%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e7%ad%89%e6%a0%88%e7%9a%84%e5%a4%a7%e5%b0%8f%e6%98%af%e5%9b%ba%e5%ae%9a%e7%9a%84%e4%b8%80%e8%88%ac8mb>#</a></h5></li></ul><h5 id=内存分配与回收><strong>内存分配与回收</strong>
<a class=anchor href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6>#</a></h5><p><strong>分配</strong></p><h5 id=malloc-对应到系统调用上有两种实现方式>malloc 对应到系统调用上有两种实现方式：
<a class=anchor href=#malloc-%e5%af%b9%e5%ba%94%e5%88%b0%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e4%b8%8a%e6%9c%89%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f>#</a></h5><ul><li><h5 id=brk-针对小块内存128k通过移动堆顶位置来分配>brk() 针对小块内存(&lt;128K)，通过移动堆顶位置来分配。
<a class=anchor href=#brk-%e9%92%88%e5%af%b9%e5%b0%8f%e5%9d%97%e5%86%85%e5%ad%98128k%e9%80%9a%e8%bf%87%e7%a7%bb%e5%8a%a8%e5%a0%86%e9%a1%b6%e4%bd%8d%e7%bd%ae%e6%9d%a5%e5%88%86%e9%85%8d>#</a></h5><h5 id=内存释放后不立即归还内存而是被缓存起来>内存释放后不立即归还内存，而是被缓存起来。
<a class=anchor href=#%e5%86%85%e5%ad%98%e9%87%8a%e6%94%be%e5%90%8e%e4%b8%8d%e7%ab%8b%e5%8d%b3%e5%bd%92%e8%bf%98%e5%86%85%e5%ad%98%e8%80%8c%e6%98%af%e8%a2%ab%e7%bc%93%e5%ad%98%e8%b5%b7%e6%9d%a5>#</a></h5></li><li><h5 id=mmap针对大块内存128k直接用内存映射来分配即在文件映射段找一块空闲内存分配>mmap()针对大块内存(>128K)，直接用内存映射来分配，即在文件映射段找一块空闲内存分配。
<a class=anchor href=#mmap%e9%92%88%e5%af%b9%e5%a4%a7%e5%9d%97%e5%86%85%e5%ad%98128k%e7%9b%b4%e6%8e%a5%e7%94%a8%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%9d%a5%e5%88%86%e9%85%8d%e5%8d%b3%e5%9c%a8%e6%96%87%e4%bb%b6%e6%98%a0%e5%b0%84%e6%ae%b5%e6%89%be%e4%b8%80%e5%9d%97%e7%a9%ba%e9%97%b2%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d>#</a></h5></li></ul><h5 id=前者的缓存可以减少缺页异常的发生提高内存访问效率但是由于内存没有归还系统在内存工作繁忙时频繁的内存分配释放会造成内存碎片>前者的缓存可以减少缺页异常的发生，提高内存访问效率。但是由于内存没有归还系统，在内存工作繁忙时，频繁的内存分配/释放会造成内存碎片。
<a class=anchor href=#%e5%89%8d%e8%80%85%e7%9a%84%e7%bc%93%e5%ad%98%e5%8f%af%e4%bb%a5%e5%87%8f%e5%b0%91%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8%e7%9a%84%e5%8f%91%e7%94%9f%e6%8f%90%e9%ab%98%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae%e6%95%88%e7%8e%87%e4%bd%86%e6%98%af%e7%94%b1%e4%ba%8e%e5%86%85%e5%ad%98%e6%b2%a1%e6%9c%89%e5%bd%92%e8%bf%98%e7%b3%bb%e7%bb%9f%e5%9c%a8%e5%86%85%e5%ad%98%e5%b7%a5%e4%bd%9c%e7%b9%81%e5%bf%99%e6%97%b6%e9%a2%91%e7%b9%81%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e9%87%8a%e6%94%be%e4%bc%9a%e9%80%a0%e6%88%90%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87>#</a></h5><h5 id=后者在释放时直接归还系统所以每次mmap都会发生缺页异常>后者在释放时直接归还系统，所以每次mmap都会发生缺页异常。
<a class=anchor href=#%e5%90%8e%e8%80%85%e5%9c%a8%e9%87%8a%e6%94%be%e6%97%b6%e7%9b%b4%e6%8e%a5%e5%bd%92%e8%bf%98%e7%b3%bb%e7%bb%9f%e6%89%80%e4%bb%a5%e6%af%8f%e6%ac%a1mmap%e9%83%bd%e4%bc%9a%e5%8f%91%e7%94%9f%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8>#</a></h5><h5 id=在内存工作繁忙时频繁内存分配会导致大量缺页异常使内核管理负担增加>在内存工作繁忙时，频繁内存分配会导致大量缺页异常，使内核管理负担增加。
<a class=anchor href=#%e5%9c%a8%e5%86%85%e5%ad%98%e5%b7%a5%e4%bd%9c%e7%b9%81%e5%bf%99%e6%97%b6%e9%a2%91%e7%b9%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%bc%9a%e5%af%bc%e8%87%b4%e5%a4%a7%e9%87%8f%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8%e4%bd%bf%e5%86%85%e6%a0%b8%e7%ae%a1%e7%90%86%e8%b4%9f%e6%8b%85%e5%a2%9e%e5%8a%a0>#</a></h5><h5 id=上述两种调用并没有真正分配内存这些内存只有在首次访问时才通过缺页异常进入内核中由内核来分配>上述两种调用并没有真正分配内存，这些内存只有在首次访问时，才通过缺页异常进入内核中，由内核来分配。
<a class=anchor href=#%e4%b8%8a%e8%bf%b0%e4%b8%a4%e7%a7%8d%e8%b0%83%e7%94%a8%e5%b9%b6%e6%b2%a1%e6%9c%89%e7%9c%9f%e6%ad%a3%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e8%bf%99%e4%ba%9b%e5%86%85%e5%ad%98%e5%8f%aa%e6%9c%89%e5%9c%a8%e9%a6%96%e6%ac%a1%e8%ae%bf%e9%97%ae%e6%97%b6%e6%89%8d%e9%80%9a%e8%bf%87%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8%e8%bf%9b%e5%85%a5%e5%86%85%e6%a0%b8%e4%b8%ad%e7%94%b1%e5%86%85%e6%a0%b8%e6%9d%a5%e5%88%86%e9%85%8d>#</a></h5><p><strong>回收</strong></p><h5 id=内存紧张时系统通过以下方式来回收内存>内存紧张时，系统通过以下方式来回收内存：
<a class=anchor href=#%e5%86%85%e5%ad%98%e7%b4%a7%e5%bc%a0%e6%97%b6%e7%b3%bb%e7%bb%9f%e9%80%9a%e8%bf%87%e4%bb%a5%e4%b8%8b%e6%96%b9%e5%bc%8f%e6%9d%a5%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98>#</a></h5><ul><li><h5 id=回收缓存lru算法回收最近最少使用的内存页面>回收缓存：LRU算法回收最近最少使用的内存页面；
<a class=anchor href=#%e5%9b%9e%e6%94%b6%e7%bc%93%e5%ad%98lru%e7%ae%97%e6%b3%95%e5%9b%9e%e6%94%b6%e6%9c%80%e8%bf%91%e6%9c%80%e5%b0%91%e4%bd%bf%e7%94%a8%e7%9a%84%e5%86%85%e5%ad%98%e9%a1%b5%e9%9d%a2>#</a></h5></li><li><h5 id=回收不常访问内存把不常用的内存通过交换分区写入磁盘>回收不常访问内存：把不常用的内存通过交换分区写入磁盘
<a class=anchor href=#%e5%9b%9e%e6%94%b6%e4%b8%8d%e5%b8%b8%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98%e6%8a%8a%e4%b8%8d%e5%b8%b8%e7%94%a8%e7%9a%84%e5%86%85%e5%ad%98%e9%80%9a%e8%bf%87%e4%ba%a4%e6%8d%a2%e5%88%86%e5%8c%ba%e5%86%99%e5%85%a5%e7%a3%81%e7%9b%98>#</a></h5></li><li><h5 id=杀死进程oom内核保护机制进程消耗内存越大-oom_score-越大占用-cpu-越多-oom_score-越小可以通过-proc-手动调整-oom_adj>杀死进程：OOM内核保护机制（进程消耗内存越大 oom_score 越大，占用 CPU 越多 oom_score 越小，可以通过 /proc 手动调整 oom_adj）
<a class=anchor href=#%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8boom%e5%86%85%e6%a0%b8%e4%bf%9d%e6%8a%a4%e6%9c%ba%e5%88%b6%e8%bf%9b%e7%a8%8b%e6%b6%88%e8%80%97%e5%86%85%e5%ad%98%e8%b6%8a%e5%a4%a7-oom_score-%e8%b6%8a%e5%a4%a7%e5%8d%a0%e7%94%a8-cpu-%e8%b6%8a%e5%a4%9a-oom_score-%e8%b6%8a%e5%b0%8f%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87-proc-%e6%89%8b%e5%8a%a8%e8%b0%83%e6%95%b4-oom_adj>#</a></h5></li><li></li></ul><pre tabindex=0><code>echo -16 &gt; /proc/$(pidof XXX)/oom_adj
</code></pre><p><strong>如何查看内存使用情况</strong></p><h5 id=free来查看整个系统的内存使用情况>free来查看整个系统的内存使用情况
<a class=anchor href=#free%e6%9d%a5%e6%9f%a5%e7%9c%8b%e6%95%b4%e4%b8%aa%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5>#</a></h5><h5 id=topps来查看某个进程的内存使用情况>top/ps来查看某个进程的内存使用情况
<a class=anchor href=#topps%e6%9d%a5%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%aa%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5>#</a></h5><ul><li><h5 id=virt-进程的虚拟内存大小>VIRT 进程的虚拟内存大小
<a class=anchor href=#virt-%e8%bf%9b%e7%a8%8b%e7%9a%84%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f>#</a></h5></li><li><h5 id=res-常驻内存的大小即进程实际使用的物理内存大小不包括swap和共享内存>RES 常驻内存的大小，即进程实际使用的物理内存大小，不包括swap和共享内存
<a class=anchor href=#res-%e5%b8%b8%e9%a9%bb%e5%86%85%e5%ad%98%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%8d%b3%e8%bf%9b%e7%a8%8b%e5%ae%9e%e9%99%85%e4%bd%bf%e7%94%a8%e7%9a%84%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f%e4%b8%8d%e5%8c%85%e6%8b%acswap%e5%92%8c%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=shr-共享内存大小与其他进程共享的内存加载的动态链接库以及程序代码段>SHR 共享内存大小，与其他进程共享的内存，加载的动态链接库以及程序代码段
<a class=anchor href=#shr-%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f%e4%b8%8e%e5%85%b6%e4%bb%96%e8%bf%9b%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%86%85%e5%ad%98%e5%8a%a0%e8%bd%bd%e7%9a%84%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93%e4%bb%a5%e5%8f%8a%e7%a8%8b%e5%ba%8f%e4%bb%a3%e7%a0%81%e6%ae%b5>#</a></h5></li><li><h5 id=mem-进程使用物理内存占系统总内存的百分比>%MEM 进程使用物理内存占系统总内存的百分比
<a class=anchor href=#mem-%e8%bf%9b%e7%a8%8b%e4%bd%bf%e7%94%a8%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e5%8d%a0%e7%b3%bb%e7%bb%9f%e6%80%bb%e5%86%85%e5%ad%98%e7%9a%84%e7%99%be%e5%88%86%e6%af%94>#</a></h5></li></ul><blockquote><p>怎样理解内存中的Buffer和Cache？</p></blockquote><h5 id=buffer是对磁盘数据的缓存cache是对文件数据的缓存它们既会用在读请求也会用在写请求中>buffer是对磁盘数据的缓存，cache是对文件数据的缓存，它们既会用在读请求也会用在写请求中
<a class=anchor href=#buffer%e6%98%af%e5%af%b9%e7%a3%81%e7%9b%98%e6%95%b0%e6%8d%ae%e7%9a%84%e7%bc%93%e5%ad%98cache%e6%98%af%e5%af%b9%e6%96%87%e4%bb%b6%e6%95%b0%e6%8d%ae%e7%9a%84%e7%bc%93%e5%ad%98%e5%ae%83%e4%bb%ac%e6%97%a2%e4%bc%9a%e7%94%a8%e5%9c%a8%e8%af%bb%e8%af%b7%e6%b1%82%e4%b9%9f%e4%bc%9a%e7%94%a8%e5%9c%a8%e5%86%99%e8%af%b7%e6%b1%82%e4%b8%ad>#</a></h5><blockquote><p>如何利用系统缓存优化程序的运行效率</p></blockquote><p><strong>缓存命中率</strong></p><h5 id=缓存命中率是指直接通过缓存获取数据的请求次数占所有请求次数的百分比命中率越高说明缓存带来的收益越高应用程序的性能也就越好>缓存命中率是指直接通过缓存获取数据的请求次数，占所有请求次数的百分比。命中率越高说明缓存带来的收益越高，应用程序的性能也就越好。
<a class=anchor href=#%e7%bc%93%e5%ad%98%e5%91%bd%e4%b8%ad%e7%8e%87%e6%98%af%e6%8c%87%e7%9b%b4%e6%8e%a5%e9%80%9a%e8%bf%87%e7%bc%93%e5%ad%98%e8%8e%b7%e5%8f%96%e6%95%b0%e6%8d%ae%e7%9a%84%e8%af%b7%e6%b1%82%e6%ac%a1%e6%95%b0%e5%8d%a0%e6%89%80%e6%9c%89%e8%af%b7%e6%b1%82%e6%ac%a1%e6%95%b0%e7%9a%84%e7%99%be%e5%88%86%e6%af%94%e5%91%bd%e4%b8%ad%e7%8e%87%e8%b6%8a%e9%ab%98%e8%af%b4%e6%98%8e%e7%bc%93%e5%ad%98%e5%b8%a6%e6%9d%a5%e7%9a%84%e6%94%b6%e7%9b%8a%e8%b6%8a%e9%ab%98%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%80%a7%e8%83%bd%e4%b9%9f%e5%b0%b1%e8%b6%8a%e5%a5%bd>#</a></h5><h5 id=安装bcc包后可以通过cachestat和cachetop来监测缓存的读写命中情况>安装bcc包后可以通过cachestat和cachetop来监测缓存的读写命中情况。
<a class=anchor href=#%e5%ae%89%e8%a3%85bcc%e5%8c%85%e5%90%8e%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87cachestat%e5%92%8ccachetop%e6%9d%a5%e7%9b%91%e6%b5%8b%e7%bc%93%e5%ad%98%e7%9a%84%e8%af%bb%e5%86%99%e5%91%bd%e4%b8%ad%e6%83%85%e5%86%b5>#</a></h5><h5 id=安装pcstat后可以查看文件在内存中的缓存大小以及缓存比例>安装pcstat后可以查看文件在内存中的缓存大小以及缓存比例
<a class=anchor href=#%e5%ae%89%e8%a3%85pcstat%e5%90%8e%e5%8f%af%e4%bb%a5%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e7%bc%93%e5%ad%98%e5%a4%a7%e5%b0%8f%e4%bb%a5%e5%8f%8a%e7%bc%93%e5%ad%98%e6%af%94%e4%be%8b>#</a></h5><pre tabindex=0><code>#首先安装Goexport GOPATH=~/goexport PATH=~/go/bin:$PATHgo get golang.org/x/sys/unixgo ge github.com/tobert/pcstat/pcstat
</code></pre><p><strong>dd缓存加速</strong></p><pre tabindex=0><code>dd if=/dev/sda1 of=file bs=1M count=512 #生产一个512MB的临时文件echo 3 &gt; /proc/sys/vm/drop_caches #清理缓存pcstat file #确定刚才生成文件不在系统缓存中，此时cached和percent都是0cachetop 5dd if=file of=/dev/null bs=1M #测试文件读取速度#此时文件读取性能为30+MB/s，查看cachetop结果发现并不是所有的读都落在磁盘上，读缓存命中率只有50%。dd if=file of=/dev/null bs=1M #重复上述读文件测试#此时文件读取性能为4+GB/s，读缓存命中率为100%pcstat file #查看文件file的缓存情况，100%全部缓存
</code></pre><p><strong>O_DIRECT选项绕过系统缓存</strong></p><pre tabindex=0><code>cachetop 5sudo docker run --privileged --name=app -itd feisky/app:io-directsudo docker logs app #确认案例启动成功#实验结果表明每读32MB数据都要花0.9s，且cachetop输出中显示1024次缓存全部命中
</code></pre><h5 id=但是凭感觉可知如果缓存命中读速度不应如此慢读次数时1024页大小为4k五秒的时间内读取了10244kb数据即每秒08mb和结果中32mb相差较大说明该案例没有充分利用缓存怀疑系统调用设置了直接io标志绕过系统缓存因此接下来观察系统调用>但是凭感觉可知如果缓存命中读速度不应如此慢，读次数时1024，页大小为4K，五秒的时间内读取了1024*4KB数据，即每秒0.8MB，和结果中32MB相差较大。说明该案例没有充分利用缓存，怀疑系统调用设置了直接I/O标志绕过系统缓存。因此接下来观察系统调用。
<a class=anchor href=#%e4%bd%86%e6%98%af%e5%87%ad%e6%84%9f%e8%a7%89%e5%8f%af%e7%9f%a5%e5%a6%82%e6%9e%9c%e7%bc%93%e5%ad%98%e5%91%bd%e4%b8%ad%e8%af%bb%e9%80%9f%e5%ba%a6%e4%b8%8d%e5%ba%94%e5%a6%82%e6%ad%a4%e6%85%a2%e8%af%bb%e6%ac%a1%e6%95%b0%e6%97%b61024%e9%a1%b5%e5%a4%a7%e5%b0%8f%e4%b8%ba4k%e4%ba%94%e7%a7%92%e7%9a%84%e6%97%b6%e9%97%b4%e5%86%85%e8%af%bb%e5%8f%96%e4%ba%8610244kb%e6%95%b0%e6%8d%ae%e5%8d%b3%e6%af%8f%e7%a7%9208mb%e5%92%8c%e7%bb%93%e6%9e%9c%e4%b8%ad32mb%e7%9b%b8%e5%b7%ae%e8%be%83%e5%a4%a7%e8%af%b4%e6%98%8e%e8%af%a5%e6%a1%88%e4%be%8b%e6%b2%a1%e6%9c%89%e5%85%85%e5%88%86%e5%88%a9%e7%94%a8%e7%bc%93%e5%ad%98%e6%80%80%e7%96%91%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e8%ae%be%e7%bd%ae%e4%ba%86%e7%9b%b4%e6%8e%a5io%e6%a0%87%e5%bf%97%e7%bb%95%e8%bf%87%e7%b3%bb%e7%bb%9f%e7%bc%93%e5%ad%98%e5%9b%a0%e6%ad%a4%e6%8e%a5%e4%b8%8b%e6%9d%a5%e8%a7%82%e5%af%9f%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8>#</a></h5><pre tabindex=0><code>strace -p $(pgrep app)#strace 结果可以看到openat打开磁盘分区/dev/sdb1，传入参数为O_RDONLY|O_DIRECT
</code></pre><h5 id=这就解释了为什么读32mb数据那么慢直接从磁盘读写肯定远远慢于缓存找出问题后我们再看案例的源代码发现flags中指定了直接io标志删除该选项后重跑验证性能变化>这就解释了为什么读32MB数据那么慢，直接从磁盘读写肯定远远慢于缓存。找出问题后我们再看案例的源代码发现flags中指定了直接IO标志。删除该选项后重跑，验证性能变化。
<a class=anchor href=#%e8%bf%99%e5%b0%b1%e8%a7%a3%e9%87%8a%e4%ba%86%e4%b8%ba%e4%bb%80%e4%b9%88%e8%af%bb32mb%e6%95%b0%e6%8d%ae%e9%82%a3%e4%b9%88%e6%85%a2%e7%9b%b4%e6%8e%a5%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e5%86%99%e8%82%af%e5%ae%9a%e8%bf%9c%e8%bf%9c%e6%85%a2%e4%ba%8e%e7%bc%93%e5%ad%98%e6%89%be%e5%87%ba%e9%97%ae%e9%a2%98%e5%90%8e%e6%88%91%e4%bb%ac%e5%86%8d%e7%9c%8b%e6%a1%88%e4%be%8b%e7%9a%84%e6%ba%90%e4%bb%a3%e7%a0%81%e5%8f%91%e7%8e%b0flags%e4%b8%ad%e6%8c%87%e5%ae%9a%e4%ba%86%e7%9b%b4%e6%8e%a5io%e6%a0%87%e5%bf%97%e5%88%a0%e9%99%a4%e8%af%a5%e9%80%89%e9%a1%b9%e5%90%8e%e9%87%8d%e8%b7%91%e9%aa%8c%e8%af%81%e6%80%a7%e8%83%bd%e5%8f%98%e5%8c%96>#</a></h5><h4 id=内存泄漏如何定位和处理><strong>内存泄漏，如何定位和处理？</strong>
<a class=anchor href=#%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%a6%82%e4%bd%95%e5%ae%9a%e4%bd%8d%e5%92%8c%e5%a4%84%e7%90%86>#</a></h4><h5 id=对应用程序来说动态内存的分配和回收是核心又复杂的一个逻辑功能模块管理内存的过程中会发生各种各样的事故>对应用程序来说，动态内存的分配和回收是核心又复杂的一个逻辑功能模块。管理内存的过程中会发生各种各样的“事故”：
<a class=anchor href=#%e5%af%b9%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e6%9d%a5%e8%af%b4%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%9e%e6%94%b6%e6%98%af%e6%a0%b8%e5%bf%83%e5%8f%88%e5%a4%8d%e6%9d%82%e7%9a%84%e4%b8%80%e4%b8%aa%e9%80%bb%e8%be%91%e5%8a%9f%e8%83%bd%e6%a8%a1%e5%9d%97%e7%ae%a1%e7%90%86%e5%86%85%e5%ad%98%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%bc%9a%e5%8f%91%e7%94%9f%e5%90%84%e7%a7%8d%e5%90%84%e6%a0%b7%e7%9a%84%e4%ba%8b%e6%95%85>#</a></h5><ul><li><h5 id=没正确回收分配的内存导致了泄漏>没正确回收分配的内存，导致了泄漏
<a class=anchor href=#%e6%b2%a1%e6%ad%a3%e7%a1%ae%e5%9b%9e%e6%94%b6%e5%88%86%e9%85%8d%e7%9a%84%e5%86%85%e5%ad%98%e5%af%bc%e8%87%b4%e4%ba%86%e6%b3%84%e6%bc%8f>#</a></h5></li><li><h5 id=访问的是已分配内存边界外的地址导致程序异常退出>访问的是已分配内存边界外的地址，导致程序异常退出
<a class=anchor href=#%e8%ae%bf%e9%97%ae%e7%9a%84%e6%98%af%e5%b7%b2%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e8%be%b9%e7%95%8c%e5%a4%96%e7%9a%84%e5%9c%b0%e5%9d%80%e5%af%bc%e8%87%b4%e7%a8%8b%e5%ba%8f%e5%bc%82%e5%b8%b8%e9%80%80%e5%87%ba>#</a></h5></li></ul><p><strong>内存的分配与回收</strong></p><h5 id=虚拟内存分布从低到高分别是只读段数据段堆内存映射段栈五部分其中会导致内存泄漏的是>虚拟内存分布从低到高分别是只读段，数据段，堆，内存映射段，栈五部分。其中会导致内存泄漏的是：
<a class=anchor href=#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%88%86%e5%b8%83%e4%bb%8e%e4%bd%8e%e5%88%b0%e9%ab%98%e5%88%86%e5%88%ab%e6%98%af%e5%8f%aa%e8%af%bb%e6%ae%b5%e6%95%b0%e6%8d%ae%e6%ae%b5%e5%a0%86%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%ae%b5%e6%a0%88%e4%ba%94%e9%83%a8%e5%88%86%e5%85%b6%e4%b8%ad%e4%bc%9a%e5%af%bc%e8%87%b4%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e7%9a%84%e6%98%af>#</a></h5><ul><li><h5 id=堆由应用程序自己来分配和管理除非程序退出这些堆内存不会被系统自动释放>堆：由应用程序自己来分配和管理，除非程序退出这些堆内存不会被系统自动释放。
<a class=anchor href=#%e5%a0%86%e7%94%b1%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e8%87%aa%e5%b7%b1%e6%9d%a5%e5%88%86%e9%85%8d%e5%92%8c%e7%ae%a1%e7%90%86%e9%99%a4%e9%9d%9e%e7%a8%8b%e5%ba%8f%e9%80%80%e5%87%ba%e8%bf%99%e4%ba%9b%e5%a0%86%e5%86%85%e5%ad%98%e4%b8%8d%e4%bc%9a%e8%a2%ab%e7%b3%bb%e7%bb%9f%e8%87%aa%e5%8a%a8%e9%87%8a%e6%94%be>#</a></h5></li><li><h5 id=内存映射段包括动态链接库和共享内存其中共享内存由程序自动分配和管理>内存映射段：包括动态链接库和共享内存，其中共享内存由程序自动分配和管理
<a class=anchor href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%ae%b5%e5%8c%85%e6%8b%ac%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93%e5%92%8c%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e5%85%b6%e4%b8%ad%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e7%94%b1%e7%a8%8b%e5%ba%8f%e8%87%aa%e5%8a%a8%e5%88%86%e9%85%8d%e5%92%8c%e7%ae%a1%e7%90%86>#</a></h5></li></ul><h5 id=内存泄漏的危害比较大这些忘记释放的内存不仅应用程序自己不能访问系统也不能把它们再次分配给其他应用内存泄漏不断累积甚至会耗尽系统内存>内存泄漏的危害比较大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用。内存泄漏不断累积甚至会耗尽系统内存。
<a class=anchor href=#%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e7%9a%84%e5%8d%b1%e5%ae%b3%e6%af%94%e8%be%83%e5%a4%a7%e8%bf%99%e4%ba%9b%e5%bf%98%e8%ae%b0%e9%87%8a%e6%94%be%e7%9a%84%e5%86%85%e5%ad%98%e4%b8%8d%e4%bb%85%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e8%87%aa%e5%b7%b1%e4%b8%8d%e8%83%bd%e8%ae%bf%e9%97%ae%e7%b3%bb%e7%bb%9f%e4%b9%9f%e4%b8%8d%e8%83%bd%e6%8a%8a%e5%ae%83%e4%bb%ac%e5%86%8d%e6%ac%a1%e5%88%86%e9%85%8d%e7%bb%99%e5%85%b6%e4%bb%96%e5%ba%94%e7%94%a8%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e4%b8%8d%e6%96%ad%e7%b4%af%e7%a7%af%e7%94%9a%e8%87%b3%e4%bc%9a%e8%80%97%e5%b0%bd%e7%b3%bb%e7%bb%9f%e5%86%85%e5%ad%98>#</a></h5><p><strong>如何检测内存泄漏</strong></p><h5 id=预先安装systatdockerbcc>预先安装systat，docker，bcc
<a class=anchor href=#%e9%a2%84%e5%85%88%e5%ae%89%e8%a3%85systatdockerbcc>#</a></h5><pre tabindex=0><code>sudo docker run --name=app -itd feisky/app:mem-leaksudo docker logs appvmstat 3
</code></pre><h5 id=可以看到free在不断下降buffer和cache基本保持不变说明系统的内存一致在升高但并不能说明存在内存泄漏此时可以通过memleak工具来跟踪系统或进程的内存分配释放请求>可以看到free在不断下降，buffer和cache基本保持不变。说明系统的内存一致在升高。但并不能说明存在内存泄漏。此时可以通过memleak工具来跟踪系统或进程的内存分配/释放请求
<a class=anchor href=#%e5%8f%af%e4%bb%a5%e7%9c%8b%e5%88%b0free%e5%9c%a8%e4%b8%8d%e6%96%ad%e4%b8%8b%e9%99%8dbuffer%e5%92%8ccache%e5%9f%ba%e6%9c%ac%e4%bf%9d%e6%8c%81%e4%b8%8d%e5%8f%98%e8%af%b4%e6%98%8e%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%86%85%e5%ad%98%e4%b8%80%e8%87%b4%e5%9c%a8%e5%8d%87%e9%ab%98%e4%bd%86%e5%b9%b6%e4%b8%8d%e8%83%bd%e8%af%b4%e6%98%8e%e5%ad%98%e5%9c%a8%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e6%ad%a4%e6%97%b6%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87memleak%e5%b7%a5%e5%85%b7%e6%9d%a5%e8%b7%9f%e8%b8%aa%e7%b3%bb%e7%bb%9f%e6%88%96%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e9%87%8a%e6%94%be%e8%af%b7%e6%b1%82>#</a></h5><pre tabindex=0><code>/usr/share/bcc/tools/memleak -a -p $(pidof app)
</code></pre><h5 id=从-memleak-输出可以看到应用在不停地分配内存并且这些分配的地址并没有被回收通过调用栈看到是-fibonacci-函数分配的内存没有释放定位到源码后查看源码来修复增加内存释放函数即可>从 memleak 输出可以看到，应用在不停地分配内存，并且这些分配的地址并没有被回收。通过调用栈看到是 fibonacci 函数分配的内存没有释放。定位到源码后查看源码来修复增加内存释放函数即可。
<a class=anchor href=#%e4%bb%8e-memleak-%e8%be%93%e5%87%ba%e5%8f%af%e4%bb%a5%e7%9c%8b%e5%88%b0%e5%ba%94%e7%94%a8%e5%9c%a8%e4%b8%8d%e5%81%9c%e5%9c%b0%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e5%b9%b6%e4%b8%94%e8%bf%99%e4%ba%9b%e5%88%86%e9%85%8d%e7%9a%84%e5%9c%b0%e5%9d%80%e5%b9%b6%e6%b2%a1%e6%9c%89%e8%a2%ab%e5%9b%9e%e6%94%b6%e9%80%9a%e8%bf%87%e8%b0%83%e7%94%a8%e6%a0%88%e7%9c%8b%e5%88%b0%e6%98%af-fibonacci-%e5%87%bd%e6%95%b0%e5%88%86%e9%85%8d%e7%9a%84%e5%86%85%e5%ad%98%e6%b2%a1%e6%9c%89%e9%87%8a%e6%94%be%e5%ae%9a%e4%bd%8d%e5%88%b0%e6%ba%90%e7%a0%81%e5%90%8e%e6%9f%a5%e7%9c%8b%e6%ba%90%e7%a0%81%e6%9d%a5%e4%bf%ae%e5%a4%8d%e5%a2%9e%e5%8a%a0%e5%86%85%e5%ad%98%e9%87%8a%e6%94%be%e5%87%bd%e6%95%b0%e5%8d%b3%e5%8f%af>#</a></h5><h4 id=为什么系统的-swap-变高><strong>为什么系统的 Swap 变高</strong>
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%b3%bb%e7%bb%9f%e7%9a%84-swap-%e5%8f%98%e9%ab%98>#</a></h4><h5 id=系统内存资源紧张时通过内存回收和oom杀死进程来解决其中可回收内存包括>系统内存资源紧张时通过内存回收和OOM杀死进程来解决。其中可回收内存包括：
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e5%86%85%e5%ad%98%e8%b5%84%e6%ba%90%e7%b4%a7%e5%bc%a0%e6%97%b6%e9%80%9a%e8%bf%87%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6%e5%92%8coom%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8b%e6%9d%a5%e8%a7%a3%e5%86%b3%e5%85%b6%e4%b8%ad%e5%8f%af%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98%e5%8c%85%e6%8b%ac>#</a></h5><ul><li><h5 id=缓存缓冲区属于可回收资源在文件管理中通常叫做文件页>缓存/缓冲区，属于可回收资源，在文件管理中通常叫做文件页
<a class=anchor href=#%e7%bc%93%e5%ad%98%e7%bc%93%e5%86%b2%e5%8c%ba%e5%b1%9e%e4%ba%8e%e5%8f%af%e5%9b%9e%e6%94%b6%e8%b5%84%e6%ba%90%e5%9c%a8%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86%e4%b8%ad%e9%80%9a%e5%b8%b8%e5%8f%ab%e5%81%9a%e6%96%87%e4%bb%b6%e9%a1%b5>#</a></h5></li><li><ul><li><h5 id=在应用程序中通过fsync将脏页同步到磁盘>在应用程序中通过fsync将脏页同步到磁盘
<a class=anchor href=#%e5%9c%a8%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%b8%ad%e9%80%9a%e8%bf%87fsync%e5%b0%86%e8%84%8f%e9%a1%b5%e5%90%8c%e6%ad%a5%e5%88%b0%e7%a3%81%e7%9b%98>#</a></h5></li><li><h5 id=交给系统内核线程pdflush负责这些脏页的刷新>交给系统，内核线程pdflush负责这些脏页的刷新
<a class=anchor href=#%e4%ba%a4%e7%bb%99%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e7%ba%bf%e7%a8%8bpdflush%e8%b4%9f%e8%b4%a3%e8%bf%99%e4%ba%9b%e8%84%8f%e9%a1%b5%e7%9a%84%e5%88%b7%e6%96%b0>#</a></h5></li><li><h5 id=被应用程序修改过暂时没写入磁盘的数据脏页要先写入磁盘然后才能内存释放>被应用程序修改过暂时没写入磁盘的数据(脏页)，要先写入磁盘然后才能内存释放
<a class=anchor href=#%e8%a2%ab%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%bf%ae%e6%94%b9%e8%bf%87%e6%9a%82%e6%97%b6%e6%b2%a1%e5%86%99%e5%85%a5%e7%a3%81%e7%9b%98%e7%9a%84%e6%95%b0%e6%8d%ae%e8%84%8f%e9%a1%b5%e8%a6%81%e5%85%88%e5%86%99%e5%85%a5%e7%a3%81%e7%9b%98%e7%84%b6%e5%90%8e%e6%89%8d%e8%83%bd%e5%86%85%e5%ad%98%e9%87%8a%e6%94%be>#</a></h5></li></ul></li><li><h5 id=内存映射获取的文件映射页也可以被释放掉下次访问时从文件重新读取>内存映射获取的文件映射页，也可以被释放掉，下次访问时从文件重新读取
<a class=anchor href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e8%8e%b7%e5%8f%96%e7%9a%84%e6%96%87%e4%bb%b6%e6%98%a0%e5%b0%84%e9%a1%b5%e4%b9%9f%e5%8f%af%e4%bb%a5%e8%a2%ab%e9%87%8a%e6%94%be%e6%8e%89%e4%b8%8b%e6%ac%a1%e8%ae%bf%e9%97%ae%e6%97%b6%e4%bb%8e%e6%96%87%e4%bb%b6%e9%87%8d%e6%96%b0%e8%af%bb%e5%8f%96>#</a></h5></li></ul><h5 id=对于程序自动分配的堆内存也就是我们在内存管理中的匿名页虽然这些内存不能直接释放但是-linux-提供了-swap-机制将不常访问的内存写入到磁盘来释放内存再次访问时从磁盘读取到内存即可>对于程序自动分配的堆内存，也就是我们在内存管理中的匿名页，虽然这些内存不能直接释放，但是 Linux 提供了 Swap 机制将不常访问的内存写入到磁盘来释放内存，再次访问时从磁盘读取到内存即可。
<a class=anchor href=#%e5%af%b9%e4%ba%8e%e7%a8%8b%e5%ba%8f%e8%87%aa%e5%8a%a8%e5%88%86%e9%85%8d%e7%9a%84%e5%a0%86%e5%86%85%e5%ad%98%e4%b9%9f%e5%b0%b1%e6%98%af%e6%88%91%e4%bb%ac%e5%9c%a8%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%b8%ad%e7%9a%84%e5%8c%bf%e5%90%8d%e9%a1%b5%e8%99%bd%e7%84%b6%e8%bf%99%e4%ba%9b%e5%86%85%e5%ad%98%e4%b8%8d%e8%83%bd%e7%9b%b4%e6%8e%a5%e9%87%8a%e6%94%be%e4%bd%86%e6%98%af-linux-%e6%8f%90%e4%be%9b%e4%ba%86-swap-%e6%9c%ba%e5%88%b6%e5%b0%86%e4%b8%8d%e5%b8%b8%e8%ae%bf%e9%97%ae%e7%9a%84%e5%86%85%e5%ad%98%e5%86%99%e5%85%a5%e5%88%b0%e7%a3%81%e7%9b%98%e6%9d%a5%e9%87%8a%e6%94%be%e5%86%85%e5%ad%98%e5%86%8d%e6%ac%a1%e8%ae%bf%e9%97%ae%e6%97%b6%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e5%8f%96%e5%88%b0%e5%86%85%e5%ad%98%e5%8d%b3%e5%8f%af>#</a></h5><h5 id=swap原理><strong>Swap原理</strong>
<a class=anchor href=#swap%e5%8e%9f%e7%90%86>#</a></h5><h5 id=swap本质就是把一块磁盘空间或者一个本地文件当作内存来使用包括换入和换出两个过程>Swap本质就是把一块磁盘空间或者一个本地文件当作内存来使用，包括换入和换出两个过程：
<a class=anchor href=#swap%e6%9c%ac%e8%b4%a8%e5%b0%b1%e6%98%af%e6%8a%8a%e4%b8%80%e5%9d%97%e7%a3%81%e7%9b%98%e7%a9%ba%e9%97%b4%e6%88%96%e8%80%85%e4%b8%80%e4%b8%aa%e6%9c%ac%e5%9c%b0%e6%96%87%e4%bb%b6%e5%bd%93%e4%bd%9c%e5%86%85%e5%ad%98%e6%9d%a5%e4%bd%bf%e7%94%a8%e5%8c%85%e6%8b%ac%e6%8d%a2%e5%85%a5%e5%92%8c%e6%8d%a2%e5%87%ba%e4%b8%a4%e4%b8%aa%e8%bf%87%e7%a8%8b>#</a></h5><ul><li><h5 id=换出将进程暂时不用的内存数据存储到磁盘中并释放这些内存>换出：将进程暂时不用的内存数据存储到磁盘中，并释放这些内存
<a class=anchor href=#%e6%8d%a2%e5%87%ba%e5%b0%86%e8%bf%9b%e7%a8%8b%e6%9a%82%e6%97%b6%e4%b8%8d%e7%94%a8%e7%9a%84%e5%86%85%e5%ad%98%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e5%88%b0%e7%a3%81%e7%9b%98%e4%b8%ad%e5%b9%b6%e9%87%8a%e6%94%be%e8%bf%99%e4%ba%9b%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=换入进程再次访问内存时将它们从磁盘读到内存中>换入：进程再次访问内存时，将它们从磁盘读到内存中
<a class=anchor href=#%e6%8d%a2%e5%85%a5%e8%bf%9b%e7%a8%8b%e5%86%8d%e6%ac%a1%e8%ae%bf%e9%97%ae%e5%86%85%e5%ad%98%e6%97%b6%e5%b0%86%e5%ae%83%e4%bb%ac%e4%bb%8e%e7%a3%81%e7%9b%98%e8%af%bb%e5%88%b0%e5%86%85%e5%ad%98%e4%b8%ad>#</a></h5></li></ul><p><strong>Linux如何衡量内存资源是否紧张？</strong></p><ul><li><h5 id=直接内存回收新的大块内存分配请求但剩余内存不足>直接内存回收新的大块内存分配请求，但剩余内存不足。
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6%e6%96%b0%e7%9a%84%e5%a4%a7%e5%9d%97%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e8%af%b7%e6%b1%82%e4%bd%86%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98%e4%b8%8d%e8%b6%b3>#</a></h5><h5 id=此时系统会回收一部分内存>此时系统会回收一部分内存；
<a class=anchor href=#%e6%ad%a4%e6%97%b6%e7%b3%bb%e7%bb%9f%e4%bc%9a%e5%9b%9e%e6%94%b6%e4%b8%80%e9%83%a8%e5%88%86%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=kswapd0-内核线程定期回收内存>kswapd0 内核线程定期回收内存。
<a class=anchor href=#kswapd0-%e5%86%85%e6%a0%b8%e7%ba%bf%e7%a8%8b%e5%ae%9a%e6%9c%9f%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98>#</a></h5><h5 id=为了衡量内存使用情况定义了pages_minpages_lowpages_high-三个阈值并根据其来进行内存的回收操作>为了衡量内存使用情况，定义了pages_min，pages_low，pages_high 三个阈值，并根据其来进行内存的回收操作。
<a class=anchor href=#%e4%b8%ba%e4%ba%86%e8%a1%a1%e9%87%8f%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5%e5%ae%9a%e4%b9%89%e4%ba%86pages_minpages_lowpages_high-%e4%b8%89%e4%b8%aa%e9%98%88%e5%80%bc%e5%b9%b6%e6%a0%b9%e6%8d%ae%e5%85%b6%e6%9d%a5%e8%bf%9b%e8%a1%8c%e5%86%85%e5%ad%98%e7%9a%84%e5%9b%9e%e6%94%b6%e6%93%8d%e4%bd%9c>#</a></h5></li><li><ul><li><h5 id=剩余内存--pages_min进程可用内存耗尽了只有内核才可以分配内存>剩余内存 &lt; pages_min，进程可用内存耗尽了，只有内核才可以分配内存
<a class=anchor href=#%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98--pages_min%e8%bf%9b%e7%a8%8b%e5%8f%af%e7%94%a8%e5%86%85%e5%ad%98%e8%80%97%e5%b0%bd%e4%ba%86%e5%8f%aa%e6%9c%89%e5%86%85%e6%a0%b8%e6%89%8d%e5%8f%af%e4%bb%a5%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=pages_min--剩余内存--pages_low内存压力较大kswapd0执行内存回收直到剩余内存--pages_high>pages_min &lt; 剩余内存 &lt; pages_low,内存压力较大，kswapd0执行内存回收，直到剩余内存 > pages_high
<a class=anchor href=#pages_min--%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98--pages_low%e5%86%85%e5%ad%98%e5%8e%8b%e5%8a%9b%e8%be%83%e5%a4%a7kswapd0%e6%89%a7%e8%a1%8c%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6%e7%9b%b4%e5%88%b0%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98--pages_high>#</a></h5></li><li><h5 id=pages_low--剩余内存--pages_high内存有一定压力但可以满足新内存请求>pages_low &lt; 剩余内存 &lt; pages_high，内存有一定压力，但可以满足新内存请求
<a class=anchor href=#pages_low--%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98--pages_high%e5%86%85%e5%ad%98%e6%9c%89%e4%b8%80%e5%ae%9a%e5%8e%8b%e5%8a%9b%e4%bd%86%e5%8f%af%e4%bb%a5%e6%bb%a1%e8%b6%b3%e6%96%b0%e5%86%85%e5%ad%98%e8%af%b7%e6%b1%82>#</a></h5></li><li><h5 id=剩余内存--pages_high说明剩余内存较多无内存压力>剩余内存 > pages_high，说明剩余内存较多，无内存压力
<a class=anchor href=#%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98--pages_high%e8%af%b4%e6%98%8e%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98%e8%be%83%e5%a4%9a%e6%97%a0%e5%86%85%e5%ad%98%e5%8e%8b%e5%8a%9b>#</a></h5><h5 id=pages_low--pages_min-5--4-pages_high--pages_min-3--2>pages_low = pages_min 5 / 4 pages_high = pages_min 3 / 2
<a class=anchor href=#pages_low--pages_min-5--4-pages_high--pages_min-3--2>#</a></h5></li></ul></li></ul><h5 id=numa-与-swap><strong>NUMA 与 SWAP</strong>
<a class=anchor href=#numa-%e4%b8%8e-swap>#</a></h5><h5 id=很多情况下系统剩余内存较多但-swap-依旧升高这是由于处理器的-numa-架构>很多情况下系统剩余内存较多，但 SWAP 依旧升高，这是由于处理器的 NUMA 架构。
<a class=anchor href=#%e5%be%88%e5%a4%9a%e6%83%85%e5%86%b5%e4%b8%8b%e7%b3%bb%e7%bb%9f%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98%e8%be%83%e5%a4%9a%e4%bd%86-swap-%e4%be%9d%e6%97%a7%e5%8d%87%e9%ab%98%e8%bf%99%e6%98%af%e7%94%b1%e4%ba%8e%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84-numa-%e6%9e%b6%e6%9e%84>#</a></h5><h5 id=在numa架构下多个处理器划分到不同的-node每个node都拥有自己的本地内存空间在分析内存的使用时应该针对每个node单独分析>在NUMA架构下多个处理器划分到不同的 Node，每个Node都拥有自己的本地内存空间。在分析内存的使用时应该针对每个Node单独分析
<a class=anchor href=#%e5%9c%a8numa%e6%9e%b6%e6%9e%84%e4%b8%8b%e5%a4%9a%e4%b8%aa%e5%a4%84%e7%90%86%e5%99%a8%e5%88%92%e5%88%86%e5%88%b0%e4%b8%8d%e5%90%8c%e7%9a%84-node%e6%af%8f%e4%b8%aanode%e9%83%bd%e6%8b%a5%e6%9c%89%e8%87%aa%e5%b7%b1%e7%9a%84%e6%9c%ac%e5%9c%b0%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%9c%a8%e5%88%86%e6%9e%90%e5%86%85%e5%ad%98%e7%9a%84%e4%bd%bf%e7%94%a8%e6%97%b6%e5%ba%94%e8%af%a5%e9%92%88%e5%af%b9%e6%af%8f%e4%b8%aanode%e5%8d%95%e7%8b%ac%e5%88%86%e6%9e%90>#</a></h5><ul><li></li></ul><pre tabindex=0><code>numactl --hardware #查看处理器在Node的分布情况，以及每个Node的内存使用情况
</code></pre><h5 id=内存三个阈值可以通过-proczoneinfo-来查看该文件中还包括活跃和非活跃的匿名页文件页数>内存三个阈值可以通过 /proc/zoneinfo 来查看，该文件中还包括活跃和非活跃的匿名页/文件页数。
<a class=anchor href=#%e5%86%85%e5%ad%98%e4%b8%89%e4%b8%aa%e9%98%88%e5%80%bc%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87-proczoneinfo-%e6%9d%a5%e6%9f%a5%e7%9c%8b%e8%af%a5%e6%96%87%e4%bb%b6%e4%b8%ad%e8%bf%98%e5%8c%85%e6%8b%ac%e6%b4%bb%e8%b7%83%e5%92%8c%e9%9d%9e%e6%b4%bb%e8%b7%83%e7%9a%84%e5%8c%bf%e5%90%8d%e9%a1%b5%e6%96%87%e4%bb%b6%e9%a1%b5%e6%95%b0>#</a></h5><h5 id=当某个node内存不足时系统可以从其他node寻找空闲资源也可以从本地内存中回收内存通过procsysvmzone_raclaim_mode来调整>当某个Node内存不足时，系统可以从其他Node寻找空闲资源，也可以从本地内存中回收内存。通过/proc/sys/vm/zone_raclaim_mode来调整。
<a class=anchor href=#%e5%bd%93%e6%9f%90%e4%b8%aanode%e5%86%85%e5%ad%98%e4%b8%8d%e8%b6%b3%e6%97%b6%e7%b3%bb%e7%bb%9f%e5%8f%af%e4%bb%a5%e4%bb%8e%e5%85%b6%e4%bb%96node%e5%af%bb%e6%89%be%e7%a9%ba%e9%97%b2%e8%b5%84%e6%ba%90%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%bb%8e%e6%9c%ac%e5%9c%b0%e5%86%85%e5%ad%98%e4%b8%ad%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98%e9%80%9a%e8%bf%87procsysvmzone_raclaim_mode%e6%9d%a5%e8%b0%83%e6%95%b4>#</a></h5><ul><li><h5 id=0表示既可以从其他node寻找空闲资源也可以从本地回收内存>0表示既可以从其他Node寻找空闲资源，也可以从本地回收内存
<a class=anchor href=#0%e8%a1%a8%e7%a4%ba%e6%97%a2%e5%8f%af%e4%bb%a5%e4%bb%8e%e5%85%b6%e4%bb%96node%e5%af%bb%e6%89%be%e7%a9%ba%e9%97%b2%e8%b5%84%e6%ba%90%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%bb%8e%e6%9c%ac%e5%9c%b0%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=124-表示只回收本地内存2表示可以会回脏数据回收内存4表示可以用swap方式回收内存>1，2，4 表示只回收本地内存，2表示可以会回脏数据回收内存，4表示可以用Swap方式回收内存。
<a class=anchor href=#124-%e8%a1%a8%e7%a4%ba%e5%8f%aa%e5%9b%9e%e6%94%b6%e6%9c%ac%e5%9c%b0%e5%86%85%e5%ad%982%e8%a1%a8%e7%a4%ba%e5%8f%af%e4%bb%a5%e4%bc%9a%e5%9b%9e%e8%84%8f%e6%95%b0%e6%8d%ae%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%984%e8%a1%a8%e7%a4%ba%e5%8f%af%e4%bb%a5%e7%94%a8swap%e6%96%b9%e5%bc%8f%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98>#</a></h5></li></ul><h5 id=swappiness><strong>swappiness</strong>
<a class=anchor href=#swappiness>#</a></h5><h5 id=在实际回收过程中linux根据-procsysvmswapiness-选项来调整使用swap的积极程度从-0-100数值越大越积极使用-swap即更倾向于回收匿名页数值越小越消极使用-swap即更倾向于回收文件页>在实际回收过程中Linux根据 /proc/sys/vm/swapiness 选项来调整使用Swap的积极程度，从 0-100，数值越大越积极使用 Swap，即更倾向于回收匿名页；数值越小越消极使用 Swap，即更倾向于回收文件页。
<a class=anchor href=#%e5%9c%a8%e5%ae%9e%e9%99%85%e5%9b%9e%e6%94%b6%e8%bf%87%e7%a8%8b%e4%b8%adlinux%e6%a0%b9%e6%8d%ae-procsysvmswapiness-%e9%80%89%e9%a1%b9%e6%9d%a5%e8%b0%83%e6%95%b4%e4%bd%bf%e7%94%a8swap%e7%9a%84%e7%a7%af%e6%9e%81%e7%a8%8b%e5%ba%a6%e4%bb%8e-0-100%e6%95%b0%e5%80%bc%e8%b6%8a%e5%a4%a7%e8%b6%8a%e7%a7%af%e6%9e%81%e4%bd%bf%e7%94%a8-swap%e5%8d%b3%e6%9b%b4%e5%80%be%e5%90%91%e4%ba%8e%e5%9b%9e%e6%94%b6%e5%8c%bf%e5%90%8d%e9%a1%b5%e6%95%b0%e5%80%bc%e8%b6%8a%e5%b0%8f%e8%b6%8a%e6%b6%88%e6%9e%81%e4%bd%bf%e7%94%a8-swap%e5%8d%b3%e6%9b%b4%e5%80%be%e5%90%91%e4%ba%8e%e5%9b%9e%e6%94%b6%e6%96%87%e4%bb%b6%e9%a1%b5>#</a></h5><h5 id=注意这只是调整-swap-积极程度的权重即使设置为0当剩余内存文件页小于页高阈值时还是会发生-swap>注意：这只是调整 Swap 积极程度的权重，即使设置为0，当剩余内存+文件页小于页高阈值时，还是会发生 Swap。
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e8%bf%99%e5%8f%aa%e6%98%af%e8%b0%83%e6%95%b4-swap-%e7%a7%af%e6%9e%81%e7%a8%8b%e5%ba%a6%e7%9a%84%e6%9d%83%e9%87%8d%e5%8d%b3%e4%bd%bf%e8%ae%be%e7%bd%ae%e4%b8%ba0%e5%bd%93%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98%e6%96%87%e4%bb%b6%e9%a1%b5%e5%b0%8f%e4%ba%8e%e9%a1%b5%e9%ab%98%e9%98%88%e5%80%bc%e6%97%b6%e8%bf%98%e6%98%af%e4%bc%9a%e5%8f%91%e7%94%9f-swap>#</a></h5><p><strong>Swap升高时如何定位分析</strong></p><pre tabindex=0><code>free #首先通过free查看swap使用情况，若swap=0表示未配置Swap#先创建并开启swapfallocate -l 8G /mnt/swapfilechmod 600 /mnt/swapfilemkswap /mnt/swapfileswapon /mnt/swapfile
free #再次执行free确保Swap配置成功
dd if=/dev/sda1 of=/dev/null bs=1G count=2048 #模拟大文件读取sar -r -S 1  #查看内存各个指标变化 -r内存 -S swap#根据结果可以看出，%memused在不断增长，剩余内存kbmemfress不断减少，缓冲区kbbuffers不断增大，由此可知剩余内存不断分配给了缓冲区#一段时间之后，剩余内存很小，而缓冲区占用了大部分内存。此时Swap使用之间增大，缓冲区和剩余内存只在小范围波动
停下sar命令cachetop5 #观察缓存#可以看到dd进程读写只有50%的命中率，未命中数为4w+页，说明正式dd进程导致缓冲区使用升高watch -d grep -A 15 ‘Normal’ /proc/zoneinfo #观察内存指标变化#发现升级内存在一个小范围不停的波动，低于页低阈值时会突然增大到一个大于页高阈值的值
</code></pre><h5 id=说明剩余内存和缓冲区的波动变化正是由于内存回收和缓存再次分配的循环往复有时候-swap-用的多有时候缓冲区波动更多此时查看-swappiness-值为60是一个相对中和的配置系统会根据实际运行情况来选去合适的回收类型>说明剩余内存和缓冲区的波动变化正是由于内存回收和缓存再次分配的循环往复。有时候 Swap 用的多，有时候缓冲区波动更多。此时查看 swappiness 值为60，是一个相对中和的配置，系统会根据实际运行情况来选去合适的回收类型。
<a class=anchor href=#%e8%af%b4%e6%98%8e%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98%e5%92%8c%e7%bc%93%e5%86%b2%e5%8c%ba%e7%9a%84%e6%b3%a2%e5%8a%a8%e5%8f%98%e5%8c%96%e6%ad%a3%e6%98%af%e7%94%b1%e4%ba%8e%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6%e5%92%8c%e7%bc%93%e5%ad%98%e5%86%8d%e6%ac%a1%e5%88%86%e9%85%8d%e7%9a%84%e5%be%aa%e7%8e%af%e5%be%80%e5%a4%8d%e6%9c%89%e6%97%b6%e5%80%99-swap-%e7%94%a8%e7%9a%84%e5%a4%9a%e6%9c%89%e6%97%b6%e5%80%99%e7%bc%93%e5%86%b2%e5%8c%ba%e6%b3%a2%e5%8a%a8%e6%9b%b4%e5%a4%9a%e6%ad%a4%e6%97%b6%e6%9f%a5%e7%9c%8b-swappiness-%e5%80%bc%e4%b8%ba60%e6%98%af%e4%b8%80%e4%b8%aa%e7%9b%b8%e5%af%b9%e4%b8%ad%e5%92%8c%e7%9a%84%e9%85%8d%e7%bd%ae%e7%b3%bb%e7%bb%9f%e4%bc%9a%e6%a0%b9%e6%8d%ae%e5%ae%9e%e9%99%85%e8%bf%90%e8%a1%8c%e6%83%85%e5%86%b5%e6%9d%a5%e9%80%89%e5%8e%bb%e5%90%88%e9%80%82%e7%9a%84%e5%9b%9e%e6%94%b6%e7%b1%bb%e5%9e%8b>#</a></h5><p><strong>如何“快准狠”找到系统内存存在的问题</strong></p><p><strong>内存性能指标</strong></p><ul><li><h5 id=系统内存指标>系统内存指标
<a class=anchor href=#%e7%b3%bb%e7%bb%9f%e5%86%85%e5%ad%98%e6%8c%87%e6%a0%87>#</a></h5></li><li><h5 id=已用内存剩余内存>已用内存/剩余内存
<a class=anchor href=#%e5%b7%b2%e7%94%a8%e5%86%85%e5%ad%98%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=共享内存-tmpfs实现>共享内存 （tmpfs实现）
<a class=anchor href=#%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98-tmpfs%e5%ae%9e%e7%8e%b0>#</a></h5></li><li><h5 id=可用内存包括剩余内存和可回收内存>可用内存：包括剩余内存和可回收内存
<a class=anchor href=#%e5%8f%af%e7%94%a8%e5%86%85%e5%ad%98%e5%8c%85%e6%8b%ac%e5%89%a9%e4%bd%99%e5%86%85%e5%ad%98%e5%92%8c%e5%8f%af%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=缓存磁盘读取文件的页缓存slab分配器中的可回收部分>缓存：磁盘读取文件的页缓存，slab分配器中的可回收部分
<a class=anchor href=#%e7%bc%93%e5%ad%98%e7%a3%81%e7%9b%98%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6%e7%9a%84%e9%a1%b5%e7%bc%93%e5%ad%98slab%e5%88%86%e9%85%8d%e5%99%a8%e4%b8%ad%e7%9a%84%e5%8f%af%e5%9b%9e%e6%94%b6%e9%83%a8%e5%88%86>#</a></h5></li><li><h5 id=缓冲区原始磁盘块的临时存储缓存将要写入磁盘的数据>缓冲区：原始磁盘块的临时存储，缓存将要写入磁盘的数据
<a class=anchor href=#%e7%bc%93%e5%86%b2%e5%8c%ba%e5%8e%9f%e5%a7%8b%e7%a3%81%e7%9b%98%e5%9d%97%e7%9a%84%e4%b8%b4%e6%97%b6%e5%ad%98%e5%82%a8%e7%bc%93%e5%ad%98%e5%b0%86%e8%a6%81%e5%86%99%e5%85%a5%e7%a3%81%e7%9b%98%e7%9a%84%e6%95%b0%e6%8d%ae>#</a></h5></li></ul><p><strong>进程内存指标</strong></p><ul><li><h5 id=虚拟内存5大部分>虚拟内存：5大部分
<a class=anchor href=#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%985%e5%a4%a7%e9%83%a8%e5%88%86>#</a></h5></li><li><h5 id=常驻内存进程实际使用的物理内存不包括swap和共享内存>常驻内存：进程实际使用的物理内存，不包括Swap和共享内存
<a class=anchor href=#%e5%b8%b8%e9%a9%bb%e5%86%85%e5%ad%98%e8%bf%9b%e7%a8%8b%e5%ae%9e%e9%99%85%e4%bd%bf%e7%94%a8%e7%9a%84%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e4%b8%8d%e5%8c%85%e6%8b%acswap%e5%92%8c%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98>#</a></h5></li><li><h5 id=共享内存与其他进程共享的内存以及动态链接库和程序的代码段>共享内存：与其他进程共享的内存，以及动态链接库和程序的代码段
<a class=anchor href=#%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e4%b8%8e%e5%85%b6%e4%bb%96%e8%bf%9b%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%86%85%e5%ad%98%e4%bb%a5%e5%8f%8a%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93%e5%92%8c%e7%a8%8b%e5%ba%8f%e7%9a%84%e4%bb%a3%e7%a0%81%e6%ae%b5>#</a></h5></li><li><h5 id=swap-内存通过swap换出到磁盘的内存>Swap 内存：通过Swap换出到磁盘的内存
<a class=anchor href=#swap-%e5%86%85%e5%ad%98%e9%80%9a%e8%bf%87swap%e6%8d%a2%e5%87%ba%e5%88%b0%e7%a3%81%e7%9b%98%e7%9a%84%e5%86%85%e5%ad%98>#</a></h5></li></ul><p><strong>缺页异常</strong></p><ul><li>可以直接从物理内存中分配，次缺页异常</li><li>需要磁盘 IO 介入（如 Swap），主缺页异常。此时内存访问会慢很多</li></ul><h5 id=内存性能工具><strong>内存性能工具</strong>
<a class=anchor href=#%e5%86%85%e5%ad%98%e6%80%a7%e8%83%bd%e5%b7%a5%e5%85%b7>#</a></h5><p>根据不同的性能指标来找合适的工具：</p><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/picture/202402261539987.png alt=image-20240226153944860></p><p>内存分析工具包含的性能指标：</p><p><img src=https://picture-base.oss-cn-hangzhou.aliyuncs.com/picture/202402261539512.png alt=image-20240226153956399></p><h4 id=如何迅速分析内存的性能瓶颈><strong>如何迅速分析内存的性能瓶颈</strong>
<a class=anchor href=#%e5%a6%82%e4%bd%95%e8%bf%85%e9%80%9f%e5%88%86%e6%9e%90%e5%86%85%e5%ad%98%e7%9a%84%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88>#</a></h4><p>通常先运行几个覆盖面比较大的性能工具，如 free，top，vmstat，pidstat 等</p><ul><li>先用 free 和 top 查看系统整体内存使用情况</li><li>再用 vmstat 和 pidstat，查看一段时间的趋势，从而判断内存问题的类型</li><li>最后进行详细分析，比如内存分配分析，缓存/缓冲区分析，具体进程的内存使用分析等</li></ul><p><strong>常见的优化思路：</strong></p><ul><li>最好禁止 Swap，若必须开启则尽量降低 swappiness 的值</li><li>减少内存的动态分配，如可以用内存池，HugePage 等</li><li>尽量使用缓存和缓冲区来访问数据。如用堆栈明确声明内存空间来存储需要缓存的数据，或者用 Redis 外部缓存组件来优化数据的访问</li><li>cgroups 等方式来限制进程的内存使用情况，确保系统内存不被异常进程耗尽</li><li>/proc/pid/oom_adj 调整核心应用的 oom_score，保证即使内存紧张核心应用也不会被OOM杀死</li></ul><p><strong>vmstat 使用详解</strong></p><p>vmstat 命令是最常见的 Linux/Unix 监控工具，可以展现给定时间间隔的服务器的状态值，包括服务器的 CPU 使用率，内存使用，虚拟内存交换情况，IO读写情况。可以看到整个机器的 CPU，内存，IO 的使用情况，而不是单单看到各个进程的 CPU 使用率和内存使用率（使用场景不一样）。</p><pre tabindex=0><code>vmstat 2
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1379064 282244 11537528    0    0     3   104    0    0  3  0 97  0  0
 0  0      0 1372716 282244 11537544    0    0     0    24 4893 8947  1  0 98  0  0
 0  0      0 1373404 282248 11537544    0    0     0    96 5105 9278  2  0 98  0  0
 0  0      0 1374168 282248 11537556    0    0     0     0 5001 9208  1  0 99  0  0
 0  0      0 1376948 282248 11537564    0    0     0    80 5176 9388  2  0 98  0  0
 0  0      0 1379356 282256 11537580    0    0     0   202 5474 9519  2  0 98  0  0
 1  0      0 1368376 282256 11543696    0    0     0     0 5894 8940 12  0 88  0  0
 1  0      0 1371936 282256 11539240    0    0     0 10554 6176 9481 14  1 85  1  0
 1  0      0 1366184 282260 11542292    0    0     0  7456 6102 9983  7  1 91  0  0
 1  0      0 1353040 282260 11556176    0    0     0 16924 7233 9578 18  1 80  1  0
 0  0      0 1359432 282260 11549124    0    0     0 12576 5495 9271  7  0 92  1  0
 0  0      0 1361744 282264 11549132    0    0     0    58 8606 15079  4  2 95  0  0
 1  0      0 1367120 282264 11549140    0    0     0     2 5716 9205  8  0 92  0  0
 0  0      0 1346580 282264 11562644    0    0     0    70 6416 9944 12  0 88  0  0
 0  0      0 1359164 282264 11550108    0    0     0  2922 4941 8969  3  0 97  0  0
 1  0      0 1353992 282264 11557044    0    0     0     0 6023 8917 15  0 84  0  0

# 结果说明
- r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。

- b 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。

- swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。

- free   空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。

- buff   Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M

- cache cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)

- si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。

- so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。

- bi  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒

- bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。

- in 每秒CPU的中断次数，包括时间中断

- cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。

- us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。

- sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。

- id 空闲CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。

- wt 等待IO CPU时间
</code></pre><p><strong>pidstat 使用详解</strong></p><h5 id=pidstat-主要用于监控全部或指定进程占用系统资源的情况如cpu内存设备io任务切换线程等>pidstat 主要用于监控全部或指定进程占用系统资源的情况，如CPU，内存、设备IO、任务切换、线程等。
<a class=anchor href=#pidstat-%e4%b8%bb%e8%a6%81%e7%94%a8%e4%ba%8e%e7%9b%91%e6%8e%a7%e5%85%a8%e9%83%a8%e6%88%96%e6%8c%87%e5%ae%9a%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8%e7%b3%bb%e7%bb%9f%e8%b5%84%e6%ba%90%e7%9a%84%e6%83%85%e5%86%b5%e5%a6%82cpu%e5%86%85%e5%ad%98%e8%ae%be%e5%a4%87io%e4%bb%bb%e5%8a%a1%e5%88%87%e6%8d%a2%e7%ba%bf%e7%a8%8b%e7%ad%89>#</a></h5><p>使用方法：</p><ul><li><h5 id=pidstat-d-interval-times-统计各个进程的io使用情况>pidstat –d interval times 统计各个进程的IO使用情况
<a class=anchor href=#pidstat-d-interval-times-%e7%bb%9f%e8%ae%a1%e5%90%84%e4%b8%aa%e8%bf%9b%e7%a8%8b%e7%9a%84io%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5>#</a></h5></li><li><h5 id=pidstat-u-interval-times-统计各个进程的cpu统计信息>pidstat –u interval times 统计各个进程的CPU统计信息
<a class=anchor href=#pidstat-u-interval-times-%e7%bb%9f%e8%ae%a1%e5%90%84%e4%b8%aa%e8%bf%9b%e7%a8%8b%e7%9a%84cpu%e7%bb%9f%e8%ae%a1%e4%bf%a1%e6%81%af>#</a></h5></li><li><h5 id=pidstat-r-interval-times-统计各个进程的内存使用信息>pidstat –r interval times 统计各个进程的内存使用信息
<a class=anchor href=#pidstat-r-interval-times-%e7%bb%9f%e8%ae%a1%e5%90%84%e4%b8%aa%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8%e4%bf%a1%e6%81%af>#</a></h5></li><li><h5 id=pidstat--w-interval-times-统计各个进程的上下文切换>pidstat -w interval times 统计各个进程的上下文切换
<a class=anchor href=#pidstat--w-interval-times-%e7%bb%9f%e8%ae%a1%e5%90%84%e4%b8%aa%e8%bf%9b%e7%a8%8b%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2>#</a></h5></li><li><h5 id=p-pid-指定pid>p PID 指定PID
<a class=anchor href=#p-pid-%e6%8c%87%e5%ae%9apid>#</a></h5></li></ul><p><strong>1、统计 IO 使用情况</strong></p><pre tabindex=0><code>pidstat -d 1 10
03:02:02 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command03:02:03 PM     0       816      0.00    918.81      0.00  jbd2/vda1-803:02:03 PM     0      1007      0.00      3.96      0.00  AliYunDun03:02:03 PM   997      7326      0.00   1904.95    918.81  java03:02:03 PM   997      8539      0.00      3.96      0.00  java03:02:03 PM     0     16066      0.00     35.64      0.00  cmagent
03:02:03 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command03:02:04 PM     0       816      0.00   1924.00      0.00  jbd2/vda1-803:02:04 PM   997      7326      0.00  11156.00   1888.00  java03:02:04 PM   997      8539      0.00      4.00      0.00  java
</code></pre><ul><li>UID</li><li>PID</li><li>kB_rd/s：每秒进程从磁盘读取的数据量 KB 单位 read from disk each second KB</li><li>kB_wr/s：每秒进程向磁盘写的数据量 KB 单位 write to disk each second KB</li><li>kB_ccwr/s：每秒进程向磁盘写入，但是被取消的数据量，This may occur when the task truncates some dirty pagecache.</li><li>iodelay：Block I/O delay，measured in clock ticks</li><li>Command：进程名 task name</li></ul><p><strong>2、统计 CPU 使用情况</strong></p><pre tabindex=0><code># 统计CPUpidstat -u 1 1003:03:33 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command03:03:34 PM     0      2321    3.96    0.00    0.00    3.96     0  ansible03:03:34 PM     0      7110    0.00    0.99    0.00    0.99     4  pidstat03:03:34 PM   997      8539    0.99    0.00    0.00    0.99     5  java03:03:34 PM   984     15517    0.99    0.00    0.00    0.99     5  java03:03:34 PM     0     24406    0.99    0.00    0.00    0.99     5  java03:03:34 PM     0     32158    3.96    0.00    0.00    3.96     2  ansible
</code></pre><ul><li>UID</li><li>PID</li><li>%usr: 进程在用户空间占用 cpu 的百分比</li><li>%system: 进程在内核空间占用 CPU 百分比</li><li>%guest: 进程在虚拟机占用 CPU 百分比</li><li>%wait: 进程等待运行的百分比</li><li>%CPU: 进程占用 CPU 百分比</li><li>CPU: 处理进程的 CPU 编号</li><li>Command: 进程名</li></ul><p><strong>3、统计内存使用情况</strong></p><pre tabindex=0><code># 统计内存
pidstat -r 1 10
Average:      UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command
Average:        0         1      0.20      0.00  191256   3064   0.01  systemd
Average:        0      1007      1.30      0.00  143256  22720   0.07  AliYunDun
Average:        0      6642      0.10      0.00 6301904 107680   0.33  java
Average:      997      7326     10.89      0.00 13468904 8395848  26.04  java
Average:        0      7795    348.15      0.00  108376   1233   0.00  pidstat
Average:      997      8539      0.50      0.00 8242256 2062228   6.40  java
Average:      987      9518      0.20      0.00 6300944 1242924   3.85  java
Average:        0     10280      3.70      0.00  807372   8344   0.03  aliyun-service
Average:      984     15517      0.40      0.00 6386464 1464572   4.54  java
Average:        0     16066    236.46      0.00 2678332  71020   0.22  cmagent
Average:      995     20955      0.30      0.00 6312520 1408040   4.37  java
Average:      995     20956      0.20      0.00 6093764 1505028   4.67  java
Average:        0     23936      0.10      0.00 5302416 110804   0.34  java
Average:        0     24406      0.70      0.00 10211672 2361304   7.32  java
Average:        0     26870      1.40      0.00 1470212  36084   0.11  promtail
</code></pre><ul><li>UID</li><li>PID</li><li>Minflt/s : 每秒次缺页错误次数 （minor page faults），虚拟内存地址映射成物理内存地址产生的 page fault 次数</li><li>Majflt/s : 每秒主缺页错误次数 (major page faults), 虚拟内存地址映射成物理内存地址时，相应 page 在 swap 中</li><li>VSZ virtual memory usage : 该进程使用的虚拟内存 KB 单位</li><li>RSS : 该进程使用的物理内存 KB 单位</li><li>%MEM : 内存使用率</li><li>Command : 该进程的命令 task name</li></ul><p><strong>4、查看具体进程使用情况</strong></p><pre tabindex=0><code>pidstat -T ALL -r -p 20955 1 10
03:12:16 PM   UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command
03:12:17 PM   995     20955      0.00      0.00 6312520 1408040   4.37  java

03:12:16 PM   UID       PID minflt-nr majflt-nr  Command
03:12:17 PM   995     20955         0         0  java
</code></pre><blockquote><p>本内容由社区会员上传分享，仅供读者交流学习，版权归原作者所有，若所引用的图片、数据、文字等来源标注有误或涉及侵权或内容不完整，请及时联系处理。</p><p>原文地址：https://www.ctq6.cn/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</p><p><strong>觉得本文有用，请转发或点击“在看”，让更多同行看到</strong></p></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li><li><a href=#cpu><strong>CPU</strong></a></li><li><a href=#内存><strong>内存</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>